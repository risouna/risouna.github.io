[{"categories":["计算机"],"content":"实现特定SDP报文转化为C结构 一、根据SDP规范定义C结构体 下面是一个sdp报文：\n1v=0 2o=HWPSS 3427743244 1084119141 IN IP4 127.0.0.1 3s=test1.mp4 // test1.mp4：媒体文件名 4c=IN IP4 0.0.0.0 5t=0 0 6a=control:* 7a=range:npt=0-44.000000 8m=video 0 RTP/AVP 96 // 96：track-\u0026gt;payload_type 视频：96音频：97 9a=control:trackID=101 // 101：轨道ID。 视频：101，102， 103 音频： 201，202， 203，204， 205 10a=rtpmap:96 MP4V-ES/90000 11a=fmtp:96 profile-level-id=2;config=000001b0020; 12m=audio 0 RTP/AVP 97 13a=control:trackID=201 14a=rtpmap:97 mpeg4-generic/24000/1 15a=fmtp:97 streamtype=5;profile-level-id=15; mode=AAC-hbr; config=1308; SizeLength=13; IndexLength=3;IndexDeltaLength=3; Profile=1; 需要注意的地方：\n 媒体数目， 媒体内的a字段数目都是不固定的。如果用C语言结构体装的话，可能需要内存分配和指针等东西。（目前想法是可以通过柔性数组处理实现） 单个字段内的数据组成也是不定的，可以先暂时取出文本域，再将文本域通过空格分为数组，至于之后的具体是什么内容，可以另写函数处理。  目前暂时就定义这个报文里面有的东西。\n二、文件流模拟输入 读文件demo feof函数判断文件结尾，fgets读取一行，遇到换行停止（会读取换行符）。\n1#include \u0026lt;stdio.h\u0026gt;2 3int main(){ 4\tFILE *file = NULL; 5\tchar buff[255]; 6\t7\tfile = fopen(\u0026#34;sdp.txt\u0026#34;, \u0026#34;r\u0026#34;); 8\tif(file == NULL){ 9\tprintf(\u0026#34;Error opening file\u0026#34;); 10\treturn 1; 11\t} 12\t13\twhile(!feof(file)){ 14\tfgets(buff, 255, (FILE*)file); 15\tprintf(\u0026#34;%s\u0026#34;, buff); 16\t} 17 18\t19\tfclose(file); 20\treturn 0; 21} 22 三、字符处理转化结构体 核心思想：\n 先初始分配一个默认的内存， 存放1个媒体， 且a行只有1个。 先扫描一遍文本，记录会话a行， 媒体个数， 各个媒体的a行个数。 如果在上面的过程中遇到了多个a，多个m，使用字段记录变动的字段，再立刻使用realloc进行动态拓展。  遇到的问题：\n 多维数组指针索引遍历问题， 这个去翻C Primer Plus的302页即可。（已解决） 结构体中的柔性数组内存分配。（以解决） 字符打印始终是乱码，乱码出现在柔性数组那里，会话部分有些乱码有些没有，且每次乱码的位置都是固定的。但是后面的柔性数组没有乱码。 好像malloc的内存自动会释放，如果自己再调用free的话会报free(): double free detected in tcache 2（已解决） 不额外写printf的话会报malloc(): corrupted top size的错误， 非常奇怪。  头文件sdp_handle.h：\n1#ifndef SDP_HANDLE_H 2#define SDP_HANDLE_H 3#define STR_LENGTH 64 4#define DEFAULT_MEDIA_ATTRIBUTE 2 5#define DEFAULT_SESSION_ATTRIBUTE 2 6 7typedef struct _media { 8\tchar information[STR_LENGTH]; //m 9\tint a_count; //记录一个媒体的a行个数 10\tchar attribute[][STR_LENGTH]; //a 11} Media; 12 13typedef struct _session { 14\tchar version; //v 15\tchar originator[STR_LENGTH]; //o 16\tchar name[STR_LENGTH]; //s 17\tchar connection_information[STR_LENGTH]; //c 18\tint time_active[2]; //t 19\tint media_count; //记录一次会话的媒体个数 20\tMedia* media[5]; //m,由于变长数组只能有一个，暂时写死 21\tint a_count; //记录会话的a属性个数 22\tchar attribute[][STR_LENGTH]; //a 23} Session; 24 25 26//字符串处理为结构体 27void handle_line_to_struct(Session* session, FILE* file); 28//打印会话信息到控制台 29void print_session(Session session); 30//将会话信息持久化到文件 31void save_session(Session session, char* file_name); 32//创建会话内存 33Session* malloc_session(Session* session); 34//清理会话内存 35void destory_session(Session* session); 36//创建媒体内存 37Media* malloc_media(Media* media); 38//清理媒体内存 39void destory_media(Media* media); 40//字符串指针复制函数 41void strcpy_p(char* from, char* dest, char stopsign); 42 43 44#endif 函数文件sdp_handle.c：\n1#include \u0026lt;stdio.h\u0026gt;2#include \u0026lt;string.h\u0026gt;3#include \u0026lt;stdlib.h\u0026gt;4#include \u0026lt;stdbool.h\u0026gt;5#include \u0026#34;sdp_handle.h\u0026#34;6 7 8//----------------------处理字符函数---------------- 9//处理字符串为结构体 10void handle_line_to_struct(Session* session, FILE* file){ 11\tchar buff[255]; //缓冲区 12\tint handled_a = 0; //记录已经处理的会话a行数 13\tint handled_a_m = 0; //记录单个媒体已经处理的a行数 14 15\t//1.读取文件 16\t//TODO 定义安全检查函数 17\t//TODO 错误处理 18\twhile(true){ 19\tfgets(buff, 255, (FILE*)file); 20\tchar* str = buff; 21 22\t//报文末尾判断 23\tif(feof(file)){ 24\tbreak; 25\t} 26\t27\t//2.对每行进行parse 28\t//char* seperate = strchr(str, \u0026#39;=\u0026#39;); //显式地区分类别和文本 29\tchar type = *str; //字段类别头 30\tchar* begin = str+2; //文本的开始 31\t//printf(\u0026#34;%c\\n\u0026#34;, type); 32\tswitch(type){ 33\t//TODO 覆盖一般SDP报文的内容 34\tcase \u0026#39;v\u0026#39;: 35\t//暂时假设v字段只有1位 36\tsession-\u0026gt;version = *begin; 37\tbreak; 38\tcase \u0026#39;o\u0026#39;: 39\tstrcpy_p(begin, session-\u0026gt;originator, \u0026#39;\\n\u0026#39;); 40\tbreak; 41\tcase \u0026#39;s\u0026#39;: 42\tstrcpy_p(begin, session-\u0026gt;name, \u0026#39;\\n\u0026#39;); 43\tbreak; 44\tcase \u0026#39;c\u0026#39;: 45\tstrcpy_p(begin, session-\u0026gt;connection_information, \u0026#39;\\n\u0026#39;); 46\tbreak; 47\tcase \u0026#39;t\u0026#39;: 48\t//由于时间有可能是长位的，采用atoi函数 49\tchar* devide = strchr(begin, \u0026#39; \u0026#39;); 50\tdevide++; 51\tchar start_time[20]; 52\tchar stop_time[20]; 53\tstrcpy_p(begin, start_time, \u0026#39; \u0026#39;); 54\tstrcpy_p(devide, stop_time, \u0026#39;\\n\u0026#39;); 55\tsession-\u0026gt;time_active[0] = atoi(start_time); 56\tsession-\u0026gt;time_active[1] = atoi(stop_time); 57\tbreak; 58\tcase \u0026#39;m\u0026#39;: 59\t//创建媒体 60\tMedia* media; 61\tmedia = malloc_media(NULL); 62\thandled_a_m = 0; //计数器清零 63\tstrcpy_p(begin, media-\u0026gt;information, \u0026#39;\\n\u0026#39;); 64\t*(session-\u0026gt;media + session-\u0026gt;media_count)= media; //赋值给对应的媒体段 65\tsession-\u0026gt;media_count++; 66\tmedia = NULL; 67\tbreak; 68\tcase \u0026#39;a\u0026#39;: 69\t//判断a行的归属 70\tif(session-\u0026gt;media_count == 0){ 71\t//1.处理session的a 72\t//如果a段的内存不够，进行扩容 73\tif(handled_a \u0026gt;= session-\u0026gt;a_count){ 74\tsession-\u0026gt;a_count += 1; //一次扩容1行 75\tsession = malloc_session(session); 76\t} 77\t//对应位置进行复制字符串 78\tstrcpy_p(begin, *(session-\u0026gt;attribute+handled_a), \u0026#39;\\n\u0026#39;); 79\thandled_a++; 80\t}else{ 81\t//2.处理media的a 82\t//还是先检查内存是否足够 83\tMedia* media_now; 84\tmedia_now = *(session-\u0026gt;media+(session-\u0026gt;media_count-1)); 85\tif(handled_a_m \u0026gt;= media_now-\u0026gt;a_count){ 86\tmedia_now-\u0026gt;a_count += 1; //一次扩容1行 87\tmedia_now = malloc_media(media_now); 88\t} 89\t//对应位置进行复制 90\tstrcpy_p(begin, *(media_now-\u0026gt;attribute+handled_a_m), \u0026#39;\\n\u0026#39;); 91\thandled_a_m++; 92\t} 93\tbreak;\t94\tdefault: 95\tprintf(\u0026#34;Unkown Type:%c\\n\u0026#34;, type); 96\t} 97\t} 98\t99} 100 101//复制字符串函数 102void strcpy_p(char* from, char* dest, char stopsign){ 103\t//复制 104\tfor(; *from != stopsign; from++, dest++){ 105\t*dest = *from; 106\t} 107\t//最后面加\u0026#39;\\0\u0026#39; 108\t*dest = \u0026#39;\\0\u0026#39;; 109} 110 111 112//-----------------输出函数----------------- 113 114//打印会话信息到控制台 115void print_session(Session session){ 116\t//printf(\u0026#34;\\n\u0026#34;); 117\tprintf(\u0026#34;Session Information:\\n\u0026#34;); 118\tprintf(\u0026#34;------------------------------\\n\u0026#34;); 119\tprintf(\u0026#34;version:%c\\n\u0026#34;, session.version); 120\tprintf(\u0026#34;originator:%s\\n\u0026#34;, session.originator); 121\tprintf(\u0026#34;name:%s\\n\u0026#34;, session.name); 122\tprintf(\u0026#34;connection information:%s\\n\u0026#34;, session.connection_information); 123\tprintf(\u0026#34;time_active, start:%d, end:%d\\n\u0026#34;, session.time_active[0], session.time_active[1]); 124\tprintf(\u0026#34;attribute:\\n\u0026#34;); 125\tfor(int i = 0; i \u0026lt; session.a_count; i++){ 126\tprintf(\u0026#34;%s\\n\u0026#34;, (*(session.attribute+i))); 127\t} 128\tprintf(\u0026#34;\\n\u0026#34;); 129\tprintf(\u0026#34;\\n\u0026#34;); 130 131\tif(session.media_count == 0){ 132\tprintf(\u0026#34;No Media Information!\\n\u0026#34;); 133\t}else{ 134\tprintf(\u0026#34;Media Information:\\n\u0026#34;); 135\tprintf(\u0026#34;------------------------------\\n\u0026#34;); 136\tfor(int i = 0; i \u0026lt; session.media_count; i++){ 137\tMedia* media_now = *(session.media+i); 138\tprintf(\u0026#34;Media %d:\\n\u0026#34;, (i+1)); 139\tprintf(\u0026#34;information:%s\\n\u0026#34;, media_now-\u0026gt;information); 140\tprintf(\u0026#34;attribute:\\n\u0026#34;); 141\tfor(int j = 0; j \u0026lt; media_now-\u0026gt;a_count; j++){ 142\tprintf(\u0026#34;%s\\n\u0026#34;, *(media_now-\u0026gt;attribute + j)); 143\t} 144\tprintf(\u0026#34;\\n\u0026#34;); 145\t} 146\t} 147} 148 149 150 151//会话持久化到rst文件 152void save_session(Session session, char* file_name){ 153\t//1.创建文件 154\tFILE* write_file = fopen(file_name, \u0026#34;w+\u0026#34;); 155 156\t//2.写入文件 157\tfprintf(write_file, \u0026#34;Session Information:\\n\u0026#34;); 158\tfprintf(write_file, \u0026#34;------------------------------\\n\u0026#34;); 159 160\tfprintf(write_file, \u0026#34;#. \u0026#34;); 161\tfprintf(write_file, \u0026#34;version: \u0026#34;); 162\tfputc(session.version, write_file); 163\tfprintf(write_file, \u0026#34;\\n\\n\u0026#34;); 164 165\tfprintf(write_file, \u0026#34;#. \u0026#34;); 166\tfprintf(write_file, \u0026#34;originator: \u0026#34;); 167\tfprintf(write_file, \u0026#34;%s\\n\\n\u0026#34;, session.originator); 168 169 170\tfprintf(write_file, \u0026#34;#. \u0026#34;); 171\tfprintf(write_file, \u0026#34;name: \u0026#34;); 172\tfprintf(write_file, \u0026#34;%s\\n\\n\u0026#34;, session.name); 173 174\tfprintf(write_file, \u0026#34;#. \u0026#34;); 175\tfprintf(write_file, \u0026#34;connection information: \u0026#34;); 176\tfprintf(write_file, \u0026#34;%s\\n\\n\u0026#34;, session.connection_information); 177 178\tfprintf(write_file, \u0026#34;#. \u0026#34;); 179\tfprintf(write_file, \u0026#34;time_active, start: \u0026#34;); 180\tfprintf(write_file, \u0026#34;%d\u0026#34;, session.time_active[0]); 181\tfprintf(write_file, \u0026#34;, end: \u0026#34;); 182\tfprintf(write_file, \u0026#34;%d\\n\\n\u0026#34;, session.time_active[1]); 183 184\tfprintf(write_file, \u0026#34;#. \u0026#34;); 185\tfprintf(write_file, \u0026#34;attribute: \\n\u0026#34;); 186\tfor(int i = 0; i \u0026lt; session.a_count; i++){ 187\tfprintf(write_file, \u0026#34;\t- %s\\n\u0026#34;, (*(session.attribute+i))); 188\t} 189\tfprintf(write_file, \u0026#34;\\n\\n\u0026#34;); 190 191\tif(session.media_count == 0){ 192\tfprintf(write_file, \u0026#34;No Media Information!\\n\\n\u0026#34;); 193\t}else{ 194\tfprintf(write_file, \u0026#34;Media Information:\\n\u0026#34;); 195\tfprintf(write_file, \u0026#34;------------------------------\\n\u0026#34;); 196\tfor(int i = 0; i \u0026lt; session.media_count; i++){ 197\tMedia* media_now = *(session.media+i); 198 199\tfprintf(write_file, \u0026#34;Media %d:\\n\\n\u0026#34;, (i+1)); 200 201\tfprintf(write_file, \u0026#34;information:\u0026#34;); 202\tfprintf(write_file, \u0026#34;%s\\n\\n\u0026#34;, media_now-\u0026gt;information); 203 204\tfprintf(write_file, \u0026#34;attribute:\\n\\n\u0026#34;); 205\tfor(int j = 0; j \u0026lt; media_now-\u0026gt;a_count; j++){ 206\tfprintf(write_file, \u0026#34;#. \u0026#34;); 207\tfprintf(write_file, \u0026#34;%s\\n\\n\u0026#34;, *(media_now-\u0026gt;attribute + j)); 208\t} 209\t} 210\t} 211 212\t//3.关闭文件 213\tfclose(write_file); 214 215} 216 217 218 219 220//----------------处理内存------------------- 221 222//分配会话内存 223Session* malloc_session(Session* session){ 224\tSession* session_new = NULL; 225\tif(session == NULL){ 226\t//初始化 227\tprintf(\u0026#34;Initial session memory:%ld\\n\u0026#34;, sizeof(Session) + DEFAULT_SESSION_ATTRIBUTE * STR_LENGTH * sizeof(char)); 228\tsession_new = (Session*)malloc(sizeof(Session) + DEFAULT_SESSION_ATTRIBUTE * STR_LENGTH * sizeof(char)); 229\tsession_new-\u0026gt;a_count=DEFAULT_SESSION_ATTRIBUTE; 230\tsession_new-\u0026gt;media_count = 0; 231\t}else{ 232\t//根据a_count动态分配内存 233\tprintf(\u0026#34;Realloc session memory:%ld\\n\u0026#34;, sizeof(Session) + session-\u0026gt;a_count * STR_LENGTH * sizeof(char)); 234\tsession_new = (Session*)realloc(session, sizeof(Session) + session-\u0026gt;a_count * STR_LENGTH * sizeof(char)); 235\t} 236 237\t//判断内存是否分配成功 238\tif(session_new == NULL){ 239\tprintf(\u0026#34;No aviliable memory for session!\\n\u0026#34;); 240\t} 241 242\treturn session_new; 243} 244 245//清理会话内存 246void destory_session(Session* session){ 247\tprintf(\u0026#34;Clear session memory\\n\u0026#34;); 248\tfor(int i = 0; i \u0026lt; session-\u0026gt;media_count; i++){ 249\tdestory_media(*(session-\u0026gt;media+i)); 250\t} 251\tfree(session); 252\tsession = NULL; 253} 254 255//分配媒体内存 256Media* malloc_media(Media* media){ 257\tMedia* media_new = NULL; 258\t//初始化判断 259\tif(media == NULL){ 260\t//新分配内存 261\tprintf(\u0026#34;Malloc new media memory\\n\u0026#34;); 262\tmedia_new = (Media*)malloc(sizeof(Media) + DEFAULT_MEDIA_ATTRIBUTE*sizeof(char)*STR_LENGTH); 263\tmedia_new-\u0026gt;a_count = DEFAULT_MEDIA_ATTRIBUTE; 264\t}else{\t265\t//动态根据参数a_count分配内存 266\tprintf(\u0026#34;Realloc media memory\\n\u0026#34;); 267\tmedia_new = realloc(media, sizeof(Media)+media-\u0026gt;a_count*sizeof(char)*STR_LENGTH); 268\t} 269\t270\t//内存分配失败检验 271\tif(media_new == NULL){ 272\tprintf(\u0026#34;No memory aviliable for media\\n\u0026#34;); 273\t} 274\t275\treturn media_new; 276} 277 278//清理媒体内存 279void destory_media(Media* media){ 280\tprintf(\u0026#34;Clear media memory\\n\u0026#34;); 281\tfree(media); 282\tmedia == NULL; 283} 284 四、文件流模拟输出\u0026amp;格式化打印结构体 对应函数在上面那节已经给出。\nmain.c文件：\n1#include \u0026lt;stdio.h\u0026gt;2#include \u0026lt;string.h\u0026gt;3#include \u0026#34;sdp_handle.h\u0026#34;4 5//TODO 修复不打印额外字符会出现：malloc(): corrupted top size的bug 6//命令行参数1作读取的sdp报文文件 7int main(int argc, char *argv[]){ 8\t//文件指针 9\tFILE *file = NULL; 10\t//会话结构体 11\tSession* session = NULL; 12 13\t//合法性检验 14\tfile = fopen(\u0026#34;sdp.txt\u0026#34;, \u0026#34;r\u0026#34;); 15\tif(file == NULL){ 16\tprintf(\u0026#34;Error opening file\u0026#34;); 17\treturn 1; 18\t} 19\t//printf(\u0026#34;Open file success\\n\u0026#34;); 20 21\t//创建新会话 22\tsession = malloc_session(session); 23 24\t//解析sdp.txt文件 25\thandle_line_to_struct(session, file); 26\t//关闭文件 27\tfclose(file); 28 29\t//打印结构体到控制台 30\tprint_session(*session); 31 32\t//保存结构体为rst文件 33\tsave_session(*session, argv[1]); 34 35\t//回收内存 36\tdestory_session(session); 37 38\treturn 0; 39} Makefile：\n1out: main.o sdp_handle.o 2\tgcc -o out main.o sdp_handle.o 3 4sdp_handle.o:sdp_handle.c 5\tgcc -c sdp_handle.c 6 7main.o: main.c 8\tgcc -c main.c 9 10 11clean: 12\trm main.o sdp_handle.o out 13 14run: 15\t./out sdp.rst 命令行输出测试：\n1./out sdp.rst 2Initial session memory:384 3Malloc new media memory 4Malloc new media memory 5Realloc media memory 6Session Information: 7------------------------------ 8version:0 9originator:HWPSS 3427743244 1084119141 IN IP4 127.0.0.1 10name:test1.mp4 11connection information:IN IP4 0.0.0.0 12time_active, start:0, end:0 13attribute: 14cont��{� 15*p 16 17 18Media Information: 19------------------------------ 20Media 1: 21information:video 0 RTP/AVP 96 22attribute: 23control:trackID=101 24fmtp:96 profile-level-id=2;config=000001b0020; 25 26Media 2: 27information:audio 0 RTP/AVP 97 28attribute: 29control:trackID=201 30rtpmap:97 mpeg4-generic/24000/1 31fmtp:97 streamtype=5;profile-level-id=15; mode=AAC-hbr; config=1308; SizeLength=13; IndexLength=3;IndexDeltaLength=3; Profile=1; 32 33Clear session memory 34Clear media memory 35Clear media memory 写文件输出测试：\n1Session Information: 2------------------------------ 3#. version: 0 4 5#. originator: HWPSS 3427743244 1084119141 IN IP4 127.0.0.1 6 7#. name: test1.mp4 8 9#. connection information: IN IP4 0.0.0.0 10 11#. time_active, start: 0, end: 0 12 13#. attribute: 14\t- contx�s� 15\t- � 16 17 18Media Information: 19------------------------------ 20Media 1: 21 22information:video 0 RTP/AVP 96 23 24attribute: 25 26#. control:trackID=101 27 28#. fmtp:96 profile-level-id=2;config=000001b0020; 29 30Media 2: 31 32information:audio 0 RTP/AVP 97 33 34attribute: 35 36#. control:trackID=201 37 38#. rtpmap:97 mpeg4-generic/24000/1 39 40#. fmtp:97 streamtype=5;profile-level-id=15; mode=AAC-hbr; config=1308; SizeLength=13; IndexLength=3;IndexDeltaLength=3; Profile=1; 可见还是存在些许问题的，有些字段始终是乱码的， 但是找不到原因。\n实现解析任意SDP报文 尚未解决问题：\n 各结构体需定义完善，覆盖所有可能的字段 session段规定的一些字段是media段的默认值 有些字段如果media段规定，session段不需要规定 optional字段需要注意 文本域里面的文本解析分离 需要判断报文的可用性，判断格式是否符合规范  暂时不考虑。\n参考 下面是做这次小软件参考的链接：\nC语言中的结构体指针_结构体指针c语言-CSDN博客 C 结构体 | 菜鸟教程 如何使用fgets防止缓冲区溢出？_如何防止fgets在缓冲区溢出时多次运行？_防止缓冲区溢出 - 腾讯云开发者社区 - 腾讯云 C语言基础—文件读写 - 知乎 vim 配置c/c++开发环境_vim配置c++开发环境 deepin-CSDN博客 (84 封私信 / 10 条消息) 如何在 Linux 下利用 Vim 搭建 C/C++ 开发环境? - 知乎 结构体嵌套问题的常见错误_c语言 结构体里嵌套结构体数组-CSDN博客 【转载】在linux下使用gcc/g++编译多个.h .c 文件_arm-linux-gnueabi-gcc编译多个。c 。h文件-CSDN博客 C语言动态内存分配_使用realloc重新分配内存后,务必要将原有地址使用free释放,否则会出现内存泄-CSDN博客 「C系列」C 错误处理_c语言错误处理-CSDN博客 realloc(): invalid next size: C语言报错-CSDN博客 C\u0026gt; fgets读取文件最后一行重复问题 - 明明1109 - 博客园 C语言打印输出字符串的几种方法_c语言输出字符串-CSDN博客 C++结构体中变长数组的使用问题分解刨析_C 语言_脚本之家 C语言——指针（数组，函数）_数组指针-CSDN博客 ","date":"2024-11-25","permalink":"/posts/tech/media-sdptoc/","series":["媒体开发"],"tags":["","",""],"title":"SDP协议解析C结构体"},{"categories":["计算机"],"content":"1. 两数之和 暴力枚举 1#include \u0026lt;stdio.h\u0026gt;2#include \u0026lt;stdlib.h\u0026gt;3 4int* twoSumNormal(int* nums, int numsSize, int target, int* returnSize); 5 6 7int main(){ 8 int nums[4] = [2,7,11,15]; 9 int target = 9; 10 int* returnSize = 0; 11 int* res = twoSumNormal(nums, 4, target, returnSize); 12 free(res); 13 return 0; 14} 15 16 17//示例 1： 18// 19//输入：nums = [2,7,11,15], target = 9 20//输出：[0,1] 21//解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 22//示例 2： 23// 24//输入：nums = [3,2,4], target = 6 25//输出：[1,2] 26//示例 3： 27// 28//输入：nums = [3,3], target = 6 29//输出：[0,1] 30 31/** 32* Note: The returned array must be malloced, assume caller calls free(). 33*/ 34int* twoSumNormal(int* nums, int numsSize, int target, int* returnSize) { 35 for (int i = 0; i \u0026lt; numsSize; i++) { 36 for (int j = i + 1; j \u0026lt; numsSize; ++j) { 37 if(nums[i] + nums[j] == target){ 38 int* res = malloc(sizeof(int) * 2); 39 res[0] = i; 40 res[1] = j; 41 *returnSize = 2; 42 return res; 43 } 44 } 45 } 46 47 *returnSize = 0; 48 return NULL; 49} 50 哈希表 关于uthash.h 1#include \u0026#34;stdio.h\u0026#34;2#include \u0026#34;stdlib.h\u0026#34;3#include \u0026#34;uthash.h\u0026#34;4 5//单个节点 6struct hashTable { 7 int key; 8 int val; 9 UT_hash_handle hh; 10}; 11 12 13struct hashTable* find(int ikey); 14void insert(int ikey, int ival); 15int* twoSum(int* nums, int numsSize, int target, int* returnSize); 16 17 18//节点群 19static struct hashTable* hashtable; 20 21 22int main(){ 23 return 0; 24} 25 26 27//从节点群中找到符合条件的单个节点, 如果找不到, 返回空 28struct hashTable* find(int ikey) { 29 struct hashTable* tmp; 30 HASH_FIND_INT(hashtable, \u0026amp;ikey, tmp); 31 return tmp; 32} 33 34void insert(int ikey, int ival) { 35 //检查是否是重复元素 36 struct hashTable* it = find(ikey); 37 if (it == NULL) { 38 struct hashTable* tmp = malloc(sizeof(struct hashTable)); 39 tmp-\u0026gt;key = ikey, tmp-\u0026gt;val = ival; 40 HASH_ADD_INT(hashtable, ikey, tmp); 41 } else { 42 it-\u0026gt;val = ival; 43 } 44} 45 46int* twoSum(int* nums, int numsSize, int target, int* returnSize) { 47 hashtable = NULL; 48 for (int i = 0; i \u0026lt; numsSize; i++) { 49 struct hashTable* it = find(target - nums[i]); 50 if (it != NULL) { 51 int* ret = malloc(sizeof(int) * 2); 52 ret[0] = it-\u0026gt;val, ret[1] = i; 53 *returnSize = 2; 54 return ret; 55 } 56 insert(nums[i], i); 57 } 58 *returnSize = 0; 59 return NULL; 60} 61 ","date":"2024-11-23","permalink":"/posts/tech/basic-algorithm-c/","series":["基础能力"],"tags":["","",""],"title":"C语言算法刷题"},{"categories":["计算机"],"content":"第零章 计算器概论","date":"2024-11-23","permalink":"/posts/tech/basic-niaoge-linux/","series":["基础能力"],"tags":["","",""],"title":"鸟哥Linux教程"},{"categories":["计算机"],"content":"不想看了.\nSDP（rfc-4566）原文件阅读 rfc-4566， SDP(Session Description Protocol 会话描述协议) 协议原文件解读。由于是第一次阅读RFC，所以会比较详尽，以后的RFC文档只抓关键，其他的需要时查阅。\n参考：\nhttps://www.rfc-editor.org/info/rfc4566\n中文的翻译部分参考:\nhttps://blog.csdn.net/jisuanji111111/article/details/120956930\nhttps://zhuanlan.zhihu.com/p/429477119\n这里我只贴出英文和必要的和一些没有翻译的中文， 全中文查阅上面的链接。\n SDP is intended for describing multimedia sessions for the purposes of session announcement, session invitation, and other forms of multimedia session initiation.\n1.Introduction 场景：When initiating multimedia teleconferences, voice-over-IP calls, streaming video, or other sessions,\n需求：there is a requirement to convey media details, transport addresses, and other session description metadata to the participants.\n简单描述： SDP provides a standard representation for such information, irrespective of how that information is transported. SDP is purely a format for session description \u0026ndash; it does not incorporate a transport protocol, and it is intended to use different transport protocols as appropriate（单纯的会话描述格式， 不包括传输协议，灵活运用）。It is not intended to support negotiation of session content or media encodings\n2.Glossary of Terms 三个重要术语：会议、会话、会话描述\n  Conference: A multimedia conference is a set of two or more communicating users along with the software they are using to communicate.\n  Session: A multimedia session is a set of multimedia senders and receivers and the data streams flowing from senders to receivers. A multimedia conference is an example of a multimedia session.\n  Session Description: A well-defined format for conveying sufficient information to discover and participate in a multimedia session.\n  RFC通用关键字：\nThe key words \u0026ldquo;MUST\u0026rdquo;, \u0026ldquo;MUST NOT\u0026rdquo;, \u0026ldquo;REQUIRED\u0026rdquo;, \u0026ldquo;SHALL\u0026rdquo;, \u0026ldquo;SHALL NOT\u0026rdquo;, \u0026ldquo;SHOULD\u0026rdquo;, \u0026ldquo;SHOULD NOT\u0026rdquo;, \u0026ldquo;RECOMMENDED\u0026rdquo;, \u0026ldquo;MAY\u0026rdquo;, and \u0026ldquo;OPTIONAL\u0026rdquo; in this document are to be interpreted as described in RFC 2119 [3].\n3.Examples of SDP Usage  用于SIP协议中的session descriptions信息。 用于部分RTSP服务器和客户端关于parameters for media delivery的沟通 用于携带电子邮件和www的会话信息描述， 它没有传输可靠的性质 用作会话目录用于多播会话场景  4.Requirements and Recommendations 目的：Thus far, multicast-based sessions on the Internet have differed from many other forms of conferencing in that anyone receiving the traffic can join the session (unless the session traffic is encrypted). In such an environment, SDP serves two primary purposes. It is a means to communicate the existence of a session, and it is a means to convey sufficient information to enable joining and participating in the session. In a unicast environment, only the latter purpose is likely to be relevant.\nSDP session decription包括：\n Session name and purpose Time(s) the session is active The media comprising the session Information needed to receive those media (addresses, ports, formats, etc.)  其他可能信息：\n Information about the bandwidth to be used by the session Contact information for the person responsible for the session  SDP用途：In general, SDP must convey sufficient information to enable applications to join a session (with the possible exception of encryption keys) and to announce the resources to be used to any non-participants that may need to know. (This latter feature is primarily useful when SDP is used with a multicast session announcement protocol.)\n4.1. Media and Transport Information SDP应携带的关于媒体和传输的信息\nAn SDP session description includes the following media information:\n The type of media (video, audio, etc.) The transport protocol (RTP/UDP/IP, H.320, etc.) The format of the media (H.261 video, MPEG video, etc.)  In addition to media format and transport protocol, SDP conveys address and port details. For an IP multicast session, these comprise:\n  The multicast group address for media\n  The transport port for media\n  This address and port are the destination address and destination port of the multicast stream, whether being sent, received, or both.\nFor unicast IP sessions, the following are conveyed:\n  The remote address for media\n  The remote transport port for media\n  The semantics of this address and port depend on the media and transport protocol defined. By default, this SHOULD be the remote address and remote port to which data is sent. Some media types may redefine this behaviour, but this is NOT RECOMMENDED since it complicates implementations (including middleboxes that must parse the addresses to open Network Address Translation (NAT) or firewall pinholes).\n4.2. Timing Information 时间信息， 应该是有界的。\nSessions may be either bounded or unbounded in time. Whether or not they are bounded, they may be only active at specific times. SDP can convey:\n  An arbitrary list of start and stop times bounding the session\n  For each bound, repeat times such as \u0026ldquo;every Wednesday at 10am for one hour\u0026rdquo;\n  This timing information is globally consistent, irrespective of local time zone or daylight saving time (see Section 5.9). （关于时间全球一致的：）\n4.3. Private Sessions 可以通过加密session description实现私有会话， 可以通过private announcement传递加密密钥和加密方案\nprivate sessions are typically conveyed by encrypting the session description during distribution. The details of how encryption is performed are dependent on the mechanism used to convey SDP; mechanisms are currently defined for SDP transported using SAP [14] and SIP [15]\nIf a session announcement is private, it is possible to use that private announcement to convey encryption keys necessary to decode each of the media in a conference, including enough information to know which encryption scheme is used for each media.\n4.4. Obtaining Further Information about a Session 应携带足够的足以参与会话的信息\nA session description should convey enough information to decide whether or not to participate in a session. SDP may include additional pointers in the form of Uniform Resource Identifiers(URIs) for more information about the session.\n4.5. Categorisation 过滤会话描述， 通过属性a。\nWhen many session descriptions are being distributed by SAP, or any other advertisement mechanism, it may be desirable to filter session announcements that are of interest from those that are not. SDP supports a categorisation mechanism for sessions that is capable of being automated (the \u0026ldquo;a=cat:\u0026rdquo; attribute; see Section 6).\n4.6. Internationalisation 国际化。要求UTF8编码的ISO 10646字符集应用于部分字段， 为了压缩可以在其他字段使用其他字符集。\nThe SDP specification recommends the use of the ISO 10646 character sets in the UTF-8 encoding [5] to allow many different languages to be represented. However, to assist in compact representations, SDP also allows other character sets such as ISO 8859-1 to be used when desired. Internationalisation only applies to free-text fields (session name and background information), and not to SDP as a whole.\n5. SDP Specification 规范。一些字符规定， 一些格式规定，一些行为规定及其原因\n An SDP session description is entirely textual using the ISO 10646 character set in UTF-8 encoding. SDP field names and attribute names use only the US-ASCII subset of UTF-8, but textual fields and attribute values MAY use the full ISO 10646 character set. Field and attribute values that use the full UTF-8 character set are never directly compared, hence there is no requirement for UTF-8 normalisation. The textual form, as opposed to a binary encoding such as ASN.1 or XDR, was chosen to enhance portability, to enable a variety of transports to be used, and to allow flexible, text-based toolkits to be used to generate and process session descriptions. However, since SDP may be used in environments where the maximum permissible size of a session description is limited, the encoding is deliberately compact. Also, since announcements may be transported via very unreliable means or damaged by an intermediate caching server, the encoding was designed with strict order and formatting rules so that most errors would result in malformed session announcements that could be detected easily and discarded. This also allows rapid discarding of encrypted session announcements for which a receiver does not have the correct key.  SDP会话描述综述。会话层，媒体层，可选项。\nAn SDP session description consists of a number of lines of text of the form:\n1\u0026lt;type\u0026gt;=\u0026lt;value\u0026gt; where \u0026lt;type\u0026gt; MUST be exactly one case-significant character and \u0026lt;value\u0026gt; is structured text whose format depends on \u0026lt;type\u0026gt;. In general, \u0026lt;value\u0026gt; is either a number of fields delimited by a single space character or a free format string, and is case-significant unless a specific field defines otherwise. Whitespace MUST NOT be used on either side of the \u0026ldquo;=\u0026rdquo; sign.\nAn SDP session description consists of a session-level section followed by zero or more media-level sections. The session-level part starts with a \u0026ldquo;v=\u0026rdquo; line and continues to the first media-level section. Each media-level section starts with an \u0026ldquo;m=\u0026rdquo; line and continues to the next media-level section or end of the whole session description. In general, session-level values are the default for all media unless overridden by an equivalent media-level value.\nSome lines in each description are REQUIRED and some are OPTIONAL, but all MUST appear in exactly the order given here (the fixed order greatly enhances error detection and allows for a simple parser). OPTIONAL items are marked with a \u0026ldquo;*\u0026rdquo;.\n1Session description 2\tv= (protocol version)(协议版本) 3\to= (originator and session identifier)(创建者和会话标识符) 4\ts= (session name)(会话名称) 5\ti=* (session information)(会话信息) 6\tu=* (URI of description)(描述的URI) 7\te=* (email address)(邮箱地址) 8\tp=* (phone number)(电话) 9\tc=* (connection information -- not required if included in all media)(连接信息 - 如果包\t含在媒体信息中，则不需要该字段) 10\tb=* (zero or more bandwidth information lines)(零行或多行带宽信息) 11\tOne or more time descriptions (\u0026#34;t=\u0026#34; and \u0026#34;r=\u0026#34; lines; see below) 12\tz=* (time zone adjustments)(时区调整) 13\tk=* (encryption key)(加密密钥) 14\ta=* (zero or more session attribute lines)(零行或多行会话属性) 15\tZero or more media descriptions 16\t17Time description 18\tt= (time the session is active)(会话活跃时间) 19\tr=* (zero or more repeat times)(零次或多次会话重复次数) 20\t21Media description, if present 22\tm= (media name and transport address)(媒体名称和传输地址) 23\ti=* (media title)(媒体标题) 24\tc=* (connection information -- optional if included at 25\tsession level)(连接信息 - 如果包含在会话信息中，则不需要该字段) 26\tb=* (zero or more bandwidth information lines)(零行或多行带宽信息) 27\tk=* (encryption key)(加密密钥) 28\ta=* (zero or more media attribute lines)(零行或多行媒体属性)   The set of type letters is deliberately small and not intended to be extensible \u0026ndash; an SDP parser MUST completely ignore any session description that contains a type letter that it does not understand.\n  a属性用作扩展：The attribute mechanism (\u0026ldquo;a=\u0026rdquo; described below) is the primary means for extending SDP and tailoring it to particular applications or media.\n  Some attributes (the ones listed in Section 6 of this memo) have a defined meaning, but others may be added on an application-, media-, or session-specific basis.\n  忽略没有规范的内容：An SDP parser MUST ignore any attribute it doesn’t understand.\n  外部引用：An SDP session description may contain URIs that reference external content in the \u0026ldquo;u=\u0026rdquo;, \u0026ldquo;k=\u0026rdquo;, and \u0026ldquo;a=\u0026rdquo; lines. These URIs may be dereferenced in some cases, making the session description non-self- contained.\n  所有媒体的默认属性：The connection (\u0026ldquo;c=\u0026quot;) and attribute (\u0026ldquo;a=\u0026quot;) information in the session-level section applies to all the media of that session unless overridden by connection information or an attribute of the same name in the media description. For instance, in the example below, each media behaves as if it were given a \u0026ldquo;recvonly\u0026rdquo; attribute.\n1v=0 2o=jdoe 2890844526 2890842807 IN IP4 10.47.16.5 3s=SDP Seminar 4i=A Seminar on the session description protocol 5u=http://www.example.com/seminars/sdp.pdf 6e=j.doe@example.com (Jane Doe) 7c=IN IP4 224.2.17.12/127 8t=2873397496 2873404696 9a=recvonly 10m=audio 49170 RTP/AVP 0 11m=video 51372 RTP/AVP 99 12a=rtpmap:99 h263-1998/90000   文本域的一些特殊字符：Text fields such as the session name and information are octet（八位字节） strings that may contain any octet with the exceptions of 0x00 (Nul), 0x0a (ASCII newline), and 0x0d (ASCII carriage return).\n  协议结尾：The sequence CRLF (0x0d0a) is used to end a record, although parsers SHOULD be tolerant and also accept records terminated with a single newline character.\n  如何解析：If the \u0026ldquo;a=charset\u0026rdquo; attribute is not present, these octet strings MUST be interpreted as containing ISO-10646 characters in UTF-8 encoding (the presence of the \u0026ldquo;a=charset\u0026rdquo; attribute may force some fields to be interpreted differently).\n  包含域名的使用：A session description can contain domain names in the \u0026ldquo;o=\u0026rdquo;, \u0026ldquo;u=\u0026rdquo;, \u0026ldquo;e=\u0026rdquo;, \u0026ldquo;c=\u0026rdquo;, and \u0026ldquo;a=\u0026rdquo; lines. Any domain name used in SDP MUST comply with [1], [2].\n  域名的编码：Internationalised domain names (IDNs) MUST be represented using the ASCII Compatible Encoding (ACE) form defined in [11] and MUST NOT be directly represented in UTF-8 or any other encoding (this requirement is for compatibility with RFC 2327 and other SDP-related standards, which predate the development of internationalised domain names).\n  5.1. Protocol Version (\u0026ldquo;v=\u0026quot;) 目前只有版本0\n1v=0 The \u0026ldquo;v=\u0026rdquo; field gives the version of the Session Description Protocol. This memo defines version 0. There is no minor version number.\n5.2. Origin (\u0026ldquo;o=\u0026quot;) 会话组织者，会话标识符，版本号\n1o=\u0026lt;username\u0026gt; \u0026lt;sess-id\u0026gt; \u0026lt;sess-version\u0026gt; \u0026lt;nettype\u0026gt; \u0026lt;addrtype\u0026gt; \u0026lt;unicast-address\u0026gt; The \u0026ldquo;o=\u0026rdquo; field gives the originator of the session (her username and the address of the user’s host) plus a session identifier and version number:\n \u0026lt;username\u0026gt;（不能有空格） is the user’s login on the originating host, or it is \u0026ldquo;-\u0026rdquo; if the originating host does not support the concept of user IDs. The \u0026lt;username\u0026gt; MUST NOT contain spaces. \u0026lt;sess-id\u0026gt; （基于这个字段的所有属性通过工具生成）is a numeric string such that the tuple of \u0026lt;username\u0026gt;, \u0026lt;sess-id\u0026gt;, \u0026lt;nettype\u0026gt;, \u0026lt;addrtype\u0026gt;, and \u0026lt;unicast-address\u0026gt; forms a globally unique identifier for the session. The method of \u0026lt;sess-id\u0026gt; allocation is up to the creating tool, but it has been suggested that a Network Time Protocol (NTP) format timestamp be used to ensure uniqueness [13]. \u0026lt;sess-version\u0026gt;（版本信息，通过工具生成） is a version number for this session description. Its usage is up to the creating tool, so long as（只要） \u0026lt;sess-version\u0026gt; is increased when a modification is made to the session data. Again, it is RECOMMENDED that an NTP format timestamp is used. \u0026lt;nettype\u0026gt;（网络类型。一般就是IN了） is a text string giving the type of network. Initially \u0026ldquo;IN\u0026rdquo; is defined to have the meaning \u0026ldquo;Internet\u0026rdquo;, but other values MAY be registered in the future (see Section 8). \u0026lt;addrtype\u0026gt;（地址类型） is a text string giving the type of the address that follows. Initially \u0026ldquo;IP4\u0026rdquo; and \u0026ldquo;IP6\u0026rdquo; are defined, but other values MAY be registered in the future (see Section 8). \u0026lt;unicast-address\u0026gt;（创建会话者的地址，最好使用域名，不要使用内网地址） is the address of the machine from which the session was created. For an address type of IP4, this is either the fully qualified domain name of the machine or the dotted- decimal representation of the IP version 4 address of the machine. For an address type of IP6, this is either the fully qualified domain name of the machine or the compressed textual representation of the IP version 6 address of the machine. For both IP4 and IP6, the fully qualified domain name is the form that SHOULD be given unless this is unavailable, in which case the globally unique address MAY be substituted. A local IP address MUST NOT be used in any context where the SDP description might leave the scope in which the address is meaningful (for example, a local address MUST NOT be included in an application-level referral that might leave the scope).  综述：In general, the \u0026ldquo;o=\u0026rdquo; field serves as a globally unique identifier for this version of this session description, and the subfields excepting the version taken together identify the session irrespective of any modifications.\n安全考虑可以随意填充username和unicast：For privacy reasons, it is sometimes desirable to obfuscate（混淆） the username and IP address of the session originator. If this is a concern, an arbitrary \u0026lt;username\u0026gt; and private \u0026lt;unicast-address\u0026gt; MAY be chosen to populate（填充） the \u0026ldquo;o=\u0026rdquo; field, provided that these are selected in a manner that does not affect the global uniqueness of the field.\n5.3. Session Name (\u0026ldquo;s=\u0026quot;) 文字会话名。\n1s=\u0026lt;session name\u0026gt; The \u0026ldquo;s=\u0026rdquo; field is the textual session name. There MUST be one and only one \u0026ldquo;s=\u0026rdquo; field per session description. The \u0026ldquo;s=\u0026rdquo; field MUST NOT be empty and SHOULD contain ISO 10646 characters (but see also the \u0026ldquo;a=charset\u0026rdquo; attribute). If a session has no meaningful name, the value \u0026ldquo;s= \u0026quot; SHOULD be used (i.e., a single space as the session name).\n5.4. Session Information (\u0026ldquo;i=\u0026quot;) 会话的一些描述信息。用作媒体域时是分类标签各个媒体\n1i=\u0026lt;session description\u0026gt; 作为会话的描述信息：The \u0026ldquo;i=\u0026rdquo; field provides textual information about the session. There MUST be at most one session-level \u0026ldquo;i=\u0026rdquo; field per session description, and at most one \u0026ldquo;i=\u0026rdquo; field per media. If the \u0026ldquo;a=charset\u0026rdquo; attribute is present, it specifies the character set used in the \u0026ldquo;i=\u0026rdquo; field. If the \u0026ldquo;a=charset\u0026rdquo; attribute is not present, the \u0026ldquo;i=\u0026rdquo; field MUST contain ISO 10646 characters in UTF-8 encoding.\n区分同一会话下同一类型的媒体：A single \u0026ldquo;i=\u0026rdquo; field MAY also be used for each media definition. In media definitions, \u0026ldquo;i=\u0026rdquo; fields are primarily intended for labelling media streams. As such, they are most likely to be useful when a single session has more than one distinct media stream of the same media type. An example would be two different whiteboards, one for slides and one for feedback and questions.\nThe \u0026ldquo;i=\u0026rdquo; field is intended to provide a free-form human-readable description of the session or the purpose of a media stream. It is not suitable for parsing by automata（自动机）.\n5.5. URI (\u0026ldquo;u=\u0026quot;) 关于会话其他信息的uri。\n1u=\u0026lt;uri\u0026gt; A URI is a Uniform Resource Identifier as used by WWW clients [7]. The URI should be a pointer to additional information about the session. This field is OPTIONAL, but if it is present it MUST be specified before the first media field. No more than one URI field is allowed per session description.\n5.6. Email Address and Phone Number (\u0026ldquo;e=\u0026rdquo; and \u0026ldquo;p=\u0026quot;) 会议负责人的联系方式。\n1e=\u0026lt;email-address\u0026gt; 2p=\u0026lt;phone-number\u0026gt; The \u0026ldquo;e=\u0026rdquo; and \u0026ldquo;p=\u0026rdquo; lines specify contact information for the person responsible for the conference. This is not necessarily the same person that created the conference announcement.\nInclusion of an email address or phone number is OPTIONAL. Note that the previous version of SDP specified that either an email field or a phone field MUST be specified, but this was widely ignored. The change brings the specification into line with common usage.\nIf an email address or phone number is present, it MUST be specified before the first media field. More than one email or phone field can be given for a session description.\nPhone numbers SHOULD be given in the form of an international public telecommunication number (see ITU-T Recommendation E.164) preceded by a \u0026ldquo;+\u0026rdquo;. Spaces and hyphens may be used to split up a phone field to aid readability if desired. For example:\n1p=+1 617 555-6011 Both email addresses and phone numbers can have an OPTIONAL free text string associated with them, normally giving the name of the person who may be contacted. This MUST be enclosed in parentheses if it is present. For example:\n1e=j.doe@example.com (Jane Doe) The alternative RFC 2822 [29] name quoting convention is also allowed for both email addresses and phone numbers. For example:\n1e=Jane Doe \u0026lt;j.doe@example.com\u0026gt; The free text string SHOULD be in the ISO-10646 character set with UTF-8 encoding, or alternatively in ISO-8859-1 or other encodings if the appropriate session-level \u0026ldquo;a=charset\u0026rdquo; attribute is set.\n5.7. Connection Data (\u0026ldquo;c=\u0026quot;) 连接数据。\n1c=\u0026lt;nettype\u0026gt; \u0026lt;addrtype\u0026gt; \u0026lt;connection-address\u0026gt; The \u0026ldquo;c=\u0026rdquo; field contains connection data.\nA session description MUST contain either at least one \u0026ldquo;c=\u0026rdquo; field in each media description or a single \u0026ldquo;c=\u0026rdquo; field at the session level. It MAY contain a single session-level \u0026ldquo;c=\u0026rdquo; field and additional \u0026ldquo;c=\u0026rdquo; field(s) per media description, in which case the per-media values override the session-level settings for the respective media.\nThe first sub-field (\u0026quot;\u0026lt;nettype\u0026gt;\u0026quot;) is the network type, which is a text string giving the type of network. Initially, \u0026ldquo;IN\u0026rdquo; is defined to have the meaning \u0026ldquo;Internet\u0026rdquo;, but other values MAY be registered in the future (see Section 8).\nThe second sub-field (\u0026quot;\u0026lt;addrtype\u0026gt;\u0026quot;) is the address type. This allows SDP to be used for sessions that are not IP based. This memo only defines IP4 and IP6, but other values MAY be registered in the future (see Section 8).\nThe third sub-field (\u0026quot;\u0026lt;connection-address\u0026gt;\u0026quot;) is the connection address. OPTIONAL sub-fields MAY be added after the connection address depending on the value of the \u0026lt;addrtype\u0026gt; field.\nWhen the \u0026lt;addrtype\u0026gt; is IP4 and IP6, the connection address is defined as follows:\n 多播场景：If the session is multicast, the connection address will be an IP multicast group address. If the session is not multicast, then the connection address contains the unicast IP address of the expected data source or data relay or data sink as determined by additional attribute fields. It is not expected that unicast addresses will be given in a session description that is communicated by a multicast announcement, though this is not prohibited. Sessions using an IPv4 multicast connection address MUST also have a time to live (TTL) value present in addition to the multicast address. The TTL and the address together define the scope with which multicast packets sent in this conference will be sent. TTL values MUST be in the range 0-255. Although the TTL MUST be specified, its use to scope multicast traffic is deprecated（不赞同使用TTL限制多播流量）; applications SHOULD use an administratively scoped address instead.  The TTL for the session is appended to the address using a slash as a separator. An example is:\n1c=IN IP4 224.2.36.42/127 IPv6 multicast does not use TTL scoping, and hence the TTL value MUST NOT be present for IPv6 multicast. It is expected that IPv6 scoped addresses will be used to limit the scope of conferences.\n","date":"2024-11-19","permalink":"/posts/tech/media-sdp/","series":["媒体开发"],"tags":["","",""],"title":"RDF-4566 SDP协议阅读"},{"categories":["计算机"],"content":"BNF 巴科斯范式(BNF: Backus-Naur Form 的缩写)是由 John Backus 和 Peter Naur 首先引入的用来描述计算机语言语法的符号集。现在，几乎每一位新编程语言书籍的作者都使用巴科斯范式来定义编程语言的语法规则。\n在BNF中，双引号中的字(\u0026ldquo;word\u0026rdquo;)代表着这些字符本身。而double_quote用来代表双引号。\n在双引号外的字（有可能有下划线）代表着语法部分。\n1\u0026lt; \u0026gt; : 内包含的为必选项。 2[ ] : 内包含的为可选项。 3{ } : 内包含的为可重复0至无数次的项。 4| : 表示在其左右两边任选一项，相当于\u0026#34;OR\u0026#34;的意思。 5::= : 是“被定义为”的意思 6\u0026#34;...\u0026#34; : 术语符号 7[...] : 选项，最多出现一次 8{...} : 重复项，任意次数，包括 0 次 9(...) : 分组 10| : 并列选项，只能选一个 11斜体字: 参数，在其它地方有解释 下面是是用BNF来定义的Java语言中的For语句的实例：\n1FOR_STATEMENT ::= 2 \u0026#34;for\u0026#34; \u0026#34;(\u0026#34; ( variable_declaration | 3 ( expression \u0026#34;;\u0026#34; ) | \u0026#34;;\u0026#34; ) 4 [ expression ] \u0026#34;;\u0026#34; 5 [ expression ] \u0026#34;;\u0026#34; 6 \u0026#34;)\u0026#34; statement ABNF RFC2234 定义了扩展的巴科斯范式(ABNF)。近年来在Internet的定义中 ABNF 被广泛使用。ABNF 做了更多的改进。扩充巴科斯-瑙尔范式(ABNF)基于了巴科斯-瑙尔范式(BNF)，但由它自己的语法和推导规则构成。这种元语言的发起原则是描述作为通信协议(双向规范)的语言的形式系统。它建档于 RFC 4234 中通常充当 IETF 通信协议的定义语言。\nABNF 规定是一组推导规则，写为：\n1规则 = 定义 ; 注释 CR LF 这里的规则是大小写敏感的非终止符，定义由定义这个规则的符号序列，一个文档注释组成，并结束于回车换行。\n规则名字是大小写不敏感的: \u0026lt;rulename\u0026gt;, \u0026lt;Rulename\u0026gt;, \u0026lt;RULENAME\u0026gt; 和 \u0026lt;rUlENamE\u0026gt; 都提及同一个规则。规则名字由开始于一个字母的字母、数字和连字符组成。不要求用尖括号(“\u0026lt;”, “\u0026gt;”) (如 BNF 那样)包围规则名字。但是它们可以用来界定规则名字，比如在冗文中识别出规则名字的时候。\nABNF 使用 7-位 ASCII 编码，在 8-位域中把高位置零。\n终结符由一个或多个数值字符指定。数值字符可以指定为跟随着基数(b = 二进制, d = 十进制, x = 十六进制)的一个百分号“%”，随后是这个数值，或数值的串联(用“.” 来指示)。例如回车可以指定为十进制的 %d13 或十六进制的 %x0D。回车换行可以指定为 %d13.10。\n文字正文通过使用包围在引号(\u0026quot;)中字符串来指定。这些字符串是大小写不敏感的，使用的字符集是 US-ASCII。所以字符串“abc”将匹配“abc”, “Abc”, “aBc”, “abC”, “ABc”, “AbC”, “aBC” 和 “ABC”。对于大小写敏感匹配，必须定义明确的字符: 要匹配 “aBc” 定义将是 %d97 %d66 %d99。\n操作符 空白被用来分隔定义的各个元素: 要使空格被识别为分割符则必须明确的包含它。\n串联 1规则1 规则2 规则可以通过列出一序列的规则名字来定义。\n要匹配字符串“aba”可以使用下列规则:\n1fu = %x61; a 2bar = %x62; b 3mumble = fu bar fu 选择 1规则1 / 规则2 规则可以通过用反斜杠(“/”)分隔的多选一规则来定义。\n要接受规则 \u0026lt;fu\u0026gt; 或规则 \u0026lt;bar\u0026gt; 可构造如下规则：\n1fubar = fu / bar 递增选择 1规则1 =/ 规则2 可以通过使用在规则名字和定义之间的“=/”来向一个规则增加补充选择。\n规则\n1ruleset = alt1 / alt2 / alt3 / alt4 / alt5 等价于\n1ruleset = alt1 / alt2 2ruleset =/ alt3 3ruleset =/ alt4 / alt5 值范围 1%c##-## 数值范围可以通过使用连字符(“-”)来指定。\n规则\n1OCTAL = \u0026#34;0\u0026#34; / \u0026#34;1\u0026#34; / \u0026#34;2\u0026#34; / \u0026#34;3\u0026#34; / \u0026#34;4\u0026#34; / \u0026#34;5\u0026#34; / \u0026#34;6\u0026#34; / \u0026#34;7\u0026#34; 等价于\n1OCTAL = %x30-37 序列分组 1(规则1 规则2) 元素可以放置在圆括号中来组合定义中的规则。\n要匹配“elem fubar snafu”或“elem tarfu snafu”可以构造下列规则：\n1group = elem (fubar / tarfu) snafu 要匹配“elem fubar”或“tarfu snafu”可以构造下列规则：\n1group = elem fubar / tarfu snafu 2group = (elem fubar) / (tarfu snafu) 可变重复 1n*n规则 要指示一个元素的重复可以使用形式 \u0026lt;a\u0026gt;*\u0026lt;b\u0026gt; 元素。可选的 \u0026lt;a\u0026gt; 给出要包括的元素的最小数目，缺省为 0。可选的 \u0026lt;b\u0026gt; 给出要包括的元素的最大数目，缺省为无穷。\n对零或多个元素使用 *元素，对一或多个元素使用 1*元素，对二或三个元素使用 2*3元素。\n特定重复 1n规则 要指示明确数目的元素可使用形式 \u0026lt;a\u0026gt; 元素，它等价于 \u0026lt;a\u0026gt;*\u0026lt;a\u0026gt;元素。\n使用 2DIGIT 得到两个数字，使用 3DIGIT 得到三个数字。(DIGIT 在下面的核心规则中定义)。\n可选序列 1[规则] 要指示可选元素下列构造是等价的：\n1[fubar snafu] 2*1(fubar snafu) 30*1(fubar snafu) 注释 1; 注释 分号(“;”)开始一个注释并持续到此行的结束。\n操作符优先级 上述操作符有从最紧绑定(binding)到最松绑定的给定优先级:\n 字符串，名字形成(formation) 注释 值范围 重复 分组，可选 串联 选择  与串联一起使用选择操作符可以造成混淆，建议使用分组来做明确串联分组。\n核心规则 核心规则定义于 ABNF 标准中。\n   规则 形式定义 意义     ALPHA %x41-5A / %x61-7A 大写和小写 ASCII 字母 (A-Z a-z)   DIGIT %x30-39 数字 (0-9)   HEXDIG DIGIT / \u0026ldquo;A\u0026rdquo; / \u0026ldquo;B\u0026rdquo; / \u0026ldquo;C\u0026rdquo; / \u0026ldquo;D\u0026rdquo; / \u0026ldquo;E\u0026rdquo; / \u0026ldquo;F\u0026rdquo; 十六进制数字 (0-9 A-F a-f)   DQUOTE %x22 双引号   SP %x20 空格   HTAB %x09 水平tab   WSP SP / HTAB 空格和水平tab   LWSP *(WSP / CRLF WSP) 线性空白(晚于换行)   VCHAR %x21-7E 可见(打印)字符   CHAR %x01-7F 任何 7-位 US-ASCII 字符，不包括 NUL   OCTET %x00-FF 8 位数据   CTL %x00-1F / %x7F 控制字符   CR %x0D 回车   LF %x0A 换行   CRLF CR LF 互联网标准换行   BIT \u0026ldquo;0\u0026rdquo; / \u0026ldquo;1\u0026rdquo;     例子 在巴科斯范式(BNF)条目中的邮政地址的例子可以被指定为：\n1postal-address = name-part street zip-part 2 3name-part = *(personal-part SP) last-name [SP suffix] CRLF 4name-part = / personal-part CRLF 5 6personal-part = first-name / (initial \u0026#34;.\u0026#34;) 7first-name = *ALPHA 8initial = ALPHA 9last-name = *ALPHA 10suffix = (\u0026#34;Jr.\u0026#34; / \u0026#34;Sr.\u0026#34; / 1*(\u0026#34;I\u0026#34; / \u0026#34;V\u0026#34; / \u0026#34;X\u0026#34;)) 11 12street = [apt SP] house-num SP street-name CRLF 13apt = 1*4DIGIT 14house-num = 1*8（DIGIT / ALPHA） 15street-name = 1*VCHAR 16 17zip-part = town-name \u0026#34;,\u0026#34; SP state 1*2SP zip-code CRLF 18town-name = 1*(ALPHA / SP) 19state = 2ALPHA 20zip-code = 5DIGIT [\u0026#34;-\u0026#34; 4DIGIT] ","date":"2024-11-18","permalink":"/posts/tech/media-abnf/","series":["媒体开发"],"tags":["","",""],"title":"ABNF"},{"categories":["普通类"],"content":"试用期完成：\n5G媒体面的测试软件， 功能包括功能测试和性能测试， 先初步完成。\n预计要学习的重点内容：\n C，C++(重要) C算法与数据结构(重要) Linux系统, 内核, 源码(重要) Erlang(重要) 各自RFC文档， 各种字符集和编码规范(重要) 视频音频的结构及处理(重要) 编译原理(重要) Python Golang 汇编 计算机体系结构(深入理解计算机系统) 计算机组成原理 操作系统原理 电子信息研究生(分块准备知识点, 优先级专业课＞数学＞英语＞政治) 物理学 ","date":"2024-11-15","permalink":"/posts/other/prospect/","series":[""],"tags":["","",""],"title":"未来知识技能展望"},{"categories":["计算机"],"content":"编译原理， 媒体处理一天都在和字符，二进制位操作， 操作系统这些底层打交道， 学这个获益极大。\n笔记大体上就是概括大意,细致的东西以后的自己翻书或者搜索吧~\n第1章 引论 1.1 语言处理器 编译器是一个将源语言翻译为目标语言的程序， 如果目标程序是一个可执行的机器语言程序， 它就可以被用户调用。解释器不通过翻译的方式生成目标程序， 它直接利用用户提供的输入执行源程序的操作。\n把用户输入映射为输出的过程中，由编译器产生的机器语言目标程序比解释器快很多， 但解释器的错误诊断效果通常比编译器更好。\n例如：Java语言处理器结合了编译和解释过程，java源程序首先被编译成字节码， 由虚拟机对字节码加以解释执行。\n语言处理系统：\n 预处理器将程序的多个模块聚合在一起，它还负责把宏的缩写形式转换为源语言的语句 编译器受到预处理的源程序可能产生一个汇编语言程序， 因为汇编语言比较容易输出和调试 汇编器处理这个汇编程序生成可重定位的机器代码 由于一个文件中的代码可能指向另一个文件的位置， 链接器解决外部内存地址的问题 加载器把所有的可执行目标文件放到内存执行  1.2 一个编译器的结构 编译器将源程序映射为目标程序， 这个映射过程由两部分组成：分析部分（前端）和综合部分（后端）\n分析部分将源程序分解为多个组成要素， 在这些要素上加上语法结构， 使用这个结构创建源程序的一个中间表示。如果分析部分检查出源程序没有按照正确的语法构成或者语义不一致就会提供有用信息使得用户按此改正。分析部分还会收集源程序的信息将其存放在一个符号表的数据结构。符号表和中间表示形式一起传送给综合部分。、\n综合部分根据中间表示形式和符号表中的信息来构造目标程序。\n编译过程步骤：字符流 \u0026mdash;(词法分析器)\u0026mdash;\u0026gt; 符号流 \u0026mdash;(语法分析)\u0026ndash;\u0026gt;语法分析\u0026mdash;(语义分析)\u0026ndash;\u0026gt;语法树 \u0026mdash;(中间代码生成器)\u0026ndash;\u0026gt; 中间表示形式 \u0026mdash;(机器无关代码优化器)\u0026ndash;\u0026gt; 中间表示形式\u0026mdash;(代码生成器)\u0026ndash;\u0026gt;目标机器语言 \u0026mdash;(机器相关代码优化器)\u0026ndash;\u0026gt; 目标机器语言\n 优化是可选的。\n 1.2.1 词法分析 编译器的第1个步骤为词法分析/扫描。\n词法分析读入源程序的字符流， 将它们组织为词素的序列。对于每个词素产生形如\u0026lt;token-name, attribute-value\u0026gt;的词法单元作为输出。其中token-name是由下一步语法分析使用的抽象符号。 attribute-value指向符号表中关于这个词法单元的条目。\n例如： 语句position = initial + rate * 60\n position: 被映射为词法单元\u0026lt;id, 1\u0026gt; ，（id是表示标识符的抽象符号， 1是符号表中position的下标， 存放着标识符的名字和类型等信息） =: \u0026lt; = \u0026gt; ，这个词法单元不需要属性值于是省略， 但也可以使用assign抽象符号作为词法单元的名字。 initial: \u0026lt; id, 2 \u0026gt;  +: \u0026lt; + \u0026gt;  rate: \u0026lt; id , 3\u0026gt;  *: \u0026lt; * \u0026gt;  60: \u0026lt; 60 \u0026gt; ，按理应是\u0026lt;number , 4 \u0026gt; ， 具体阅读第2， 3章  于是position = initial + rate * 60 \u0026mdash;词法分析\u0026ndash;\u0026gt; \u0026lt;id,1\u0026gt;\u0026lt;=\u0026gt;\u0026lt;id,2\u0026gt;\u0026lt;+\u0026gt;\u0026lt;id,3\u0026gt;\u0026lt;*\u0026gt;\u0026lt;60\u0026gt;\n1.2.2 语法分析 编译器的第2个步骤称为语法分析/解析。\n语法分析器使用词法分析器生成的各词法单元的第一个分量来创建树形的中间表示， 它给出了词法单元分析的语法结构。一个常用的表示方法是语法树， 树中每一个内部节点表示一个运算， 该节点的子结点表示运算的分量。\n这颗树显示了语句position = initial + rate * 60的运算执行顺序：\n1\t= 2 / \\ 3\u0026lt;id,1\u0026gt; + 4\t/ \\ 5 \u0026lt;id,2\u0026gt; * 6 / \\ 7 \u0026lt;id,3\u0026gt; 60 运算顺序和通常的算术规则相同。\n1.2.3 语义分析 语义分析器使用语法树和符号表检查源程序是否和语言定义的语义一致， 同时也收集信息存放在语法树和符号表中以便后续中间代码过程使用。\n语义分析还执行类型检查， 检查每个运算符是否具有匹配的运算分量。如果类型错误将报告错误。\n如果程序设计语言允许自动类型转换， 那么语义分析将进行自动类型转换。\n例如：\u0026lt;id,1\u0026gt;，\u0026lt;id,2\u0026gt;，\u0026lt;id,3\u0026gt;为浮点数， 那么60在这种情况下需要转化为浮点数才能相，这时语义分析器输出一个关于运算符inttofloat的额外结点。inttofloat明确地将整数参数转化为浮点数。\n1\t= 2 / \\ 3\u0026lt;id,1\u0026gt; + 4\t/ \\ 5 \u0026lt;id,2\u0026gt; * 6 / \\ 7 \u0026lt;id,3\u0026gt; | 8 inttofloat 9 | 10 60 1.2.4 中间代码生成 在语法分析和语义分析完成后， 编译器生成一个低级的类机器语言的中间表示，这种语言具有两个性质：它易于生成，能够轻松地翻译为目标机器上的语言。\n第6章会介绍一种叫三地址代码的中间表示形式， 它类似于汇编指令， 每个指令具有三个运算分量， 每个运算分量类似于寄存器。\n1t1 = inttofloat(60) 2t2 = id3 * t1 3t3 = id2 + t2 4id1 = t3 关于三地址指令：\n 每个三地址赋值指令的右部最多只有一个运算符 编译器应该生成一个临时名字存放三地址指令计算得到的值 有些三地址指令运算分量少于三个  1.2.5 代码优化 机器无关的代码优化生成更好的代码， 通常意味着更快， 也可以是更短或者能耗更低。\n不同编译器代码优化的工作量相差很大， 有的优化工作做得很多会在优化阶段花相当多的时间；有些优化简单可以极大提高程序运行效率且不会降低很多编译速度。\n例如：优化器得出结论，把60转化为浮点数的运算可以在编译时刻一劳永逸地完成， 于是使用浮点数60.0替代整数60可以消除inttofloat运算；t3仅被使用一次， 可以把它的值传递给id1\n1t1 = id3 * 60.0 2id1 = id2 + t1 1.2.6 代码生成 代码生成器以中间表示形式输入映射为目标语言， 如果目标语言是机器代码， 它将为程序使用的每个变量选择寄存器或内存位置，然后中间指令被翻译成为机器指令序列。\n例如使用寄存器R1和R2：\n1#将地址id3的内容加载到寄存器R2中 2LDF R2, id3 3 4#‘#’表示60.0作为一个立即数处理。将60.0乘R2中的内容 5MULF R2, R2, #60.0 6 7LDF R1, id2 8 9#将存放在R2的值加到R1上 10ADDF R1, R1, R2 11 12#将寄存器R1中的值存放到id1中 13STF id1, R1 1.2.7 符号表管理 符号表为每个变量创建条目, 记录名字的各个属性如类型,作用域; 对于过程名字还包括参数数量和类型, 每个参数的传递方法和返回类型.\n1.2.8 将多个步骤组合成趟 多个步骤组合成一趟. 我们可以把不同前端和某个目标机的后端结合为不同源语言建立目标机上的编译器; 同样也可以将同一个前端和不同目标机后端结合建立不同目标机的编译器. 这一切通过前端和后端的中间表示形式连接.\n1.2.9 编译器构造工具 工具实现编译器的不同阶段, 它们生成的组件易于和编译器的其他部分相集成, 如语法分析器的生成器, 扫描器的生成器, 语法制导的翻译引擎, 代码生成器的生成器, 数据流分析引擎, 编译器构造工具集.\n1.3 程序设计语言的发展历程 1.3.1 走向高级程序设计语言 按照代分类:\n 第一代语言:机器语言 第二代语言: 汇编语言 第三代语言: 高级程序设计语言(Fortran, Cobol, Lisp, C, C++, C#, Java) 第四代语言: 为特定应用设计的语言(NOMAD, SQL, Postscript) 第五代语言: 基于逻辑和约束的语言(Prolog, OPS5)  另一种分类方式:\n 强制式语言:指明如何完成一个计算任务的语言 声明式语言: 指明要进行哪些运算的语言.  冯诺依曼语言: 以冯诺依曼计算机体系结构为计算模型的程序设计语言\n面向对象语言, 脚本语言\u0026hellip;\n1.3.2 对编译器的影响  编译器设计者必须设计算法和表示方式来翻译和支持新的语言特征. 通过降低用高级语言程序的执行开销, 编译器还可以推动这些高级语言的使用. 编译器必须能够正确翻译用源语言书写的所有程序, 但为源程序生成最佳代码的问题一般是不可判定的, 编译器设计者需要折中处理, 以解决高效代码生成问题.  1.4 构建一个编译器的相关科学 1.4.1 编译器设计和实现中的建模 如何设计正确的数学模型和选择正确算法的研究, 在过程中需考虑通用性, 功能, 简单性, 有效性之间的平衡. 如:\n 有穷状态自动机和正则表达式用来描述程序的词法单位(关键字, 标识符等)以及描述被编译器用来识别这些单位的算法 上下文无关法用于描述程序设计语言的语法结构 树形结构表示程序结构以及程序到目标代码的翻译方法  1.4.2 代码优化的科学 处理器体系结构更加复杂, 这让编译器有了更多改进代码执行方式的机会.\n编译器设计目标:\n  优化必须是正确的(不改变编译程序的含义)\n  优化必须能够改善很多程序的性能.\n性能通常意味着执行速度, 也希望降低生成代码的大小, 降低代码能耗. 另外错误报告和调试等可用性也很重要.\n  优化所需的时间必须保持在合理范围内\n开启优化有时候会暴露源程序中的新问题, 需要对经过优化的代码再次进行测试.\n  所需要的工程方面的工作必须是可管理的\n  1.5 编译技术的应用","date":"2024-11-15","permalink":"/posts/tech/basic-compilersprinciples/","series":["基础能力"],"tags":["","",""],"title":"编译原理"},{"categories":["普通类"],"content":"关于学生思维 面向的是知识的稳固和结构性，应用通过刷题解决。\n于是乎笔记和记忆最重要\n工作需要的东西 工作面向的是产品和创新， 这意味着知识是其次的， 最重要的是应用及创新能力，自己生疏的知识只需要立刻去查即可。知识只需要过一过，重要的是应用和创新。\n我决定将笔记数目减少， 只保留最容易忘记， 最重要的笔记。\n学习知识的目的转向思考能做出的东西及创新。\n笔记要记录的只是重复性容易忘记的内容, 或者是新学的生疏的内容.\n如果是不能记录笔记的书籍, 可以采用读后感的形式记录读过的书.\n","date":"2024-11-14","permalink":"/posts/other/note-rule/","series":[""],"tags":["","",""],"title":"笔记规范"},{"categories":["计算机"],"content":"运行shell脚本的方法 1.作为可执行程序\n1chmod +x ./test.sh #使脚本具有执行权限 2./test.sh #执行脚本 2.作为解释器参数\n1/bin/sh test.sh 2/bin/php test.php 变量 定义变量 变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。同时，变量名的命名须遵循如下规则：\n 只包含字母、数字和下划线：** 变量名可以包含字母（大小写敏感）、数字和下划线 _，不能包含其他特殊字符。 不能以数字开头： 变量名不能以数字开头，但可以包含数字。 避免使用 Shell 关键字： 不要使用Shell的关键字（例如 if、then、else、fi、for、while 等）作为变量名，以免引起混淆。 使用大写字母表示常量：习惯上，常量的变量名通常使用大写字母，例如 PI=3.14。 避免使用特殊符号： 尽量避免在变量名中使用特殊符号，因为它们可能与 Shell 的语法产生冲突。 避免使用空格： 变量名中不应该包含空格，因为空格通常用于分隔命令和参数。  有效的 Shell 变量名示例如下：\n1RUNOOB=\u0026#34;www.runoob.com\u0026#34; 2LD_LIBRARY_PATH=\u0026#34;/bin/\u0026#34; 3_var=\u0026#34;123\u0026#34; 4var2=\u0026#34;abc\u0026#34; 除了显式地直接赋值，还可以用语句给变量赋值，如：\n1for file in `ls /etc` 2 或 3for file in $(ls /etc) 以上语句将 /etc 下目录的文件名循环出来。\n使用变量 使用一个定义过的变量，只要在变量名前面加美元符号即可，如：\n1your_name=\u0026#34;qinjx\u0026#34; 2 echo $your_name 3 echo ${your_name} 变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况：\n1for skill in Ada Coffe Action Java; do 2 echo \u0026#34;I am good at ${skill}Script\u0026#34; 3done 如果不给skill变量加花括号，写成echo \u0026ldquo;I am good at $skillScript\u0026rdquo;，解释器就会把$skillScript当成一个变量（其值为空），代码执行结果就不是我们期望的样子了。\n推荐给所有变量加上花括号，这是个好的编程习惯。\n只读变量 使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。\n1#!/bin/bash 2 3myUrl=\u0026#34;https://www.google.com\u0026#34; 4readonly myUrl 5myUrl=\u0026#34;https://www.runoob.com\u0026#34; 6 7#/bin/sh: NAME: This variable is read only. 删除变量 使用 unset 命令可以删除变量。语法：\n1unset variable_name 变量被删除后不能再次使用。unset 命令不能删除只读变量。\n变量类型   字符串变量： 使用单引号 ' 或双引号 \u0026quot; 来定义字符串\n  整数变量： 可以使用 declare 或 typeset 命令来声明整数变量。\n1declare -i my_integer=42 这样的声明告诉 Shell 将 my_integer 视为整数，如果尝试将非整数值赋给它，Shell会尝试将其转换为整数。\n  数组变量：\n  Shell 也支持数组，允许你在一个变量中存储多个值。数组可以是整数索引数组或关联数组\n  1#整数索引数组 2my_array=(1 2 3 4 5) 3 4#关联数组 5declare -A associative_array 6associative_array[\u0026#34;name\u0026#34;]=\u0026#34;John\u0026#34; 7associative_array[\u0026#34;age\u0026#34;]=30   环境变量：这些是由操作系统或用户设置的特殊变量，用于配置 Shell 的行为和影响其执行环境。例如，PATH 变量包含了操作系统搜索可执行文件的路径\n  特殊变量：有一些特殊变量在 Shell 中具有特殊含义，例如 $0 表示脚本的名称，$1, $2, 等表示脚本的参数。\n$#表示传递给脚本的参数数量，$? 表示上一个命令的退出状态等。\n  字符串 字符串可以用单引号，也可以用双引号，也可以不用引号。\n1.单引号字符串的限制：\n 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的； 单引号字符串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。  2.双引号的优点：\n 双引号里可以有变量 双引号里可以出现转义字符  1your_name=\u0026#34;runoob\u0026#34; 2str=\u0026#34;Hello, I know you are \\\u0026#34;$your_name\\\u0026#34;! \\n\u0026#34; 3echo -e $str 3.字符串拼接：\n 可以使用双引号或者单引号包裹变量 单引号中包裹变量只能使用单引号  1your_name=\u0026#34;runoob\u0026#34; 2# 使用双引号拼接 3greeting=\u0026#34;hello, \u0026#34;$your_name\u0026#34; !\u0026#34; 4greeting_1=\u0026#34;hello, ${your_name}!\u0026#34; 5echo $greeting $greeting_1 6#hello, runoob ! hello, runoob ! 7 8# 使用单引号拼接 9greeting_2=\u0026#39;hello, \u0026#39;$your_name\u0026#39; !\u0026#39; 10greeting_3=\u0026#39;hello, ${your_name} !\u0026#39; 11echo $greeting_2 $greeting_3 12#hello, runoob ! hello, ${your_name} ! 4.获取字符串长度\n${#string}\n变量为字符串时，${#string} 等价于 ${#string[0]}:\n1string=\u0026#34;abcd\u0026#34; 2echo ${#string} # 输出 4 3 4string=\u0026#34;abcd\u0026#34; 5echo ${#string[0]} # 输出 4 5.提取子字符串\n${string:开始下标：总共截取长度}\n从字符串第 2 个字符开始截取 4 个字符：\n1string=\u0026#34;runoob is a great site\u0026#34; 2echo ${string:1:4} # 输出 unoo 应用shell特殊符号截取：\n假设有变量 var=http://www.aaa.com/123.htm\n # 号截取，删除左边字符，保留右边字符。  1echo ${var#*//} 其中 var 是变量名，# 号是运算符，*// 表示从左边开始删除第一个 // 号及左边的所有字符\n即删除 http://\n结果是 ：www.aaa.com/123.htm\n## 号截取，删除左边字符，保留右边字符。  1echo ${var##*/} ##*/ 表示从左边开始删除最后（最右边）一个 / 号及左边的所有字符\n即删除 http://www.aaa.com/\n结果是 123.htm\n%号截取，删除右边字符，保留左边字符  1echo ${var%/*} %/* 表示从右边开始，删除第一个 / 号及右边的字符\n结果是：http://www.aaa.com\n%% 号截取，删除右边字符，保留左边字符  1echo ${var%%/*} %%/* 表示从右边开始，删除最后（最左边）一个 / 号及右边的字符\n结果是：http:\n从左边第几个字符开始，及字符的个数  1echo ${var:0:5} 其中的 0 表示左边第一个字符开始，5 表示字符的总个数。\n结果是：http:\n从左边第几个字符开始，一直到结束。  1echo ${var:7} 其中的 7 表示左边第8个字符开始，一直到结束。\n结果是 ：www.aaa.com/123.htm\n从右边第几个字符开始，及字符的个数  1echo ${var:0-7:3} 其中的 0-7 表示右边算起第七个字符开始，3 表示字符的个数。\n结果是：123\n从右边第几个字符开始，一直到结束。  1echo ${var:0-7} 表示从右边第七个字符开始，一直到结束。\n结果是：123.htm\n注：（左边的第一个字符是用 0 表示，右边的第一个字符用 0-1 表示）\n#、## 表示从左边开始删除。一个 # 表示从左边删除到第一个指定的字符；两个 # 表示从左边删除到最后一个指定的字符。\n%、%% 表示从右边开始删除。一个 % 表示从右边删除到第一个指定的字符；两个 % 表示从左边删除到最后一个指定的字符。\n删除包括了指定的字符本身。\n6.查找子字符串\nexpr index \u0026quot;$string\u0026quot; 子串\n查找字符 i 或 o 的位置(哪个字母先出现就计算哪个)：\n1string=\u0026#34;runoob is a great site\u0026#34; 2echo `expr index \u0026#34;$string\u0026#34; io` # 输出 4 用反引号括起来， 不然echo直接打印后面的字符。\n数组 bash支持一维数组（不支持多维数组），并且没有限定数组的大小。类似于 C 语言，数组元素的下标由 0 开始编号。获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于 0。\n定义数组 数组名=(值1 值2 ... 值n)\n定义示例：\n可以不使用连续的下标，而且下标的范围没有限制。\n1array_name=(value0 value1 value2 value3) 2 3array_name=( 4value0 5value1 6value2 7value3 8) 9 10array_name[0]=value0 11array_name[1]=value1 12array_name[n]=valuen 读取数组 ${数组名[下标]}\n使用 @ 符号可以获取数组中的所有元素\n1valuen=${array_name[n]} 2 3echo ${array_name[@]} 获取数组的长度 和字符串一样\n1# 取得数组元素的个数 2length=${#array_name[@]} 3# 或者 4length=${#array_name[*]} 5 6# 取得数组单个元素的长度 7length=${#array_name[n]} 注释 单行注释 以 # 开头的行就是注释，会被解释器忽略。通过每一行加一个 # 号设置多行注释\n如果在开发过程中，遇到大段的代码需要临时注释起来，过一会儿又取消注释，怎么办呢？\n每一行加个#符号太费力了，可以把这一段要注释的代码用一对花括号括起来，定义成一个函数，没有地方调用这个函数，这块代码就不会执行，达到了和注释一样的效果。\n多行注释 1#语法 2:\u0026lt;\u0026lt;EOF 3注释内容... 4注释内容... 5注释内容... 6EOF 7 8#示例 9: \u0026lt;\u0026lt;\u0026#39;COMMENT\u0026#39; 10这是注释的部分。 11可以有多行内容。 12COMMENT 13 14:\u0026lt;\u0026lt;\u0026#39; 15注释内容... 16注释内容... 17注释内容... 18\u0026#39; 19 20:\u0026lt;\u0026lt;! 21注释内容... 22注释内容... 23注释内容... 24! 或者使用：号\n: + 空格 + 单引号\n1: \u0026#39; 2这是注释的部分。 3可以有多行内容。 4\u0026#39; 传递参数 我们可以在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为 $n，n 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数。\n例如可以使用 $1、$2 等来引用传递给脚本的参数，其中 $1 表示第一个参数，$2 表示第二个参数，依此类推。\n例：\n1#!/bin/bash 2# author:菜鸟教程 3# url:www.runoob.com 4 5echo \u0026#34;Shell 传递参数实例！\u0026#34;; 6echo \u0026#34;执行的文件名：$0\u0026#34;; 7echo \u0026#34;第一个参数为：$1\u0026#34;; 8echo \u0026#34;第二个参数为：$2\u0026#34;; 9echo \u0026#34;第三个参数为：$3\u0026#34;; 10 11 12--------------- 13 14 15$ chmod +x test.sh 16$ ./test.sh 1 2 3 17Shell 传递参数实例！ 18执行的文件名：./test.sh 19第一个参数为：1 20第二个参数为：2 21第三个参数为：3 特殊字符：\n   参数处理 说明     $# 传递到脚本的参数个数   $* 以一个单字符串显示所有向脚本传递的参数。 如\u0026quot;$*\u0026ldquo;用「\u0026quot;」括起来的情况、以\u0026rdquo;$1 $2 … $n\u0026quot;的形式输出所有参数。   $$ 脚本运行的当前进程ID号   $! 后台运行的最后一个进程的ID号   $@ 与$*相同，但是使用时加引号，并在引号中返回每个参数。 如\u0026quot;$@\u0026ldquo;用「\u0026quot;」括起来的情况、以\u0026rdquo;$1\u0026quot; \u0026ldquo;$2\u0026rdquo; … \u0026ldquo;$n\u0026rdquo; 的形式输出所有参数。   $- 显示Shell使用的当前选项，与set命令 功能相同。   $? 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。    例：\n1#!/bin/bash 2# author:菜鸟教程 3# url:www.runoob.com 4 5echo \u0026#34;Shell 传递参数实例！\u0026#34;; 6echo \u0026#34;第一个参数为：$1\u0026#34;; 7 8echo \u0026#34;参数个数为：$#\u0026#34;; 9echo \u0026#34;传递的参数作为一个字符串显示：$*\u0026#34;; 10 11 12--------------- 13 14$ chmod +x test.sh 15$ ./test.sh 1 2 3 16Shell 传递参数实例！ 17第一个参数为：1 18参数个数为：3 19传递的参数作为一个字符串显示：1 2 3 20 $* 与 $@ 区别：\n 相同点：都是引用所有参数。 不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，则 \u0026quot; * \u0026quot; 等价于 \u0026ldquo;1 2 3\u0026rdquo;（传递了一个参数），而 \u0026ldquo;@\u0026rdquo; 等价于 \u0026ldquo;1\u0026rdquo; \u0026ldquo;2\u0026rdquo; \u0026ldquo;3\u0026rdquo;（传递了三个参数）。  1#!/bin/bash 2# author:菜鸟教程 3# url:www.runoob.com 4 5echo \u0026#34;-- \\$* 演示 ---\u0026#34; 6for i in \u0026#34;$*\u0026#34;; do 7 echo $i 8done 9 10echo \u0026#34;-- \\$@ 演示 ---\u0026#34; 11for i in \u0026#34;$@\u0026#34;; do 12 echo $i 13done 14 15 16--------------- 17 18$ chmod +x test.sh 19$ ./test.sh 1 2 3 20-- $* 演示 --- 211 2 3 22-- $@ 演示 --- 231 242 253 数组 基础在上面\n关联数组 定义：declare -A array_name\n其实也就是java中的字典。\n1declare -A site=([\u0026#34;google\u0026#34;]=\u0026#34;www.google.com\u0026#34; [\u0026#34;runoob\u0026#34;]=\u0026#34;www.runoob.com\u0026#34; [\u0026#34;taobao\u0026#34;]=\u0026#34;www.taobao.com\u0026#34;) 2 3#先声明一个关联数组，然后再设置键和值 4declare -A site 5site[\u0026#34;google\u0026#34;]=\u0026#34;www.google.com\u0026#34; 6site[\u0026#34;runoob\u0026#34;]=\u0026#34;www.runoob.com\u0026#34; 7site[\u0026#34;taobao\u0026#34;]=\u0026#34;www.taobao.com\u0026#34; 访问：array_name[\u0026quot;index\u0026quot;]\n1declare -A site 2site[\u0026#34;google\u0026#34;]=\u0026#34;www.google.com\u0026#34; 3site[\u0026#34;runoob\u0026#34;]=\u0026#34;www.runoob.com\u0026#34; 4site[\u0026#34;taobao\u0026#34;]=\u0026#34;www.taobao.com\u0026#34; 5 6echo ${site[\u0026#34;runoob\u0026#34;]} 获取数组所有元素 使用 @ 或 * 可以获取数组中的所有元素\n1#!/bin/bash 2# author:菜鸟教程 3# url:www.runoob.com 4 5my_array[0]=A 6my_array[1]=B 7my_array[2]=C 8my_array[3]=D 9 10echo \u0026#34;数组的元素为: ${my_array[*]}\u0026#34; 11echo \u0026#34;数组的元素为: ${my_array[@]}\u0026#34; 12 13------------- 14 15$ chmod +x test.sh 16$ ./test.sh 17数组的元素为: A B C D 18数组的元素为: A B C D 19 1declare -A site 2site[\u0026#34;google\u0026#34;]=\u0026#34;www.google.com\u0026#34; 3site[\u0026#34;runoob\u0026#34;]=\u0026#34;www.runoob.com\u0026#34; 4site[\u0026#34;taobao\u0026#34;]=\u0026#34;www.taobao.com\u0026#34; 5 6echo \u0026#34;数组的元素为: ${site[*]}\u0026#34; 7echo \u0026#34;数组的元素为: ${site[@]}\u0026#34; 8 9--------------- 10 11$ chmod +x test.sh 12$ ./test.sh 13数组的元素为: www.google.com www.runoob.com www.taobao.com 14数组的元素为: www.google.com www.runoob.com www.taobao.com 在数组前加一个感叹号 ! 可以获取数组的所有键\n1declare -A site 2site[\u0026#34;google\u0026#34;]=\u0026#34;www.google.com\u0026#34; 3site[\u0026#34;runoob\u0026#34;]=\u0026#34;www.runoob.com\u0026#34; 4site[\u0026#34;taobao\u0026#34;]=\u0026#34;www.taobao.com\u0026#34; 5 6echo \u0026#34;数组的键为: ${!site[*]}\u0026#34; 7echo \u0026#34;数组的键为: ${!site[@]}\u0026#34; 8 9------------- 10 11数组的键为: google runoob taobao 12数组的键为: google runoob taobao 获取数组的长度 获取数组长度的方法与获取字符串长度的方法相同\n1#!/bin/bash 2# author:菜鸟教程 3# url:www.runoob.com 4 5my_array[0]=A 6my_array[1]=B 7my_array[2]=C 8my_array[3]=D 9 10echo \u0026#34;数组元素个数为: ${#my_array[*]}\u0026#34; 11echo \u0026#34;数组元素个数为: ${#my_array[@]}\u0026#34; Tips 数组的值也可以写入变量。\n1A=1 2my_array=($A B C D) 3echo \u0026#34;第一个元素为: ${my_array[0]}\u0026#34; 4echo \u0026#34;第二个元素为: ${my_array[1]}\u0026#34; 5echo \u0026#34;第三个元素为: ${my_array[2]}\u0026#34; 6echo \u0026#34;第四个元素为: ${my_array[3]}\u0026#34; 根据数组元素索引获取该数组元素值时，数组下标可为变量。\n1arr=(a b c d) 2i=2 3echo ${arr[i]} 运算符 原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。\nexpr 是一款表达式计算工具，使用它能完成表达式的求值操作。\n 表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。 完整的表达式要被   包含，注意这个字符不是常用的单引号，在 Esc 键下边。  1#!/bin/bash 2 3val=`expr 2 + 2` 4echo \u0026#34;两数之和为 : $val\u0026#34; 算术运算符 表列出了常用的算术运算符，假定变量 a 为 10，变量 b 为 20：\n   运算符 说明 举例     + 加法 expr $a + $b 结果为 30。   - 减法 expr $a - $b 结果为 -10。   * 乘法 expr $a \\* $b 结果为 200。   / 除法 expr $b / $a 结果为 2。   % 取余 expr $b % $a 结果为 0。   = 赋值 a=$b 把变量 b 的值赋给 a。   == 相等。用于比较两个数字，相同则返回 true。 [ $a == $b ] 返回 false。   != 不相等。用于比较两个数字，不相同则返回 true。 [ $a != $b ] 返回 true。    条件表达式要放在方括号之间，并且要有空格，例如: [$a==$b] 是错误的，必须写成 [ $a == $b ]。\n关系运算符 假定变量 a 为 10，变量 b 为 20：\n   运算符 说明 举例     -eq 检测两个数是否相等，相等返回 true。 [ $a -eq $b ] 返回 false。   -ne 测两个数是否不相等，不相等返回 true。 [ $a -ne $b ] 返回 true。   -gt 检测左边的数是否大于右边的，如果是，则返回 true。 [ $a -gt $b ] 返回 false。   -lt 检测左边的数是否小于右边的，如果是，则返回 true。 [ $a -lt $b ] 返回 true。   -ge 检测左边的数是否大于等于右边的，如果是，则返回 true。 [ $a -ge $b ] 返回 false。   -le 检测左边的数是否小于等于右边的，如果是，则返回 true。 [ $a -le $b ] 返回 true。    布尔运算符 假定变量 a 为 10，变量 b 为 20：\n   运算符 说明 举例     ! 非运算，表达式为 true 则返回 false，否则返回 true。 [ ! false ] 返回 true。   -o 或运算，有一个表达式为 true 则返回 true。 [ $a -lt 20 -o $b -gt 100 ] 返回 true。   -a 与运算，两个表达式都为 true 才返回 true。 [ $a -lt 20 -a $b -gt 100 ] 返回 false。    逻辑运算符 假定变量 a 为 10，变量 b 为 20:\n   运算符 说明 举例     \u0026amp;\u0026amp; 逻辑的 AND [[ $a -lt 100 \u0026amp;\u0026amp; $b -gt 100 ]] 返回 false   || 逻辑的 OR [[ $a -lt 100 || $b -gt 100 ]] 返回 true    字符串运算符 假定变量 a 为 \u0026ldquo;abc\u0026rdquo;，变量 b 为 \u0026ldquo;efg\u0026rdquo;：\n   运算符 说明 举例     = 检测两个字符串是否相等，相等返回 true。 [ $a = $b ] 返回 false。   != 检测两个字符串是否不相等，不相等返回 true。 [ $a != $b ] 返回 true。   -z 检测字符串长度是否为0，为0返回 true。 [ -z $a ] 返回 false。   -n 检测字符串长度是否不为 0，不为 0 返回 true。 [ -n \u0026ldquo;$a\u0026rdquo; ] 返回 true。   $ 检测字符串是否不为空，不为空返回 true。 [ $a ] 返回 true。    文件测试运算符 文件测试运算符用于检测 Unix 文件的各种属性。\n属性检测描述如下：\n   操作符 说明 举例     -b file 检测文件是否是块设备文件，如果是，则返回 true。 [ -b $file ] 返回 false。   -c file 检测文件是否是字符设备文件，如果是，则返回 true。 [ -c $file ] 返回 false。   -d file 检测文件是否是目录，如果是，则返回 true。 [ -d $file ] 返回 false。   -f file 检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。 [ -f $file ] 返回 true。   -g file 检测文件是否设置了 SGID 位，如果是，则返回 true。 [ -g $file ] 返回 false。   -k file 检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。 [ -k $file ] 返回 false。   -p file 检测文件是否是有名管道，如果是，则返回 true。 [ -p $file ] 返回 false。   -u file 检测文件是否设置了 SUID 位，如果是，则返回 true。 [ -u $file ] 返回 false。   -r file 检测文件是否可读，如果是，则返回 true。 [ -r $file ] 返回 true。   -w file 检测文件是否可写，如果是，则返回 true。 [ -w $file ] 返回 true。   -x file 检测文件是否可执行，如果是，则返回 true。 [ -x $file ] 返回 true。   -s file 检测文件是否为空（文件大小是否大于0），不为空返回 true。 [ -s $file ] 返回 true。   -e file 检测文件（包括目录）是否存在，如果是，则返回 true。 [ -e $file ] 返回 true。    其他检查符：\n -S: 判断某文件是否 socket。 -L: 检测文件是否存在并且是一个符号链接。  1#!/bin/bash 2# author:菜鸟教程 3# url:www.runoob.com 4 5file=\u0026#34;/var/www/runoob/test.sh\u0026#34; 6if [ -r $file ] 7then 8 echo \u0026#34;文件可读\u0026#34; 9else 10 echo \u0026#34;文件不可读\u0026#34; 11fi 12if [ -w $file ] 13then 14 echo \u0026#34;文件可写\u0026#34; 15else 16 echo \u0026#34;文件不可写\u0026#34; 17fi 18if [ -x $file ] 19then 20 echo \u0026#34;文件可执行\u0026#34; 21else 22 echo \u0026#34;文件不可执行\u0026#34; 23fi 24if [ -f $file ] 25then 26 echo \u0026#34;文件为普通文件\u0026#34; 27else 28 echo \u0026#34;文件为特殊文件\u0026#34; 29fi 30if [ -d $file ] 31then 32 echo \u0026#34;文件是个目录\u0026#34; 33else 34 echo \u0026#34;文件不是个目录\u0026#34; 35fi 36if [ -s $file ] 37then 38 echo \u0026#34;文件不为空\u0026#34; 39else 40 echo \u0026#34;文件为空\u0026#34; 41fi 42if [ -e $file ] 43then 44 echo \u0026#34;文件存在\u0026#34; 45else 46 echo \u0026#34;文件不存在\u0026#34; 47fi 自增和自减操作符 尽管 Shell 本身没有像 C、C++ 或 Java 那样的 ++ 和 \u0026ndash; 操作符，但可以通过其他方式实现相同的功能。以下是一些常见的方法：\nlet命令 1#!/bin/bash 2 3# 初始化变量 4num=5 5 6# 自增 7let num++ 8 9# 自减 10let num-- 11 12echo $num $(()) 1#!/bin/bash 2 3# 初始化变量 4num=5 5 6# 自增 7num=$((num + 1)) 8 9# 自减 10num=$((num - 1)) 11 12echo $num expr 1#!/bin/bash 2 3# 初始化变量 4num=5 5 6# 自增 7num=$(expr $num + 1) 8 9# 自减 10num=$(expr $num - 1) 11 12echo $num (()) 1#!/bin/bash 2 3# 初始化变量 4num=5 5 6# 自增 7((num++)) 8 9# 自减 10((num--)) 11 12echo $num echo命令 停止 自己只需要过一过就行， 忘记了自己去查， 故不再更新。\n","date":"2024-11-14","permalink":"/posts/tech/media-misc-shell/","series":["媒体开发"],"tags":["","",""],"title":"菜鸟教程Shell"},{"categories":["计算机"],"content":"  在线rst编辑器：\nhttp://rst.ninjs.org/\nhttps://notex.ch/editor\n  英文文档：https://docutils.sourceforge.io/docs/ref/rst/restructuredtext.html\n  国内资料： reStructuredText(.rst)语法规则快速入门 1, reStructuredText(.rst)语法规则快速入门2   简单总结：\n  标题： ! \u0026quot; # $ % \u0026amp; ' ( ) * + , - . / : ; \u0026lt; = \u0026gt; ? @ [ \\ ] ^ _ ` { | } ~ 连续几个分为几级标题\n  段落： 空行为一段， 缩进变成引用段落\n  列表\n无序列表：* + - • ‣ ⁃\n有序列表：\n1arabic numerals: 1, 2, 3, ... (no upper limit). 2uppercase alphabet characters: A, B, C, ..., Z. 3lower-case alphabet characters: a, b, c, ..., z. 4uppercase Roman numerals: I, II, III, IV, ..., MMMMCMXCIX (4999). 5lowercase Roman numerals: i, ii, iii, iv, ..., mmmmcmxcix (4999). 如果你不想使用这些，在你标明第一个条目的序号字符后，第二个开始你还可以使用”#”号来让reStructuredText自动生成需要的序号。\n定义列表\n字段列表\n选项列表\n  表格：\n网格表： - = | +\n-” 用来分隔行， “=“ 用来分隔表头和表体行，”|” 用来分隔列，而”+”用来表示行和列相交的节点\n简单表格: = -\n1 2基本形式 3======== 4 5`下面这种是最简单的表格形式，当然你也可以去掉表头展示。`6 7===== ===== =======8 A B A and B9===== ===== =======10False False False11True False False12False True False13True True True14===== ===== =======15 16表内嵌入 17======== 18 19`下面这种简单表内有列表`20 21===== =====22col 1 col 223===== =====241 Second column of row 1.252 Second column of row 2.26 Second line of paragraph.273 - Second column of row 3.28 29 - Second item in bullet30 list (row 3, column 2).31\\ Row 4; column 1 will be empty.32===== =====  块：\n文字块： 前面两冒号+空行， 块内内容要有缩进。\n  样式：\n1.. Strong Emphasis 2 3This is **Strong Text**. HTML tag is strong.粗体 4 5.. Italic, Emphasis 6 7This is *Emphasis* Text.这个HTML使用em， 斜体 8 9.. Interpreted Text 10 11This is `Interpreted Text`. 注意，这个HTML一般用\u0026lt;cite\u0026gt;表示 12 13.. Inline Literals 14 15This is ``Inline Literals``. HTML tag is \u0026lt;tt\u0026gt;. 等宽字体. 16 17 18 19我这里是一个 链接_. 20 21.. _链接: http://blog.useasp.net 22 23这里同样是一个 `链接\u0026lt;http://blog.useasp.net\u0026gt;`_，不需要特别设置。  ","date":"2024-11-13","permalink":"/posts/tech/media-misc-rst/","series":["媒体开发"],"tags":["","",""],"title":"Rst语法"},{"categories":["计算机"],"content":"git 1.创建repository仓库\n1git --version 2mkdir my-cool-website 3cd my-cool-website 4git status #在不知道怎么办时获取一些信息 5git init #初始化仓库 6git status 2.设置用户信息\n1## global 全局配置 2git config --global user.name \u0026#34;Valenti Despa\u0026#34; 3git config --global user.email \u0026#34;valenti@example.com\u0026#34; 3.第一次commit提交\n1git commit #无文件提交(文件没有变化) 2vim readme.md #:x保存退出 3git status #出现未跟踪文件 4git add readme.md #添加追踪文件（暂存区） 5git status #出现要提交的变更 6git commit -m \u0026#34;My first commit\u0026#34; 4.一次提交多个文件\n1vim index.html 2vim readme.md 3git status #出现未跟踪的文件以及待提交的变更 4#一个一个添加 5#git add readme.md index.html 6git add . #全部添加 5.取消暂存区的文件的变更\n这样做不意味着原文件的变更取消了\n1git reset HEAD readme.md 2git status 3git commit -m \u0026#34;Added first page\u0026#34; 4 5git add . 6git status 7git commit -m \u0026#34;Improve readme\u0026#34; 8git status 9 6.查看变更\n1git log 2git log --patch #查看更详细的变更 7.提交文件夹\n1mkdir temp 2git status #git不跟踪文件夹 3#插入空文件 4touch temp/.gitkeep 5git status 6git add . 7git commit -m \u0026#34;Added temp folder\u0026#34; 8.删除文件\n1#未跟踪文件 2touch newfile.txt 3git status #未跟踪文件 4rm newfile.txt 5 6#在跟踪文件 7rm -rf -- temp #删除在跟踪目录 8git status 9git add . #暂存区删除目录 10git commit -m \u0026#34;Removed temp folder\u0026#34; 9..gitignore文件\n有些文件在目录中但是不想让他们在仓库中，使用gitignore排除他们。\n1mkdir config 2touch config/private.txt 3git status 4vim .gitignore 5 6config 7 8git status 9git add . 10git commit -m \u0026#34;Added gitignore configuration\u0026#34; 10.创建分支\n创建实验性的东西， 开发新功能等。这样不会影响主分支\n1git checkout -b feature/new-table #创建新分支并切换 2git status 3vim index.html 4git add . 5git commit -m \u0026#34;Added table\u0026#34; 6 7git checkout master #回到主分支 8cat index.html #没有变化 9 10git checkout feature/new-table 11.合并分支\n这里只是出现简单合并。\n1git branch -d featrue/new-table #删除分支出现error 2 3git checkout master 4git merge feature/new-table 5git log 6 7#合并模式为fastforward， 这只会在当master没有出现更改情况下的合并 8git branch -d featrue/new-table 12.高级分支场景\n1git checkout -b bugfix/table 2vim index.html 3git add . 4git status 5git commit -m \u0026#34;Added table cell\u0026#34; 6 7git checkout master 8vim readme.md 9git add . 10git commit -m \u0026#34;Learning branching\u0026#34; 11 12#这时出现了双分支。两分支无共同父 13git merge bugfix/table 14#这时使用的是recursive 递归策略 15 13.获取另一个分支的修改\n这样可以使得两个分支在一些文件保持一直， 可以进行快速合并\n1git checkout -b bugfix/table-2 2vim index.html 3git add . 4git commit -m \u0026#34;Added 2nd cell\u0026#34; 5 6git checkout master 7vim readme.md 8git add . 9git commit -m \u0026#34;Learning rebaseing\u0026#34; 10 11#不能进行快速合并 12 13git checkout bugfix/table-2 14#bugfix/table-2获取，master的修改 15git rebase master 16 17git log 18git checkout master 19#快速合并 20git merge bugfix/table-2 14.解决合并冲突\n合并冲突通常是两次提交修改到了同一文件甚至三同一行\n1#准备 2git checkout -b bugfix/table-3 3vim index.html 4git add . 5git commit -m \u0026#34;Rename cell\u0026#34; 6 7git checkout master 8vim index.html #修改同一行 9git add . 10git commit -m \u0026#34;Renamed in My cell\u0026#34; 11 12#冲突 13git merge bugfix/table-3 #冲突 14git status #both modified: index.html 15git merge --abort #停止合并 16git status #一切都好 17 18git checkout bugfix/table-3 19git rebase master #冲突 20git rebase --abort #停止同步 21 22#解决 23git merge bugfix/table-3 #冲突 24git status #both modified: index.html 25vim index.html #出现HEAD， 分支等信息， 告诉你那里冲突了 26#解决冲突， 可以使用ide打开更好解决。 27 28#告诉git已经处理好冲突 29git add index.html 30git commit -m \u0026#34;Resolve conflict\u0026#34; 31git status 15.在远程仓库开发\n  创建新的项目\n  创建新仓库或者推送已有仓库\n1git init 2 3#origin是后面链接的别名 4git remote add origin git@gitlab.---.team:---/my-cool-website.git 5 6git remote -v #显示所有远程库   推送变化\n1#注意如果没有sshkey需要生成并上传到代码平台 2ssh-keygem -t rsa -C \u0026#34;...\u0026#34; 3 4#只推送master 5git push origin master   Gitlab 1.gitlab web界面\n可以查看提交commit看看那些内容发生了变化\n可以master旁边添加分支\n可以快速改变文件内容而不需要在本地改变\n2.web界面中commit\n直接edit文件，然后commit就行\n3.从远程拉取变化到本地\n1git pull 2git pull origin master 4.解决冲突\n本地commit之后， web那里也收到了同一文件的commit, 这是本地不能push\n1#方法一： 2#先把远程的冲突pull过来 3git pull origin master 4 5#进行冲突处理。merge commit 6 7#方法二： 8#直接同步为远端的master 9git reset --hard origin/master 10 11#或者rebase， 解决冲突/自动合并 12git pull origin master --rebase 5.克隆远端仓库\nclone按钮有连接\n1git clone 链接 6.将分支合并到master\n1git pull 更新 2git checkout -b feature/cool-table 3git add . 4git commit -m \u0026#34;Text change\u0026#34; 5#推送远端分支 6git push origin feature/cool-table 7#进行merge request， 请求合并到主分支 8访问连接， 或者gitlab上merge‘ 9 10vim index.html 11git add . 12git commit -m \u0026#34;fix\u0026#34; 13git push origin feature/cool-table 14这样再次更改也会反映在merge中。 15squash commit可以合并多个commit， 保持历史记录整洁 ","date":"2024-11-12","permalink":"/posts/tech/basic-git/","series":["基础能力"],"tags":["","",""],"title":"Git\u0026gitlab"},{"categories":["计算机"],"content":"一、Linux系统启动过程 1.内核引导 当计算机打开电源后，首先是BIOS开机自检，按照BIOS中设置的启动设备（通常是硬盘）来启动。\n操作系统接管硬件以后，首先读入 /boot 目录下的内核文件。\n2.运行init init 进程是系统所有进程的起点，你可以把它比拟成系统所有进程的老祖宗，没有这个进程，系统中任何进程都不会启动。\ninit 程序首先是需要读取配置文件 /etc/inittab。\n3.运行级别 许多程序需要开机启动。它们在Windows叫做\u0026quot;服务\u0026quot;（service），在Linux就叫做\u0026quot;守护进程\u0026quot;（daemon）。\ninit进程的一大任务，就是去运行这些开机启动的程序。\n但是，不同的场合需要启动不同的程序，比如用作服务器时，需要启动Apache，用作桌面就不需要。\nLinux允许为不同的场合，分配不同的开机启动程序，这就叫做\u0026quot;运行级别\u0026quot;（runlevel）。也就是说，启动时根据\u0026quot;运行级别\u0026quot;，确定要运行哪些程序。\nLinux系统有7个运行级别(runlevel)：\n 运行级别0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动 运行级别1：单用户工作状态，root权限，用于系统维护，禁止远程登录 运行级别2：多用户状态(没有NFS) 运行级别3：完全的多用户状态(有NFS)，登录后进入控制台命令行模式 运行级别4：系统未使用，保留 运行级别5：X11控制台，登录后进入图形GUI模式 运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动  4.系统初始化 在init的配置文件中有这么一行： si::sysinit:/etc/rc.d/rc.sysinit　它调用执行了/etc/rc.d/rc.sysinit，而rc.sysinit是一个bash shell的脚本，它主要是完成一些系统初始化的工作，rc.sysinit是每一个运行级别都要首先运行的重要脚本。\n它主要完成的工作有：激活交换分区，检查磁盘，加载硬件模块以及其它一些需要优先执行任务。\n1l5:5:wait:/etc/rc.d/rc 5 这一行表示以5为参数运行/etc/rc.d/rc，/etc/rc.d/rc是一个Shell脚本，它接受5作为参数，去执行/etc/rc.d/rc5.d/目录下的所有的rc启动脚本，/etc/rc.d/rc5.d/目录中的这些启动脚本实际上都是一些连接文件，而不是真正的rc启动脚本，真正的rc启动脚本实际上都是放在/etc/rc.d/init.d/目录下。\n而这些rc启动脚本有着类似的用法，它们一般能接受start、stop、restart、status等参数。\n/etc/rc.d/rc5.d/中的rc启动脚本通常是K或S开头的连接文件，对于以 S 开头的启动脚本，将以start参数来运行。\n而如果发现存在相应的脚本也存在K打头的连接，而且已经处于运行态了(以/var/lock/subsys/下的文件作为标志)，则将首先以stop为参数停止这些已经启动了的守护进程，然后再重新运行。\n这样做是为了保证是当init改变运行级别时，所有相关的守护进程都将重启。\n至于在每个运行级中将运行哪些守护进程，用户可以通过chkconfig或setup中的\u0026quot;System Services\u0026quot;来自行设定。\n5.建立终端 rc执行完毕后，返回init。这时基本系统环境已经设置好了，各种守护进程也已经启动了。\ninit接下来会打开6个终端，以便用户登录系统。在inittab中的以下6行就是定义了6个终端：\n11:2345:respawn:/sbin/mingetty tty1 22:2345:respawn:/sbin/mingetty tty2 33:2345:respawn:/sbin/mingetty tty3 44:2345:respawn:/sbin/mingetty tty4 55:2345:respawn:/sbin/mingetty tty5 66:2345:respawn:/sbin/mingetty tty6 从上面可以看出在2、3、4、5的运行级别中都将以respawn方式运行mingetty程序，mingetty程序能打开终端、设置模式。\n同时它会显示一个文本登录界面，这个界面就是我们经常看到的登录界面，在这个登录界面中会提示用户输入用户名，而用户输入的用户将作为参数传给login程序来验证用户的身份。\n6.用户登录系统 一般来说，用户的登录方式有三种：\n （1）命令行登录 （2）ssh登录 （3）图形界面登录  对于运行级别为5的图形方式用户来说，他们的登录是通过一个图形化的登录界面。登录成功后可以直接进入 KDE、Gnome 等窗口管理器。\n而本文主要讲的还是文本方式登录的情况：当我们看到mingetty的登录界面时，我们就可以输入用户名和密码来登录系统了。\nLinux 的账号验证程序是 login，login 会接收 mingetty 传来的用户名作为用户名参数。\n然后 login 会对用户名进行分析：如果用户名不是 root，且存在 /etc/nologin 文件，login 将输出 nologin 文件的内容，然后退出。\n这通常用来系统维护时防止非root用户登录。只有/etc/securetty中登记了的终端才允许 root 用户登录，如果不存在这个文件，则 root 用户可以在任何终端上登录。\n/etc/usertty文件用于对用户作出附加访问限制，如果不存在这个文件，则没有其他限制。\n7.图形模式与文字模式的切换方式 Linux预设提供了六个命令窗口终端机让我们来登录。\n默认我们登录的就是第一个窗口，也就是tty1，这个六个窗口分别为tty1,tty2 … tty6，你可以按下Ctrl + Alt + F1 ~ F6 来切换它们。\n如果你安装了图形界面，默认情况下是进入图形界面的，此时你就可以按Ctrl + Alt + F1 ~ F6来进入其中一个命令窗口界面。\n当你进入命令窗口界面后再返回图形界面只要按下Ctrl + Alt + F7 就回来了。\n8.Linux关机 正确的关机流程为：sync \u0026gt; shutdown \u0026gt; reboot \u0026gt; halt\n关机指令为：shutdown ，你可以man shutdown 来看一下帮助文档。\n例如你可以运行如下命令关机：\n1sync 将数据由内存同步到硬盘中。 2 3shutdown 关机指令，你可以man shutdown 来看一下帮助文档。例如你可以运行如下命令关机： 4 5shutdown –h 10 ‘This server will shutdown after 10 mins’ 这个命令告诉大家，计算机将在10分钟后关机，并且会显示在登陆用户的当前屏幕中。 6 7shutdown –h now 立马关机 8 9shutdown –h 20:25 系统会在今天20:25关机 10 11shutdown –h +10 十分钟后关机 12 13shutdown –r now 系统立马重启 14 15shutdown –r +10 系统十分钟后重启 16 17reboot 就是重启，等同于 shutdown –r now 18 19halt 关闭系统，等同于shutdown –h now 和 poweroff 最后总结一下，不管是重启系统还是关闭系统，首先要运行 sync 命令，把内存中的数据写到磁盘中。\n关机的命令有 shutdown –h now halt poweroff 和 init 0 , 重启系统的命令有 shutdown –r now reboot init 6。\nhalt 命令通知硬件来停止所有的 CPU 功能，但是仍然保持通电。你可以用它使系统处于低层维护状态。注意在有些情况会它会完全关闭系统。\n1# halt ### 停止机器 2# halt -p ### 关闭机器、关闭电源 3# halt --reboot ### 重启机器 poweroff 会发送一个 ACPI 信号来通知系统关机。\n1# poweroff ### 关闭机器、关闭电源 2# poweroff --halt ### 停止机器 3# poweroff --reboot ### 重启机器 reboot 命令 reboot 通知系统重启。\n1# reboot ### 重启机器 2# reboot --halt ### 停止机器 3# reboot -p ### 关闭机器 二、Linux系统目录结构 在 Linux 或 Unix 操作系统中，所有的文件和目录都被组织成以一个根节点开始的倒置的树状结构。\n文件系统的最顶层是由根目录开始的，系统使用 / 来表示根目录。在根目录之下的既可以是目录，也可以是文件，而每一个目录中又可以包含子目录文件。如此反复就可以构成一个庞大的文件系统。\n在Linux文件系统中有两个特殊的目录，一个用户所在的工作目录，也叫当前目录，可以使用一个点 . 来表示；另一个是当前目录的上一级目录，也叫父目录，可以使用两个点 .. 来表示。\n树状目录结构：\n  /bin： bin 是 Binaries (二进制文件) 的缩写, 这个目录存放着最经常使用的命令。\n  /boot： 这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。\n  /dev ： dev 是 Device(设备) 的缩写, 该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。\n  /etc： etc 是 Etcetera(等等) 的缩写,这个目录用来存放所有的系统管理所需要的配置文件和子目录。\n  /home： 用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的，如上图中的 alice、bob 和 eve。\n  /lib： lib 是 Library(库) 的缩写这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。\n  /lost+found： 这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。\n  /media： linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。\n  /mnt： 系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 /mnt/ 上，然后进入该目录就可以查看光驱里的内容了。\n  /opt： opt 是 optional(可选) 的缩写，这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。\n  /proc： proc 是 Processes(进程) 的缩写，/proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。 这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器：\n1echo 1 \u0026gt; /proc/sys/net/ipv4/icmp_echo_ignore_all   /root： 该目录为系统管理员，也称作超级权限者的用户主目录。\n  /sbin： s 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序。\n  /selinux： 这个目录是 Redhat/CentOS 所特有的目录，Selinux 是一个安全机制，类似于 windows 的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。\n  /srv： 该目录存放一些服务启动之后需要提取的数据。\n  /sys：\n这是 Linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs 。\nsysfs 文件系统集成了下面3种文件系统的信息：针对进程信息的 proc 文件系统、针对设备的 devfs 文件系统以及针对伪终端的 devpts 文件系统。\n该文件系统是内核设备树的一个直观反映。\n当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。\n  /tmp： tmp 是 temporary(临时) 的缩写这个目录是用来存放一些临时文件的。\n  /usr： usr 是 unix system resources(unix 系统资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。\n  /usr/bin： 系统用户使用的应用程序。\n  /usr/sbin： 超级用户使用的比较高级的管理程序和系统守护程序。\n  /usr/src： 内核源代码默认的放置目录。\n  /var： var 是 variable(变量) 的缩写，这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。\n  /run： 是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。\n  三、Linux 远程登录 登陆到自己的Linux上 密钥对已经生成了。你可以给你的密钥输入一个密码，（在Key Passphrase那里）也可以留空。然后点 Save public key 保存公钥，点 Save private Key 保存私钥。笔者建议你放到一个比较安全的地方，一来防止别人偷窥，二来防止误删除。接下来就该到远程 linux 主机上设置了。\n1）创建目录 /root/.ssh 并设置权限\n[root@localhost ~]# mkdir /root/.ssh mkdir 命令用来创建目录，以后会详细介绍，暂时只了解即可。\n[root@localhost ~]# chmod 700 /root/.ssh chmod 命令是用来修改文件属性权限的，以后会详细介绍。\n2）创建文件 / root/.ssh/authorized_keys\n[root@localhost ~]# vim /root/.ssh/authorized_keys vim 命令是编辑一个文本文件的命令，同样在后续章节详细介绍。\n3）打开刚才生成的public key 文件，建议使用写字板打开，这样看着舒服一些，复制从AAAA开头至 \u0026ldquo;\u0026mdash;- END SSH2 PUBLIC KEY \u0026mdash;-\u0026rdquo; 该行上的所有内容，粘贴到/root/.ssh/authorized_keys 文件中，要保证所有字符在一行。\n设置putty选项，点窗口左侧的SSh –\u0026gt; Auth ，单击窗口右侧的Browse… 选择刚刚生成的私钥， 再点Open ，此时输入root，就不用输入密码就能登录了。\n利用ssh登录远程服务器 启动ssh：\n1service sshd start 登录远程服务器：\n1ssh -p 50022 my@127.0.0.1 2输入密码： 3my@127.0.0.1: -p 后面是端口\nmy 是服务器用户名\n127.0.0.1 是服务器 ip\n回车输入密码即可登录\n四、Linux文件基本属性 为了保护系统的安全性，Linux 系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。不同的用户处于不同的地位，拥有不同的权限。\n在 Linux 中我们通常使用以下两个命令来修改文件或目录的所属用户与权限：\n chown (change owner) ： 修改所属用户与组。 chmod (change mode) ： 修改用户的权限。  在 Linux 中我们可以使用 ll 或者 ls –l 命令来显示一个文件的属性以及文件所属的用户和组\n在 Linux 中第一个字符代表这个文件是目录、文件或链接文件等等。\n 当为 d 则是目录 当为 - 则是文件； 若是 l 则表示为链接文档(link file)； 若是 b 则表示为装置文件里面的可供储存的接口设备(可随机存取装置)； 若是 c 则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。  接下来的字符中，以三个为一组，且均为 rwx 的三个参数的组合。其中， r 代表可读(read)、 w 代表可写(write)、 x 代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号 - 而已。\n所以每个文件的属性由左边第一部分的 10 个字符来确定：\n从左至右用 0-9 这些数字来表示。\n第 0 位确定文件类型，第 1-3 位确定属主（该文件的所有者）拥有该文件的权限。第4-6位确定属组（所有者的同组用户）拥有该文件的权限，第7-9位确定其他用户拥有该文件的权限。\n其中，第 1、4、7 位表示读权限，如果用 r 字符表示，则有读权限；第 2、5、8 位表示写权限，如果用 w 字符表示，则有写权限，；第 3、6、9 位表示可执行权限，如果用 x 字符表示，则有执行权限。\nLinux文件属主和属组 对于文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户。\n同时，在Linux系统中，用户是按组分类的，一个用户属于一个或多个组。\n文件所有者以外的用户又可以分为文件所属组的同组用户和其他用户。\n因此，Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。\n对于 root 用户来说，一般情况下，文件的权限对其不起作用。\n更改文件属性 chgrp：更改文件属组 语法：\n1chgrp [-R] 属组名 文件名 参数选项\n -R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上 -R 的参数，那么该目录下的所有文件的属组都会更改。  chown：更改文件所有者（owner），也可以同时更改文件所属组。 语法：\n1chown [–R] 所有者 文件名 2chown [-R] 所有者:属组名 文件名 进入 /root 目录（~）将install.log的拥有者改为bin这个账号：\n1[root@www ~] cd ~ 2[root@www ~]# chown bin install.log 3[root@www ~]# ls -l 4-rw-r--r-- 1 bin users 68495 Jun 25 08:53 install.log 将install.log的拥有者与群组改回为root：\n1[root@www ~]# chown root:root install.log 2[root@www ~]# ls -l 3-rw-r--r-- 1 root root 68495 Jun 25 08:53 install.log chmod：更改文件9个属性 Linux文件属性有两种设置方法，一种是数字，一种是符号。\nLinux 文件的基本权限就有九个，分别是 owner/group/others(拥有者/组/其他) 三种身份各有自己的 read/write/execute 权限。\n数字版： 文件的权限字符为： -rwxrwxrwx ， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下：\n r:4 w:2 x:1  选项与参数：\n xyz : 就是刚刚提到的数字类型的权限属性，为 rwx 属性数值的相加。 -R : 进行递归(recursive)的持续变更，以及连同次目录下的所有文件都会变更  符号版： 以使用 u, g, o 来代表三种身份的权限。\n外， a 则代表 all，即全部的身份。读写的权限可以写成 r, w, x，也就是可以使用下表的方式来看：\n   chmod u g o a +(加入) -(除去) =(设定) r w x 文件或目录    如果我们需要将文件权限设置为 -rwxr-xr\u0026ndash; ，可以使用 chmod u=rwx,g=rx,o=r 文件名 来设定\n五、Linux文件与目录管理 处理目录的常用命令  ls（英文全拼：list files）: 列出目录及文件名 cd（英文全拼：change directory）：切换目录 pwd（英文全拼：print work directory）：显示目前的目录 mkdir（英文全拼：make directory）：创建一个新的目录 rmdir（英文全拼：remove directory）：删除一个空的目录 cp（英文全拼：copy file）: 复制文件或目录 rm（英文全拼：remove）: 删除文件或目录 mv（英文全拼：move file）: 移动文件与目录，或修改文件与目录的名称  你可以使用 man [命令] 来查看各个命令的使用文档，如 ：man cp。\nls 选项与参数：\n -a ：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来(常用) -d ：仅列出目录本身，而不是列出目录内的文件数据(常用) -l ：长数据串列出，包含文件的属性与权限等等数据；(常用)  将目录下的所有文件列出来(含属性与隐藏档)\n1[root@www ~]# ls -al ~ cd pwd 选项与参数：\n -P ：显示出确实的路径，而非使用链接 (link) 路径。  实例：单纯显示出目前的工作目录：\n1[root@www ~]# pwd 2/root \u0026lt;== 显示出目录啦～ 实例显示出实际的工作目录，而非链接档本身的目录名而已。\n1[root@www ~]# cd /var/mail \u0026lt;==注意，/var/mail是一个链接档 2[root@www mail]# pwd 3/var/mail \u0026lt;==列出目前的工作目录 4[root@www mail]# pwd -P 5/var/spool/mail \u0026lt;==怎么回事？有没有加 -P 差很多～ 6[root@www mail]# ls -ld /var/mail 7lrwxrwxrwx 1 root root 10 Sep 4 17:54 /var/mail -\u0026gt; spool/mail 8# 看到这里应该知道为啥了吧？因为 /var/mail 是链接档，链接到 /var/spool/mail 9# 所以，加上 pwd -P 的选项后，会不以链接档的数据显示，而是显示正确的完整路径啊！ mkdir 语法：\n1mkdir [-mp] 目录名称 选项与参数：\n -m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～ -p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！  实例：请到/tmp底下尝试创建数个新目录看看：\n1[root@www ~]# cd /tmp 2[root@www tmp]# mkdir test \u0026lt;==创建一名为 test 的新目录 3[root@www tmp]# mkdir test1/test2/test3/test4 4mkdir: cannot create directory `test1/test2/test3/test4\u0026#39;: 5No such file or directory \u0026lt;== 没办法直接创建此目录啊！ 6[root@www tmp]# mkdir -p test1/test2/test3/test4 加了这个 -p 的选项，可以自行帮你创建多层目录！\n实例：创建权限为 rwx\u0026ndash;x\u0026ndash;x 的目录。\n1[root@www tmp]# mkdir -m 711 test2 2[root@www tmp]# ls -l 3drwxr-xr-x 3 root root 4096 Jul 18 12:50 test 4drwxr-xr-x 3 root root 4096 Jul 18 12:53 test1 5drwx--x--x 2 root root 4096 Jul 18 12:54 test2 上面的权限部分，如果没有加上 -m 来强制配置属性，系统会使用默认属性。\n如果我们使用 -m ，如上例我们给予 -m 711 来给予新的目录 drwx\u0026ndash;x\u0026ndash;x 的权限。\nrmdir 语法：\n1 rmdir [-p] 目录名称 选项与参数：\n **-p ：**从该目录起，一次删除多级空目录  删除 runoob 目录\n1[root@www tmp]# rmdir runoob/ 将 mkdir 实例中创建的目录(/tmp 底下)删除掉！\n1[root@www tmp]# ls -l \u0026lt;==看看有多少目录存在？ 2drwxr-xr-x 3 root root 4096 Jul 18 12:50 test 3drwxr-xr-x 3 root root 4096 Jul 18 12:53 test1 4drwx--x--x 2 root root 4096 Jul 18 12:54 test2 5[root@www tmp]# rmdir test \u0026lt;==可直接删除掉，没问题 6[root@www tmp]# rmdir test1 \u0026lt;==因为尚有内容，所以无法删除！ 7rmdir: `test1\u0026#39;: Directory not empty 8[root@www tmp]# rmdir -p test1/test2/test3/test4 9[root@www tmp]# ls -l \u0026lt;==您看看，底下的输出中test与test1不见了！ 10drwx--x--x 2 root root 4096 Jul 18 12:54 test2 利用 -p 这个选项，立刻就可以将 test1/test2/test3/test4 一次删除。\n不过要注意的是，这个 rmdir 仅能删除空的目录，你可以使用 rm 命令来删除非空目录。\ncp 语法:\n1[root@www ~]# cp [-adfilprsu] 来源档(source) 目标档(destination) 2[root@www ~]# cp [options] source1 source2 source3 .... directory 选项与参数：\n **-a：**相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用) **-d：**若来源档为链接档的属性(link file)，则复制链接档属性而非文件本身； **-f：**为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次； **-i：**若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用) **-l：**进行硬式链接(hard link)的链接档创建，而非复制文件本身； **-p：**连同文件的属性一起复制过去，而非使用默认属性(备份常用)； **-r：**递归持续复制，用於目录的复制行为；(常用) **-s：**复制成为符号链接档 (symbolic link)，亦即『捷径』文件； **-u：**若 destination 比 source 旧才升级 destination ！  用 root 身份，将 root 目录下的 .bashrc 复制到 /tmp 下，并命名为 bashrc\n1[root@www ~]# cp ~/.bashrc /tmp/bashrc 2[root@www ~]# cp -i ~/.bashrc /tmp/bashrc 3cp: overwrite `/tmp/bashrc\u0026#39;? n \u0026lt;==n不覆盖，y为覆盖 rm 语法：\n1 rm [-fir] 文件或目录 选项与参数：\n -f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息； -i ：互动模式，在删除前会询问使用者是否动作 -r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！  mv 语法：\n1[root@www ~]# mv [-fiu] source destination 2[root@www ~]# mv [options] source1 source2 source3 .... directory 选项与参数：\n -f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖； -i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！ -u ：若目标文件已经存在，且 source 比较新，才会升级 (update)  Linux文件内容查看  cat 由第一行开始显示文件内容 tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！ nl 显示的时候，顺道输出行号！ more 一页一页的显示文件内容 less 与 more 类似，但是比 more 更好的是，他可以往前翻页！ head 只看头几行 tail 只看尾巴几行  cat 语法：\n1cat [-AbEnTv] 选项与参数：\n -A ：相当於 -vET 的整合选项，可列出一些特殊字符而不是空白而已； -b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！ -E ：将结尾的断行字节 $ 显示出来； -n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同； -T ：将 [tab] 按键以 ^I 显示出来； -v ：列出一些看不出来的特殊字符  tac tac与cat命令刚好相反，文件内容从最后一行开始显示，可以看出 tac 是 cat 的倒着写！\nnl 显示行号\n语法：\n1nl [-bnw] 文件 选项与参数：\n -b ：指定行号指定的方式，主要有两种： -b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)； -b t ：如果有空行，空的那一行不要列出行号(默认值)； -n ：列出行号表示的方法，主要有三种： -n ln ：行号在荧幕的最左方显示； -n rn ：行号在自己栏位的最右方显示，且不加 0 ； -n rz ：行号在自己栏位的最右方显示，且加 0 ； -w ：行号栏位的占用的位数。  more 一页一页翻动\n在 more 这个程序的运行过程中，你有几个按键可以按的：\n 空白键 (space)：代表向下翻一页； Enter ：代表向下翻『一行』； /字串 ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字； :f ：立刻显示出档名以及目前显示的行数； q ：代表立刻离开 more ，不再显示该文件内容。 b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。  less less运行时可以输入的命令有：\n 空白键 ：向下翻动一页； [pagedown]：向下翻动一页； [pageup] ：向上翻动一页； /字串 ：向下搜寻『字串』的功能； ?字串 ：向上搜寻『字串』的功能； n ：重复前一个搜寻 (与 / 或 ? 有关！) N ：反向的重复前一个搜寻 (与 / 或 ? 有关！) q ：离开 less 这个程序；  head 语法：\n1head [-n number] 文件 选项与参数：\n -n ：后面接数字，代表显示几行的意思  1[root@www ~]# head /etc/man.config 默认的情况中，显示前面 10 行！若要显示前 20 行，就得要这样：\n1[root@www ~]# head -n 20 /etc/man.config tail 取出文件后面几行\n语法：\n1tail [-n number] 文件 选项与参数：\n -n ：后面接数字，代表显示几行的意思 -f ：表示持续侦测后面所接的档名，要等到按下[ctrl]-c才会结束tail的侦测  Linux链接概念 Linux 链接分两种，一种被称为硬链接（Hard Link），另一种被称为符号链接（Symbolic Link）。默认情况下，ln 命令产生硬链接。\n硬连接 硬连接指通过索引节点来进行连接。在 Linux 的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在 Linux 中，多个文件名指向同一索引节点是存在的。比如：A 是 B 的硬链接（A 和 B 都是文件名），则 A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号相同，即一个 inode 节点对应两个不同的文件名，两个文件名指向同一个文件，A 和 B 对文件系统来说是完全平等的。删除其中任何一个都不会影响另外一个的访问。\n硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，**只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。**也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。\n软连接 另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有类似于 Windows 的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。比如：A 是 B 的软链接（A 和 B 都是文件名），A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号不相同，A 和 B 指向的是两个不同的 inode，继而指向两块不同的数据块。但是 A 的数据块中存放的只是 B 的路径名（可以根据这个找到 B 的目录项）。A 和 B 之间是“主从”关系，如果 B 被删除了，A 仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。\n1[oracle@Linux]$ touch f1 #创建一个测试文件f1 2[oracle@Linux]$ ln f1 f2 #创建f1的一个硬连接文件f2 3[oracle@Linux]$ ln -s f1 f3 #创建f1的一个符号连接文件f3 4[oracle@Linux]$ ls -li # -i参数显示文件的inode节点信息 5total 0 69797648 -rw-r--r-- 2 oracle oinstall 0 Apr 21 08:11 f1 79797648 -rw-r--r-- 2 oracle oinstall 0 Apr 21 08:11 f2 89797649 lrwxrwxrwx 1 oracle oinstall 2 Apr 21 08:11 f3 -\u0026gt; f1 从上面的结果中可以看出，硬连接文件 f2 与原文件 f1 的 inode 节点相同，均为 9797648，然而符号连接文件的 inode 节点不同。\n1[oracle@Linux]$ echo \u0026#34;I am f1 file\u0026#34; \u0026gt;\u0026gt;f1 2[oracle@Linux]$ cat f1 3I am f1 file 4[oracle@Linux]$ cat f2 5I am f1 file 6[oracle@Linux]$ cat f3 7I am f1 file 8[oracle@Linux]$ rm -f f1 9[oracle@Linux]$ cat f2 10I am f1 file 11[oracle@Linux]$ cat f3 12cat: f3: No such file or directory 通过上面的测试可以看出：当删除原始文件 f1 后，硬连接 f2 不受影响，但是符号连接 f3 文件无效\n依此您可以做一些相关的测试，可以得到以下全部结论：\n 1).删除符号连接f3,对f1,f2无影响； 2).删除硬连接f2，对f1,f3也无影响； 3).删除原文件f1，对硬连接f2没有影响，导致符号连接f3失效； 4).同时删除原文件f1,硬连接f2，整个文件会真正的被删除。  六、Linux用户和用户组管理 Linux系统用户账号的管理 添加账号 1 参数说明：\n  选项:\n -c comment 指定一段注释性描述。 -d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。 -g 用户组 指定用户所属的用户组。 -G 用户组，用户组 指定用户所属的附加组。 -s Shell文件 指定用户的登录Shell。 -u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。    用户名:\n指定新账号的登录名。\n  1# useradd -s /bin/sh -g group –G adm,root gem 此命令新建了一个用户gem，该用户的登录Shell是 /bin/sh，它属于group用户组，同时又属于adm和root用户组，其中group用户组是其主组。\n这里可能新建组：#groupadd group及groupadd adm\n增加用户账号就是在/etc/passwd文件中为新用户增加一条记录，同时更新其他系统文件如/etc/shadow, /etc/group等。\nLinux提供了集成的系统管理工具userconf，它可以用来对用户账号进行统一管理。\n删除帐号 删除用户账号就是要将/etc/passwd等系统文件中的该用户记录删除，必要时还删除用户的主目录。\n删除一个已有的用户账号使用userdel命令，其格式如下：\n1userdel 选项 用户名 常用的选项是 -r，它的作用是把用户的主目录一起删除。\n例如：\n1# userdel -r sam 此命令删除用户sam在系统文件中（主要是/etc/passwd, /etc/shadow, /etc/group等）的记录，同时删除用户的主目录。\n修改帐号 1usermod 选项 用户名 常用的选项包括-c, -d, -m, -g, -G, -s, -u以及-o等，这些选项的意义与useradd命令中的选项一样，可以为用户指定新的资源值。\n另外，有些系统可以使用选项：-l 新用户名\n这个选项指定一个新的账号，即将原来的用户名改为新的用户名。\n1# usermod -s /bin/ksh -d /home/z –g developer sam 此命令将用户sam的登录Shell修改为ksh，主目录改为/home/z，用户组改为developer。\n用户口令的管理 用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。\n指定和修改用户口令的Shell命令是passwd。超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令。命令的格式为：\n1passwd 选项 用户名 可使用的选项：\n -l 锁定口令，即禁用账号。 -u 口令解锁。 -d 使账号无口令。 -f 强迫用户下次登录时修改口令。  如果默认用户名，则修改当前用户的口令。\nLinux系统用户组的管理 不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。\n用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的更新。\n增加一个新的用户组 1groupadd 选项 用户组 可以使用的选项有：\n -g GID 指定新用户组的组标识号（GID）。 -o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。  删除一个已有的用户组 1groupdel 用户组 修改用户组的属性 1groupmod 选项 用户组 常用的选项有：\n -g GID 为用户组指定新的组标识号。 -o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。 -n新用户组 将用户组的名字改为新名字  切换到其他用户组 用户可以在登录后，使用命令newgrp切换到其他用户组，这个命令的参数就是目的用户组。例如：\n1$ newgrp root 这条命令将当前用户切换到root用户组，前提条件是root用户组确实是该用户的主组或附加组。类似于用户账号的管理，用户组的管理也可以通过集成的系统管理工具来完成。\n与用户账号有关的系统文件 完成用户管理的工作有许多种方法，但是每一种方法实际上都是对有关的系统文件进行修改。\n与用户和用户组相关的信息都存放在一些系统文件中，这些文件包括/etc/passwd, /etc/shadow, /etc/group等。\n/etc/passwd Linux系统中的每个用户都在/etc/passwd文件中有一个对应的记录行，它记录了这个用户的一些基本属性。\n这个文件对所有用户都是可读的。\n1root❌0:0:Superuser:/: 2daemon❌1:1:System daemons:/etc: 3bin❌2:2:Owner of system commands:/bin: 4sys❌3:3:Owner of system files:/usr/sys: 5adm❌4:4:System accounting:/usr/adm: 6uucp❌5:5:UUCP administrator:/usr/lib/uucp: 7auth❌7:21:Authentication administrator:/tcb/files/auth: 8cron❌9:16:Cron daemon:/usr/spool/cron: 9listen❌37:4:Network daemon:/usr/net/nls: 10lp❌71:18:Printer administrator:/usr/spool/lp: 11sam❌200:50:Sam san:/home/sam:/bin/sh 从上面的例子我们可以看到，/etc/passwd中一行记录对应着一个用户，每行记录又被冒号(:)分隔为7个字段，其格式和具体含义如下：\n1用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell 系统中有一类用户称为伪用户（pseudo users）。\n这些用户在/etc/passwd文件中也占有一条记录，但是不能登录，因为它们的登录Shell为空。它们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求。\n常见的伪用户如下所示：\n1伪 用 户 含 义 2bin 拥有可执行的用户命令文件 3sys 拥有系统文件 4adm 拥有帐户文件 5uucp UUCP使用 6lp lp或lpd子系统使用 7nobody NFS使用 /etc/shadow 由于/etc/passwd文件是所有用户都可读的，如果用户的密码太简单或规律比较明显的话，一台普通的计算机就能够很容易地将它破解，因此对安全性要求较高的Linux系统都把加密后的口令字分离出来，单独存放在一个文件中，这个文件是/etc/shadow文件。 有超级用户才拥有该文件读权限，这就保证了用户密码的安全性。\n它的文件格式与/etc/passwd类似，由若干个字段组成，字段之间用\u0026quot;:\u0026ldquo;隔开。这些字段是：\n1登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志  \u0026ldquo;登录名\u0026quot;是与/etc/passwd文件中的登录名相一致的用户账号 \u0026ldquo;口令\u0026quot;字段存放的是加密后的用户口令字，长度为13个字符。如果为空，则对应用户没有口令，登录时不需要口令；如果含有不属于集合 { ./0-9A-Za-z }中的字符，则对应的用户不能登录。 \u0026ldquo;最后一次修改时间\u0026quot;表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。例如在SCO Linux 中，这个时间起点是1970年1月1日。 \u0026ldquo;最小时间间隔\u0026quot;指的是两次修改口令之间所需的最小天数。 \u0026ldquo;最大时间间隔\u0026quot;指的是口令保持有效的最大天数。 \u0026ldquo;警告时间\u0026quot;字段表示的是从系统开始警告用户到用户密码正式失效之间的天数。 \u0026ldquo;不活动时间\u0026quot;表示的是用户没有登录活动但账号仍能保持有效的最大天数。 \u0026ldquo;失效时间\u0026quot;字段给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了。  /etc/group 当一个用户同时是多个组中的成员时，在/etc/passwd文件中记录的是用户所属的主组，也就是登录时所属的默认组，而其他组称为附加组。\n用户要访问属于附加组的文件时，必须首先使用newgrp命令使自己成为所要访问的组中的成员。\n用户组的所有信息都存放在/etc/group文件中。此文件的格式也类似于/etc/passwd文件，由冒号(:)隔开若干个字段，这些字段有：\n1组名:口令:组标识号:组内用户列表  \u0026ldquo;组名\u0026quot;是用户组的名称，由字母或数字构成。与/etc/passwd中的登录名一样，组名不应重复。 \u0026ldquo;口令\u0026quot;字段存放的是用户组加密后的口令字。一般Linux 系统的用户组都没有口令，即这个字段一般为空，或者是*。 \u0026ldquo;组标识号\u0026quot;与用户标识号类似，也是一个整数，被系统内部用来标识组。 \u0026ldquo;组内用户列表\u0026quot;是属于这个组的所有用户的列表，不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组。  七、磁盘管理 df 检查文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。\n1df [-ahikHTm] [目录或文件名] 选项与参数：\n -h：以人类可读的方式显示输出结果（例如，使用 KB、MB、GB 等单位）。 -T：显示文件系统的类型。 -t \u0026lt;文件系统类型\u0026gt;：只显示指定类型的文件系统。 -i：显示 inode 使用情况。 -H：该参数是 -h 的变体，但是使用 1000 字节作为基本单位而不是 1024 字节。这意味着它会以 SI（国际单位制）单位（例如 MB、GB）而不是二进制单位（例如 MiB、GiB）来显示磁盘使用情况。 -k：这个选项会以 KB 作为单位显示磁盘空间使用情况。 -a：该参数将显示所有的文件系统，包括虚拟文件系统，例如 proc、sysfs 等。如果没有使用该选项，默认情况下，df 命令不会显示虚拟文件系统。  du Linux du 命令也是查看使用空间的，但是与 df 命令不同的是 Linux du 命令是对文件和目录磁盘使用的空间的查看\n语法：\n1du [-ahskm] 文件或目录名称 选项与参数：\n -a ：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。 -h ：以人们较易读的容量格式 (G/M) 显示； -s ：仅显示指定目录或文件的总大小，而不显示其子目录的大小。 -S ：包括子目录下的总计，与 -s 有点差别。 -k ：以 KBytes 列出容量显示； -m ：以 MBytes 列出容量显示；  fdisk fdisk 是 Linux 的磁盘分区表操作工具。\n语法：\n1fdisk [-l] 装置名称 选项与参数：\n -l ：输出后面接的装置所有的分区内容。若仅有 fdisk -l 时， 则系统将会把整个系统内能够搜寻到的装置的分区均列出来。  列出所有分区信息\n1[root@AY120919111755c246621 tmp]# fdisk -l 出你系统中的根目录所在磁盘，并查阅该硬盘内的相关信息\n1[root@www ~]# df / \u0026lt;==注意：重点在找出磁盘文件名而已 2Filesystem 1K-blocks Used Available Use% Mounted on 3/dev/hdc2 9920624 3823168 5585388 41% / 4 5[root@www ~]# fdisk /dev/hdc \u0026lt;==仔细看，不要加上数字喔！ 6The number of cylinders for this disk is set to 5005. 7There is nothing wrong with that, but this is larger than 1024, 8and could in certain setups cause problems with: 91) software that runs at boot time (e.g., old versions of LILO) 102) booting and partitioning software from other OSs 11 (e.g., DOS FDISK, OS/2 FDISK) 12 13Command (m for help): \u0026lt;==等待你的输入！ 输入 m 后，就会看到底下这些命令介绍\n1Command (m for help): m \u0026lt;== 输入 m 后，就会看到底下这些命令介绍 2Command action 3 a toggle a bootable flag 4 b edit bsd disklabel 5 c toggle the dos compatibility flag 6 d delete a partition \u0026lt;==删除一个partition 7 l list known partition types 8 m print this menu 9 n add a new partition \u0026lt;==新增一个partition 10 o create a new empty DOS partition table 11 p print the partition table \u0026lt;==在屏幕上显示分割表 12 q quit without saving changes \u0026lt;==不储存离开fdisk程序 13 s create a new empty Sun disklabel 14 t change a partition\u0026#39;s system id 15 u change display/entry units 16 v verify the partition table 17 w write table to disk and exit \u0026lt;==将刚刚的动作写入分割表 18 x extra functionality (experts only) 离开 fdisk 时按下 q，那么所有的动作都不会生效！相反的， 按下w就是动作生效的意思。\n磁盘格式化 磁盘分割完毕后自然就是要进行文件系统的格式化，格式化的命令非常的简单，使用 mkfs（make filesystem） 命令。\n语法：\n1mkfs [-t 文件系统格式] 装置文件名 选项与参数：\n -t ：可以接文件系统格式，例如 ext3, ext2, vfat 等(系统有支持才会生效)  看 mkfs 支持的文件格式\n1[root@www ~]# mkfs[tab][tab] 2mkfs mkfs.cramfs mkfs.ext2 mkfs.ext3 mkfs.msdos mkfs.vfat 将分区 /dev/hdc6（可指定你自己的分区） 格式化为 ext3 文件系统：\n1[root@www ~]# mkfs -t ext3 /dev/hdc6 2mke2fs 1.39 (29-May-2006) 3Filesystem label= \u0026lt;==这里指的是分割槽的名称(label) 4OS type: Linux 5Block size=4096 (log=2) \u0026lt;==block 的大小配置为 4K 6Fragment size=4096 (log=2) 7251392 inodes, 502023 blocks \u0026lt;==由此配置决定的inode/block数量 825101 blocks (5.00%) reserved for the super user 9First data block=0 10Maximum filesystem blocks=515899392 1116 block groups 1232768 blocks per group, 32768 fragments per group 1315712 inodes per group 14Superblock backups stored on blocks: 15 32768, 98304, 163840, 229376, 294912 16 17Writing inode tables: done 18Creating journal (8192 blocks): done \u0026lt;==有日志记录 19Writing superblocks and filesystem accounting information: done 20 21This filesystem will be automatically checked every 34 mounts or 22180 days, whichever comes first. Use tune2fs -c or -i to override. 23# 这样就创建起来我们所需要的 Ext3 文件系统了！简单明了！ 磁盘检验 fsck（file system check）用来检查和维护不一致的文件系统。\n若系统掉电或磁盘发生问题，可利用fsck命令对文件系统进行检查。\n语法：\n1fsck [-t 文件系统] [-ACay] 装置名称 选项与参数：\n -t : 给定档案系统的型式，若在 /etc/fstab 中已有定义或 kernel 本身已支援的则不需加上此参数 -s : 依序一个一个地执行 fsck 的指令来检查 -A : 对/etc/fstab 中所有列出来的 分区（partition）做检查 -C : 显示完整的检查进度 -d : 打印出 e2fsck 的 debug 结果 -p : 同时有 -A 条件时，同时有多个 fsck 的检查一起执行 -R : 同时有 -A 条件时，省略 / 不检查 -V : 详细显示模式 -a : 如果检查有错则自动修复 -r : 如果检查有错则由使用者回答是否修复 -y : 选项指定检测每个文件是自动输入yes，在不确定那些是不正常的时候，可以执行 # fsck -y 全部检查修复。  查看系统有多少文件系统支持的 fsck 命令：\n1[root@www ~]# fsck[tab][tab] 2fsck fsck.cramfs fsck.ext2 fsck.ext3 fsck.msdos fsck.vfat 强制检测 /dev/hdc6 分区:\n1[root@www ~]# fsck -C -f -t ext3 /dev/hdc6 2fsck 1.39 (29-May-2006) 3e2fsck 1.39 (29-May-2006) 4Pass 1: Checking inodes, blocks, and sizes 5Pass 2: Checking directory structure 6Pass 3: Checking directory connectivity 7Pass 4: Checking reference counts 8Pass 5: Checking group summary information 9vbird_logical: 11/251968 files (9.1% non-contiguous), 36926/1004046 blocks 如果没有加上 -f 的选项，则由于这个文件系统不曾出现问题，检查的经过非常快速！若加上 -f 强制检查，才会一项一项的显示过程。\n磁盘挂载与卸除 Linux 的磁盘挂载使用 mount 命令，卸载使用 umount 命令。\n磁盘挂载语法：\n1mount [-t 文件系统] [-L Label名] [-o 额外选项] [-n] 装置文件名 挂载点 用默认的方式，将刚刚创建的 /dev/hdc6 挂载到 /mnt/hdc6 上面！\n1[root@www ~]# mkdir /mnt/hdc6 2[root@www ~]# mount /dev/hdc6 /mnt/hdc6 磁盘卸载命令 umount 语法：\n1umount [-fn] 装置文件名或挂载点 选项与参数：\n -f ：强制卸除！可用在类似网络文件系统 (NFS) 无法读取到的情况下； -n ：不升级 /etc/mtab 情况下卸除。  卸载/dev/hdc6\n1[root@www ~]# umount /dev/hdc6 八、vi/vim 基本上 vi/vim 共分为三种模式，命令模式（Command Mode）、输入模式（Insert Mode）和命令行模式（Command-Line Mode）。\n第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等    移动光标的方法      h 或 向左箭头键(←) 光标向左移动一个字符   j 或 向下箭头键(↓) 光标向下移动一个字符   k 或 向上箭头键(↑) 光标向上移动一个字符   l 或 向右箭头键(→) 光标向右移动一个字符   如果想要进行多次移动的话，例如向下移动 30 行，可以使用 \u0026ldquo;30j\u0026rdquo; 或 \u0026ldquo;30↓\u0026rdquo; 的组合按键    [Ctrl] + [f] 屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)   [Ctrl] + [b] 屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)   [Ctrl] + [d] 屏幕『向下』移动半页   [Ctrl] + [u] 屏幕『向上』移动半页   + 光标移动到非空格符的下一行   - 光标移动到非空格符的上一行   n 那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20 则光标会向后面移动 20 个字符距离。   0 或功能键[Home] 这是数字『 0 』：移动到这一行的最前面字符处 (常用)   $ 或功能键[End] 移动到这一行的最后面字符处(常用)   H 光标移动到这个屏幕的最上方那一行的第一个字符   M 光标移动到这个屏幕的中央那一行的第一个字符   L 光标移动到这个屏幕的最下方那一行的第一个字符   G 移动到这个档案的最后一行(常用)   nG n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)   gg 移动到这个档案的第一行，相当于 1G 啊！ (常用)   n n 为数字。光标向下移动 n 行(常用)   搜索替换    /word 向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！ (常用)   ?word 向光标之上寻找一个字符串名称为 word 的字符串。   n 这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！   N 这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。   使用 /word 配合 n 及 N 是非常有帮助的！可以让你重复的找到一些你搜寻的关键词！    :n1,n2s/word1/word2/g n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则： 『:100,200s/vbird/VBIRD/g』。(常用)   :1,$s/word1/word2/g 或 :%s/word1/word2/g 从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用)   :1,$s/word1/word2/gc 或 :%s/word1/word2/gc 从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用)   删除、复制与贴上    x, X 在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)   nx n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。   dd 剪切游标所在的那一整行(常用)，用 p/P 可以粘贴。   ndd n 为数字。剪切光标所在的向下 n 行，例如 20dd 则是剪切 20 行(常用)，用 p/P 可以粘贴。   d1G 删除光标所在到第一行的所有数据   dG 删除光标所在到最后一行的所有数据   d$ 删除游标所在处，到该行的最后一个字符   d0 那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符   yy 复制游标所在的那一行(常用)   nyy n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)   y1G 复制游标所在行到第一行的所有数据   yG 复制游标所在行到最后一行的所有数据   y0 复制光标所在的那个字符到该行行首的所有数据   y$ 复制光标所在的那个字符到该行行尾的所有数据   p, P p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用)   J 将光标所在行与下一行的数据结合成同一行   c 重复删除多个数据，例如向下删除 10 行，[ 10cj ]   u 复原前一个动作。(常用)   [Ctrl]+r 重做上一个动作。(常用)   这个 u 与 [Ctrl]+r 是很常用的指令！一个是复原，另一个则是重做一次～ 利用这两个功能按键，你的编辑，嘿嘿！很快乐的啦！    . 不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用)    第二部分：一般模式切换到编辑模式的可用的按钮说明    进入输入或取代的编辑模式      i, I 进入输入模式(Insert mode)： i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。 (常用)   a, A 进入输入模式(Insert mode)： a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用)   o, O 进入输入模式(Insert mode)： 这是英文字母 o 的大小写。o 为在目前光标所在的下一行处输入新的一行； O 为在目前光标所在的上一行处输入新的一行！(常用)   r, R 进入取代模式(Replace mode)： r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)   上面这些按键中，在 vi 画面的左下角处会出现『\u0026ndash;INSERT\u0026ndash;』或『\u0026ndash;REPLACE\u0026ndash;』的字样。 由名称就知道该动作了吧！！特别注意的是，我们上面也提过了，你想要在档案里面输入字符时， 一定要在左下角处看到 INSERT 或 REPLACE 才能输入喔！    [Esc] 退出编辑模式，回到一般模式中(常用)    第三部分：一般模式切换到指令行模式的可用的按钮说明    指令行的储存、离开等指令      :w 将编辑的数据写入硬盘档案中(常用)   :w! 若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！   :q 离开 vi (常用)   :q! 若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。   注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～    :wq 储存后离开，若为 :wq! 则为强制储存后离开 (常用)   ZZ 这是大写的 Z 喔！如果修改过，保存当前文件，然后退出！效果等同于(保存并退出)   ZQ 不保存，强制退出。效果等同于 :q!。   :w [filename] 将编辑的数据储存成另一个档案（类似另存新档）   :r [filename] 在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面   :n1,n2 w [filename] 将 n1 到 n2 的内容储存成 filename 这个档案。   :! command 暂时离开 vi 到指令行模式下执行 command 的显示结果！例如 『:! ls /home』即可在 vi 当中察看 /home 底下以 ls 输出的档案信息！   vim 环境的变更    :set nu 显示行号，设定之后，会在每一行的前缀显示该行的行号   :set nonu 与 set nu 相反，为取消行号！   ","date":"2024-11-11","permalink":"/posts/tech/basic-runnoob-linux/","series":["基础能力"],"tags":["","",""],"title":"菜鸟教程Linux教程"},{"categories":["计算机"],"content":"快速回顾一下, 简单的就不记了.\n1.常量 作用：用于记录程序中不可更改的数据\nC++定义常量两种方式\n  #define 宏常量： #define 常量名 常量值\n 通常在文件上方定义，表示一个常量    const修饰的变量 const 数据类型 常量名 = 常量值\n 通常在变量定义前加关键字const，修饰该变量为常量，不可修改    1//1、宏常量 2#define day 7 3 4int main() { 5 6\tcout \u0026lt;\u0026lt; \u0026#34;一周里总共有 \u0026#34; \u0026lt;\u0026lt; day \u0026lt;\u0026lt; \u0026#34; 天\u0026#34; \u0026lt;\u0026lt; endl; 7\t//day = 8; //报错，宏常量不可以修改 8 9\t//2、const修饰变量 10\tconst int month = 12; 11\tcout \u0026lt;\u0026lt; \u0026#34;一年里总共有 \u0026#34; \u0026lt;\u0026lt; month \u0026lt;\u0026lt; \u0026#34; 个月份\u0026#34; \u0026lt;\u0026lt; endl; 12\t//month = 24; //报错，常量是不可以修改的 13\t14\t15\tsystem(\u0026#34;pause\u0026#34;); 16 17\treturn 0; 18} 2.数据类型 整型 C++中能够表示整型的类型有以下几种方式，区别在于所占内存空间不同：\n   数据类型 占用空间 取值范围     short(短整型) 2字节 (-2^15 ~ 2^15-1)   int(整型) 4字节 (-2^31 ~ 2^31-1)   long(长整形) Windows为4字节，Linux为4字节(32位)，8字节(64位) (-2^31 ~ 2^31-1)   long long(长长整形) 8字节 (-2^63 ~ 2^63-1)    sizeof关键字: 利用sizeof关键字可以统计数据类型所占内存大小\nsizeof( 数据类型 / 变量)\n浮点型 浮点型变量分为两种：\n 单精度float 双精度double  两者的区别在于表示的有效数字范围不同。\n   数据类型 占用空间 有效数字范围     float 4字节 7位有效数字   double 8字节 15～16位有效数字    字符型 字符型变量用于显示单个字符\nchar ch = 'a';\n 注意1：在显示字符型变量时，用单引号将字符括起来，不要用双引号\n  注意2：单引号内只能有一个字符，不可以是字符串\n  C和C++中字符型变量只占用1个字节。 字符型变量并不是把字符本身放到内存中存储，而是将对应的ASCII编码放入到存储单元  字符串 两种风格\n C风格字符串： char 变量名[] = \u0026quot;字符串值\u0026quot;   注意：C风格的字符串要用双引号括起来\n  C++风格字符串： string 变量名 = \u0026quot;字符串值\u0026quot;   注意：C++风格字符串，需要加入头文件==#include\u0026lt;string\u0026gt;==\n 布尔值 bool类型只有两个值：\n true \u0026mdash; 真（本质是1） false \u0026mdash; 假（本质是0）  bool类型占==1个字节==大小\n数据的输入: cin \u0026gt;\u0026gt; 变量 \n3.运算符 算术运算符    运算符 术语 示例 结果     + 正号 +3 3   - 负号 -3 -3   + 加 10 + 5 15   - 减 10 - 5 5   * 乘 10 * 5 50   / 除 10 / 5 2   % 取模(取余) 10 % 3 1   ++ 前置递增 a=2; b=++a; a=3; b=3;   ++ 后置递增 a=2; b=a++; a=3; b=2;   \u0026ndash; 前置递减 a=2; b=\u0026ndash;a; a=1; b=1;   \u0026ndash; 后置递减 a=2; b=a\u0026ndash;; a=1; b=2;    赋值运算符    运算符 术语 示例 结果     = 赋值 a=2; b=3; a=2; b=3;   += 加等于 a=0; a+=2; a=2;   -= 减等于 a=5; a-=3; a=2;   *= 乘等于 a=2; a*=2; a=4;   /= 除等于 a=4; a/=2; a=2;   %= 模等于 a=3; a%2; a=1;    比较运算符    运算符 术语 示例 结果     == 相等于 4 == 3 0   != 不等于 4 != 3 1   \u0026lt; 小于 4 \u0026lt; 3 0   \u0026gt; 大于 4 \u0026gt; 3 1   \u0026lt;= 小于等于 4 \u0026lt;= 3 0   \u0026gt;= 大于等于 4 \u0026gt;= 1 1    逻辑运算符    运算符 术语 示例 结果     ! 非 !a 如果a为假，则!a为真； 如果a为真，则!a为假。   \u0026amp;\u0026amp; 与 a \u0026amp;\u0026amp; b 如果a和b都为真，则结果为真，否则为假。   || 或 a || b 如果a和b有一个为真，则结果为真，二者都为假时，结果为假。    4.程序流程结构 if 三元运算符 switch 语法：\n1switch(表达式) 2 3{ 4 5\tcase 结果1：执行语句;break; 6 7\tcase 结果2：执行语句;break; 8 9\t... 10 11\tdefault:执行语句;break; 12 13} 14 示例\n1int main() { 2 3\t//请给电影评分 4\t//10 ~ 9 经典 5\t// 8 ~ 7 非常好 6\t// 6 ~ 5 一般 7\t// 5分以下 烂片 8 9\tint score = 0; 10\tcout \u0026lt;\u0026lt; \u0026#34;请给电影打分\u0026#34; \u0026lt;\u0026lt; endl; 11\tcin \u0026gt;\u0026gt; score; 12 13\tswitch (score) 14\t{ 15\tcase 10: 16\tcase 9: 17\tcout \u0026lt;\u0026lt; \u0026#34;经典\u0026#34; \u0026lt;\u0026lt; endl; 18\tbreak; 19\tcase 8: 20\tcout \u0026lt;\u0026lt; \u0026#34;非常好\u0026#34; \u0026lt;\u0026lt; endl; 21\tbreak; 22\tcase 7: 23\tcase 6: 24\tcout \u0026lt;\u0026lt; \u0026#34;一般\u0026#34; \u0026lt;\u0026lt; endl; 25\tbreak; 26\tdefault: 27\tcout \u0026lt;\u0026lt; \u0026#34;烂片\u0026#34; \u0026lt;\u0026lt; endl; 28\tbreak; 29\t} 30 31\tsystem(\u0026#34;pause\u0026#34;); 32 33\treturn 0; 34}  注意1：switch语句中表达式类型只能是整型或者字符型\n  注意2：case里如果没有break，那么程序会一直向下执行\n  总结：与if语句比，对于多条件判断时，switch的结构清晰，执行效率高，缺点是switch不可以判断区间\n while do\u0026hellip;while for 跳转语句 break 作用: 用于跳出==选择结构==或者==循环结构==\nbreak使用的时机：\n 出现在switch条件语句中，作用是终止case并跳出switch 出现在循环语句中，作用是跳出当前的循环语句 出现在嵌套循环中，跳出最近的内层循环语句  continue **作用：**在==循环语句==中，跳过本次循环中余下尚未执行的语句，继续执行下一次循环\ngoto **作用：**可以无条件跳转语句\n语法： goto 标记;\n**解释：**如果标记的名称存在，执行到goto语句时，会跳转到标记的位置\n示例：\n1int main() { 2 3\tcout \u0026lt;\u0026lt; \u0026#34;1\u0026#34; \u0026lt;\u0026lt; endl; 4 5\tgoto FLAG; 6 7\tcout \u0026lt;\u0026lt; \u0026#34;2\u0026#34; \u0026lt;\u0026lt; endl; 8\tcout \u0026lt;\u0026lt; \u0026#34;3\u0026#34; \u0026lt;\u0026lt; endl; 9\tcout \u0026lt;\u0026lt; \u0026#34;4\u0026#34; \u0026lt;\u0026lt; endl; 10 11\tFLAG: 12 13\tcout \u0026lt;\u0026lt; \u0026#34;5\u0026#34; \u0026lt;\u0026lt; endl; 14\t15\tsystem(\u0026#34;pause\u0026#34;); 16 17\treturn 0; 18}  注意：在程序中不建议使用goto语句，以免造成程序流程混乱\n 5.数组 一维数组 一维数组定义的三种方式：\n 数据类型 数组名[ 数组长度 ]; 数据类型 数组名[ 数组长度 ] = { 值1，值2 ...}; (如果{}内不足10个数据，剩余数据用0补全) 数据类型 数组名[ ] = { 值1，值2 ...};  一维数组名称的用途：\n 可以统计整个数组在内存中的长度 可以获取数组在内存中的首地址  示例：\n1int main() { 2 3\t//数组名用途 4\t//1、可以获取整个数组占用内存空间大小 5\tint arr[10] = { 1,2,3,4,5,6,7,8,9,10 }; 6 7\tcout \u0026lt;\u0026lt; \u0026#34;整个数组所占内存空间为： \u0026#34; \u0026lt;\u0026lt; sizeof(arr) \u0026lt;\u0026lt; endl; 8\tcout \u0026lt;\u0026lt; \u0026#34;每个元素所占内存空间为： \u0026#34; \u0026lt;\u0026lt; sizeof(arr[0]) \u0026lt;\u0026lt; endl; 9\tcout \u0026lt;\u0026lt; \u0026#34;数组的元素个数为： \u0026#34; \u0026lt;\u0026lt; sizeof(arr) / sizeof(arr[0]) \u0026lt;\u0026lt; endl; 10 11\t//2、可以通过数组名获取到数组首地址 12\tcout \u0026lt;\u0026lt; \u0026#34;数组首地址为： \u0026#34; \u0026lt;\u0026lt; (int)arr \u0026lt;\u0026lt; endl; 13\tcout \u0026lt;\u0026lt; \u0026#34;数组中第一个元素地址为： \u0026#34; \u0026lt;\u0026lt; (int)\u0026amp;arr[0] \u0026lt;\u0026lt; endl; 14\tcout \u0026lt;\u0026lt; \u0026#34;数组中第二个元素地址为： \u0026#34; \u0026lt;\u0026lt; (int)\u0026amp;arr[1] \u0026lt;\u0026lt; endl; 15 16\t//arr = 100; 错误，数组名是常量，因此不可以赋值 17 18 19\tsystem(\u0026#34;pause\u0026#34;); 20 21\treturn 0; 22}  注意：数组名是常量，不可以赋值\n  总结1：直接打印数组名，可以查看数组所占内存的首地址\n  总结2：对数组名进行sizeof，可以获取整个数组占内存空间的大小\n 二维数组 二维数组定义的四种方式：\n 数据类型 数组名[ 行数 ][ 列数 ]; 数据类型 数组名[ 行数 ][ 列数 ] = { {数据1，数据2 } ，{数据3，数据4 } }; 数据类型 数组名[ 行数 ][ 列数 ] = { 数据1，数据2，数据3，数据4};  数据类型 数组名[ ][ 列数 ] = { 数据1，数据2，数据3，数据4};  二维数组数组名:\n 查看二维数组所占内存空间 获取二维数组首地址  示例：\n1int main() { 2 3\t//二维数组数组名 4\tint arr[2][3] = 5\t{ 6\t{1,2,3}, 7\t{4,5,6} 8\t}; 9 10\tcout \u0026lt;\u0026lt; \u0026#34;二维数组大小： \u0026#34; \u0026lt;\u0026lt; sizeof(arr) \u0026lt;\u0026lt; endl; 11\tcout \u0026lt;\u0026lt; \u0026#34;二维数组一行大小： \u0026#34; \u0026lt;\u0026lt; sizeof(arr[0]) \u0026lt;\u0026lt; endl; 12\tcout \u0026lt;\u0026lt; \u0026#34;二维数组元素大小： \u0026#34; \u0026lt;\u0026lt; sizeof(arr[0][0]) \u0026lt;\u0026lt; endl; 13 14\tcout \u0026lt;\u0026lt; \u0026#34;二维数组行数： \u0026#34; \u0026lt;\u0026lt; sizeof(arr) / sizeof(arr[0]) \u0026lt;\u0026lt; endl; 15\tcout \u0026lt;\u0026lt; \u0026#34;二维数组列数： \u0026#34; \u0026lt;\u0026lt; sizeof(arr[0]) / sizeof(arr[0][0]) \u0026lt;\u0026lt; endl; 16 17\t//地址 18\tcout \u0026lt;\u0026lt; \u0026#34;二维数组首地址：\u0026#34; \u0026lt;\u0026lt; arr \u0026lt;\u0026lt; endl; 19\tcout \u0026lt;\u0026lt; \u0026#34;二维数组第一行地址：\u0026#34; \u0026lt;\u0026lt; arr[0] \u0026lt;\u0026lt; endl; 20\tcout \u0026lt;\u0026lt; \u0026#34;二维数组第二行地址：\u0026#34; \u0026lt;\u0026lt; arr[1] \u0026lt;\u0026lt; endl; 21 22\tcout \u0026lt;\u0026lt; \u0026#34;二维数组第一个元素地址：\u0026#34; \u0026lt;\u0026lt; \u0026amp;arr[0][0] \u0026lt;\u0026lt; endl; 23\tcout \u0026lt;\u0026lt; \u0026#34;二维数组第二个元素地址：\u0026#34; \u0026lt;\u0026lt; \u0026amp;arr[0][1] \u0026lt;\u0026lt; endl; 24 25\tsystem(\u0026#34;pause\u0026#34;); 26 27\treturn 0; 28}  总结1：二维数组名就是这个数组的首地址\n  总结2：对二维数组名进行sizeof时，可以获取整个二维数组占用的内存空间大小\n 6.函数 函数的定义 语法：\n1返回值类型 函数名 （参数列表） 2{ 3 4 函数体语句 5 6 return表达式 7 8} 函数的调用 值传递  所谓值传递，就是函数调用时实参将数值传入给形参 值传递时，如果形参发生，并不会影响实参  函数的常见样式 函数的声明 作用： 告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。\n 函数的声明可以多次，但是函数的定义只能有一次  函数的分文件编写 函数分文件编写一般有4个步骤\n 创建后缀名为.h的头文件 创建后缀名为.cpp的源文件 在头文件中写函数的声明 在源文件中写函数的定义  示例：\n1//swap.h文件 2#include\u0026lt;iostream\u0026gt;3using namespace std; 4 5//实现两个数字交换的函数声明 6void swap(int a, int b); 7 1//swap.cpp文件 2#include \u0026#34;swap.h\u0026#34;3 4void swap(int a, int b) 5{ 6\tint temp = a; 7\ta = b; 8\tb = temp; 9 10\tcout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; 11\tcout \u0026lt;\u0026lt; \u0026#34;b = \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; 12} 1//main函数文件 2#include \u0026#34;swap.h\u0026#34;3int main() { 4 5\tint a = 100; 6\tint b = 200; 7\tswap(a, b); 8 9\tsystem(\u0026#34;pause\u0026#34;); 10 11\treturn 0; 12} 13 7.指针 指针变量定义语法： 数据类型 * 变量名；\n示例：\n1int main() { 2 3\t//1、指针的定义 4\tint a = 10; //定义整型变量a 5\t6\t//指针定义语法： 数据类型 * 变量名 ; 7\tint * p; 8 9\t//指针变量赋值 10\tp = \u0026amp;a; //指针指向变量a的地址 11\tcout \u0026lt;\u0026lt; \u0026amp;a \u0026lt;\u0026lt; endl; //打印数据a的地址 12\tcout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; //打印指针变量p 13 14\t//2、指针的使用 15\t//通过*操作指针变量指向的内存 16\tcout \u0026lt;\u0026lt; \u0026#34;*p = \u0026#34; \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; 17 18\tsystem(\u0026#34;pause\u0026#34;); 19 20\treturn 0; 21} 指针变量和普通变量的区别\n 普通变量存放的是数据,指针变量存放的是地址 指针变量可以通过\u0026quot; * \u0026ldquo;操作符，操作指针变量指向的内存空间，这个过程称为解引用   总结1： 我们可以通过 \u0026amp; 符号 获取变量的地址\n  总结2：利用指针可以记录地址\n  总结3：对指针变量解引用，可以操作指针指向的内存\n 指针所占内存空间 所有指针类型在32位操作系统下是4个字节\n空指针和野指针 空指针：指针变量指向内存中编号为0的空间\n**注意：**空指针指向的内存是不可以访问的\n示例1：空指针\n1int main() { 2 3\t//指针变量p指向内存地址编号为0的空间 4\tint * p = NULL; 5 6\t//访问空指针报错 7\t//内存编号0 ~255为系统占用内存，不允许用户访问 8\tcout \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; 9 10\tsystem(\u0026#34;pause\u0026#34;); 11 12\treturn 0; 13} 野指针：指针变量指向非法的内存空间\n示例2：野指针\n1int main() { 2 3\t//指针变量p指向内存地址编号为0x1100的空间 4\tint * p = (int *)0x1100; 5 6\t//访问野指针报错 7\tcout \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; 8 9\tsystem(\u0026#34;pause\u0026#34;); 10 11\treturn 0; 12}  总结：空指针和野指针都不是我们申请的空间，因此不要访问。\n const修饰指针 const修饰指针有三种情况\n const修饰指针 \u0026mdash; 常量指针 const int * p1 = \u0026amp;a; const修饰常量 \u0026mdash; 指针常量 int * const p2 = \u0026amp;a; const即修饰指针，又修饰常量 const int * const p3 = \u0026amp;a;  **示例： **\n1int main() { 2 3\tint a = 10; 4\tint b = 10; 5 6\t//const修饰的是指针，指针指向可以改，指针指向的值不可以更改 7\tconst int * p1 = \u0026amp;a; 8\tp1 = \u0026amp;b; //正确 9\t//*p1 = 100; 报错 10\t11 12\t//const修饰的是常量，指针指向不可以改，指针指向的值可以更改 13\tint * const p2 = \u0026amp;a; 14\t//p2 = \u0026amp;b; //错误 15\t*p2 = 100; //正确 16 17 //const既修饰指针又修饰常量 18\tconst int * const p3 = \u0026amp;a; 19\t//p3 = \u0026amp;b; //错误 20\t//*p3 = 100; //错误 21 22\tsystem(\u0026#34;pause\u0026#34;); 23 24\treturn 0; 25}  技巧：看const右侧紧跟着的是指针还是常量, 是指针就是常量指针，是常量就是指针常量\n 指针和数组 当数组名传入到函数作为参数时，被退化为指向首元素的指针\n示例：\n1int main() { 2 3\tint arr[] = { 1,2,3,4,5,6,7,8,9,10 }; 4 5\tint * p = arr; //指向数组的指针 6 7\tcout \u0026lt;\u0026lt; \u0026#34;第一个元素： \u0026#34; \u0026lt;\u0026lt; arr[0] \u0026lt;\u0026lt; endl; 8\tcout \u0026lt;\u0026lt; \u0026#34;指针访问第一个元素： \u0026#34; \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; 9 10\tfor (int i = 0; i \u0026lt; 10; i++) 11\t{ 12\t//利用指针遍历数组 13\tcout \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; 14\tp++; 15\t} 16 17\tsystem(\u0026#34;pause\u0026#34;); 18 19\treturn 0; 20} 指针和函数 利用指针作函数参数，可以修改实参的值\n1//地址传递 2void swap2(int * p1, int *p2) 3{ 4\tint temp = *p1; 5\t*p1 = *p2; 6\t*p2 = temp; 7} 如果不想修改实参，就用值传递，如果想修改实参，就用地址传递\n8.结构体 结构体定义和使用 语法：struct 结构体名 { 结构体成员列表 }；\n通过结构体创建变量的方式有三种：\n struct 结构体名 变量名 struct 结构体名 变量名 = { 成员1值 ， 成员2值\u0026hellip;} 定义结构体时顺便创建变量  示例：\n1//结构体定义 2struct student 3{ 4\t//成员列表 5\tstring name; //姓名 6\tint age; //年龄 7\tint score; //分数 8}stu3; //结构体变量创建方式3 9 10 11int main() { 12 13\t//结构体变量创建方式1 14\tstruct student stu1; //struct 关键字可以省略 15 16\tstu1.name = \u0026#34;张三\u0026#34;; 17\tstu1.age = 18; 18\tstu1.score = 100; 19\t20\tcout \u0026lt;\u0026lt; \u0026#34;姓名：\u0026#34; \u0026lt;\u0026lt; stu1.name \u0026lt;\u0026lt; \u0026#34; 年龄：\u0026#34; \u0026lt;\u0026lt; stu1.age \u0026lt;\u0026lt; \u0026#34; 分数：\u0026#34; \u0026lt;\u0026lt; stu1.score \u0026lt;\u0026lt; endl; 21 22\t//结构体变量创建方式2 23\tstruct student stu2 = { \u0026#34;李四\u0026#34;,19,60 }; 24 25\tcout \u0026lt;\u0026lt; \u0026#34;姓名：\u0026#34; \u0026lt;\u0026lt; stu2.name \u0026lt;\u0026lt; \u0026#34; 年龄：\u0026#34; \u0026lt;\u0026lt; stu2.age \u0026lt;\u0026lt; \u0026#34; 分数：\u0026#34; \u0026lt;\u0026lt; stu2.score \u0026lt;\u0026lt; endl; 26 27 28\tstu3.name = \u0026#34;王五\u0026#34;; 29\tstu3.age = 18; 30\tstu3.score = 80; 31\t32 33\tcout \u0026lt;\u0026lt; \u0026#34;姓名：\u0026#34; \u0026lt;\u0026lt; stu3.name \u0026lt;\u0026lt; \u0026#34; 年龄：\u0026#34; \u0026lt;\u0026lt; stu3.age \u0026lt;\u0026lt; \u0026#34; 分数：\u0026#34; \u0026lt;\u0026lt; stu3.score \u0026lt;\u0026lt; endl; 34 35\tsystem(\u0026#34;pause\u0026#34;); 36 37\treturn 0; 38}  总结1：定义结构体时的关键字是struct，不可省略\n  总结2：创建结构体变量时，关键字struct可以省略\n  总结3：结构体变量利用操作符 \u0026lsquo;\u0026rsquo;.'' 访问成员\n 结构体数组  struct 结构体名 数组名[元素个数] = { {} , {} , ... {} }\n1struct student arr[3]= 2\t{ 3\t{\u0026#34;张三\u0026#34;,18,80 }, 4\t{\u0026#34;李四\u0026#34;,19,60 }, 5\t{\u0026#34;王五\u0026#34;,20,70 } 6\t}; 7 结构体指针 利用操作符 -\u0026gt; 可以通过结构体指针访问结构体属性\n1int main() { 2\t3\tstruct student stu = { \u0026#34;张三\u0026#34;,18,100, }; 4\t5\tstruct student * p = \u0026amp;stu; 6\t7\tp-\u0026gt;score = 80; //指针通过 -\u0026gt; 操作符可以访问成员 8 9\tcout \u0026lt;\u0026lt; \u0026#34;姓名：\u0026#34; \u0026lt;\u0026lt; p-\u0026gt;name \u0026lt;\u0026lt; \u0026#34; 年龄：\u0026#34; \u0026lt;\u0026lt; p-\u0026gt;age \u0026lt;\u0026lt; \u0026#34; 分数：\u0026#34; \u0026lt;\u0026lt; p-\u0026gt;score \u0026lt;\u0026lt; endl; 10\t11\tsystem(\u0026#34;pause\u0026#34;); 12 13\treturn 0; 14} 结构体嵌套结构体 结构体做函数参数 传递方式有两种：\n 值传递 地址传递  1//值传递 2void printStudent(student stu ) 3{ 4\tstu.age = 28; 5\tcout \u0026lt;\u0026lt; \u0026#34;子函数中 姓名：\u0026#34; \u0026lt;\u0026lt; stu.name \u0026lt;\u0026lt; \u0026#34; 年龄： \u0026#34; \u0026lt;\u0026lt; stu.age \u0026lt;\u0026lt; \u0026#34; 分数：\u0026#34; \u0026lt;\u0026lt; stu.score \u0026lt;\u0026lt; endl; 6} 7 8//地址传递 9void printStudent2(student *stu) 10{ 11\tstu-\u0026gt;age = 28; 12\tcout \u0026lt;\u0026lt; \u0026#34;子函数中 姓名：\u0026#34; \u0026lt;\u0026lt; stu-\u0026gt;name \u0026lt;\u0026lt; \u0026#34; 年龄： \u0026#34; \u0026lt;\u0026lt; stu-\u0026gt;age \u0026lt;\u0026lt; \u0026#34; 分数：\u0026#34; \u0026lt;\u0026lt; stu-\u0026gt;score \u0026lt;\u0026lt; endl; 13} 结构体中 const使用场景 用const来防止误操作\n1//const使用场景 2void printStudent(const student *stu) //加const防止函数体中的误操作 3{ 4\t//stu-\u0026gt;age = 100; //操作失败，因为加了const修饰 5\tcout \u0026lt;\u0026lt; \u0026#34;姓名：\u0026#34; \u0026lt;\u0026lt; stu-\u0026gt;name \u0026lt;\u0026lt; \u0026#34; 年龄：\u0026#34; \u0026lt;\u0026lt; stu-\u0026gt;age \u0026lt;\u0026lt; \u0026#34; 分数：\u0026#34; \u0026lt;\u0026lt; stu-\u0026gt;score \u0026lt;\u0026lt; endl; 6 7} 9.内存分区模型 C++程序在执行时，将内存大方向划分为4个区域\n 代码区：存放函数体的二进制代码，由操作系统进行管理的 全局区：存放全局变量和静态变量以及常量 栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等 堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收  不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程\n程序运行前 在程序编译后，生成了exe可执行程序，未执行该程序前分为两个区域\n代码区：\n​\t存放 CPU 执行的机器指令\n​\t代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可\n​\t代码区是只读的，使其只读的原因是防止程序意外地修改了它的指令\n全局区：\n​\t全局变量和静态变量存放在此.\n​\t全局区还包含了常量区, 字符串常量和其他常量也存放在此.\n​\t==该区域的数据在程序结束后由操作系统释放==.\n程序运行后 栈区：\n​\t由编译器自动分配释放, 存放函数的参数值,局部变量等\n​\t注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放\n堆区：\n​\t由程序员分配释放,若程序员不释放,程序结束时由操作系统回收\n​\t在C++中主要利用new在堆区开辟内存\nnew操作符 C++中利用==new==操作符在堆区开辟数据\n​\t堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 ==delete==\n​\t语法： new 数据类型\n​\t利用new创建的数据，会返回该数据对应的类型的指针\n示例1： 基本语法\n1int* func() 2{ 3\tint* a = new int(10); 4\treturn a; 5} 6 7int main() { 8 9\tint *p = func(); 10 11\tcout \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; 12\tcout \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; 13 14\t//利用delete释放堆区数据 15\tdelete p; 16 17\t//cout \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; //报错，释放的空间不可访问 18 19\tsystem(\u0026#34;pause\u0026#34;); 20 21\treturn 0; 22} 示例2：开辟数组\n1//堆区开辟数组 2int main() { 3 4\tint* arr = new int[10]; 5 6\tfor (int i = 0; i \u0026lt; 10; i++) 7\t{ 8\tarr[i] = i + 100; 9\t} 10 11\tfor (int i = 0; i \u0026lt; 10; i++) 12\t{ 13\tcout \u0026lt;\u0026lt; arr[i] \u0026lt;\u0026lt; endl; 14\t} 15\t//释放数组 delete 后加 [] 16\tdelete[] arr; 17 18\tsystem(\u0026#34;pause\u0026#34;); 19 20\treturn 0; 21} 22 10.引用 引用的基本使用 给变量起别名\n数据类型 \u0026amp;别名 = 原名\n引用注意事项  引用必须初始化 引用在初始化后，不可以改变  1int main() { 2 3\tint a = 10; 4\tint b = 20; 5\t//int \u0026amp;c; //错误，引用必须初始化 6\tint \u0026amp;c = a; //一旦初始化后，就不可以更改 7\tc = b; //这是赋值操作，不是更改引用 8 9\tcout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; 10\tcout \u0026lt;\u0026lt; \u0026#34;b = \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; 11\tcout \u0026lt;\u0026lt; \u0026#34;c = \u0026#34; \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl; 12 13\tsystem(\u0026#34;pause\u0026#34;); 14 15\treturn 0; 16} 引用做函数参数 **作用：**函数传参时，可以利用引用的技术让形参修饰实参\n**优点：**可以简化指针修改实参, 通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单\n1//1. 值传递 2void mySwap01(int a, int b) { 3\tint temp = a; 4\ta = b; 5\tb = temp; 6} 7 8//2. 地址传递 9void mySwap02(int* a, int* b) { 10\tint temp = *a; 11\t*a = *b; 12\t*b = temp; 13} 14 15//3. 引用传递 16void mySwap03(int\u0026amp; a, int\u0026amp; b) { 17\tint temp = a; 18\ta = b; 19\tb = temp; 20} 引用做函数返回值 引用是可以作为函数的返回值存在的\n注意：不要返回局部变量引用\n用法：函数调用作为左值\n1//返回局部变量引用 2int\u0026amp; test01() { 3\tint a = 10; //局部变量 4\treturn a; 5} 6 7//返回静态变量引用 8int\u0026amp; test02() { 9\tstatic int a = 20; 10\treturn a; 11} 12 13int main() { 14 15\t//不能返回局部变量的引用 16\tint\u0026amp; ref = test01(); 17\tcout \u0026lt;\u0026lt; \u0026#34;ref = \u0026#34; \u0026lt;\u0026lt; ref \u0026lt;\u0026lt; endl; 18\tcout \u0026lt;\u0026lt; \u0026#34;ref = \u0026#34; \u0026lt;\u0026lt; ref \u0026lt;\u0026lt; endl; 19 20\t//如果函数做左值，那么必须返回引用 21\tint\u0026amp; ref2 = test02(); 22\tcout \u0026lt;\u0026lt; \u0026#34;ref2 = \u0026#34; \u0026lt;\u0026lt; ref2 \u0026lt;\u0026lt; endl; 23\tcout \u0026lt;\u0026lt; \u0026#34;ref2 = \u0026#34; \u0026lt;\u0026lt; ref2 \u0026lt;\u0026lt; endl; 24 25\ttest02() = 1000; 26 27\tcout \u0026lt;\u0026lt; \u0026#34;ref2 = \u0026#34; \u0026lt;\u0026lt; ref2 \u0026lt;\u0026lt; endl; 28\tcout \u0026lt;\u0026lt; \u0026#34;ref2 = \u0026#34; \u0026lt;\u0026lt; ref2 \u0026lt;\u0026lt; endl; 29 30\tsystem(\u0026#34;pause\u0026#34;); 31 32\treturn 0; 33} 引用的本质 引用的本质在c++内部实现是一个指针常量.\nC++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了\n1//发现是引用，转换为 int* const ref = \u0026amp;a; 2void func(int\u0026amp; ref){ 3\tref = 100; // ref是引用，转换为*ref = 100 4} 5int main(){ 6\tint a = 10; 7 8 //自动转换为 int* const ref = \u0026amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改 9\tint\u0026amp; ref = a; 10\tref = 20; //内部发现ref是引用，自动帮我们转换为: *ref = 20; 11 12\tcout \u0026lt;\u0026lt; \u0026#34;a:\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; 13\tcout \u0026lt;\u0026lt; \u0026#34;ref:\u0026#34; \u0026lt;\u0026lt; ref \u0026lt;\u0026lt; endl; 14 15\tfunc(a); 16\treturn 0; 17} 常量引用 常量引用主要用来修饰形参，防止误操作\n1//引用使用的场景，通常用来修饰形参 2void showValue(const int\u0026amp; v) { 3\t//v += 10; 4\tcout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; endl; 5} 6 7int main() { 8 9\t//int\u0026amp; ref = 10; 引用本身需要一个合法的内存空间，因此这行错误 10\t//加入const就可以了，编译器优化代码，int temp = 10; const int\u0026amp; ref = temp; 11\tconst int\u0026amp; ref = 10; 12 13\t//ref = 100; //加入const后不可以修改变量 14\tcout \u0026lt;\u0026lt; ref \u0026lt;\u0026lt; endl; 15 16\t//函数中利用常量引用防止误操作修改实参 17\tint a = 10; 18\tshowValue(a); 19 20\tsystem(\u0026#34;pause\u0026#34;); 21 22\treturn 0; 23} 11.函数提高 函数默认参数 在C++中，函数的形参列表中的形参是可以有默认值的。\n 返回值类型 函数名 （参数= 默认值）{}\n1int func(int a, int b = 10, int c = 10) { 2\treturn a + b + c; 3} 4 5//1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值 6//2. 如果函数声明有默认值，函数实现的时候就不能有默认参数 7int func2(int a = 10, int b = 10); 8int func2(int a, int b) { 9\treturn a + b; 10} 函数占位参数 C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置\n返回值类型 函数名 (数据类型){}\n1//函数占位参数 ，占位参数也可以有默认参数 2void func(int a, int) { 3\tcout \u0026lt;\u0026lt; \u0026#34;this is func\u0026#34; \u0026lt;\u0026lt; endl; 4} 5 6int main() { 7 8\tfunc(10,10); //占位参数必须填补 9 10\tsystem(\u0026#34;pause\u0026#34;); 11 12\treturn 0; 13} 12.函数重载 函数重载概述 函数重载满足条件：\n 同一个作用域下 函数名称相同 函数参数类型不同 或者 个数不同 或者 顺序不同  注意: 函数的返回值不可以作为函数重载的条件\n函数重载注意事项  引用作为重载条件 函数重载碰到函数默认参数  示例：\n1//函数重载注意事项 2//1、引用作为重载条件 3 4void func(int \u0026amp;a) 5{ 6\tcout \u0026lt;\u0026lt; \u0026#34;func (int \u0026amp;a) 调用 \u0026#34; \u0026lt;\u0026lt; endl; 7} 8 9void func(const int \u0026amp;a) 10{ 11\tcout \u0026lt;\u0026lt; \u0026#34;func (const int \u0026amp;a) 调用 \u0026#34; \u0026lt;\u0026lt; endl; 12} 13 14 15//2、函数重载碰到函数默认参数 16 17void func2(int a, int b = 10) 18{ 19\tcout \u0026lt;\u0026lt; \u0026#34;func2(int a, int b = 10) 调用\u0026#34; \u0026lt;\u0026lt; endl; 20} 21 22void func2(int a) 23{ 24\tcout \u0026lt;\u0026lt; \u0026#34;func2(int a) 调用\u0026#34; \u0026lt;\u0026lt; endl; 25} 26 27int main() { 28\t29\tint a = 10; 30\tfunc(a); //调用无const 31\tfunc(10);//调用有const 32 33 34\t//func2(10); //碰到默认参数产生歧义，需要避免 35 36\tsystem(\u0026#34;pause\u0026#34;); 37 38\treturn 0; 39} 13.类和对象 封装 封装的意义：\n 将属性和行为作为一个整体，表现生活中的事物 将属性和行为加以权限控制  class 类名{ 访问权限： 属性 / 行为 };\n访问权限有三种：\n public 公共权限 protected 保护权限 private 私有权限  示例：\n1//三种权限 2//公共权限 public 类内可以访问 类外可以访问 3//保护权限 protected 类内可以访问 类外不可以访问 4//私有权限 private 类内可以访问 类外不可以访问 5 6class Person 7{ 8\t//姓名 公共权限 9public: 10\tstring m_Name; 11 12\t//汽车 保护权限 13protected: 14\tstring m_Car; 15 16\t//银行卡密码 私有权限 17private: 18\tint m_Password; 19 20public: 21\tvoid func() 22\t{ 23\tm_Name = \u0026#34;张三\u0026#34;; 24\tm_Car = \u0026#34;拖拉机\u0026#34;; 25\tm_Password = 123456; 26\t} 27}; 28 29int main() { 30 31\tPerson p; 32\tp.m_Name = \u0026#34;李四\u0026#34;; 33\t//p.m_Car = \u0026#34;奔驰\u0026#34;; //保护权限类外访问不到 34\t//p.m_Password = 123; //私有权限类外访问不到 35 36\tsystem(\u0026#34;pause\u0026#34;); 37 38\treturn 0; 39} struct和class区别 在C++中 struct和class唯一的区别就在于 默认的访问权限不同\n区别：\n struct 默认权限为公共 class 默认权限为私有  1class C1 2{ 3\tint m_A; //默认是私有权限 4}; 5 6struct C2 7{ 8\tint m_A; //默认是公共权限 9}; 10 11int main() { 12 13\tC1 c1; 14\tc1.m_A = 10; //错误，访问权限是私有 15 16\tC2 c2; 17\tc2.m_A = 10; //正确，访问权限是公共 18 19\tsystem(\u0026#34;pause\u0026#34;); 20 21\treturn 0; 22} 成员属性设置为私有 **优点1：**将所有成员属性设置为私有，可以自己控制读写权限\n**优点2：**对于写权限，我们可以检测数据的有效性\n对象的初始化和清理 I 构造函数和析构函数 c++利用了构造函数和析构函数解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。\n对象的初始化和清理工作是编译器强制要我们做的事情，因此如果我们不提供构造和析构，编译器会提供, 编译器提供的构造函数和析构函数是空实现。\n 构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。 析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理工作。  构造函数语法：类名(){}\n 构造函数，没有返回值也不写void 函数名称与类名相同 构造函数可以有参数，因此可以发生重载 程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次  析构函数语法： ~类名(){}\n 析构函数，没有返回值也不写void 函数名称与类名相同,在名称前加上符号 ~ 析构函数不可以有参数，因此不可以发生重载 程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次  II 构造函数的分类及调用 两种分类方式：\n​\t按参数分为： 有参构造和无参构造\n​\t按类型分为： 普通构造和拷贝构造\n三种调用方式：\n​\t括号法\n​\t显示法\n​\t隐式转换法\n1class Person { 2public: 3\t//无参（默认）构造函数 4\tPerson() { 5\tcout \u0026lt;\u0026lt; \u0026#34;无参构造函数!\u0026#34; \u0026lt;\u0026lt; endl; 6\t} 7\t//有参构造函数 8\tPerson(int a) { 9\tage = a; 10\tcout \u0026lt;\u0026lt; \u0026#34;有参构造函数!\u0026#34; \u0026lt;\u0026lt; endl; 11\t} 12\t//拷贝构造函数 13\tPerson(const Person\u0026amp; p) { 14\tage = p.age; 15\tcout \u0026lt;\u0026lt; \u0026#34;拷贝构造函数!\u0026#34; \u0026lt;\u0026lt; endl; 16\t} 17\t//析构函数 18\t~Person() { 19\tcout \u0026lt;\u0026lt; \u0026#34;析构函数!\u0026#34; \u0026lt;\u0026lt; endl; 20\t} 21public: 22\tint age; 23}; 24 25//2、构造函数的调用 26//调用无参构造函数 27void test01() { 28\tPerson p; //调用无参构造函数 29} 30 31//调用有参的构造函数 32void test02() { 33 34\t//2.1 括号法，常用 35\tPerson p1(10); 36\t//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明 37\t//Person p2(); 38 39\t//2.2 显式法 40\tPerson p2 = Person(10); 41\tPerson p3 = Person(p2); 42\t//Person(10)单独写就是匿名对象 当前行结束之后，马上析构 43 44\t//2.3 隐式转换法 45\tPerson p4 = 10; // Person p4 = Person(10); 46\tPerson p5 = p4; // Person p5 = Person(p4); 47 48\t//注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明 49\t//Person p5(p4); 50} 51 52int main() { 53 54\ttest01(); 55\t//test02(); 56 57\tsystem(\u0026#34;pause\u0026#34;); 58 59\treturn 0; 60} III 拷贝构造函数调用时机 C++中拷贝构造函数调用时机通常有三种情况\n 使用一个已经创建完毕的对象来初始化一个新对象 值传递的方式给函数参数传值 以值方式返回局部对象  1class Person { 2public: 3\tPerson() { 4\tcout \u0026lt;\u0026lt; \u0026#34;无参构造函数!\u0026#34; \u0026lt;\u0026lt; endl; 5\tmAge = 0; 6\t} 7\tPerson(int age) { 8\tcout \u0026lt;\u0026lt; \u0026#34;有参构造函数!\u0026#34; \u0026lt;\u0026lt; endl; 9\tmAge = age; 10\t} 11\tPerson(const Person\u0026amp; p) { 12\tcout \u0026lt;\u0026lt; \u0026#34;拷贝构造函数!\u0026#34; \u0026lt;\u0026lt; endl; 13\tmAge = p.mAge; 14\t} 15\t//析构函数在释放内存之前调用 16\t~Person() { 17\tcout \u0026lt;\u0026lt; \u0026#34;析构函数!\u0026#34; \u0026lt;\u0026lt; endl; 18\t} 19public: 20\tint mAge; 21}; 22 23//1. 使用一个已经创建完毕的对象来初始化一个新对象 24void test01() { 25 26\tPerson man(100); //p对象已经创建完毕 27\tPerson newman(man); //调用拷贝构造函数 28\tPerson newman2 = man; //拷贝构造 29 30\t//Person newman3; 31\t//newman3 = man; //不是调用拷贝构造函数，赋值操作 32} 33 34//2. 值传递的方式给函数参数传值 35//相当于Person p1 = p; 36void doWork(Person p1) {} 37void test02() { 38\tPerson p; //无参构造函数 39\tdoWork(p); 40} 41 42//3. 以值方式返回局部对象 43Person doWork2() 44{ 45\tPerson p1; 46\tcout \u0026lt;\u0026lt; (int *)\u0026amp;p1 \u0026lt;\u0026lt; endl; 47\treturn p1; 48} 49 50void test03() 51{ 52\tPerson p = doWork2(); 53\tcout \u0026lt;\u0026lt; (int *)\u0026amp;p \u0026lt;\u0026lt; endl; 54} 55 56 57int main() { 58 59\t//test01(); 60\t//test02(); 61\ttest03(); 62 63\tsystem(\u0026#34;pause\u0026#34;); 64 65\treturn 0; 66} IV 构造函数调用规则 默认情况下，c++编译器至少给一个类添加3个函数\n1．默认构造函数(无参，函数体为空)\n2．默认析构函数(无参，函数体为空)\n3．默认拷贝构造函数，对属性进行值拷贝\n构造函数调用规则如下：\n  如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造\n  如果用户定义拷贝构造函数，c++不会再提供其他构造函数\n  1class Person { 2public: 3\t//无参（默认）构造函数 4\tPerson() { 5\tcout \u0026lt;\u0026lt; \u0026#34;无参构造函数!\u0026#34; \u0026lt;\u0026lt; endl; 6\t} 7\t//有参构造函数 8\tPerson(int a) { 9\tage = a; 10\tcout \u0026lt;\u0026lt; \u0026#34;有参构造函数!\u0026#34; \u0026lt;\u0026lt; endl; 11\t} 12\t//拷贝构造函数 13\tPerson(const Person\u0026amp; p) { 14\tage = p.age; 15\tcout \u0026lt;\u0026lt; \u0026#34;拷贝构造函数!\u0026#34; \u0026lt;\u0026lt; endl; 16\t} 17\t//析构函数 18\t~Person() { 19\tcout \u0026lt;\u0026lt; \u0026#34;析构函数!\u0026#34; \u0026lt;\u0026lt; endl; 20\t} 21public: 22\tint age; 23}; 24 25void test01() 26{ 27\tPerson p1(18); 28\t//如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作 29\tPerson p2(p1); 30 31\tcout \u0026lt;\u0026lt; \u0026#34;p2的年龄为： \u0026#34; \u0026lt;\u0026lt; p2.age \u0026lt;\u0026lt; endl; 32} 33 34void test02() 35{ 36\t//如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造 37\tPerson p1; //此时如果用户自己没有提供默认构造，会出错 38\tPerson p2(10); //用户提供的有参 39\tPerson p3(p2); //此时如果用户没有提供拷贝构造，编译器会提供 40 41\t//如果用户提供拷贝构造，编译器不会提供其他构造函数 42\tPerson p4; //此时如果用户自己没有提供默认构造，会出错 43\tPerson p5(10); //此时如果用户自己没有提供有参，会出错 44\tPerson p6(p5); //用户自己提供拷贝构造 45} 46 47int main() { 48 49\ttest01(); 50 51\tsystem(\u0026#34;pause\u0026#34;); 52 53\treturn 0; 54} V 深拷贝与浅拷贝 浅拷贝：简单的赋值拷贝操作\n深拷贝：在堆区重新申请空间，进行拷贝操作\n如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题\n示例：\n1class Person { 2public: 3\t//无参（默认）构造函数 4\tPerson() { 5\tcout \u0026lt;\u0026lt; \u0026#34;无参构造函数!\u0026#34; \u0026lt;\u0026lt; endl; 6\t} 7\t//有参构造函数 8\tPerson(int age ,int height) { 9\t10\tcout \u0026lt;\u0026lt; \u0026#34;有参构造函数!\u0026#34; \u0026lt;\u0026lt; endl; 11 12\tm_age = age; 13\tm_height = new int(height); 14\t15\t} 16\t//拷贝构造函数 17\tPerson(const Person\u0026amp; p) { 18\tcout \u0026lt;\u0026lt; \u0026#34;拷贝构造函数!\u0026#34; \u0026lt;\u0026lt; endl; 19\t//如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题 20\tm_age = p.m_age; 21\tm_height = new int(*p.m_height); 22\t23\t} 24 25\t//析构函数 26\t~Person() { 27\tcout \u0026lt;\u0026lt; \u0026#34;析构函数!\u0026#34; \u0026lt;\u0026lt; endl; 28\tif (m_height != NULL) 29\t{ 30\tdelete m_height; 31\t} 32\t} 33public: 34\tint m_age; 35\tint* m_height; 36}; VI 初始化列表 C++提供了初始化列表语法，用来初始化属性\n构造函数()：属性1(值1),属性2（值2）... {}\n1\t////传统方式初始化 2\t//Person(int a, int b, int c) { 3\t//\tm_A = a; 4\t//\tm_B = b; 5\t//\tm_C = c; 6\t//} 7 8\t//初始化列表方式初始化 9\tPerson(int a, int b, int c) :m_A(a), m_B(b), m_C(c) {} VII 类对象作为类成员 当类中成员是其他类对象时，我们称该成员为 对象成员\n构造的顺序是 ：先调用对象成员的构造，再调用本类构造\n析构顺序与构造相反\nVIII 静态成员 静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员\n静态成员分为：\n 静态成员变量  所有对象共享同一份数据 在编译阶段分配内存 类内声明，类外初始化   静态成员函数  所有对象共享同一个函数 静态成员函数只能访问静态成员变量    C++对象模型和this指针 成员变量和成员函数分开存储 1class Person { 2public: 3\tPerson() { 4\tmA = 0; 5\t} 6\t//非静态成员变量占对象空间 7\tint mA; 8\t//静态成员变量不占对象空间 9\tstatic int mB; 10\t//函数也不占对象空间，所有函数共享一个函数实例 11\tvoid func() { 12\tcout \u0026lt;\u0026lt; \u0026#34;mA:\u0026#34; \u0026lt;\u0026lt; this-\u0026gt;mA \u0026lt;\u0026lt; endl; 13\t} 14\t//静态成员函数也不占对象空间 15\tstatic void sfunc() { 16\t} 17}; this指针概念 每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码\n那么问题是：这一块代码是如何区分那个对象调用自己的呢？\nc++通过提供特殊的对象指针，this指针，解决上述问题。this指针指向被调用的成员函数所属的对象\nthis指针是隐含每一个非静态成员函数内的一种指针\nthis指针不需要定义，直接使用即可\nthis指针的用途：\n 当形参和成员变量同名时，可用this指针来区分 在类的非静态成员函数中返回对象本身，可使用return *this  1Person(int age) 2\t{ 3\t//1、当形参和成员变量同名时，可用this指针来区分 4\tthis-\u0026gt;age = age; 5\t} 6 7\tPerson\u0026amp; PersonAddPerson(Person p) 8\t{ 9\tthis-\u0026gt;age += p.age; 10\t//返回对象本身 11\treturn *this; 12\t} 空指针访问成员函数 C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针\n如果用到this指针，需要加以判断保证代码的健壮性\n1//空指针访问成员函数 2class Person { 3public: 4 5\tvoid ShowClassName() { 6\tcout \u0026lt;\u0026lt; \u0026#34;我是Person类!\u0026#34; \u0026lt;\u0026lt; endl; 7\t} 8 9\tvoid ShowPerson() { 10\tif (this == NULL) { 11\treturn; 12\t} 13\tcout \u0026lt;\u0026lt; mAge \u0026lt;\u0026lt; endl; 14\t} 15 16public: 17\tint mAge; 18}; 19 20void test01() 21{ 22\tPerson * p = NULL; 23\tp-\u0026gt;ShowClassName(); //空指针，可以调用成员函数 24\tp-\u0026gt;ShowPerson(); //但是如果成员函数中用到了this指针，就不可以了 25} const修饰成员函数 常函数：\n 成员函数后加const后我们称为这个函数为常函数 常函数内不可以修改成员属性 成员属性声明时加关键字mutable后，在常函数中依然可以修改  常对象：\n 声明对象前加const称该对象为常对象 常对象只能调用常函数  示例：\n1class Person { 2public: 3\tPerson() { 4\tm_A = 0; 5\tm_B = 0; 6\t} 7 8\t//this指针的本质是一个指针常量，指针的指向不可修改 9\t//如果想让指针指向的值也不可以修改，需要声明常函数 10\tvoid ShowPerson() const { 11\t//const Type* const pointer; 12\t//this = NULL; //不能修改指针的指向 Person* const this; 13\t//this-\u0026gt;mA = 100; //但是this指针指向的对象的数据是可以修改的 14 15\t//const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量 16\tthis-\u0026gt;m_B = 100; 17\t} 18 19\tvoid MyFunc() const { 20\t//mA = 10000; 21\t} 22 23public: 24\tint m_A; 25\tmutable int m_B; //可修改 可变的 26}; 27 28 29//const修饰对象 常对象 30void test01() { 31 32\tconst Person person; //常量对象 33\tcout \u0026lt;\u0026lt; person.m_A \u0026lt;\u0026lt; endl; 34\t//person.mA = 100; //常对象不能修改成员变量的值,但是可以访问 35\tperson.m_B = 100; //但是常对象可以修改mutable修饰成员变量 36 37\t//常对象访问成员函数 38\tperson.MyFunc(); //常对象不能调用const的函数 39 40} 友元 在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术\n友元的目的就是让一个函数或者类 访问另一个类中私有成员\n友元的关键字为 ==friend==\n友元的三种实现\n 全局函数做友元 类做友元 成员函数做友元  全局函数做友元 1class Building 2{ 3\t//告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容 4\tfriend void goodGay(Building * building); 5 6public: 7 8\tBuilding() 9\t{ 10\tthis-\u0026gt;m_SittingRoom = \u0026#34;客厅\u0026#34;; 11\tthis-\u0026gt;m_BedRoom = \u0026#34;卧室\u0026#34;; 12\t} 13 14 15public: 16\tstring m_SittingRoom; //客厅 17 18private: 19\tstring m_BedRoom; //卧室 20}; 21 22 23void goodGay(Building * building) 24{ 25\tcout \u0026lt;\u0026lt; \u0026#34;好基友正在访问： \u0026#34; \u0026lt;\u0026lt; building-\u0026gt;m_SittingRoom \u0026lt;\u0026lt; endl; 26\tcout \u0026lt;\u0026lt; \u0026#34;好基友正在访问： \u0026#34; \u0026lt;\u0026lt; building-\u0026gt;m_BedRoom \u0026lt;\u0026lt; endl; 27} 28 29 30void test01() 31{ 32\tBuilding b; 33\tgoodGay(\u0026amp;b); 34} 35 类做友元 1class Building; 2class goodGay 3{ 4public: 5 6\tgoodGay(); 7\tvoid visit(); 8 9private: 10\tBuilding *building; 11}; 12 13 14class Building 15{ 16\t//告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容 17\tfriend class goodGay; 18 19public: 20\tBuilding(); 21 22public: 23\tstring m_SittingRoom; //客厅 24private: 25\tstring m_BedRoom;//卧室 26}; 27 28Building::Building() 29{ 30\tthis-\u0026gt;m_SittingRoom = \u0026#34;客厅\u0026#34;; 31\tthis-\u0026gt;m_BedRoom = \u0026#34;卧室\u0026#34;; 32} 33 34goodGay::goodGay() 35{ 36\tbuilding = new Building; 37} 38 39void goodGay::visit() 40{ 41\tcout \u0026lt;\u0026lt; \u0026#34;好基友正在访问\u0026#34; \u0026lt;\u0026lt; building-\u0026gt;m_SittingRoom \u0026lt;\u0026lt; endl; 42\tcout \u0026lt;\u0026lt; \u0026#34;好基友正在访问\u0026#34; \u0026lt;\u0026lt; building-\u0026gt;m_BedRoom \u0026lt;\u0026lt; endl; 43} 44 45void test01() 46{ 47\tgoodGay gg; 48\tgg.visit(); 49 50} 成员函数做友元 1class Building; 2class goodGay 3{ 4public: 5 6\tgoodGay(); 7\tvoid visit(); //只让visit函数作为Building的好朋友，可以发访问Building中私有内容 8\tvoid visit2(); 9 10private: 11\tBuilding *building; 12}; 13 14 15class Building 16{ 17\t//告诉编译器 goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容 18\tfriend void goodGay::visit(); 19 20public: 21\tBuilding(); 22 23public: 24\tstring m_SittingRoom; //客厅 25private: 26\tstring m_BedRoom;//卧室 27}; 28 29Building::Building() 30{ 31\tthis-\u0026gt;m_SittingRoom = \u0026#34;客厅\u0026#34;; 32\tthis-\u0026gt;m_BedRoom = \u0026#34;卧室\u0026#34;; 33} 34 35goodGay::goodGay() 36{ 37\tbuilding = new Building; 38} 39 40void goodGay::visit() 41{ 42\tcout \u0026lt;\u0026lt; \u0026#34;好基友正在访问\u0026#34; \u0026lt;\u0026lt; building-\u0026gt;m_SittingRoom \u0026lt;\u0026lt; endl; 43\tcout \u0026lt;\u0026lt; \u0026#34;好基友正在访问\u0026#34; \u0026lt;\u0026lt; building-\u0026gt;m_BedRoom \u0026lt;\u0026lt; endl; 44} 45 46void goodGay::visit2() 47{ 48\tcout \u0026lt;\u0026lt; \u0026#34;好基友正在访问\u0026#34; \u0026lt;\u0026lt; building-\u0026gt;m_SittingRoom \u0026lt;\u0026lt; endl; 49\t//cout \u0026lt;\u0026lt; \u0026#34;好基友正在访问\u0026#34; \u0026lt;\u0026lt; building-\u0026gt;m_BedRoom \u0026lt;\u0026lt; endl; 50} 51 52void test01() 53{ 54\tgoodGay gg; 55\tgg.visit(); 56 57} 运算符重载 运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型\n加号运算符重载 1class Person { 2public: 3\tPerson() {}; 4\tPerson(int a, int b) 5\t{ 6\tthis-\u0026gt;m_A = a; 7\tthis-\u0026gt;m_B = b; 8\t} 9\t//成员函数实现 + 号运算符重载 10\tPerson operator+(const Person\u0026amp; p) { 11\tPerson temp; 12\ttemp.m_A = this-\u0026gt;m_A + p.m_A; 13\ttemp.m_B = this-\u0026gt;m_B + p.m_B; 14\treturn temp; 15\t} 16 17 18public: 19\tint m_A; 20\tint m_B; 21}; 22 23//全局函数实现 + 号运算符重载 24//Person operator+(const Person\u0026amp; p1, const Person\u0026amp; p2) { 25//\tPerson temp(0, 0); 26//\ttemp.m_A = p1.m_A + p2.m_A; 27//\ttemp.m_B = p1.m_B + p2.m_B; 28//\treturn temp; 29//} 30 31//运算符重载 可以发生函数重载 32Person operator+(const Person\u0026amp; p2, int val) 33{ 34\tPerson temp; 35\ttemp.m_A = p2.m_A + val; 36\ttemp.m_B = p2.m_B + val; 37\treturn temp; 38} 39 40void test() { 41 42\tPerson p1(10, 10); 43\tPerson p2(20, 20); 44 45\t//成员函数方式 46\tPerson p3 = p2 + p1; //相当于 p2.operaor+(p1) 47\tcout \u0026lt;\u0026lt; \u0026#34;mA:\u0026#34; \u0026lt;\u0026lt; p3.m_A \u0026lt;\u0026lt; \u0026#34; mB:\u0026#34; \u0026lt;\u0026lt; p3.m_B \u0026lt;\u0026lt; endl; 48 49 50\tPerson p4 = p3 + 10; //相当于 operator+(p3,10) 51\tcout \u0026lt;\u0026lt; \u0026#34;mA:\u0026#34; \u0026lt;\u0026lt; p4.m_A \u0026lt;\u0026lt; \u0026#34; mB:\u0026#34; \u0026lt;\u0026lt; p4.m_B \u0026lt;\u0026lt; endl; 52 53} 左移运算符重载 重载左移运算符配合友元可以实现输出自定义数据类型\n1class Person { 2\tfriend ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; out, Person\u0026amp; p); 3 4public: 5 6\tPerson(int a, int b) 7\t{ 8\tthis-\u0026gt;m_A = a; 9\tthis-\u0026gt;m_B = b; 10\t} 11 12\t//成员函数 实现不了 p \u0026lt;\u0026lt; cout 不是我们想要的效果 13\t//void operator\u0026lt;\u0026lt;(Person\u0026amp; p){ 14\t//} 15 16private: 17\tint m_A; 18\tint m_B; 19}; 20 21//全局函数实现左移重载 22//ostream对象只能有一个 23ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; out, Person\u0026amp; p) { 24\tout \u0026lt;\u0026lt; \u0026#34;a:\u0026#34; \u0026lt;\u0026lt; p.m_A \u0026lt;\u0026lt; \u0026#34; b:\u0026#34; \u0026lt;\u0026lt; p.m_B; 25\treturn out; 26} 27 28void test() { 29 30\tPerson p1(10, 20); 31 32\tcout \u0026lt;\u0026lt; p1 \u0026lt;\u0026lt; \u0026#34;hello world\u0026#34; \u0026lt;\u0026lt; endl; //链式编程 33} 34 递增运算符重载 前置递增返回引用，后置递增返回值\n1class MyInteger { 2 3\tfriend ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; out, MyInteger myint); 4 5public: 6\tMyInteger() { 7\tm_Num = 0; 8\t} 9\t//前置++ 10\tMyInteger\u0026amp; operator++() { 11\t//先++ 12\tm_Num++; 13\t//再返回 14\treturn *this; 15\t} 16 17\t//后置++ 18\tMyInteger operator++(int) { 19\t//先返回 20\tMyInteger temp = *this; //记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++； 21\tm_Num++; 22\treturn temp; 23\t} 24 25private: 26\tint m_Num; 27}; 28 29 30ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; out, MyInteger myint) { 31\tout \u0026lt;\u0026lt; myint.m_Num; 32\treturn out; 33} 34 35 36//前置++ 先++ 再返回 37void test01() { 38\tMyInteger myInt; 39\tcout \u0026lt;\u0026lt; ++myInt \u0026lt;\u0026lt; endl; 40\tcout \u0026lt;\u0026lt; myInt \u0026lt;\u0026lt; endl; 41} 42 43//后置++ 先返回 再++ 44void test02() { 45 46\tMyInteger myInt; 47\tcout \u0026lt;\u0026lt; myInt++ \u0026lt;\u0026lt; endl; 48\tcout \u0026lt;\u0026lt; myInt \u0026lt;\u0026lt; endl; 49} 赋值运算符重载 c++编译器至少给一个类添加4个函数\n 默认构造函数(无参，函数体为空) 默认析构函数(无参，函数体为空) 默认拷贝构造函数，对属性进行值拷贝 赋值运算符 operator=, 对属性进行值拷贝  如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题\n1class Person 2{ 3public: 4 5\tPerson(int age) 6\t{ 7\t//将年龄数据开辟到堆区 8\tm_Age = new int(age); 9\t} 10 11\t//重载赋值运算符 12\tPerson\u0026amp; operator=(Person \u0026amp;p) 13\t{ 14\tif (m_Age != NULL) 15\t{ 16\tdelete m_Age; 17\tm_Age = NULL; 18\t} 19\t//编译器提供的代码是浅拷贝 20\t//m_Age = p.m_Age; 21 22\t//提供深拷贝 解决浅拷贝的问题 23\tm_Age = new int(*p.m_Age); 24 25\t//返回自身 26\treturn *this; 27\t} 28 29 30\t~Person() 31\t{ 32\tif (m_Age != NULL) 33\t{ 34\tdelete m_Age; 35\tm_Age = NULL; 36\t} 37\t} 38 39\t//年龄的指针 40\tint *m_Age; 41 42}; 43 44 45void test01() 46{ 47\tPerson p1(18); 48 49\tPerson p2(20); 50 51\tPerson p3(30); 52 53\tp3 = p2 = p1; //赋值操作 54 55\tcout \u0026lt;\u0026lt; \u0026#34;p1的年龄为：\u0026#34; \u0026lt;\u0026lt; *p1.m_Age \u0026lt;\u0026lt; endl; 56 57\tcout \u0026lt;\u0026lt; \u0026#34;p2的年龄为：\u0026#34; \u0026lt;\u0026lt; *p2.m_Age \u0026lt;\u0026lt; endl; 58 59\tcout \u0026lt;\u0026lt; \u0026#34;p3的年龄为：\u0026#34; \u0026lt;\u0026lt; *p3.m_Age \u0026lt;\u0026lt; endl; 60} 关系运算符重载 重载关系运算符，可以让两个自定义类型对象进行对比操作\n1class Person 2{ 3public: 4\tPerson(string name, int age) 5\t{ 6\tthis-\u0026gt;m_Name = name; 7\tthis-\u0026gt;m_Age = age; 8\t}; 9 10\tbool operator==(Person \u0026amp; p) 11\t{ 12\tif (this-\u0026gt;m_Name == p.m_Name \u0026amp;\u0026amp; this-\u0026gt;m_Age == p.m_Age) 13\t{ 14\treturn true; 15\t} 16\telse 17\t{ 18\treturn false; 19\t} 20\t} 21 22\tbool operator!=(Person \u0026amp; p) 23\t{ 24\tif (this-\u0026gt;m_Name == p.m_Name \u0026amp;\u0026amp; this-\u0026gt;m_Age == p.m_Age) 25\t{ 26\treturn false; 27\t} 28\telse 29\t{ 30\treturn true; 31\t} 32\t} 33 34\tstring m_Name; 35\tint m_Age; 36}; 函数调用运算符重载  函数调用运算符 () 也可以重载 由于重载后使用的方式非常像函数的调用，因此称为仿函数 仿函数没有固定写法，非常灵活  1class MyPrint 2{ 3public: 4\tvoid operator()(string text) 5\t{ 6\tcout \u0026lt;\u0026lt; text \u0026lt;\u0026lt; endl; 7\t} 8 9}; 10void test01() 11{ 12\t//重载的（）操作符 也称为仿函数 13\tMyPrint myFunc; 14\tmyFunc(\u0026#34;hello world\u0026#34;); 15} 16 17 18class MyAdd 19{ 20public: 21\tint operator()(int v1, int v2) 22\t{ 23\treturn v1 + v2; 24\t} 25}; 26 27void test02() 28{ 29\tMyAdd add; 30\tint ret = add(10, 10); 31\tcout \u0026lt;\u0026lt; \u0026#34;ret = \u0026#34; \u0026lt;\u0026lt; ret \u0026lt;\u0026lt; endl; 32 33\t//匿名对象调用 34\tcout \u0026lt;\u0026lt; \u0026#34;MyAdd()(100,100) = \u0026#34; \u0026lt;\u0026lt; MyAdd()(100, 100) \u0026lt;\u0026lt; endl; 35} 继承 继承的基本语法 class A : public B;\nA 类称为子类 或 派生类\nB 类称为父类 或 基类\n派生类中的成员，包含两大部分：\n一类是从基类继承过来的，一类是自己增加的成员。\n从基类继承过过来的表现其共性，而新增的成员体现了其个性。\n继承方式 继承的语法：class 子类 : 继承方式 父类\n继承方式一共有三种：\n 公共继承 保护继承 私有继承  1class Base1 2{ 3public: 4\tint m_A; 5protected: 6\tint m_B; 7private: 8\tint m_C; 9}; 10 11//公共继承 12class Son1 :public Base1 13{ 14public: 15\tvoid func() 16\t{ 17\tm_A; //可访问 public权限 18\tm_B; //可访问 protected权限 19\t//m_C; //不可访问 20\t} 21}; 22 23void myClass() 24{ 25\tSon1 s1; 26\ts1.m_A; //其他类只能访问到公共权限 27} 28 29//保护继承 30class Base2 31{ 32public: 33\tint m_A; 34protected: 35\tint m_B; 36private: 37\tint m_C; 38}; 39class Son2:protected Base2 40{ 41public: 42\tvoid func() 43\t{ 44\tm_A; //可访问 protected权限 45\tm_B; //可访问 protected权限 46\t//m_C; //不可访问 47\t} 48}; 49void myClass2() 50{ 51\tSon2 s; 52\t//s.m_A; //不可访问 53} 54 55//私有继承 56class Base3 57{ 58public: 59\tint m_A; 60protected: 61\tint m_B; 62private: 63\tint m_C; 64}; 65class Son3:private Base3 66{ 67public: 68\tvoid func() 69\t{ 70\tm_A; //可访问 private权限 71\tm_B; //可访问 private权限 72\t//m_C; //不可访问 73\t} 74}; 75class GrandSon3 :public Son3 76{ 77public: 78\tvoid func() 79\t{ 80\t//Son3是私有继承，所以继承Son3的属性在GrandSon3中都无法访问到 81\t//m_A; 82\t//m_B; 83\t//m_C; 84\t} 85}; 继承中的对象模型 从父类继承过来的成员，哪些属于子类对象中？\n私有成员只是被隐藏了，但是还是会继承下去\n继承中构造和析构顺序 子类继承父类后，当创建子类对象，也会调用父类的构造函数\n继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反\n继承同名成员处理方式 当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？\n 访问子类同名成员 直接访问即可 访问父类同名成员 需要加作用域  1class Base { 2public: 3\tBase() 4\t{ 5\tm_A = 100; 6\t} 7 8\tvoid func() 9\t{ 10\tcout \u0026lt;\u0026lt; \u0026#34;Base - func()调用\u0026#34; \u0026lt;\u0026lt; endl; 11\t} 12 13\tvoid func(int a) 14\t{ 15\tcout \u0026lt;\u0026lt; \u0026#34;Base - func(int a)调用\u0026#34; \u0026lt;\u0026lt; endl; 16\t} 17 18public: 19\tint m_A; 20}; 21 22 23class Son : public Base { 24public: 25\tSon() 26\t{ 27\tm_A = 200; 28\t} 29 30\t//当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数 31\t//如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域 32\tvoid func() 33\t{ 34\tcout \u0026lt;\u0026lt; \u0026#34;Son - func()调用\u0026#34; \u0026lt;\u0026lt; endl; 35\t} 36public: 37\tint m_A; 38}; 39 40void test01() 41{ 42\tSon s; 43 44\tcout \u0026lt;\u0026lt; \u0026#34;Son下的m_A = \u0026#34; \u0026lt;\u0026lt; s.m_A \u0026lt;\u0026lt; endl; 45\tcout \u0026lt;\u0026lt; \u0026#34;Base下的m_A = \u0026#34; \u0026lt;\u0026lt; s.Base::m_A \u0026lt;\u0026lt; endl; 46 47\ts.func(); 48\ts.Base::func(); 49\ts.Base::func(10); 50 51} 继承同名静态成员处理方式 继承中同名的静态成员在子类对象上如何进行访问？\n静态成员和非静态成员出现同名，处理方式一致\n 访问子类同名成员 直接访问即可 访问父类同名成员 需要加作用域   同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）\n 1class Base { 2public: 3\tstatic void func() 4\t{ 5\tcout \u0026lt;\u0026lt; \u0026#34;Base - static void func()\u0026#34; \u0026lt;\u0026lt; endl; 6\t} 7\tstatic void func(int a) 8\t{ 9\tcout \u0026lt;\u0026lt; \u0026#34;Base - static void func(int a)\u0026#34; \u0026lt;\u0026lt; endl; 10\t} 11 12\tstatic int m_A; 13}; 14 15int Base::m_A = 100; 16 17class Son : public Base { 18public: 19\tstatic void func() 20\t{ 21\tcout \u0026lt;\u0026lt; \u0026#34;Son - static void func()\u0026#34; \u0026lt;\u0026lt; endl; 22\t} 23\tstatic int m_A; 24}; 25 26int Son::m_A = 200; 27 28//同名成员属性 29void test01() 30{ 31\t//通过对象访问 32\tcout \u0026lt;\u0026lt; \u0026#34;通过对象访问： \u0026#34; \u0026lt;\u0026lt; endl; 33\tSon s; 34\tcout \u0026lt;\u0026lt; \u0026#34;Son 下 m_A = \u0026#34; \u0026lt;\u0026lt; s.m_A \u0026lt;\u0026lt; endl; 35\tcout \u0026lt;\u0026lt; \u0026#34;Base 下 m_A = \u0026#34; \u0026lt;\u0026lt; s.Base::m_A \u0026lt;\u0026lt; endl; 36 37\t//通过类名访问 38\tcout \u0026lt;\u0026lt; \u0026#34;通过类名访问： \u0026#34; \u0026lt;\u0026lt; endl; 39\tcout \u0026lt;\u0026lt; \u0026#34;Son 下 m_A = \u0026#34; \u0026lt;\u0026lt; Son::m_A \u0026lt;\u0026lt; endl; 40\tcout \u0026lt;\u0026lt; \u0026#34;Base 下 m_A = \u0026#34; \u0026lt;\u0026lt; Son::Base::m_A \u0026lt;\u0026lt; endl; 41} 42 43//同名成员函数 44void test02() 45{ 46\t//通过对象访问 47\tcout \u0026lt;\u0026lt; \u0026#34;通过对象访问： \u0026#34; \u0026lt;\u0026lt; endl; 48\tSon s; 49\ts.func(); 50\ts.Base::func(); 51 52\tcout \u0026lt;\u0026lt; \u0026#34;通过类名访问： \u0026#34; \u0026lt;\u0026lt; endl; 53\tSon::func(); 54\tSon::Base::func(); 55\t//出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问 56\tSon::Base::func(100); 57} 多继承语法 C++允许一个类继承多个类\n语法： class 子类 ：继承方式 父类1 ， 继承方式 父类2...\n多继承可能会引发父类中有同名成员出现，需要加作用域区分\nC++实际开发中不建议用多继承\n1class Base1 { 2public: 3\tBase1() 4\t{ 5\tm_A = 100; 6\t} 7public: 8\tint m_A; 9}; 10 11class Base2 { 12public: 13\tBase2() 14\t{ 15\tm_A = 200; //开始是m_B 不会出问题，但是改为mA就会出现不明确 16\t} 17public: 18\tint m_A; 19}; 20 21//语法：class 子类：继承方式 父类1 ，继承方式 父类2 22class Son : public Base2, public Base1 23{ 24public: 25\tSon() 26\t{ 27\tm_C = 300; 28\tm_D = 400; 29\t} 30public: 31\tint m_C; 32\tint m_D; 33}; 34 35 36//多继承容易产生成员同名的情况 37//通过使用类名作用域可以区分调用哪一个基类的成员 38void test01() 39{ 40\tSon s; 41\tcout \u0026lt;\u0026lt; \u0026#34;sizeof Son = \u0026#34; \u0026lt;\u0026lt; sizeof(s) \u0026lt;\u0026lt; endl; 42\tcout \u0026lt;\u0026lt; s.Base1::m_A \u0026lt;\u0026lt; endl; 43\tcout \u0026lt;\u0026lt; s.Base2::m_A \u0026lt;\u0026lt; endl; 44} 菱形继承 两个派生类继承同一个基类\n又有某个类同时继承者两个派生类\n 菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义 利用虚继承可以解决菱形继承问题  1class Animal 2{ 3public: 4\tint m_Age; 5}; 6 7//继承前加virtual关键字后，变为虚继承 8//此时公共的父类Animal称为虚基类 9class Sheep : virtual public Animal {}; 10class Tuo : virtual public Animal {}; 11class SheepTuo : public Sheep, public Tuo {}; 12 13void test01() 14{ 15\tSheepTuo st; 16\tst.Sheep::m_Age = 100; 17\tst.Tuo::m_Age = 200; 18 19\tcout \u0026lt;\u0026lt; \u0026#34;st.Sheep::m_Age = \u0026#34; \u0026lt;\u0026lt; st.Sheep::m_Age \u0026lt;\u0026lt; endl; 20\tcout \u0026lt;\u0026lt; \u0026#34;st.Tuo::m_Age = \u0026#34; \u0026lt;\u0026lt; st.Tuo::m_Age \u0026lt;\u0026lt; endl; 21\tcout \u0026lt;\u0026lt; \u0026#34;st.m_Age = \u0026#34; \u0026lt;\u0026lt; st.m_Age \u0026lt;\u0026lt; endl; 22} 多态 多态分为两类\n 静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名 动态多态: 派生类和虚函数实现运行时多态  静态多态和动态多态区别：\n 静态多态的函数地址早绑定 - 编译阶段确定函数地址 动态多态的函数地址晚绑定 - 运行阶段确定函数地址  多态满足条件\n 有继承关系 子类重写父类中的虚函数  多态使用条件\n 父类指针或引用指向子类对象  重写：函数返回值类型 函数名 参数列表 完全一致称为重写\n1class Animal 2{ 3public: 4\t//Speak函数就是虚函数 5\t//函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。 6\tvirtual void speak() 7\t{ 8\tcout \u0026lt;\u0026lt; \u0026#34;动物在说话\u0026#34; \u0026lt;\u0026lt; endl; 9\t} 10}; 11 12class Cat :public Animal 13{ 14public: 15\tvoid speak() 16\t{ 17\tcout \u0026lt;\u0026lt; \u0026#34;小猫在说话\u0026#34; \u0026lt;\u0026lt; endl; 18\t} 19}; 20 21class Dog :public Animal 22{ 23public: 24 25\tvoid speak() 26\t{ 27\tcout \u0026lt;\u0026lt; \u0026#34;小狗在说话\u0026#34; \u0026lt;\u0026lt; endl; 28\t} 29 30}; 31//我们希望传入什么对象，那么就调用什么对象的函数 32//如果函数地址在编译阶段就能确定，那么静态联编 33//如果函数地址在运行阶段才能确定，就是动态联编 34 35void DoSpeak(Animal \u0026amp; animal) 36{ 37\tanimal.speak(); 38} 39// 40//多态满足条件： 41//1、有继承关系 42//2、子类重写父类中的虚函数 43//多态使用： 44//父类指针或引用指向子类对象 45 46void test01() 47{ 48\tCat cat; 49\tDoSpeak(cat); 50 51 52\tDog dog; 53\tDoSpeak(dog); 54} 多态案例一-计算器类 1//多态实现 2//抽象计算器类 3//多态优点：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护 4class AbstractCalculator 5{ 6public : 7 8\tvirtual int getResult() 9\t{ 10\treturn 0; 11\t} 12 13\tint m_Num1; 14\tint m_Num2; 15}; 16 17//加法计算器 18class AddCalculator :public AbstractCalculator 19{ 20public: 21\tint getResult() 22\t{ 23\treturn m_Num1 + m_Num2; 24\t} 25}; 26 27//减法计算器 28class SubCalculator :public AbstractCalculator 29{ 30public: 31\tint getResult() 32\t{ 33\treturn m_Num1 - m_Num2; 34\t} 35}; 36 37//乘法计算器 38class MulCalculator :public AbstractCalculator 39{ 40public: 41\tint getResult() 42\t{ 43\treturn m_Num1 * m_Num2; 44\t} 45}; 46 47 48void test02() 49{ 50\t//创建加法计算器 51\tAbstractCalculator *abc = new AddCalculator; 52\tabc-\u0026gt;m_Num1 = 10; 53\tabc-\u0026gt;m_Num2 = 10; 54\tcout \u0026lt;\u0026lt; abc-\u0026gt;m_Num1 \u0026lt;\u0026lt; \u0026#34; + \u0026#34; \u0026lt;\u0026lt; abc-\u0026gt;m_Num2 \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; abc-\u0026gt;getResult() \u0026lt;\u0026lt; endl; 55\tdelete abc; //用完了记得销毁 56 57\t//创建减法计算器 58\tabc = new SubCalculator; 59\tabc-\u0026gt;m_Num1 = 10; 60\tabc-\u0026gt;m_Num2 = 10; 61\tcout \u0026lt;\u0026lt; abc-\u0026gt;m_Num1 \u0026lt;\u0026lt; \u0026#34; - \u0026#34; \u0026lt;\u0026lt; abc-\u0026gt;m_Num2 \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; abc-\u0026gt;getResult() \u0026lt;\u0026lt; endl; 62\tdelete abc; 63 64\t//创建乘法计算器 65\tabc = new MulCalculator; 66\tabc-\u0026gt;m_Num1 = 10; 67\tabc-\u0026gt;m_Num2 = 10; 68\tcout \u0026lt;\u0026lt; abc-\u0026gt;m_Num1 \u0026lt;\u0026lt; \u0026#34; * \u0026#34; \u0026lt;\u0026lt; abc-\u0026gt;m_Num2 \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; abc-\u0026gt;getResult() \u0026lt;\u0026lt; endl; 69\tdelete abc; 70} 71 纯虚函数和抽象类 在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容\n因此可以将虚函数改为纯虚函数\n纯虚函数语法：virtual 返回值类型 函数名 （参数列表）= 0 ;\n当类中有了纯虚函数，这个类也称为抽象类\n抽象类特点：\n 无法实例化对象 子类必须重写抽象类中的纯虚函数，否则也属于抽象类  1class Base 2{ 3public: 4\t//纯虚函数 5\t//类中只要有一个纯虚函数就称为抽象类 6\t//抽象类无法实例化对象 7\t//子类必须重写父类中的纯虚函数，否则也属于抽象类 8\tvirtual void func() = 0; 9}; 10 11class Son :public Base 12{ 13public: 14\tvirtual void func() 15\t{ 16\tcout \u0026lt;\u0026lt; \u0026#34;func调用\u0026#34; \u0026lt;\u0026lt; endl; 17\t}; 18}; 19 20void test01() 21{ 22\tBase * base = NULL; 23\t//base = new Base; // 错误，抽象类无法实例化对象 24\tbase = new Son; 25\tbase-\u0026gt;func(); 26\tdelete base;//记得销毁 27} 多态案例二-制作饮品 1//抽象制作饮品 2class AbstractDrinking { 3public: 4\t//烧水 5\tvirtual void Boil() = 0; 6\t//冲泡 7\tvirtual void Brew() = 0; 8\t//倒入杯中 9\tvirtual void PourInCup() = 0; 10\t//加入辅料 11\tvirtual void PutSomething() = 0; 12\t//规定流程 13\tvoid MakeDrink() { 14\tBoil(); 15\tBrew(); 16\tPourInCup(); 17\tPutSomething(); 18\t} 19}; 20 21//制作咖啡 22class Coffee : public AbstractDrinking { 23public: 24\t//烧水 25\tvirtual void Boil() { 26\tcout \u0026lt;\u0026lt; \u0026#34;煮农夫山泉!\u0026#34; \u0026lt;\u0026lt; endl; 27\t} 28\t//冲泡 29\tvirtual void Brew() { 30\tcout \u0026lt;\u0026lt; \u0026#34;冲泡咖啡!\u0026#34; \u0026lt;\u0026lt; endl; 31\t} 32\t//倒入杯中 33\tvirtual void PourInCup() { 34\tcout \u0026lt;\u0026lt; \u0026#34;将咖啡倒入杯中!\u0026#34; \u0026lt;\u0026lt; endl; 35\t} 36\t//加入辅料 37\tvirtual void PutSomething() { 38\tcout \u0026lt;\u0026lt; \u0026#34;加入牛奶!\u0026#34; \u0026lt;\u0026lt; endl; 39\t} 40}; 41 42//制作茶水 43class Tea : public AbstractDrinking { 44public: 45\t//烧水 46\tvirtual void Boil() { 47\tcout \u0026lt;\u0026lt; \u0026#34;煮自来水!\u0026#34; \u0026lt;\u0026lt; endl; 48\t} 49\t//冲泡 50\tvirtual void Brew() { 51\tcout \u0026lt;\u0026lt; \u0026#34;冲泡茶叶!\u0026#34; \u0026lt;\u0026lt; endl; 52\t} 53\t//倒入杯中 54\tvirtual void PourInCup() { 55\tcout \u0026lt;\u0026lt; \u0026#34;将茶水倒入杯中!\u0026#34; \u0026lt;\u0026lt; endl; 56\t} 57\t//加入辅料 58\tvirtual void PutSomething() { 59\tcout \u0026lt;\u0026lt; \u0026#34;加入枸杞!\u0026#34; \u0026lt;\u0026lt; endl; 60\t} 61}; 62 63//业务函数 64void DoWork(AbstractDrinking* drink) { 65\tdrink-\u0026gt;MakeDrink(); 66\tdelete drink; 67} 68 69void test01() { 70\tDoWork(new Coffee); 71\tcout \u0026lt;\u0026lt; \u0026#34;--------------\u0026#34; \u0026lt;\u0026lt; endl; 72\tDoWork(new Tea); 73} 虚析构和纯虚析构 多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码\n解决方式：将父类中的析构函数改为虚析构或者纯虚析构\n虚析构和纯虚析构共性：\n 可以解决父类指针释放子类对象 都需要有具体的函数实现  虚析构和纯虚析构区别：\n 如果是纯虚析构，该类属于抽象类，无法实例化对象  虚析构语法：\nvirtual ~类名(){}\n纯虚析构语法：\n virtual ~类名() = 0;\n类名::~类名(){}\n​\t1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象\n​\t2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构\n​\t3. 拥有纯虚析构函数的类也属于抽象类\n1class Animal { 2public: 3 4\tAnimal() 5\t{ 6\tcout \u0026lt;\u0026lt; \u0026#34;Animal 构造函数调用！\u0026#34; \u0026lt;\u0026lt; endl; 7\t} 8\tvirtual void Speak() = 0; 9 10\t//析构函数加上virtual关键字，变成虚析构函数 11\t//virtual ~Animal() 12\t//{ 13\t//\tcout \u0026lt;\u0026lt; \u0026#34;Animal虚析构函数调用！\u0026#34; \u0026lt;\u0026lt; endl; 14\t//} 15 16 17\tvirtual ~Animal() = 0; 18}; 19 20Animal::~Animal() 21{ 22\tcout \u0026lt;\u0026lt; \u0026#34;Animal 纯虚析构函数调用！\u0026#34; \u0026lt;\u0026lt; endl; 23} 24 25//和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。 26 27class Cat : public Animal { 28public: 29\tCat(string name) 30\t{ 31\tcout \u0026lt;\u0026lt; \u0026#34;Cat构造函数调用！\u0026#34; \u0026lt;\u0026lt; endl; 32\tm_Name = new string(name); 33\t} 34\tvirtual void Speak() 35\t{ 36\tcout \u0026lt;\u0026lt; *m_Name \u0026lt;\u0026lt; \u0026#34;小猫在说话!\u0026#34; \u0026lt;\u0026lt; endl; 37\t} 38\t~Cat() 39\t{ 40\tcout \u0026lt;\u0026lt; \u0026#34;Cat析构函数调用!\u0026#34; \u0026lt;\u0026lt; endl; 41\tif (this-\u0026gt;m_Name != NULL) { 42\tdelete m_Name; 43\tm_Name = NULL; 44\t} 45\t} 46 47public: 48\tstring *m_Name; 49}; 50 51void test01() 52{ 53\tAnimal *animal = new Cat(\u0026#34;Tom\u0026#34;); 54\tanimal-\u0026gt;Speak(); 55 56\t//通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏 57\t//怎么解决？给基类增加一个虚析构函数 58\t//虚析构函数就是用来解决通过父类指针释放子类对象 59\tdelete animal; 60} 多态案例三-电脑组装 14.文件操作 程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放\n通过文件可以将数据持久化\nC++中对文件操作需要包含头文件 \u0026lt; fstream \u0026gt;\n文件类型分为两种：\n 文本文件 - 文件以文本的ASCII码形式存储在计算机中 二进制文件 - 文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂它们  操作文件的三大类:\n ofstream：写操作 ifstream： 读操作 fstream ： 读写操作  文本文件 写文件 写文件步骤如下：\n  包含头文件\n#include \u0026lt;fstream\u0026gt;\n  创建流对象\nofstream ofs;\n  打开文件\nofs.open(\u0026ldquo;文件路径\u0026rdquo;,打开方式);\n  写数据\nofs \u0026laquo; \u0026ldquo;写入的数据\u0026rdquo;;\n  关闭文件\nofs.close();\n  文件打开方式：\n   打开方式 解释     ios::in 为读文件而打开文件   ios::out 为写文件而打开文件   ios::ate 初始位置：文件尾   ios::app 追加方式写文件   ios::trunc 如果文件存在先删除，再创建   ios::binary 二进制方式    注意： 文件打开方式可以配合使用，利用|操作符\n**例如：**用二进制方式写文件 ios::binary | ios:: out\n示例：\n1#include \u0026lt;fstream\u0026gt;2 3void test01() 4{ 5\tofstream ofs; 6\tofs.open(\u0026#34;test.txt\u0026#34;, ios::out); 7 8\tofs \u0026lt;\u0026lt; \u0026#34;姓名：张三\u0026#34; \u0026lt;\u0026lt; endl; 9\tofs \u0026lt;\u0026lt; \u0026#34;性别：男\u0026#34; \u0026lt;\u0026lt; endl; 10\tofs \u0026lt;\u0026lt; \u0026#34;年龄：18\u0026#34; \u0026lt;\u0026lt; endl; 11 12\tofs.close(); 13} 14 15int main() { 16 17\ttest01(); 18 19\tsystem(\u0026#34;pause\u0026#34;); 20 21\treturn 0; 22} 总结：\n 文件操作必须包含头文件 fstream 读文件可以利用 ofstream ，或者fstream类 打开文件时候需要指定操作文件的路径，以及打开方式 利用\u0026laquo;可以向文件中写数据 操作完毕，要关闭文件  读文件 读文件步骤如下：\n  包含头文件\n#include \u0026lt;fstream\u0026gt;\n  创建流对象\nifstream ifs;\n  打开文件并判断文件是否打开成功\nifs.open(\u0026ldquo;文件路径\u0026rdquo;,打开方式);\n  读数据\n四种方式读取\n  关闭文件\nifs.close();示例：\n1#include \u0026lt;fstream\u0026gt;2#include \u0026lt;string\u0026gt;3void test01() 4{ 5\tifstream ifs; 6\tifs.open(\u0026#34;test.txt\u0026#34;, ios::in); 7 8\tif (!ifs.is_open()) 9\t{ 10 cout \u0026lt;\u0026lt; \u0026#34;文件打开失败\u0026#34; \u0026lt;\u0026lt; endl; 11 return; 12\t} 13 14\t//第一种方式 15\t//char buf[1024] = { 0 }; 16\t//while (ifs \u0026gt;\u0026gt; buf) 17\t//{ 18\t//\tcout \u0026lt;\u0026lt; buf \u0026lt;\u0026lt; endl; 19\t//} 20 21\t//第二种 22\t//char buf[1024] = { 0 }; 23\t//while (ifs.getline(buf,sizeof(buf))) 24\t//{ 25\t//\tcout \u0026lt;\u0026lt; buf \u0026lt;\u0026lt; endl; 26\t//} 27 28\t//第三种 29\t//string buf; 30\t//while (getline(ifs, buf)) 31\t//{ 32\t//\tcout \u0026lt;\u0026lt; buf \u0026lt;\u0026lt; endl; 33\t//} 34 35\tchar c; 36\twhile ((c = ifs.get()) != EOF) 37\t{ 38 cout \u0026lt;\u0026lt; c; 39\t} 40 41\tifs.close(); 42 43 44} 45 46int main() { 47 48\ttest01(); 49 50\tsystem(\u0026#34;pause\u0026#34;); 51 52\treturn 0; 53} 总结：\n 读文件可以利用 ifstream ，或者fstream类 利用is_open函数可以判断文件是否打开成功 close 关闭文件    二进制文件 以二进制的方式对文件进行读写操作\n打开方式要指定为 ios::binary\n写文件 二进制方式写文件主要利用流对象调用成员函数write\n函数原型 ：ostream\u0026amp; write(const char * buffer,int len);\n参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数\n1#include \u0026lt;fstream\u0026gt;2#include \u0026lt;string\u0026gt;3 4class Person 5{ 6public: 7\tchar m_Name[64]; 8\tint m_Age; 9}; 10 11//二进制文件 写文件 12void test01() 13{ 14\t//1、包含头文件 15 16\t//2、创建输出流对象 17\tofstream ofs(\u0026#34;person.txt\u0026#34;, ios::out | ios::binary); 18\t19\t//3、打开文件 20\t//ofs.open(\u0026#34;person.txt\u0026#34;, ios::out | ios::binary); 21 22\tPerson p = {\u0026#34;张三\u0026#34; , 18}; 23 24\t//4、写文件 25\tofs.write((const char *)\u0026amp;p, sizeof(p)); 26 27\t//5、关闭文件 28\tofs.close(); 29} 读文件 二进制方式读文件主要利用流对象调用成员函数read\n函数原型：istream\u0026amp; read(char *buffer,int len);\n参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数\n示例：\n1#include \u0026lt;fstream\u0026gt;2#include \u0026lt;string\u0026gt;3 4class Person 5{ 6public: 7\tchar m_Name[64]; 8\tint m_Age; 9}; 10 11void test01() 12{ 13\tifstream ifs(\u0026#34;person.txt\u0026#34;, ios::in | ios::binary); 14\tif (!ifs.is_open()) 15\t{ 16\tcout \u0026lt;\u0026lt; \u0026#34;文件打开失败\u0026#34; \u0026lt;\u0026lt; endl; 17\t} 18 19\tPerson p; 20\tifs.read((char *)\u0026amp;p, sizeof(p)); 21 22\tcout \u0026lt;\u0026lt; \u0026#34;姓名： \u0026#34; \u0026lt;\u0026lt; p.m_Name \u0026lt;\u0026lt; \u0026#34; 年龄： \u0026#34; \u0026lt;\u0026lt; p.m_Age \u0026lt;\u0026lt; endl; 23} 15.模板 模板的概念 模板就是建立通用的模具，大大提高复用性\n函数模板   C++另一种编程思想称为 泛型编程，主要利用的技术就是模板\n  C++提供两种模板机制:函数模板和类模板\n  函数模板语法 建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个虚拟的类型来代表。\n语法：\n1template\u0026lt;typename T\u0026gt; 2函数声明或定义 解释：\ntemplate \u0026mdash; 声明创建模板\ntypename \u0026mdash; 表面其后面的符号是一种数据类型，可以用class代替\nT \u0026mdash; 通用的数据类型，名称可以替换，通常为大写字母\n示例：\n1//交换整型函数 2void swapInt(int\u0026amp; a, int\u0026amp; b) { 3\tint temp = a; 4\ta = b; 5\tb = temp; 6} 7 8//交换浮点型函数 9void swapDouble(double\u0026amp; a, double\u0026amp; b) { 10\tdouble temp = a; 11\ta = b; 12\tb = temp; 13} 14 15//利用模板提供通用的交换函数 16template\u0026lt;typename T\u0026gt; 17void mySwap(T\u0026amp; a, T\u0026amp; b) 18{ 19\tT temp = a; 20\ta = b; 21\tb = temp; 22} 23 24void test01() 25{ 26\tint a = 10; 27\tint b = 20; 28\t29\t//swapInt(a, b); 30 31\t//利用模板实现交换 32\t//1、自动类型推导 33\tmySwap(a, b); 34 35\t//2、显示指定类型 36\tmySwap\u0026lt;int\u0026gt;(a, b); 37 38\tcout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; 39\tcout \u0026lt;\u0026lt; \u0026#34;b = \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; 40 41} 总结：\n 函数模板利用关键字 template 使用函数模板有两种方式：自动类型推导、显示指定类型 模板的目的是为了提高复用性，将类型参数化  函数模板注意事项   自动类型推导，必须推导出一致的数据类型T,才可以使用\n  模板必须要确定出T的数据类型，才可以使用\n  1//利用模板提供通用的交换函数 2template\u0026lt;class T\u0026gt; 3void mySwap(T\u0026amp; a, T\u0026amp; b) 4{ 5\tT temp = a; 6\ta = b; 7\tb = temp; 8} 9 10 11// 1、自动类型推导，必须推导出一致的数据类型T,才可以使用 12void test01() 13{ 14\tint a = 10; 15\tint b = 20; 16\tchar c = \u0026#39;c\u0026#39;; 17 18\tmySwap(a, b); // 正确，可以推导出一致的T 19\t//mySwap(a, c); // 错误，推导不出一致的T类型 20} 21 22 23// 2、模板必须要确定出T的数据类型，才可以使用 24template\u0026lt;class T\u0026gt; 25void func() 26{ 27\tcout \u0026lt;\u0026lt; \u0026#34;func 调用\u0026#34; \u0026lt;\u0026lt; endl; 28} 29 30void test02() 31{ 32\t//func(); //错误，模板不能独立使用，必须确定出T的类型 33\tfunc\u0026lt;int\u0026gt;(); //利用显示指定类型的方式，给T一个类型，才可以使用该模板 34} 函数模板案例 案例描述：\n 利用函数模板封装一个排序的函数，可以对不同数据类型数组进行排序 排序规则从大到小，排序算法为选择排序 分别利用char数组和int数组进行测试  1//交换的函数模板 2template\u0026lt;typename T\u0026gt; 3void mySwap(T \u0026amp;a, T\u0026amp;b) 4{ 5\tT temp = a; 6\ta = b; 7\tb = temp; 8} 9 10 11template\u0026lt;class T\u0026gt; // 也可以替换成typename 12//利用选择排序，进行对数组从大到小的排序 13void mySort(T arr[], int len) 14{ 15\tfor (int i = 0; i \u0026lt; len; i++) 16\t{ 17\tint max = i; //最大数的下标 18\tfor (int j = i + 1; j \u0026lt; len; j++) 19\t{ 20\tif (arr[max] \u0026lt; arr[j]) 21\t{ 22\tmax = j; 23\t} 24\t} 25\tif (max != i) //如果最大数的下标不是i，交换两者 26\t{ 27\tmySwap(arr[max], arr[i]); 28\t} 29\t} 30} 31template\u0026lt;typename T\u0026gt; 32void printArray(T arr[], int len) { 33 34\tfor (int i = 0; i \u0026lt; len; i++) { 35\tcout \u0026lt;\u0026lt; arr[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 36\t} 37\tcout \u0026lt;\u0026lt; endl; 38} 39void test01() 40{ 41\t//测试char数组 42\tchar charArr[] = \u0026#34;bdcfeagh\u0026#34;; 43\tint num = sizeof(charArr) / sizeof(char); 44\tmySort(charArr, num); 45\tprintArray(charArr, num); 46} 47 48void test02() 49{ 50\t//测试int数组 51\tint intArr[] = { 7, 5, 8, 1, 3, 9, 2, 4, 6 }; 52\tint num = sizeof(intArr) / sizeof(int); 53\tmySort(intArr, num); 54\tprintArray(intArr, num); 55} 普通函数与函数模板的区别 普通函数与函数模板区别：\n 普通函数调用时可以发生自动类型转换（隐式类型转换） 函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换 如果利用显示指定类型的方式，可以发生隐式类型转换  1//普通函数 2int myAdd01(int a, int b) 3{ 4\treturn a + b; 5} 6 7//函数模板 8template\u0026lt;class T\u0026gt; 9T myAdd02(T a, T b) 10{ 11\treturn a + b; 12} 13 14//使用函数模板时，如果用自动类型推导，不会发生自动类型转换,即隐式类型转换 15void test01() 16{ 17\tint a = 10; 18\tint b = 20; 19\tchar c = \u0026#39;c\u0026#39;; 20\t21\tcout \u0026lt;\u0026lt; myAdd01(a, c) \u0026lt;\u0026lt; endl; //正确，将char类型的\u0026#39;c\u0026#39;隐式转换为int类型 \u0026#39;c\u0026#39; 对应 ASCII码 99 22 23\t//myAdd02(a, c); // 报错，使用自动类型推导时，不会发生隐式类型转换 24 25\tmyAdd02\u0026lt;int\u0026gt;(a, c); //正确，如果用显示指定类型，可以发生隐式类型转换 26} 普通函数与函数模板的调用规则 调用规则如下：\n 如果函数模板和普通函数都可以实现，优先调用普通函数 可以通过空模板参数列表来强制调用函数模板 函数模板也可以发生重载 如果函数模板可以产生更好的匹配,优先调用函数模板  总结：既然提供了函数模板，最好就不要提供普通函数，否则容易出现二义性\n1//普通函数与函数模板调用规则 2void myPrint(int a, int b) 3{ 4\tcout \u0026lt;\u0026lt; \u0026#34;调用的普通函数\u0026#34; \u0026lt;\u0026lt; endl; 5} 6 7template\u0026lt;typename T\u0026gt; 8void myPrint(T a, T b) 9{ 10\tcout \u0026lt;\u0026lt; \u0026#34;调用的模板\u0026#34; \u0026lt;\u0026lt; endl; 11} 12 13template\u0026lt;typename T\u0026gt; 14void myPrint(T a, T b, T c) 15{ 16\tcout \u0026lt;\u0026lt; \u0026#34;调用重载的模板\u0026#34; \u0026lt;\u0026lt; endl; 17} 18 19void test01() 20{ 21\t//1、如果函数模板和普通函数都可以实现，优先调用普通函数 22\t// 注意 如果告诉编译器 普通函数是有的，但只是声明没有实现，或者不在当前文件内实现，就会报错找不到 23\tint a = 10; 24\tint b = 20; 25\tmyPrint(a, b); //调用普通函数 26 27\t//2、可以通过空模板参数列表来强制调用函数模板 28\tmyPrint\u0026lt;\u0026gt;(a, b); //调用函数模板 29 30\t//3、函数模板也可以发生重载 31\tint c = 30; 32\tmyPrint(a, b, c); //调用重载的函数模板 33 34\t//4、 如果函数模板可以产生更好的匹配,优先调用函数模板 35\tchar c1 = \u0026#39;a\u0026#39;; 36\tchar c2 = \u0026#39;b\u0026#39;; 37\tmyPrint(c1, c2); //调用函数模板 38} 模板的局限性 例如：\n1\ttemplate\u0026lt;class T\u0026gt; 2\tvoid f(T a, T b) 3\t{ 4 a = b; 5 } 在上述代码中提供的赋值操作，如果传入的a和b是一个数组，就无法实现了\n再例如：\n1\ttemplate\u0026lt;class T\u0026gt; 2\tvoid f(T a, T b) 3\t{ 4 if(a \u0026gt; b) { ... } 5 } 在上述代码中，如果T的数据类型传入的是像Person这样的自定义数据类型，也无法正常运行\n因此C++为了解决这种问题，提供模板的重载，可以为这些特定的类型提供具体化的模板\n1//普通函数模板 2template\u0026lt;class T\u0026gt; 3bool myCompare(T\u0026amp; a, T\u0026amp; b) 4{ 5\tif (a == b) 6\t{ 7\treturn true; 8\t} 9\telse 10\t{ 11\treturn false; 12\t} 13} 14 15 16//具体化，显示具体化的原型和定意思以template\u0026lt;\u0026gt;开头，并通过名称来指出类型 17//具体化优先于常规模板 18template\u0026lt;\u0026gt; bool myCompare(Person \u0026amp;p1, Person \u0026amp;p2) 19{ 20\tif ( p1.m_Name == p2.m_Name \u0026amp;\u0026amp; p1.m_Age == p2.m_Age) 21\t{ 22\treturn true; 23\t} 24\telse 25\t{ 26\treturn false; 27\t} 28} 29 30void test01() 31{ 32\tint a = 10; 33\tint b = 20; 34\t//内置数据类型可以直接使用通用的函数模板 35\tbool ret = myCompare(a, b); 36\tif (ret) 37\t{ 38\tcout \u0026lt;\u0026lt; \u0026#34;a == b \u0026#34; \u0026lt;\u0026lt; endl; 39\t} 40\telse 41\t{ 42\tcout \u0026lt;\u0026lt; \u0026#34;a != b \u0026#34; \u0026lt;\u0026lt; endl; 43\t} 44} 45 46void test02() 47{ 48\tPerson p1(\u0026#34;Tom\u0026#34;, 10); 49\tPerson p2(\u0026#34;Tom\u0026#34;, 10); 50\t//自定义数据类型，不会调用普通的函数模板 51\t//可以创建具体化的Person数据类型的模板，用于特殊处理这个类型 52\tbool ret = myCompare(p1, p2); 53\tif (ret) 54\t{ 55\tcout \u0026lt;\u0026lt; \u0026#34;p1 == p2 \u0026#34; \u0026lt;\u0026lt; endl; 56\t} 57\telse 58\t{ 59\tcout \u0026lt;\u0026lt; \u0026#34;p1 != p2 \u0026#34; \u0026lt;\u0026lt; endl; 60\t} 61} 类模板 类模板语法 建立一个通用类，类中的成员 数据类型可以不具体制定，用一个虚拟的类型来代表。\n语法：\n1template\u0026lt;typename T\u0026gt; 2类 解释：\ntemplate \u0026mdash; 声明创建模板\ntypename \u0026mdash; 表面其后面的符号是一种数据类型，可以用class代替\nT \u0026mdash; 通用的数据类型，名称可以替换，通常为大写字母\n示例：\n1#include \u0026lt;string\u0026gt;2//类模板 3template\u0026lt;class NameType, class AgeType\u0026gt; 4class Person 5{ 6public: 7\tPerson(NameType name, AgeType age) 8\t{ 9\tthis-\u0026gt;mName = name; 10\tthis-\u0026gt;mAge = age; 11\t} 12\tvoid showPerson() 13\t{ 14\tcout \u0026lt;\u0026lt; \u0026#34;name: \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;mName \u0026lt;\u0026lt; \u0026#34; age: \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;mAge \u0026lt;\u0026lt; endl; 15\t} 16public: 17\tNameType mName; 18\tAgeType mAge; 19}; 20 21void test01() 22{ 23\t// 指定NameType 为string类型，AgeType 为 int类型 24\tPerson\u0026lt;string, int\u0026gt;P1(\u0026#34;孙悟空\u0026#34;, 999); 25\tP1.showPerson(); 26} 类模板与函数模板区别 类模板与函数模板区别主要有两点：\n 类模板没有自动类型推导的使用方式 类模板在模板参数列表中可以有默认参数  1#include \u0026lt;string\u0026gt;2//类模板 3template\u0026lt;class NameType, class AgeType = int\u0026gt; 4class Person 5{ 6public: 7\tPerson(NameType name, AgeType age) 8\t{ 9\tthis-\u0026gt;mName = name; 10\tthis-\u0026gt;mAge = age; 11\t} 12\tvoid showPerson() 13\t{ 14\tcout \u0026lt;\u0026lt; \u0026#34;name: \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;mName \u0026lt;\u0026lt; \u0026#34; age: \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;mAge \u0026lt;\u0026lt; endl; 15\t} 16public: 17\tNameType mName; 18\tAgeType mAge; 19}; 20 21//1、类模板没有自动类型推导的使用方式 22void test01() 23{ 24\t// Person p(\u0026#34;孙悟空\u0026#34;, 1000); // 错误 类模板使用时候，不可以用自动类型推导 25\tPerson \u0026lt;string ,int\u0026gt;p(\u0026#34;孙悟空\u0026#34;, 1000); //必须使用显示指定类型的方式，使用类模板 26\tp.showPerson(); 27} 28 29//2、类模板在模板参数列表中可以有默认参数 30void test02() 31{ 32\tPerson \u0026lt;string\u0026gt; p(\u0026#34;猪八戒\u0026#34;, 999); //类模板中的模板参数列表 可以指定默认参数 33\tp.showPerson(); 34} 类模板中成员函数创建时机 类模板中成员函数和普通类中成员函数创建时机是有区别的：\n 普通类中的成员函数一开始就可以创建 类模板中的成员函数在调用时才创建  类模板对象做函数参数 一共有三种传入方式：\n 指定传入的类型 \u0026mdash; 直接显示对象的数据类型 参数模板化 \u0026mdash; 将对象中的参数变为模板进行传递 整个类模板化 \u0026mdash; 将这个对象类型 模板化进行传递  1//1、指定传入的类型 2void printPerson1(Person\u0026lt;string, int\u0026gt; \u0026amp;p) 3{ 4\tp.showPerson(); 5} 6void test01() 7{ 8\tPerson \u0026lt;string, int \u0026gt;p(\u0026#34;孙悟空\u0026#34;, 100); 9\tprintPerson1(p); 10} 11 12//2、参数模板化 13template \u0026lt;class T1, class T2\u0026gt; 14void printPerson2(Person\u0026lt;T1, T2\u0026gt;\u0026amp;p) 15{ 16\tp.showPerson(); 17\tcout \u0026lt;\u0026lt; \u0026#34;T1的类型为： \u0026#34; \u0026lt;\u0026lt; typeid(T1).name() \u0026lt;\u0026lt; endl; 18\tcout \u0026lt;\u0026lt; \u0026#34;T2的类型为： \u0026#34; \u0026lt;\u0026lt; typeid(T2).name() \u0026lt;\u0026lt; endl; 19} 20void test02() 21{ 22\tPerson \u0026lt;string, int \u0026gt;p(\u0026#34;猪八戒\u0026#34;, 90); 23\tprintPerson2(p); 24} 25 26//3、整个类模板化 27template\u0026lt;class T\u0026gt; 28void printPerson3(T \u0026amp; p) 29{ 30\tcout \u0026lt;\u0026lt; \u0026#34;T的类型为： \u0026#34; \u0026lt;\u0026lt; typeid(T).name() \u0026lt;\u0026lt; endl; 31\tp.showPerson(); 32 33} 34void test03() 35{ 36\tPerson \u0026lt;string, int \u0026gt;p(\u0026#34;唐僧\u0026#34;, 30); 37\tprintPerson3(p); 38} 类模板与继承 当类模板碰到继承时，需要注意一下几点：\n 当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型 如果不指定，编译器无法给子类分配内存 如果想灵活指定出父类中T的类型，子类也需变为类模板  1template\u0026lt;class T\u0026gt; 2class Base 3{ 4\tT m; 5}; 6 7//class Son:public Base //错误，c++编译需要给子类分配内存，必须知道父类中T的类型才可以向下继承 8class Son :public Base\u0026lt;int\u0026gt; //必须指定一个类型 9{ 10}; 11void test01() 12{ 13\tSon c; 14} 15 16//类模板继承类模板 ,可以用T2指定父类中的T类型 17template\u0026lt;class T1, class T2\u0026gt; 18class Son2 :public Base\u0026lt;T2\u0026gt; 19{ 20public: 21\tSon2() 22\t{ 23\tcout \u0026lt;\u0026lt; typeid(T1).name() \u0026lt;\u0026lt; endl; 24\tcout \u0026lt;\u0026lt; typeid(T2).name() \u0026lt;\u0026lt; endl; 25\t} 26}; 27 28void test02() 29{ 30\tSon2\u0026lt;int, char\u0026gt; child1; 31} 类模板成员函数 类外实现 1#include \u0026lt;string\u0026gt;2 3//类模板中成员函数类外实现 4template\u0026lt;class T1, class T2\u0026gt; 5class Person { 6public: 7\t//成员函数类内声明 8\tPerson(T1 name, T2 age); 9\tvoid showPerson(); 10 11public: 12\tT1 m_Name; 13\tT2 m_Age; 14}; 15 16//构造函数 类外实现 17template\u0026lt;class T1, class T2\u0026gt; 18Person\u0026lt;T1, T2\u0026gt;::Person(T1 name, T2 age) { 19\tthis-\u0026gt;m_Name = name; 20\tthis-\u0026gt;m_Age = age; 21} 22 23//成员函数 类外实现 24template\u0026lt;class T1, class T2\u0026gt; 25void Person\u0026lt;T1, T2\u0026gt;::showPerson() { 26\tcout \u0026lt;\u0026lt; \u0026#34;姓名: \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;m_Name \u0026lt;\u0026lt; \u0026#34; 年龄:\u0026#34; \u0026lt;\u0026lt; this-\u0026gt;m_Age \u0026lt;\u0026lt; endl; 27} 28 29void test01() 30{ 31\tPerson\u0026lt;string, int\u0026gt; p(\u0026#34;Tom\u0026#34;, 20); 32\tp.showPerson(); 33} 类模板分文件编写 问题：\n 类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到  解决：\n 解决方式1：直接包含.cpp源文件 解决方式2：将声明和实现写到同一个文件中，并更改后缀名为.hpp，hpp是约定的名称，并不是强制  主流的解决方式是第二种，将类模板成员函数写到一起，并将后缀名改为.hpp\nperson.hpp中代码：\n1#pragma once 2#include \u0026lt;iostream\u0026gt;3using namespace std; 4#include \u0026lt;string\u0026gt;5 6template\u0026lt;class T1, class T2\u0026gt; 7class Person { 8public: 9\tPerson(T1 name, T2 age); 10\tvoid showPerson(); 11public: 12\tT1 m_Name; 13\tT2 m_Age; 14}; 15 16//构造函数 类外实现 17template\u0026lt;class T1, class T2\u0026gt; 18Person\u0026lt;T1, T2\u0026gt;::Person(T1 name, T2 age) { 19\tthis-\u0026gt;m_Name = name; 20\tthis-\u0026gt;m_Age = age; 21} 22 23//成员函数 类外实现 24template\u0026lt;class T1, class T2\u0026gt; 25void Person\u0026lt;T1, T2\u0026gt;::showPerson() { 26\tcout \u0026lt;\u0026lt; \u0026#34;姓名: \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;m_Name \u0026lt;\u0026lt; \u0026#34; 年龄:\u0026#34; \u0026lt;\u0026lt; this-\u0026gt;m_Age \u0026lt;\u0026lt; endl; 27} 类模板分文件编写.cpp中代码\n1#include\u0026lt;iostream\u0026gt;2using namespace std; 3 4//#include \u0026#34;person.h\u0026#34; 5#include \u0026#34;person.cpp\u0026#34; //解决方式1，包含cpp源文件6 7//解决方式2，将声明和实现写到一起，文件后缀名改为.hpp 8#include \u0026#34;person.hpp\u0026#34;9void test01() 10{ 11\tPerson\u0026lt;string, int\u0026gt; p(\u0026#34;Tom\u0026#34;, 10); 12\tp.showPerson(); 13} 14 15int main() { 16 17\ttest01(); 18 19\tsystem(\u0026#34;pause\u0026#34;); 20 21\treturn 0; 22} 类模板与友元 全局函数类内实现 - 直接在类内声明友元即可\n全局函数类外实现 - 需要提前让编译器知道全局函数的存在\n建议全局函数做类内实现，用法简单，而且编译器可以直接识别\n1#include \u0026lt;string\u0026gt;2 3//2、全局函数配合友元 类外实现 - 先做函数模板声明，下方在做函数模板定义，在做友元 4template\u0026lt;class T1, class T2\u0026gt; class Person; 5 6//如果声明了函数模板，可以将实现写到后面，否则需要将实现体写到类的前面让编译器提前看到 7//template\u0026lt;class T1, class T2\u0026gt; void printPerson2(Person\u0026lt;T1, T2\u0026gt; \u0026amp; p); 8 9template\u0026lt;class T1, class T2\u0026gt; 10void printPerson2(Person\u0026lt;T1, T2\u0026gt; \u0026amp; p) 11{ 12\tcout \u0026lt;\u0026lt; \u0026#34;类外实现 ---- 姓名： \u0026#34; \u0026lt;\u0026lt; p.m_Name \u0026lt;\u0026lt; \u0026#34; 年龄：\u0026#34; \u0026lt;\u0026lt; p.m_Age \u0026lt;\u0026lt; endl; 13} 14 15template\u0026lt;class T1, class T2\u0026gt; 16class Person 17{ 18\t//1、全局函数配合友元 类内实现 19\tfriend void printPerson(Person\u0026lt;T1, T2\u0026gt; \u0026amp; p) 20\t{ 21\tcout \u0026lt;\u0026lt; \u0026#34;姓名： \u0026#34; \u0026lt;\u0026lt; p.m_Name \u0026lt;\u0026lt; \u0026#34; 年龄：\u0026#34; \u0026lt;\u0026lt; p.m_Age \u0026lt;\u0026lt; endl; 22\t} 23 24 25\t//全局函数配合友元 类外实现 26\tfriend void printPerson2\u0026lt;\u0026gt;(Person\u0026lt;T1, T2\u0026gt; \u0026amp; p); 27 28public: 29 30\tPerson(T1 name, T2 age) 31\t{ 32\tthis-\u0026gt;m_Name = name; 33\tthis-\u0026gt;m_Age = age; 34\t} 35 36 37private: 38\tT1 m_Name; 39\tT2 m_Age; 40 41}; 42 43//1、全局函数在类内实现 44void test01() 45{ 46\tPerson \u0026lt;string, int \u0026gt;p(\u0026#34;Tom\u0026#34;, 20); 47\tprintPerson(p); 48} 49 50 51//2、全局函数在类外实现 52void test02() 53{ 54\tPerson \u0026lt;string, int \u0026gt;p(\u0026#34;Jerry\u0026#34;, 30); 55\tprintPerson2(p); 56} 16.STL初识 STL基本概念  STL(Standard Template Library,标准模板库) STL 从广义上分为: 容器(container) 算法(algorithm) 迭代器(iterator) 容器和算法之间通过迭代器进行无缝连接。 STL 几乎所有的代码都采用了模板类或者模板函数  STL六大组件 STL大体分为六大组件，分别是:容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器\n 容器：各种数据结构，如vector、list、deque、set、map等,用来存放数据。 算法：各种常用的算法，如sort、find、copy、for_each等 迭代器：扮演了容器与算法之间的胶合剂。 仿函数：行为类似函数，可作为算法的某种策略。 适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。 空间配置器：负责空间的配置与管理。  STL中容器、算法、迭代器 **容器：**置物之所也\nSTL容器就是将运用最广泛的一些数据结构实现出来\n常用的数据结构：数组, 链表,树, 栈, 队列, 集合, 映射表 等\n这些容器分为序列式容器和关联式容器两种:\n​\t序列式容器:强调值的排序，序列式容器中的每个元素均有固定的位置。 ​\t关联式容器:二叉树结构，各元素之间没有严格的物理上的顺序关系\n**算法：**问题之解法也\n有限的步骤，解决逻辑或数学上的问题，这一门学科我们叫做算法(Algorithms)\n算法分为:质变算法和非质变算法。\n质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等\n非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等\n**迭代器：**容器和算法之间粘合剂\n提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。\n每个容器都有自己专属的迭代器\n迭代器使用非常类似于指针，初学阶段我们可以先理解迭代器为指针\n迭代器种类：\n   种类 功能 支持运算     输入迭代器 对数据的只读访问 只读，支持++、==、！=   输出迭代器 对数据的只写访问 只写，支持++   前向迭代器 读写操作，并能向前推进迭代器 读写，支持++、==、！=   双向迭代器 读写操作，并能向前和向后操作 读写，支持++、\u0026ndash;，   随机访问迭代器 读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器 读写，支持++、\u0026ndash;、[n]、-n、\u0026lt;、\u0026lt;=、\u0026gt;、\u0026gt;=    常用的容器中迭代器种类为双向迭代器，和随机访问迭代器\n容器算法迭代器初识 vector存放内置数据类型 1#include \u0026lt;vector\u0026gt;2#include \u0026lt;algorithm\u0026gt;3 4void MyPrint(int val) 5{ 6\tcout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; endl; 7} 8 9void test01() { 10 11\t//创建vector容器对象，并且通过模板参数指定容器中存放的数据的类型 12\tvector\u0026lt;int\u0026gt; v; 13\t//向容器中放数据 14\tv.push_back(10); 15\tv.push_back(20); 16\tv.push_back(30); 17\tv.push_back(40); 18 19\t//每一个容器都有自己的迭代器，迭代器是用来遍历容器中的元素 20\t//v.begin()返回迭代器，这个迭代器指向容器中第一个数据 21\t//v.end()返回迭代器，这个迭代器指向容器元素的最后一个元素的下一个位置 22\t//vector\u0026lt;int\u0026gt;::iterator 拿到vector\u0026lt;int\u0026gt;这种容器的迭代器类型 23 24\tvector\u0026lt;int\u0026gt;::iterator pBegin = v.begin(); 25\tvector\u0026lt;int\u0026gt;::iterator pEnd = v.end(); 26 27\t//第一种遍历方式： 28\twhile (pBegin != pEnd) { 29\tcout \u0026lt;\u0026lt; *pBegin \u0026lt;\u0026lt; endl; 30\tpBegin++; 31\t} 32 33\t34\t//第二种遍历方式： 35\tfor (vector\u0026lt;int\u0026gt;::iterator it = v.begin(); it != v.end(); it++) { 36\tcout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl; 37\t} 38\tcout \u0026lt;\u0026lt; endl; 39 40\t//第三种遍历方式： 41\t//使用STL提供标准遍历算法 头文件 algorithm 42\tfor_each(v.begin(), v.end(), MyPrint); 43} Vector存放自定义数据类型 1//存放对象 2void test01() { 3 4\tvector\u0026lt;Person\u0026gt; v; 5 6\t//创建数据 7\tPerson p1(\u0026#34;aaa\u0026#34;, 10); 8\tPerson p2(\u0026#34;bbb\u0026#34;, 20); 9\tPerson p3(\u0026#34;ccc\u0026#34;, 30); 10\tPerson p4(\u0026#34;ddd\u0026#34;, 40); 11\tPerson p5(\u0026#34;eee\u0026#34;, 50); 12 13\tv.push_back(p1); 14\tv.push_back(p2); 15\tv.push_back(p3); 16\tv.push_back(p4); 17\tv.push_back(p5); 18 19\tfor (vector\u0026lt;Person\u0026gt;::iterator it = v.begin(); it != v.end(); it++) { 20\tcout \u0026lt;\u0026lt; \u0026#34;Name:\u0026#34; \u0026lt;\u0026lt; (*it).mName \u0026lt;\u0026lt; \u0026#34; Age:\u0026#34; \u0026lt;\u0026lt; (*it).mAge \u0026lt;\u0026lt; endl; 21 22\t} 23} 24 25 26//放对象指针 27void test02() { 28 29\tvector\u0026lt;Person*\u0026gt; v; 30 31\t//创建数据 32\tPerson p1(\u0026#34;aaa\u0026#34;, 10); 33\tPerson p2(\u0026#34;bbb\u0026#34;, 20); 34\tPerson p3(\u0026#34;ccc\u0026#34;, 30); 35\tPerson p4(\u0026#34;ddd\u0026#34;, 40); 36\tPerson p5(\u0026#34;eee\u0026#34;, 50); 37 38\tv.push_back(\u0026amp;p1); 39\tv.push_back(\u0026amp;p2); 40\tv.push_back(\u0026amp;p3); 41\tv.push_back(\u0026amp;p4); 42\tv.push_back(\u0026amp;p5); 43 44\tfor (vector\u0026lt;Person*\u0026gt;::iterator it = v.begin(); it != v.end(); it++) { 45\tPerson * p = (*it); 46\tcout \u0026lt;\u0026lt; \u0026#34;Name:\u0026#34; \u0026lt;\u0026lt; p-\u0026gt;mName \u0026lt;\u0026lt; \u0026#34; Age:\u0026#34; \u0026lt;\u0026lt; (*it)-\u0026gt;mAge \u0026lt;\u0026lt; endl; 47\t} 48} Vector容器嵌套容器 1#include \u0026lt;vector\u0026gt;2 3//容器嵌套容器 4void test01() { 5 6\tvector\u0026lt; vector\u0026lt;int\u0026gt; \u0026gt; v; 7 8\tvector\u0026lt;int\u0026gt; v1; 9\tvector\u0026lt;int\u0026gt; v2; 10\tvector\u0026lt;int\u0026gt; v3; 11\tvector\u0026lt;int\u0026gt; v4; 12 13\tfor (int i = 0; i \u0026lt; 4; i++) { 14\tv1.push_back(i + 1); 15\tv2.push_back(i + 2); 16\tv3.push_back(i + 3); 17\tv4.push_back(i + 4); 18\t} 19 20\t//将容器元素插入到vector v中 21\tv.push_back(v1); 22\tv.push_back(v2); 23\tv.push_back(v3); 24\tv.push_back(v4); 25 26 27\tfor (vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;::iterator it = v.begin(); it != v.end(); it++) { 28 29\tfor (vector\u0026lt;int\u0026gt;::iterator vit = (*it).begin(); vit != (*it).end(); vit++) { 30\tcout \u0026lt;\u0026lt; *vit \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 31\t} 32\tcout \u0026lt;\u0026lt; endl; 33\t} 34 35} 17.STL- 常用容器 string容器 string基本概念 string 类内部封装了很多成员方法\n例如：查找find，拷贝copy，删除delete 替换replace，插入insert\nstring管理char*所分配的内存，不用担心复制越界和取值越界等，由类内部进行负责\nstring构造函数 构造函数原型：\n string(); //创建一个空的字符串 例如: string str; string(const char* s);\t//使用字符串s初始化 string(const string\u0026amp; str); //使用一个string对象初始化另一个string对象 string(int n, char c); //使用n个字符c初始化  1#include \u0026lt;string\u0026gt;2//string构造 3void test01() 4{ 5\tstring s1; //创建空字符串，调用无参构造函数 6\tcout \u0026lt;\u0026lt; \u0026#34;str1 = \u0026#34; \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; 7 8\tconst char* str = \u0026#34;hello world\u0026#34;; 9\tstring s2(str); //把c_string转换成了string 10 11\tcout \u0026lt;\u0026lt; \u0026#34;str2 = \u0026#34; \u0026lt;\u0026lt; s2 \u0026lt;\u0026lt; endl; 12 13\tstring s3(s2); //调用拷贝构造函数 14\tcout \u0026lt;\u0026lt; \u0026#34;str3 = \u0026#34; \u0026lt;\u0026lt; s3 \u0026lt;\u0026lt; endl; 15 16\tstring s4(10, \u0026#39;a\u0026#39;); 17\tcout \u0026lt;\u0026lt; \u0026#34;str3 = \u0026#34; \u0026lt;\u0026lt; s3 \u0026lt;\u0026lt; endl; 18} string赋值操作  string\u0026amp; operator=(const char* s); //char*类型字符串 赋值给当前的字符串 string\u0026amp; operator=(const string \u0026amp;s); //把字符串s赋给当前的字符串 string\u0026amp; operator=(char c); //字符赋值给当前的字符串 string\u0026amp; assign(const char *s); //把字符串s赋给当前的字符串 string\u0026amp; assign(const char *s, int n); //把字符串s的前n个字符赋给当前的字符串 string\u0026amp; assign(const string \u0026amp;s); //把字符串s赋给当前字符串 string\u0026amp; assign(int n, char c); //用n个字符c赋给当前字符串  1void test01() 2{ 3\tstring str1; 4\tstr1 = \u0026#34;hello world\u0026#34;; 5\tcout \u0026lt;\u0026lt; \u0026#34;str1 = \u0026#34; \u0026lt;\u0026lt; str1 \u0026lt;\u0026lt; endl; 6 7\tstring str2; 8\tstr2 = str1; 9\tcout \u0026lt;\u0026lt; \u0026#34;str2 = \u0026#34; \u0026lt;\u0026lt; str2 \u0026lt;\u0026lt; endl; 10 11\tstring str3; 12\tstr3 = \u0026#39;a\u0026#39;; 13\tcout \u0026lt;\u0026lt; \u0026#34;str3 = \u0026#34; \u0026lt;\u0026lt; str3 \u0026lt;\u0026lt; endl; 14 15\tstring str4; 16\tstr4.assign(\u0026#34;hello c++\u0026#34;); 17\tcout \u0026lt;\u0026lt; \u0026#34;str4 = \u0026#34; \u0026lt;\u0026lt; str4 \u0026lt;\u0026lt; endl; 18 19\tstring str5; 20\tstr5.assign(\u0026#34;hello c++\u0026#34;,5); 21\tcout \u0026lt;\u0026lt; \u0026#34;str5 = \u0026#34; \u0026lt;\u0026lt; str5 \u0026lt;\u0026lt; endl; 22 23 24\tstring str6; 25\tstr6.assign(str5); 26\tcout \u0026lt;\u0026lt; \u0026#34;str6 = \u0026#34; \u0026lt;\u0026lt; str6 \u0026lt;\u0026lt; endl; 27 28\tstring str7; 29\tstr7.assign(5, \u0026#39;x\u0026#39;); 30\tcout \u0026lt;\u0026lt; \u0026#34;str7 = \u0026#34; \u0026lt;\u0026lt; str7 \u0026lt;\u0026lt; endl; 31} 32 string字符串拼接  string\u0026amp; operator+=(const char* str); //重载+=操作符 string\u0026amp; operator+=(const char c); //重载+=操作符 string\u0026amp; operator+=(const string\u0026amp; str); //重载+=操作符 string\u0026amp; append(const char *s);  //把字符串s连接到当前字符串结尾 string\u0026amp; append(const char *s, int n); //把字符串s的前n个字符连接到当前字符串结尾 string\u0026amp; append(const string \u0026amp;s); //同operator+=(const string\u0026amp; str) string\u0026amp; append(const string \u0026amp;s, int pos, int n);//字符串s中从pos开始的n个字符连接到字符串结尾  1void test01() 2{ 3\tstring str1 = \u0026#34;我\u0026#34;; 4 5\tstr1 += \u0026#34;爱玩游戏\u0026#34;; 6 7\tcout \u0026lt;\u0026lt; \u0026#34;str1 = \u0026#34; \u0026lt;\u0026lt; str1 \u0026lt;\u0026lt; endl; 8\t9\tstr1 += \u0026#39;:\u0026#39;; 10 11\tcout \u0026lt;\u0026lt; \u0026#34;str1 = \u0026#34; \u0026lt;\u0026lt; str1 \u0026lt;\u0026lt; endl; 12 13\tstring str2 = \u0026#34;LOL DNF\u0026#34;; 14 15\tstr1 += str2; 16 17\tcout \u0026lt;\u0026lt; \u0026#34;str1 = \u0026#34; \u0026lt;\u0026lt; str1 \u0026lt;\u0026lt; endl; 18 19\tstring str3 = \u0026#34;I\u0026#34;; 20\tstr3.append(\u0026#34; love \u0026#34;); 21\tstr3.append(\u0026#34;game abcde\u0026#34;, 4); 22\t//str3.append(str2); 23\tstr3.append(str2, 4, 3); // 从下标4位置开始 ，截取3个字符，拼接到字符串末尾 24\tcout \u0026lt;\u0026lt; \u0026#34;str3 = \u0026#34; \u0026lt;\u0026lt; str3 \u0026lt;\u0026lt; endl; 25} string查找和替换  int find(const string\u0026amp; str, int pos = 0) const; //查找str第一次出现位置,从pos开始查找 int find(const char* s, int pos = 0) const;  //查找s第一次出现位置,从pos开始查找 int find(const char* s, int pos, int n) const;  //从pos位置查找s的前n个字符第一次位置 int find(const char c, int pos = 0) const;  //查找字符c第一次出现位置 int rfind(const string\u0026amp; str, int pos = npos) const; //查找str最后一次位置,从pos开始查找 int rfind(const char* s, int pos = npos) const; //查找s最后一次出现位置,从pos开始查找 int rfind(const char* s, int pos, int n) const; //从pos查找s的前n个字符最后一次位置 int rfind(const char c, int pos = 0) const;  //查找字符c最后一次出现位置 string\u0026amp; replace(int pos, int n, const string\u0026amp; str);  //替换从pos开始n个字符为字符串str string\u0026amp; replace(int pos, int n,const char* s);  //替换从pos开始的n个字符为字符串s  find找到字符串后返回查找的第一个字符位置，找不到返回-1\n1//查找和替换 2void test01() 3{ 4\t//查找 5\tstring str1 = \u0026#34;abcdefgde\u0026#34;; 6 7\tint pos = str1.find(\u0026#34;de\u0026#34;); 8 9\tif (pos == -1) 10\t{ 11\tcout \u0026lt;\u0026lt; \u0026#34;未找到\u0026#34; \u0026lt;\u0026lt; endl; 12\t} 13\telse 14\t{ 15\tcout \u0026lt;\u0026lt; \u0026#34;pos = \u0026#34; \u0026lt;\u0026lt; pos \u0026lt;\u0026lt; endl; 16\t} 17\t18 19\tpos = str1.rfind(\u0026#34;de\u0026#34;); 20 21\tcout \u0026lt;\u0026lt; \u0026#34;pos = \u0026#34; \u0026lt;\u0026lt; pos \u0026lt;\u0026lt; endl; 22 23} 24 25void test02() 26{ 27\t//替换 28\tstring str1 = \u0026#34;abcdefgde\u0026#34;; 29\tstr1.replace(1, 3, \u0026#34;1111\u0026#34;); 30 31\tcout \u0026lt;\u0026lt; \u0026#34;str1 = \u0026#34; \u0026lt;\u0026lt; str1 \u0026lt;\u0026lt; endl; 32} string字符串比较  字符串比较是按字符的ASCII码进行对比  = 返回 0\n\u0026gt; 返回 1\n\u0026lt; 返回 -1\n int compare(const string \u0026amp;s) const;  //与字符串s比较 int compare(const char *s) const; //与字符串s比较  string字符存取  char\u0026amp; operator[](int n);  //通过[]方式取字符 char\u0026amp; at(int n);  //通过at方法获取字符  1void test01() 2{ 3\tstring str = \u0026#34;hello world\u0026#34;; 4 5\tfor (int i = 0; i \u0026lt; str.size(); i++) 6\t{ 7\tcout \u0026lt;\u0026lt; str[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 8\t} 9\tcout \u0026lt;\u0026lt; endl; 10 11\tfor (int i = 0; i \u0026lt; str.size(); i++) 12\t{ 13\tcout \u0026lt;\u0026lt; str.at(i) \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 14\t} 15\tcout \u0026lt;\u0026lt; endl; 16 17 18\t//字符修改 19\tstr[0] = \u0026#39;x\u0026#39;; 20\tstr.at(1) = \u0026#39;x\u0026#39;; 21\tcout \u0026lt;\u0026lt; str \u0026lt;\u0026lt; endl; 22\t23} string插入和删除  string\u0026amp; insert(int pos, const char* s);  //插入字符串 string\u0026amp; insert(int pos, const string\u0026amp; str);  //插入字符串 string\u0026amp; insert(int pos, int n, char c); //在指定位置插入n个字符c string\u0026amp; erase(int pos, int n = npos); //删除从Pos开始的n个字符  string子串 string substr(int pos = 0, int n = npos) const; //返回由pos开始的n个字符组成的字符串\n1//子串 2void test01() 3{ 4 5\tstring str = \u0026#34;abcdefg\u0026#34;; 6\tstring subStr = str.substr(1, 3); 7\tcout \u0026lt;\u0026lt; \u0026#34;subStr = \u0026#34; \u0026lt;\u0026lt; subStr \u0026lt;\u0026lt; endl; 8 9\tstring email = \u0026#34;hello@sina.com\u0026#34;; 10\tint pos = email.find(\u0026#34;@\u0026#34;); 11\tstring username = email.substr(0, pos); 12\tcout \u0026lt;\u0026lt; \u0026#34;username: \u0026#34; \u0026lt;\u0026lt; username \u0026lt;\u0026lt; endl; 13 14} vector容器 vector基本概念 vector数据结构和数组非常相似，也称为单端数组\nvector可以动态扩展, 并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间\nvector容器的迭代器是支持随机访问的迭代器\nvector构造函数  vector\u0026lt;T\u0026gt; v;  //采用模板实现类实现，默认构造函数 vector(v.begin(), v.end());  //将v[begin(), end())区间中的元素拷贝给本身。 vector(n, elem); //构造函数将n个elem拷贝给本身。 vector(const vector \u0026amp;vec); //拷贝构造函数。  1#include \u0026lt;vector\u0026gt;2 3void printVector(vector\u0026lt;int\u0026gt;\u0026amp; v) { 4 5\tfor (vector\u0026lt;int\u0026gt;::iterator it = v.begin(); it != v.end(); it++) { 6\tcout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 7\t} 8\tcout \u0026lt;\u0026lt; endl; 9} 10 11void test01() 12{ 13\tvector\u0026lt;int\u0026gt; v1; //无参构造 14\tfor (int i = 0; i \u0026lt; 10; i++) 15\t{ 16\tv1.push_back(i); 17\t} 18\tprintVector(v1); 19 20\tvector\u0026lt;int\u0026gt; v2(v1.begin(), v1.end()); 21\tprintVector(v2); 22 23\tvector\u0026lt;int\u0026gt; v3(10, 100); 24\tprintVector(v3); 25\t26\tvector\u0026lt;int\u0026gt; v4(v3); 27\tprintVector(v4); 28} vector赋值操作   vector\u0026amp; operator=(const vector \u0026amp;vec);//重载等号操作符\n  assign(beg, end); //将[beg, end)区间中的数据拷贝赋值给本身。\n  assign(n, elem); //将n个elem拷贝赋值给本身。\n  1#include \u0026lt;vector\u0026gt;2 3void printVector(vector\u0026lt;int\u0026gt;\u0026amp; v) { 4 5\tfor (vector\u0026lt;int\u0026gt;::iterator it = v.begin(); it != v.end(); it++) { 6\tcout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 7\t} 8\tcout \u0026lt;\u0026lt; endl; 9} 10 11//赋值操作 12void test01() 13{ 14\tvector\u0026lt;int\u0026gt; v1; //无参构造 15\tfor (int i = 0; i \u0026lt; 10; i++) 16\t{ 17\tv1.push_back(i); 18\t} 19\tprintVector(v1); 20 21\tvector\u0026lt;int\u0026gt;v2; 22\tv2 = v1; 23\tprintVector(v2); 24 25\tvector\u0026lt;int\u0026gt;v3; 26\tv3.assign(v1.begin(), v1.end()); 27\tprintVector(v3); 28 29\tvector\u0026lt;int\u0026gt;v4; 30\tv4.assign(10, 100); 31\tprintVector(v4); 32} vector容量和大小   empty();  //判断容器是否为空\n  capacity(); //容器的容量\n  size(); //返回容器中元素的个数\n  resize(int num); //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。\n​\t//如果容器变短，则末尾超出容器长度的元素被删除。\n  resize(int num, elem); //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。\n​\t//如果容器变短，则末尾超出容器长度的元素被删除\n  1void test01() 2{ 3\tvector\u0026lt;int\u0026gt; v1; 4\tfor (int i = 0; i \u0026lt; 10; i++) 5\t{ 6\tv1.push_back(i); 7\t} 8\tprintVector(v1); 9\tif (v1.empty()) 10\t{ 11\tcout \u0026lt;\u0026lt; \u0026#34;v1为空\u0026#34; \u0026lt;\u0026lt; endl; 12\t} 13\telse 14\t{ 15\tcout \u0026lt;\u0026lt; \u0026#34;v1不为空\u0026#34; \u0026lt;\u0026lt; endl; 16\tcout \u0026lt;\u0026lt; \u0026#34;v1的容量 = \u0026#34; \u0026lt;\u0026lt; v1.capacity() \u0026lt;\u0026lt; endl; 17\tcout \u0026lt;\u0026lt; \u0026#34;v1的大小 = \u0026#34; \u0026lt;\u0026lt; v1.size() \u0026lt;\u0026lt; endl; 18\t} 19 20\t//resize 重新指定大小 ，若指定的更大，默认用0填充新位置，可以利用重载版本替换默认填充 21\tv1.resize(15,10); 22\tprintVector(v1); 23 24\t//resize 重新指定大小 ，若指定的更小，超出部分元素被删除 25\tv1.resize(5); 26\tprintVector(v1); 27} vector插入和删除  push_back(ele); //尾部插入元素ele pop_back(); //删除最后一个元素 insert(const_iterator pos, ele); //迭代器指向位置pos插入元素ele insert(const_iterator pos, int count,ele);//迭代器指向位置pos插入count个元素ele erase(const_iterator pos); //删除迭代器指向的元素 erase(const_iterator start, const_iterator end);//删除迭代器从start到end之间的元素 clear(); //删除容器中所有元素  1void test01() 2{ 3\tvector\u0026lt;int\u0026gt; v1; 4\t//尾插 5\tv1.push_back(10); 6\tv1.push_back(20); 7\tv1.push_back(30); 8\tv1.push_back(40); 9\tv1.push_back(50); 10\tprintVector(v1); 11\t//尾删 12\tv1.pop_back(); 13\tprintVector(v1); 14\t//插入 15\tv1.insert(v1.begin(), 100); 16\tprintVector(v1); 17 18\tv1.insert(v1.begin(), 2, 1000); 19\tprintVector(v1); 20 21\t//删除 22\tv1.erase(v1.begin()); 23\tprintVector(v1); 24 25\t//清空 26\tv1.erase(v1.begin(), v1.end()); 27\tv1.clear(); 28\tprintVector(v1); 29} vector数据存取  at(int idx);  //返回索引idx所指的数据 operator[];  //返回索引idx所指的数据 front();  //返回容器中第一个数据元素 back(); //返回容器中最后一个数据元素  vector互换容器 swap(vec); // 将vec与本身的元素互换\nswap可以使两个容器互换，可以达到实用的收缩内存效果\n1void test01() 2{ 3\tvector\u0026lt;int\u0026gt;v1; 4\tfor (int i = 0; i \u0026lt; 10; i++) 5\t{ 6\tv1.push_back(i); 7\t} 8\tprintVector(v1); 9 10\tvector\u0026lt;int\u0026gt;v2; 11\tfor (int i = 10; i \u0026gt; 0; i--) 12\t{ 13\tv2.push_back(i); 14\t} 15\tprintVector(v2); 16 17\t//互换容器 18\tcout \u0026lt;\u0026lt; \u0026#34;互换后\u0026#34; \u0026lt;\u0026lt; endl; 19\tv1.swap(v2); 20\tprintVector(v1); 21\tprintVector(v2); 22} 23 24void test02() 25{ 26\tvector\u0026lt;int\u0026gt; v; 27\tfor (int i = 0; i \u0026lt; 100000; i++) { 28\tv.push_back(i); 29\t} 30 31\tcout \u0026lt;\u0026lt; \u0026#34;v的容量为：\u0026#34; \u0026lt;\u0026lt; v.capacity() \u0026lt;\u0026lt; endl; 32\tcout \u0026lt;\u0026lt; \u0026#34;v的大小为：\u0026#34; \u0026lt;\u0026lt; v.size() \u0026lt;\u0026lt; endl; 33 34\tv.resize(3); 35 36\tcout \u0026lt;\u0026lt; \u0026#34;v的容量为：\u0026#34; \u0026lt;\u0026lt; v.capacity() \u0026lt;\u0026lt; endl; 37\tcout \u0026lt;\u0026lt; \u0026#34;v的大小为：\u0026#34; \u0026lt;\u0026lt; v.size() \u0026lt;\u0026lt; endl; 38 39\t//收缩内存 40\tvector\u0026lt;int\u0026gt;(v).swap(v); //匿名对象 41 42\tcout \u0026lt;\u0026lt; \u0026#34;v的容量为：\u0026#34; \u0026lt;\u0026lt; v.capacity() \u0026lt;\u0026lt; endl; 43\tcout \u0026lt;\u0026lt; \u0026#34;v的大小为：\u0026#34; \u0026lt;\u0026lt; v.size() \u0026lt;\u0026lt; endl; 44} vector预留空间 减少vector在动态扩展容量时的扩展次数\nreserve(int len);//容器预留len个元素长度，预留位置不初始化，元素不可访问。\n1void test01() 2{ 3\tvector\u0026lt;int\u0026gt; v; 4 5\t//预留空间 6\tv.reserve(100000); 7 8\tint num = 0; 9\tint* p = NULL; 10\tfor (int i = 0; i \u0026lt; 100000; i++) { 11\tv.push_back(i); 12\tif (p != \u0026amp;v[0]) { 13\tp = \u0026amp;v[0]; 14\tnum++; 15\t} 16\t} 17 18\tcout \u0026lt;\u0026lt; \u0026#34;num:\u0026#34; \u0026lt;\u0026lt; num \u0026lt;\u0026lt; endl; 19} deque容器 deque容器基本概念 双端数组，可以对头端进行插入删除操作\ndeque与vector区别：\n vector对于头部的插入删除效率低，数据量越大，效率越低 deque相对而言，对头部的插入删除速度回比vector快 vector访问元素时的速度会比deque快,这和两者内部实现有关  deque内部工作原理:\ndeque内部有个中控器，维护每段缓冲区中的内容，缓冲区中存放真实数据\n中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间\ndeque构造函数  deque\u0026lt;T\u0026gt; deqT; //默认构造形式 deque(beg, end); //构造函数将[beg, end)区间中的元素拷贝给本身。 deque(n, elem); //构造函数将n个elem拷贝给本身。 deque(const deque \u0026amp;deq); //拷贝构造函数  deque赋值操作   deque\u0026amp; operator=(const deque \u0026amp;deq);  //重载等号操作符\n  assign(beg, end); //将[beg, end)区间中的数据拷贝赋值给本身。\n  assign(n, elem); //将n个elem拷贝赋值给本身。\n  deque大小操作   deque.empty(); //判断容器是否为空\n  deque.size(); //返回容器中元素的个数\n  deque.resize(num); //重新指定容器的长度为num,若容器变长，则以默认值填充新位置。\n​\t//如果容器变短，则末尾超出容器长度的元素被删除。\n  deque.resize(num, elem); //重新指定容器的长度为num,若容器变长，则以elem值填充新位置。\n​ //如果容器变短，则末尾超出容器长度的元素被删除。\n  deque 插入和删除 两端插入操作：\n push_back(elem); //在容器尾部添加一个数据 push_front(elem); //在容器头部插入一个数据 pop_back(); //删除容器最后一个数据 pop_front(); //删除容器第一个数据  指定位置操作：\n  insert(pos,elem); //在pos位置插入一个elem元素的拷贝，返回新数据的位置。\n  insert(pos,n,elem); //在pos位置插入n个elem数据，无返回值。\n  insert(pos,beg,end); //在pos位置插入[beg,end)区间的数据，无返回值。\n  clear(); //清空容器的所有数据\n  erase(beg,end); //删除[beg,end)区间的数据，返回下一个数据的位置。\n  erase(pos); //删除pos位置的数据，返回下一个数据的位置。\n  1void test01() 2{ 3\tdeque\u0026lt;int\u0026gt; d; 4\t//尾插 5\td.push_back(10); 6\td.push_back(20); 7\t//头插 8\td.push_front(100); 9\td.push_front(200); 10 11\tprintDeque(d); 12 13\t//尾删 14\td.pop_back(); 15\t//头删 16\td.pop_front(); 17\tprintDeque(d); 18} 19 20//插入 21void test02() 22{ 23\tdeque\u0026lt;int\u0026gt; d; 24\td.push_back(10); 25\td.push_back(20); 26\td.push_front(100); 27\td.push_front(200); 28\tprintDeque(d); 29 30\td.insert(d.begin(), 1000); 31\tprintDeque(d); 32 33\td.insert(d.begin(), 2,10000); 34\tprintDeque(d); 35 36\tdeque\u0026lt;int\u0026gt;d2; 37\td2.push_back(1); 38\td2.push_back(2); 39\td2.push_back(3); 40 41\td.insert(d.begin(), d2.begin(), d2.end()); 42\tprintDeque(d); 43 44} 45 46//删除 47void test03() 48{ 49\tdeque\u0026lt;int\u0026gt; d; 50\td.push_back(10); 51\td.push_back(20); 52\td.push_front(100); 53\td.push_front(200); 54\tprintDeque(d); 55 56\td.erase(d.begin()); 57\tprintDeque(d); 58 59\td.erase(d.begin(), d.end()); 60\td.clear(); 61\tprintDeque(d); 62} deque 数据存取  at(int idx);  //返回索引idx所指的数据 operator[];  //返回索引idx所指的数据 front();  //返回容器中第一个数据元素 back(); //返回容器中最后一个数据元素  deque 排序 sort(iterator beg, iterator end) //对beg和end区间内元素进行排序\n1void test01() 2{ 3 4\tdeque\u0026lt;int\u0026gt; d; 5\td.push_back(10); 6\td.push_back(20); 7\td.push_front(100); 8\td.push_front(200); 9 10\tprintDeque(d); 11\tsort(d.begin(), d.end()); 12\tprintDeque(d); 13 14} stack容器 stack 基本概念 stack是一种先进后出(First In Last Out,FILO)的数据结构，它只有一个出口\nstack 常用接口 构造函数：\n stack\u0026lt;T\u0026gt; stk; //stack采用模板类实现， stack对象的默认构造形式 stack(const stack \u0026amp;stk); //拷贝构造函数  赋值操作：\n stack\u0026amp; operator=(const stack \u0026amp;stk); //重载等号操作符  数据存取：\n push(elem); //向栈顶添加元素 pop(); //从栈顶移除第一个元素 top();  //返回栈顶元素  大小操作：\n empty(); //判断堆栈是否为空 size();  //返回栈的大小  1#include \u0026lt;stack\u0026gt;2 3//栈容器常用接口 4void test01() 5{ 6\t//创建栈容器 栈容器必须符合先进后出 7\tstack\u0026lt;int\u0026gt; s; 8 9\t//向栈中添加元素，叫做 压栈 入栈 10\ts.push(10); 11\ts.push(20); 12\ts.push(30); 13 14\twhile (!s.empty()) { 15\t//输出栈顶元素 16\tcout \u0026lt;\u0026lt; \u0026#34;栈顶元素为： \u0026#34; \u0026lt;\u0026lt; s.top() \u0026lt;\u0026lt; endl; 17\t//弹出栈顶元素 18\ts.pop(); 19\t} 20\tcout \u0026lt;\u0026lt; \u0026#34;栈的大小为：\u0026#34; \u0026lt;\u0026lt; s.size() \u0026lt;\u0026lt; endl; 21 22} queue 容器 queue 基本概念 Queue是一种先进先出(First In First Out,FIFO)的数据结构，它有两个出口\nqueue 常用接口 构造函数：\n queue\u0026lt;T\u0026gt; que; //queue采用模板类实现，queue对象的默认构造形式 queue(const queue \u0026amp;que); //拷贝构造函数  赋值操作：\n queue\u0026amp; operator=(const queue \u0026amp;que); //重载等号操作符  数据存取：\n push(elem); //往队尾添加元素 pop(); //从队头移除第一个元素 back(); //返回最后一个元素 front();  //返回第一个元素  大小操作：\n empty(); //判断堆栈是否为空 size();  //返回栈的大小  1void test01() { 2 3\t//创建队列 4\tqueue\u0026lt;Person\u0026gt; q; 5 6\t//准备数据 7\tPerson p1(\u0026#34;唐僧\u0026#34;, 30); 8\tPerson p2(\u0026#34;孙悟空\u0026#34;, 1000); 9\tPerson p3(\u0026#34;猪八戒\u0026#34;, 900); 10\tPerson p4(\u0026#34;沙僧\u0026#34;, 800); 11 12\t//向队列中添加元素 入队操作 13\tq.push(p1); 14\tq.push(p2); 15\tq.push(p3); 16\tq.push(p4); 17 18\t//队列不提供迭代器，更不支持随机访问\t19\twhile (!q.empty()) { 20\t//输出队头元素 21\tcout \u0026lt;\u0026lt; \u0026#34;队头元素-- 姓名： \u0026#34; \u0026lt;\u0026lt; q.front().m_Name 22 \u0026lt;\u0026lt; \u0026#34; 年龄： \u0026#34;\u0026lt;\u0026lt; q.front().m_Age \u0026lt;\u0026lt; endl; 23 24\tcout \u0026lt;\u0026lt; \u0026#34;队尾元素-- 姓名： \u0026#34; \u0026lt;\u0026lt; q.back().m_Name 25 \u0026lt;\u0026lt; \u0026#34; 年龄： \u0026#34; \u0026lt;\u0026lt; q.back().m_Age \u0026lt;\u0026lt; endl; 26 27\tcout \u0026lt;\u0026lt; endl; 28\t//弹出队头元素 29\tq.pop(); 30\t} 31 32\tcout \u0026lt;\u0026lt; \u0026#34;队列大小为：\u0026#34; \u0026lt;\u0026lt; q.size() \u0026lt;\u0026lt; endl; 33} list容器 list基本概念 将数据进行链式存储\nSTL中的链表是一个双向循环链表\n由于链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移，属于双向迭代器\nList有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效，这在vector是不成立的。\nlist构造函数  list\u0026lt;T\u0026gt; lst; //list采用采用模板类实现,对象的默认构造形式： list(beg,end); //构造函数将[beg, end)区间中的元素拷贝给本身。 list(n,elem); //构造函数将n个elem拷贝给本身。 list(const list \u0026amp;lst); //拷贝构造函数。  list 赋值和交换  assign(beg, end); //将[beg, end)区间中的数据拷贝赋值给本身。 assign(n, elem); //将n个elem拷贝赋值给本身。 list\u0026amp; operator=(const list \u0026amp;lst); //重载等号操作符 swap(lst); //将lst与本身的元素互换。  list 大小操作   size();  //返回容器中元素的个数\n  empty();  //判断容器是否为空\n  resize(num); //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。\n​\t//如果容器变短，则末尾超出容器长度的元素被删除。\n  resize(num, elem);  //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。\n ​\t//如果容器变短，则末尾超出容器长度的元素被删除。\r   list 插入和删除  push_back(elem);//在容器尾部加入一个元素 pop_back();//删除容器中最后一个元素 push_front(elem);//在容器开头插入一个元素 pop_front();//从容器开头移除第一个元素 insert(pos,elem);//在pos位置插elem元素的拷贝，返回新数据的位置。 insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。 insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。 clear();//移除容器的所有数据 erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。 erase(pos);//删除pos位置的数据，返回下一个数据的位置。 remove(elem);//删除容器中所有与elem值匹配的元素。  list 数据存取  front(); //返回第一个元素。 back(); //返回最后一个元素。  list容器中不可以通过[]或者at方式访问数据\n1//数据存取 2void test01() 3{ 4\tlist\u0026lt;int\u0026gt;L1; 5\tL1.push_back(10); 6\tL1.push_back(20); 7\tL1.push_back(30); 8\tL1.push_back(40); 9 10\t11\t//cout \u0026lt;\u0026lt; L1.at(0) \u0026lt;\u0026lt; endl;//错误 不支持at访问数据 12\t//cout \u0026lt;\u0026lt; L1[0] \u0026lt;\u0026lt; endl; //错误 不支持[]方式访问数据 13\tcout \u0026lt;\u0026lt; \u0026#34;第一个元素为： \u0026#34; \u0026lt;\u0026lt; L1.front() \u0026lt;\u0026lt; endl; 14\tcout \u0026lt;\u0026lt; \u0026#34;最后一个元素为： \u0026#34; \u0026lt;\u0026lt; L1.back() \u0026lt;\u0026lt; endl; 15 16\t//list容器的迭代器是双向迭代器，不支持随机访问 17\tlist\u0026lt;int\u0026gt;::iterator it = L1.begin(); 18\t//it = it + 1;//错误，不可以跳跃访问，即使是+1 19 //区别it++ 20} list 反转和排序  reverse(); //反转链表 sort(); //链表排序  1void printList(const list\u0026lt;int\u0026gt;\u0026amp; L) { 2 3\tfor (list\u0026lt;int\u0026gt;::const_iterator it = L.begin(); it != L.end(); it++) { 4\tcout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 5\t} 6\tcout \u0026lt;\u0026lt; endl; 7} 8 9bool myCompare(int val1 , int val2) 10{ 11\treturn val1 \u0026gt; val2; 12} 13 14//反转和排序 15void test01() 16{ 17\tlist\u0026lt;int\u0026gt; L; 18\tL.push_back(90); 19\tL.push_back(30); 20\tL.push_back(20); 21\tL.push_back(70); 22\tprintList(L); 23 24\t//反转容器的元素 25\tL.reverse(); 26\tprintList(L); 27 28\t//排序 29\tL.sort(); //默认的排序规则 从小到大 30\tprintList(L); 31 32\tL.sort(myCompare); //指定规则，从大到小 33\tprintList(L); 34} set/ multiset 容器 set基本概念  所有元素都会在插入时自动被排序 set/multiset属于关联式容器，底层结构是用二叉树实现。  set和multiset区别：\n set不允许容器中有重复的元素 multiset允许容器中有重复的元素  set构造和赋值 构造：\n set\u0026lt;T\u0026gt; st; //默认构造函数： set(const set \u0026amp;st); //拷贝构造函数  赋值：\n set\u0026amp; operator=(const set \u0026amp;st); //重载等号操作符  1void test01() 2{ 3\tset\u0026lt;int\u0026gt; s1; 4 5\ts1.insert(10); 6\ts1.insert(30); 7\ts1.insert(20); 8\ts1.insert(40); 9\tprintSet(s1); 10 11\t//拷贝构造 12\tset\u0026lt;int\u0026gt;s2(s1); 13\tprintSet(s2); 14 15\t//赋值 16\tset\u0026lt;int\u0026gt;s3; 17\ts3 = s2; 18\tprintSet(s3); 19} set大小和交换  size(); //返回容器中元素的数目 empty(); //判断容器是否为空 swap(st); //交换两个集合容器  1void test01() 2{ 3 4\tset\u0026lt;int\u0026gt; s1; 5\t6\ts1.insert(10); 7\ts1.insert(30); 8\ts1.insert(20); 9\ts1.insert(40); 10 11\tif (s1.empty()) 12\t{ 13\tcout \u0026lt;\u0026lt; \u0026#34;s1为空\u0026#34; \u0026lt;\u0026lt; endl; 14\t} 15\telse 16\t{ 17\tcout \u0026lt;\u0026lt; \u0026#34;s1不为空\u0026#34; \u0026lt;\u0026lt; endl; 18\tcout \u0026lt;\u0026lt; \u0026#34;s1的大小为： \u0026#34; \u0026lt;\u0026lt; s1.size() \u0026lt;\u0026lt; endl; 19\t} 20 21} 22 23//交换 24void test02() 25{ 26\tset\u0026lt;int\u0026gt; s1; 27 28\ts1.insert(10); 29\ts1.insert(30); 30\ts1.insert(20); 31\ts1.insert(40); 32 33\tset\u0026lt;int\u0026gt; s2; 34 35\ts2.insert(100); 36\ts2.insert(300); 37\ts2.insert(200); 38\ts2.insert(400); 39 40\tcout \u0026lt;\u0026lt; \u0026#34;交换前\u0026#34; \u0026lt;\u0026lt; endl; 41\tprintSet(s1); 42\tprintSet(s2); 43\tcout \u0026lt;\u0026lt; endl; 44 45\tcout \u0026lt;\u0026lt; \u0026#34;交换后\u0026#34; \u0026lt;\u0026lt; endl; 46\ts1.swap(s2); 47\tprintSet(s1); 48\tprintSet(s2); 49} set插入和删除  insert(elem); //在容器中插入元素。 clear(); //清除所有元素 erase(pos); //删除pos迭代器所指的元素，返回下一个元素的迭代器。 erase(beg, end); //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。 erase(elem); //删除容器中值为elem的元素。  1void test01() 2{ 3\tset\u0026lt;int\u0026gt; s1; 4\t//插入 5\ts1.insert(10); 6\ts1.insert(30); 7\ts1.insert(20); 8\ts1.insert(40); 9\tprintSet(s1); 10 11\t//删除 12\ts1.erase(s1.begin()); 13\tprintSet(s1); 14 15\ts1.erase(30); 16\tprintSet(s1); 17 18\t//清空 19\t//s1.erase(s1.begin(), s1.end()); 20\ts1.clear(); 21\tprintSet(s1); 22} set查找和统计  find(key); //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end(); count(key); //统计key的元素个数  1void test01() 2{ 3\tset\u0026lt;int\u0026gt; s1; 4\t//插入 5\ts1.insert(10); 6\ts1.insert(30); 7\ts1.insert(20); 8\ts1.insert(40); 9\t10\t//查找 11\tset\u0026lt;int\u0026gt;::iterator pos = s1.find(30); 12 13\tif (pos != s1.end()) 14\t{ 15\tcout \u0026lt;\u0026lt; \u0026#34;找到了元素 ： \u0026#34; \u0026lt;\u0026lt; *pos \u0026lt;\u0026lt; endl; 16\t} 17\telse 18\t{ 19\tcout \u0026lt;\u0026lt; \u0026#34;未找到元素\u0026#34; \u0026lt;\u0026lt; endl; 20\t} 21 22\t//统计 23\tint num = s1.count(30); 24\tcout \u0026lt;\u0026lt; \u0026#34;num = \u0026#34; \u0026lt;\u0026lt; num \u0026lt;\u0026lt; endl; 25} set和multiset区别  set不可以插入重复数据，而multiset可以 set插入数据的同时会返回插入结果，表示插入是否成功 multiset不会检测数据，因此可以插入重复数据  1void test01() 2{ 3\tset\u0026lt;int\u0026gt; s; 4\tpair\u0026lt;set\u0026lt;int\u0026gt;::iterator, bool\u0026gt; ret = s.insert(10); 5\tif (ret.second) { 6\tcout \u0026lt;\u0026lt; \u0026#34;第一次插入成功!\u0026#34; \u0026lt;\u0026lt; endl; 7\t} 8\telse { 9\tcout \u0026lt;\u0026lt; \u0026#34;第一次插入失败!\u0026#34; \u0026lt;\u0026lt; endl; 10\t} 11 12\tret = s.insert(10); 13\tif (ret.second) { 14\tcout \u0026lt;\u0026lt; \u0026#34;第二次插入成功!\u0026#34; \u0026lt;\u0026lt; endl; 15\t} 16\telse { 17\tcout \u0026lt;\u0026lt; \u0026#34;第二次插入失败!\u0026#34; \u0026lt;\u0026lt; endl; 18\t} 19 20\t//multiset 21\tmultiset\u0026lt;int\u0026gt; ms; 22\tms.insert(10); 23\tms.insert(10); 24 25\tfor (multiset\u0026lt;int\u0026gt;::iterator it = ms.begin(); it != ms.end(); it++) { 26\tcout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 27\t} 28\tcout \u0026lt;\u0026lt; endl; 29} pair对组创建 成对出现的数据，利用对组可以返回两个数据\n pair\u0026lt;type, type\u0026gt; p ( value1, value2 ); pair\u0026lt;type, type\u0026gt; p = make_pair( value1, value2 );  1void test01() 2{ 3\tpair\u0026lt;string, int\u0026gt; p(string(\u0026#34;Tom\u0026#34;), 20); 4\tcout \u0026lt;\u0026lt; \u0026#34;姓名： \u0026#34; \u0026lt;\u0026lt; p.first \u0026lt;\u0026lt; \u0026#34; 年龄： \u0026#34; \u0026lt;\u0026lt; p.second \u0026lt;\u0026lt; endl; 5 6\tpair\u0026lt;string, int\u0026gt; p2 = make_pair(\u0026#34;Jerry\u0026#34;, 10); 7\tcout \u0026lt;\u0026lt; \u0026#34;姓名： \u0026#34; \u0026lt;\u0026lt; p2.first \u0026lt;\u0026lt; \u0026#34; 年龄： \u0026#34; \u0026lt;\u0026lt; p2.second \u0026lt;\u0026lt; endl; 8} set容器排序 set容器默认排序规则为从小到大，利用仿函数，可以改变排序规则\n对于自定义数据类型，set必须指定排序规则才可以插入数据\n1class MyCompare 2{ 3public: 4\tbool operator()(int v1, int v2) { 5\treturn v1 \u0026gt; v2; 6\t} 7}; 8void test01() 9{ 10\tset\u0026lt;int\u0026gt; s1; 11\ts1.insert(10); 12\ts1.insert(40); 13\ts1.insert(20); 14\ts1.insert(30); 15\ts1.insert(50); 16 17\t//默认从小到大 18\tfor (set\u0026lt;int\u0026gt;::iterator it = s1.begin(); it != s1.end(); it++) { 19\tcout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 20\t} 21\tcout \u0026lt;\u0026lt; endl; 22 23\t//指定排序规则 24\tset\u0026lt;int,MyCompare\u0026gt; s2; 25\ts2.insert(10); 26\ts2.insert(40); 27\ts2.insert(20); 28\ts2.insert(30); 29\ts2.insert(50); 30 31\tfor (set\u0026lt;int, MyCompare\u0026gt;::iterator it = s2.begin(); it != s2.end(); it++) { 32\tcout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 33\t} 34\tcout \u0026lt;\u0026lt; endl; 35} 1class Person 2{ 3public: 4\tPerson(string name, int age) 5\t{ 6\tthis-\u0026gt;m_Name = name; 7\tthis-\u0026gt;m_Age = age; 8\t} 9 10\tstring m_Name; 11\tint m_Age; 12 13}; 14class comparePerson 15{ 16public: 17\tbool operator()(const Person\u0026amp; p1, const Person \u0026amp;p2) 18\t{ 19\t//按照年龄进行排序 降序 20\treturn p1.m_Age \u0026gt; p2.m_Age; 21\t} 22}; 23 24void test01() 25{ 26\tset\u0026lt;Person, comparePerson\u0026gt; s; 27 28\tPerson p1(\u0026#34;刘备\u0026#34;, 23); 29\tPerson p2(\u0026#34;关羽\u0026#34;, 27); 30\tPerson p3(\u0026#34;张飞\u0026#34;, 25); 31\tPerson p4(\u0026#34;赵云\u0026#34;, 21); 32 33\ts.insert(p1); 34\ts.insert(p2); 35\ts.insert(p3); 36\ts.insert(p4); 37 38\tfor (set\u0026lt;Person, comparePerson\u0026gt;::iterator it = s.begin(); it != s.end(); it++) 39\t{ 40\tcout \u0026lt;\u0026lt; \u0026#34;姓名： \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;m_Name \u0026lt;\u0026lt; \u0026#34; 年龄： \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;m_Age \u0026lt;\u0026lt; endl; 41\t} 42} map/ multimap容器 map基本概念  map中所有元素都是pair pair中第一个元素为key（键值），起到索引作用，第二个元素为value（实值） 所有元素都会根据元素的键值自动排序 map/multimap属于关联式容器，底层结构是用二叉树实现。  map和multimap区别：\n map不允许容器中有重复key值元素 multimap允许容器中有重复key值元素  map构造和赋值 构造：\n map\u0026lt;T1, T2\u0026gt; mp; //map默认构造函数: map(const map \u0026amp;mp); //拷贝构造函数  赋值：\n map\u0026amp; operator=(const map \u0026amp;mp); //重载等号操作符  1void printMap(map\u0026lt;int,int\u0026gt;\u0026amp;m) 2{ 3\tfor (map\u0026lt;int, int\u0026gt;::iterator it = m.begin(); it != m.end(); it++) 4\t{ 5\tcout \u0026lt;\u0026lt; \u0026#34;key = \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;first \u0026lt;\u0026lt; \u0026#34; value = \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; endl; 6\t} 7\tcout \u0026lt;\u0026lt; endl; 8} 9 10void test01() 11{ 12\tmap\u0026lt;int,int\u0026gt;m; //默认构造 13\tm.insert(pair\u0026lt;int, int\u0026gt;(1, 10)); 14\tm.insert(pair\u0026lt;int, int\u0026gt;(2, 20)); 15\tm.insert(pair\u0026lt;int, int\u0026gt;(3, 30)); 16\tprintMap(m); 17 18\tmap\u0026lt;int, int\u0026gt;m2(m); //拷贝构造 19\tprintMap(m2); 20 21\tmap\u0026lt;int, int\u0026gt;m3; 22\tm3 = m2; //赋值 23\tprintMap(m3); 24} map大小和交换  size(); //返回容器中元素的数目 empty(); //判断容器是否为空 swap(st); //交换两个集合容器  map插入和删除  insert(elem); //在容器中插入元素。 clear(); //清除所有元素 erase(pos); //删除pos迭代器所指的元素，返回下一个元素的迭代器。 erase(beg, end); //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。 erase(key); //删除容器中值为key的元素。  1void test01() 2{ 3\t//插入 4\tmap\u0026lt;int, int\u0026gt; m; 5\t//第一种插入方式 6\tm.insert(pair\u0026lt;int, int\u0026gt;(1, 10)); 7\t//第二种插入方式 8\tm.insert(make_pair(2, 20)); 9\t//第三种插入方式 10\tm.insert(map\u0026lt;int, int\u0026gt;::value_type(3, 30)); 11\t//第四种插入方式 12\tm[4] = 40; 13\tprintMap(m); 14 15\t//删除 16\tm.erase(m.begin()); 17\tprintMap(m); 18 19\tm.erase(3); 20\tprintMap(m); 21 22\t//清空 23\tm.erase(m.begin(),m.end()); 24\tm.clear(); 25\tprintMap(m); 26} map查找和统计  find(key); //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end(); count(key); //统计key的元素个数  1void test01() 2{ 3\tmap\u0026lt;int, int\u0026gt;m; 4\tm.insert(pair\u0026lt;int, int\u0026gt;(1, 10)); 5\tm.insert(pair\u0026lt;int, int\u0026gt;(2, 20)); 6\tm.insert(pair\u0026lt;int, int\u0026gt;(3, 30)); 7 8\t//查找 9\tmap\u0026lt;int, int\u0026gt;::iterator pos = m.find(3); 10 11\tif (pos != m.end()) 12\t{ 13\tcout \u0026lt;\u0026lt; \u0026#34;找到了元素 key = \u0026#34; \u0026lt;\u0026lt; (*pos).first \u0026lt;\u0026lt; \u0026#34; value = \u0026#34; \u0026lt;\u0026lt; (*pos).second \u0026lt;\u0026lt; endl; 14\t} 15\telse 16\t{ 17\tcout \u0026lt;\u0026lt; \u0026#34;未找到元素\u0026#34; \u0026lt;\u0026lt; endl; 18\t} 19 20\t//统计 21\tint num = m.count(3); 22\tcout \u0026lt;\u0026lt; \u0026#34;num = \u0026#34; \u0026lt;\u0026lt; num \u0026lt;\u0026lt; endl; 23} map容器排序 map容器默认排序规则为 按照key值进行 从小到大排序，利用仿函数，可以改变排序规则\n1#include \u0026lt;map\u0026gt;2 3class MyCompare { 4public: 5\tbool operator()(int v1, int v2) { 6\treturn v1 \u0026gt; v2; 7\t} 8}; 9 10void test01() 11{ 12\t//默认从小到大排序 13\t//利用仿函数实现从大到小排序 14\tmap\u0026lt;int, int, MyCompare\u0026gt; m; 15 16\tm.insert(make_pair(1, 10)); 17\tm.insert(make_pair(2, 20)); 18\tm.insert(make_pair(3, 30)); 19\tm.insert(make_pair(4, 40)); 20\tm.insert(make_pair(5, 50)); 21 22\tfor (map\u0026lt;int, int, MyCompare\u0026gt;::iterator it = m.begin(); it != m.end(); it++) { 23\tcout \u0026lt;\u0026lt; \u0026#34;key:\u0026#34; \u0026lt;\u0026lt; it-\u0026gt;first \u0026lt;\u0026lt; \u0026#34; value:\u0026#34; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; endl; 24\t} 25} 18.STL- 函数对象 函数对象 函数对象概念","date":"2024-10-28","permalink":"/posts/tech/cpp-1-basic/","series":["Cpp"],"tags":["","",""],"title":"C++基础查漏补缺"},{"categories":["计算机"],"content":"黑马的视频文档特别清楚, 这里我只是安装自己的话语总结一下.\nRedis 1.什么是缓存穿透？怎么解决？ 缓存穿透是指查询一个一定不存在的数据，由于存储层查不到数据因此不写入缓存，这将导致这个不存在的数据每次请求都要到 DB 去查询，可能导致 DB 挂掉。这种情况大概率是遭到了攻击。解决方案的话，我们通常都会用布隆过滤器来解决它。\n2.你能介绍一下布隆过滤器吗？ 布隆过滤器主要是用于检索一个元素是否在一个集合中。我们当时使用的是Redisson实现的布隆过滤器。它的底层原理是，先初始化一个比较大的数组，里面存放的是二进制0或1。一开始都是0，当一个key来了之后，经过3次hash计算，模数组长度找到数据的下标，然后把数组中原来的0改为1。这样，三个数组的位置就能标明一个key的存在。查找的过程也是一样的。当然，布隆过滤器有可能会产生一定的误判，我们一般可以设置这个误判率，大概不会超过5%。其实这个误判是必然存在的，要不就得增加数组的长度。5%以内的误判率一般的项目也能接受，不至于高并发下压倒数据库。\n3.什么是缓存击穿？怎么解决？ 缓存击穿的意思是，对于设置了过期时间的key，缓存在某个时间点过期的时候，恰好这个时间点对这个Key有大量的并发请求过来。这些请求发现缓存过期，一般都会从后端 DB 加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把 DB 压垮。\n解决方案有两种方式：第一，可以使用互斥锁：当缓存失效时，不立即去load db，先使用如 Redis 的 SETNX 去设置一个互斥锁。当操作成功返回时，再进行 load db的操作并回设缓存，否则重试get缓存的方法。第二种方案是设置当前key逻辑过期，大概思路如下：1) 在设置key的时候，设置一个过期时间字段一块存入缓存中，不给当前key设置过期时间；2) 当查询的时候，从redis取出数据后判断时间是否过期；3) 如果过期，则开通另外一个线程进行数据同步，当前线程正常返回数据，这个数据可能不是最新的。\n当然，两种方案各有利弊：如果选择数据的强一致性，建议使用分布式锁的方案，但性能上可能没那么高，且有可能产生死锁的问题。如果选择key的逻辑删除，则优先考虑高可用性，性能比较高，但数据同步这块做不到强一致。\n4.什么是缓存雪崩？怎么解决？ 缓存雪崩意思是，设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过重而雪崩。与缓存击穿的区别是：雪崩是很多key，而击穿是某一个key缓存。\n解决方案主要是，可以将缓存失效时间分散开。比如，可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机。这样，每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。\n5.redis做为缓存，mysql的数据如何与redis进行同步呢？（双写一致性） 我最近做的这个项目，里面有xxxx（根据自己的简历上写）的功能，需要让数据库与redis高度保持一致，因为要求时效性比较高。\n我们当时采用的读写锁保证的强一致性。我们使用的是Redisson实现的读写锁。在读的时候添加共享锁，可以保证读读不互斥、读写互斥。当我们更新数据的时候，添加排他锁。它是读写、读读都互斥，这样就能保证在写数据的同时，是不会让其他线程读数据的，避免了脏数据。这里面需要注意的是，读方法和写方法上需要使用同一把锁才行。\n数据同步可以有一定的延时（这符合大部分业务需求）。我们当时采用的阿里的Canal组件实现数据同步：不需要更改业务代码，只需部署一个Canal服务。Canal服务把自己伪装成mysql的一个从节点。当mysql数据更新以后，Canal会读取binlog数据，然后再通过Canal的客户端获取到数据，并更新缓存即可。\n6. 那这个排他锁是如何保证读写、读读互斥的呢？ 其实排他锁底层使用的也是SETNX，它保证了同时只能有一个线程操作锁住的方法。\n7. 你听说过延时双删吗？为什么不用它呢？ 延迟双删，如果是写操作，我们先把缓存中的数据删除，然后更新数据库，最后再延时删除缓存中的数据。其中，这个延时多久不太好确定。在延时的过程中，可能会出现脏数据，并不能保证强一致性，所以没有采用它。\n8.redis做为缓存，数据的持久化是怎么做的？这两种持久化方式有什么区别呢？ 在Redis中提供了两种数据持久化的方式：1) RDB；2) AOF。\nRDB是一个快照文件。它是把redis内存存储的数据写到磁盘上。当redis实例宕机恢复数据的时候，可以从RDB的快照文件中恢复数据。AOF的含义是追加文件。当redis执行写命令的时候，都会存储到这个文件中。当redis实例宕机恢复数据的时候，会从这个文件中再次执行一遍命令来恢复数据。\n9.这两种方式，哪种恢复的比较快呢？ RDB因为是二进制文件，保存时体积也比较小，所以它恢复得比较快。但它有可能会丢数据。我们通常在项目中也会使用AOF来恢复数据。虽然AOF恢复的速度慢一些，但它丢数据的风险要小很多。在AOF文件中可以设置刷盘策略。我们当时设置的就是每秒批量写入一次命令。\n10.Redis的数据过期策略有哪些？ 在redis中提供了两种数据过期删除策略。第一种是惰性删除。在设置该key过期时间后，我们不去管它。当需要该key时，我们检查其是否过期。如果过期，我们就删掉它；反之，返回该key。第二种是定期删除。就是说，每隔一段时间，我们就对一些key进行检查，并删除里面过期的key。定期清理的两种模式是：1) SLOW模式，是定时任务，执行频率默认为10hz，每次不超过25ms，可以通过修改配置文件redis.conf的hz选项来调整这个次数；2) FAST模式，执行频率不固定，每次事件循环会尝试执行，但两次间隔不低于2ms，每次耗时不超过1ms。Redis的过期删除策略是：惰性删除 + 定期删除两种策略配合使用。\n11.Redis的数据淘汰策略有哪些？ 这个在redis中提供了很多种，默认是noeviction，不删除任何数据，内部不足时直接报错。这个可以在redis的配置文件中进行设置。里面有两个非常重要的概念：一个是LRU，另外一个是LFU。LRU的意思就是最少最近使用。它会用当前时间减去最后一次访问时间。这个值越大，则淘汰优先级越高。LFU的意思是最少频率使用。它会统计每个key的访问频率。值越小，淘汰优先级越高。我们在项目中设置的是allkeys-lru，它会挑选最近最少使用的数据进行淘汰，把一些经常访问的key留在redis中。\n12.数据库有1000万数据，Redis只能缓存20w数据。如何保证Redis中的数据都是热点数据？ 可以使用allkeys-lru（挑选最近最少使用的数据淘汰）淘汰策略。那留下来的都是经常访问的热点数据。\n13.Redis的内存用完了会发生什么？ 这个要看redis的数据淘汰策略是什么。如果是默认的配置，redis内存用完以后则直接报错。我们当时设置的是allkeys-lru策略，把最近最常访问的数据留在缓存中。\n14.Redis分布式锁如何实现？ 在redis中提供了一个命令SETNX(SET if not exists)。由于redis是单线程的，用了这个命令之后，只能有一个客户端对某一个key设置值。在没有过期或删除key的时候，其他客户端是不能设置这个key的。\n15.那你如何控制Redis实现分布式锁的有效时长呢？ redis的SETNX指令不好控制这个问题。我们当时采用的是redis的一个框架Redisson实现的。在Redisson中需要手动加锁，并且可以控制锁的失效时间和等待时间。当锁住的一个业务还没有执行完成的时候，Redisson会引入一个看门狗机制。就是说，每隔一段时间就检查当前业务是否还持有锁。如果持有，就增加加锁的持有时间。当业务执行完成之后，需要使用释放锁就可以了。还有一个好处就是，在高并发下，一个业务有可能会执行很快。客户1持有锁的时候，客户2来了以后并不会马上被拒绝。它会自旋不断尝试获取锁。如果客户1释放之后，客户2就可以马上持有锁，性能也得到了提升。\n16.Redisson实现的分布式锁是可重入的吗？ 是可以重入的。这样做是为了避免死锁的产生。这个重入其实在内部就是判断是否是当前线程持有的锁，如果是当前线程持有的锁就会计数，如果释放锁就会在计数上减一。在存储数据的时候采用的hash结构，大key可以按照自己的业务进行定制，其中小key是当前线程的唯一标识，value是当前线程重入的次数。\n17.Redisson实现的分布式锁能解决主从一致性的问题吗？ 这个是不能的。比如，当线程1加锁成功后，master节点数据会异步复制到slave节点，此时如果当前持有Redis锁的master节点宕机，slave节点被提升为新的master节点，假如现在来了一个线程2，再次加锁，会在新的master节点上加锁成功，这个时候就会出现两个节点同时持有一把锁的问题。\n我们可以利用Redisson提供的红锁来解决这个问题，它的主要作用是，不能只在一个Redis实例上创建锁，应该是在多个Redis实例上创建锁，并且要求在大多数Redis节点上都成功创建锁，红锁中要求是Redis的节点数量要过半。这样就能避免线程1加锁成功后master节点宕机导致线程2成功加锁到新的master节点上的问题了。\n但是，如果使用了红锁，因为需要同时在多个节点上都添加锁，性能就变得非常低，并且运维维护成本也非常高，所以，我们一般在项目中也不会直接使用红锁，并且官方也暂时废弃了这个红锁。\n18.如果业务非要保证数据的强一致性，这个该怎么解决呢？ Redis本身就是支持高可用的，要做到强一致性，就非常影响性能，所以，如果有强一致性要求高的业务，建议使用ZooKeeper实现的分布式锁，它是可以保证强一致性的。\n19. Redis集群有哪些方案，知道吗？ 在Redis中提供的集群方案总共有三种：主从复制、哨兵模式、Redis分片集群。\n20.介绍一下主从同步 单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，可以搭建主从集群，实现读写分离。一般都是一主多从，主节点负责写数据，从节点负责读数据，主节点写入数据之后，需要把数据同步到从节点中。\n21.能说一下，主从同步数据的流程吗？ 主从同步分为了两个阶段，一个是全量同步，一个是增量同步。\n全量同步是指从节点第一次与主节点建立连接的时候使用全量同步，流程是这样的：\n第一：从节点请求主节点同步数据，其中从节点会携带自己的replication id和offset偏移量。\n第二：主节点判断是否是第一次请求，主要判断的依据就是，主节点与从节点是否是同一个replication id，如果不是，就说明是第一次同步，那主节点就会把自己的replication id和offset发送给从节点，让从节点与主节点的信息保持一致。\n第三：在同时主节点会执行BGSAVE，生成RDB文件后，发送给从节点去执行，从节点先把自己的数据清空，然后执行主节点发送过来的RDB文件，这样就保持了一致。\n当然，如果在RDB生成执行期间，依然有请求到了主节点，而主节点会以命令的方式记录到缓冲区，缓冲区是一个日志文件，最后把这个日志文件发送给从节点，这样就能保证主节点与从节点完全一致了，后期再同步数据的时候，都是依赖于这个日志文件，这个就是全量同步。\n增量同步指的是，当从节点服务重启之后，数据就不一致了，所以这个时候，从节点会请求主节点同步数据，主节点还是判断不是第一次请求，不是第一次就获取从节点的offset值，然后主节点从命令日志中获取offset值之后的数据，发送给从节点进行数据同步。\n22.怎么保证Redis的高并发高可用？ 首先可以搭建主从集群，再加上使用Redis中的哨兵模式，哨兵模式可以实现主从集群的自动故障恢复，里面就包含了对主从服务的监控、自动故障恢复、通知；如果master故障，Sentinel会将一个slave提升为master。当故障实例恢复后也以新的master为主；同时Sentinel也充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给Redis的客户端，所以一般项目都会采用哨兵的模式来保证Redis的高并发高可用。\n23.你们使用Redis是单点还是集群，哪种集群？ 我们当时使用的是主从（1主1从）加哨兵。一般单节点不超过10G内存，如果Redis内存不足则可以给不同服务分配独立的Redis主从节点。尽量不做分片集群。因为集群维护起来比较麻烦，并且集群之间的心跳检测和数据通信会消耗大量的网络带宽，也没有办法使用Lua脚本和事务。\n24.Redis集群脑裂，该怎么解决呢？ 这个在项目中很少见，不过脑裂的问题是这样的，我们现在用的是Redis的哨兵模式集群的。\n有的时候由于网络等原因可能会出现脑裂的情况，就是说，由于Redis master节点和Redis slave节点和Sentinel处于不同的网络分区，使得Sentinel没有能够心跳感知到master，所以通过选举的方式提升了一个slave为master，这样就存在了两个master，就像大脑分裂了一样，这样会导致客户端还在old master那里写入数据，新节点无法同步数据，当网络恢复后，Sentinel会将old master降为slave，这时再从新master同步数据，这会导致old master中的大量数据丢失。\n关于解决的话，我记得在Redis的配置中可以设置：第一可以设置最少的slave节点个数，比如设置至少要有一个从节点才能同步数据，第二个可以设置主从数据复制和同步的延迟时间，达不到要求就拒绝请求，就可以避免大量的数据丢失。\n25.Redis的分片集群有什么作用？ 分片集群主要解决的是海量数据存储的问题，集群中有多个master，每个master保存不同数据，并且还可以给每个master设置多个slave节点，就可以继续增大集群的高并发能力。同时每个master之间通过ping监测彼此健康状态，就类似于哨兵模式了。当客户端请求可以访问集群任意节点，最终都会被转发到正确节点。\n26.Redis分片集群中数据是怎么存储和读取的？ Redis 集群引入了哈希槽的概念，有 16384 个哈希槽，集群中每个主节点绑定了一定范围的哈希槽范围，key通过CRC16校验后对16384取模来决定放置哪个槽，通过槽找到对应的节点进行存储。取值的逻辑是一样的。\n27.Redis是单线程的，但是为什么还那么快？ 这个有几个原因吧~~~\n  完全基于内存的，C语言编写。\n  采用单线程，避免不必要的上下文切换和竞争条件。\n  使用多路I/O复用模型，非阻塞IO。\n  例如：BGSAVE和BGREWRITEAOF都是在后台执行操作，不影响主线程的正常使用，不会产生阻塞。\n28.能解释一下I/O多路复用模型？ I/O多路复用是指利用单个线程来同时监听多个Socket，并且在某个Socket可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。目前的I/O多路复用都是采用的epoll模式实现，它会在通知用户进程Socket就绪的同时，把已就绪的Socket写入用户空间，不需要挨个遍历Socket来判断是否就绪，提升了性能。\n其中Redis的网络模型就是使用I/O多路复用结合事件的处理器来应对多个Socket请求，比如，提供了连接应答处理器、命令回复处理器，命令请求处理器；\n在Redis6.0之后，为了提升更好的性能，在命令回复处理器使用了多线程来处理回复事件，在命令请求处理器中，将命令的转换使用了多线程，增加命令转换速度，在命令执行的时候，依然是单线程\nMySQL 1.MySQL中，如何定位慢查询？ 系统部署了运维监控系统Skywalking，在它的报表展示中可以看到哪个接口慢，并且能分析出接口中哪部分耗时较多，包括具体的SQL执行时间，这样就能定位到出现问题的SQL。\n如果没有这种监控系统，MySQL本身也提供了慢查询日志功能。可以在MySQL的系统配置文件中开启慢查询日志，并设置SQL执行时间超过多少就记录到日志文件，比如我们之前项目设置的是2秒，超过这个时间的SQL就会记录在日志文件中，我们就可以在那里找到执行慢的SQL。\n2.那这个SQL语句执行很慢，如何分析呢？ 如果一条SQL执行很慢，我们通常会使用MySQL的EXPLAIN命令来分析这条SQL的执行情况。通过key和key_len可以检查是否命中了索引，如果已经添加了索引，也可以判断索引是否有效。通过type字段可以查看SQL是否有优化空间，比如是否存在全索引扫描或全表扫描。通过extra建议可以判断是否出现回表情况，如果出现，可以尝试添加索引或修改返回字段来优化。\n3.了解过索引吗？（什么是索引） 索引在项目中非常常见，它是一种帮助MySQL高效获取数据的数据结构，主要用来提高数据检索效率，降低数据库的I/O成本。同时，索引列可以对数据进行排序，降低数据排序的成本，也能减少CPU的消耗。\n4.索引的底层数据结构了解过吗？ MySQL的默认存储引擎InnoDB使用的是B+树作为索引的存储结构。选择B+树的原因包括：节点可以有更多子节点，路径更短；磁盘读写代价更低，非叶子节点只存储键值和指针，叶子节点存储数据；B+树适合范围查询和扫描，因为叶子节点形成了一个双向链表。\n5.B树和B+树的区别是什么呢？   B树的非叶子节点和叶子节点都存放数据，而B+树的所有数据只出现在叶子节点，这使得B+树在查询时效率更稳定。\n  B+树在进行范围查询时效率更高，因为所有数据都在叶子节点，并且叶子节点之间形成了双向链表。\n  6.什么是聚簇索引什么是非聚簇索引？ 聚簇索引是指数据与索引放在一起，B+树的叶子节点保存了整行数据，通常只有一个聚簇索引，一般是由主键构成。\n非聚簇索引则是数据与索引分开存储，B+树的叶子节点保存的是主键值，可以有多个非聚簇索引，通常我们自定义的索引都是非聚簇索引。\n7.知道什么是回表查询吗？ 回表查询是指通过二级索引找到对应的主键值，然后再通过主键值查询聚簇索引中对应的整行数据的过程。\n8.知道什么叫覆盖索引吗？ 覆盖索引是指在SELECT查询中，返回的列全部能在索引中找到，避免了回表查询，提高了性能。使用覆盖索引可以减少对主键索引的查询次数，提高查询效率。\n9.MySQL超大分页怎么处理？ 超大分页通常发生在数据量大的情况下，使用LIMIT分页查询且需要排序时效率较低。可以通过覆盖索引和子查询来解决。首先查询数据的ID字段进行分页，然后根据ID列表用子查询来过滤只查询这些ID的数据，因为查询ID时使用的是覆盖索引，所以效率可以提升。\n10.索引创建原则有哪些？ 创建索引的原则包括：\n• 表中的数据量超过10万以上时考虑创建索引。\n• 选择查询频繁的字段作为索引，如查询条件、排序字段或分组字段。\n• 尽量使用复合索引，覆盖SQL的返回值。\n• 如果字段区分度不高，可以将其放在组合索引的后面。\n• 对于内容较长的字段，考虑使用前缀索引。\n• 控制索引数量，因为索引虽然可以提高查询速度，但也会影响插入、更新的速度。\n11.什么情况下索引会失效？ 索引可能在以下情况下失效：\n• 没有遵循最左匹配原则。\n• 使用了模糊查询且%号在前面。\n• 在索引字段上进行了运算或类型转换。\n• 使用了复合索引但在中间使用了范围查询，导致右边的条件索引失效。\n12.SQL的优化经验有哪些？ SQL优化可以从以下几个方面考虑：\n• 建表时选择合适的字段类型。\n• 使用索引，遵循创建索引的原则。\n• 编写高效的SQL语句，比如避免使用SELECT *，尽量使用UNION ALL代替UNION，以及在表关联时使用INNER JOIN。\n• 采用主从复制和读写分离提高性能。\n• 在数据量大时考虑分库分表。\n13.创建表的时候，你们是如何优化的呢？ 创建表时，我们主要参考《嵩山版》开发手册，选择字段类型时结合字段内容，比如数值类型选择TINYINT、INT、BIGINT等，字符串类型选择CHAR、VARCHAR或TEXT。\n14.在使用索引的时候，是如何优化呢？ 在使用索引时，我们遵循索引创建原则，确保索引字段是查询频繁的，使用复合索引覆盖SQL返回值，避免在索引字段上进行运算或类型转换，以及控制索引数量。\n15.你平时对SQL语句做了哪些优化呢？ 我对SQL语句的优化包括指明字段名称而不是使用SELECT *，避免造成索引失效的写法，聚合查询时使用UNION ALL代替UNION，表关联时优先使用INNER JOIN，以及在必须使用LEFT JOIN或RIGHT JOIN时，确保小表作为驱动表。\n16.事务的特性是什么？可以详细说一下吗？ 事务的特性是ACID，即原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。例如，A向B转账500元，这个操作要么都成功，要么都失败，体现了原子性。转账过程中数据要保持一致，A扣除了500元，B必须增加500元。隔离性体现在A向B转账时，不受其他事务干扰。持久性体现在事务提交后，数据要被持久化存储。\n17.并发事务带来哪些问题？ 并发事务可能导致脏读、不可重复读和幻读。脏读是指一个事务读到了另一个事务未提交的“脏数据”。不可重复读是指在一个事务内多次读取同一数据，由于其他事务的修改导致数据不一致。幻读是指一个事务读取到了其他事务插入的“幻行”。\n18.怎么解决这些问题呢？MySQL的默认隔离级别是？ 解决这些问题的方法是使用事务隔离。MySQL支持四种隔离级别：\n  未提交读（READ UNCOMMITTED）：解决不了所有问题。\n  读已提交（READ COMMITTED）：能解决脏读，但不能解决不可重复读和幻读。\n  可重复读（REPEATABLE READ）：能解决脏读和不可重复读，但不能解决幻读，这也是MySQL的默认隔离级别。\n  串行化（SERIALIZABLE）：可以解决所有问题，但性能较低。\n  19.undo log和redo log的区别是什么？ redo log记录的是数据页的物理变化，用于服务宕机后的恢复，保证事务的持久性。而undo log记录的是逻辑日志，用于事务回滚时恢复原始数据，保证事务的原子性和一致性。\n20.事务中的隔离性是如何保证的呢？（你解释一下MVCC） 事务的隔离性通过锁和多版本并发控制（MVCC）来保证。MVCC通过维护数据的多个版本来避免读写冲突。底层实现包括隐藏字段、undo log和read view。隐藏字段包括trx_id和roll_pointer。undo log记录了不同版本的数据，通过roll_pointer形成版本链。read view定义了不同隔离级别下的快照读，决定了事务访问哪个版本的数据。\n21. MySQL主从同步原理是什么？ MySQL主从复制的核心是二进制日志（Binlog）。步骤如下：\n  主库在事务提交时记录数据变更到Binlog。\n  从库读取主库的Binlog并写入中继日志（Relay Log）。\n  从库重做中继日志中的事件，反映到自己的数据中。\n  22.你们项目用过MySQL的分库分表吗？ 我们采用微服务架构，每个微服务对应一个数据库，是根据业务进行拆分的，这个其实就是垂直拆分。\n23. 那你之前使用过水平分库吗？ 使用过。当时业务发展迅速，某个表数据量超过1000万，单库优化后性能仍然很慢，因此采用了水平分库。我们首先部署了3台服务器和3个数据库，使用mycat进行数据分片。旧数据也按照ID取模规则迁移到了各个数据库中，这样各个数据库可以分摊存储和读取压力，解决了性能问题。\nSSM 1. Spring框架中的单例bean是线程安全的吗？ 不是线程安全的。当多用户同时请求一个服务时，容器会给每个请求分配一个线程，这些线程会并发执行业务逻辑。如果处理逻辑中包含对单例状态的修改，比如修改单例的成员属性，就必须考虑线程同步问题。Spring框架本身并不对单例bean进行线程安全封装，线程安全和并发问题需要开发者自行处理。\n通常在项目中使用的Spring bean是不可变状态（如Service类和DAO类），因此在某种程度上可以说Spring的单例bean是线程安全的。如果bean有多种状态（如ViewModel对象），就需要自行保证线程安全。最简单的解决办法是将单例bean的作用域由“singleton”变更为“prototype”。\n2.什么是AOP？ AOP，即面向切面编程，在Spring中用于将那些与业务无关但对多个对象产生影响的公共行为和逻辑抽取出来，实现公共模块复用，降低耦合。常见的应用场景包括公共日志保存和事务处理。\n3.你们项目中有没有使用到AOP？ 我们之前在后台管理系统中使用AOP来记录系统操作日志。主要思路是使用AOP的环绕通知和切点表达式，找到需要记录日志的方法，然后通过环绕通知的参数获取请求方法的参数，例如类信息、方法信息、注解、请求方式等，并将这些参数保存到数据库。\n4.Spring中的事务是如何实现的？ Spring实现事务的本质是利用AOP完成的。它对方法前后进行拦截，在执行方法前开启事务，在执行完目标方法后根据执行情况提交或回滚事务。\n5. Spring中事务失效的场景有哪些？ 在项目中，我遇到过几种导致事务失效的场景：\n  如果方法内部捕获并处理了异常，没有将异常抛出，会导致事务失效。因此，处理异常后应该确保异常能够被抛出。\n  如果方法抛出检查型异常（checked exception），并且没有在@Transactional注解上配置rollbackFor属性为Exception，那么异常发生时事务可能不会回滚。\n  如果事务注解的方法不是公开（public）修饰的，也可能导致事务失效。\n  6.Spring的bean的生命周期？ Spring中bean的生命周期包括以下步骤：\n  通过BeanDefinition获取bean的定义信息。\n  调用构造函数实例化bean。\n  进行bean的依赖注入，例如通过setter方法或@Autowired注解。\n  处理实现了Aware接口的bean。\n  执行BeanPostProcessor的前置处理器。\n  调用初始化方法，如实现了InitializingBean接口或自定义的init-method。\n  执行BeanPostProcessor的后置处理器，可能在这里产生代理对象。\n  最后是销毁bean。\n  7.Spring中的循环引用？ 循环依赖发生在两个或两个以上的bean互相持有对方，形成闭环。Spring框架允许循环依赖存在，并通过三级缓存解决大部分循环依赖问题：\n  一级缓存：单例池，缓存已完成初始化的bean对象。\n  二级缓存：缓存尚未完成生命周期的早期bean对象。\n  三级缓存：缓存ObjectFactory，用于创建bean对象。\n  8.那具体解决流程清楚吗？ 解决循环依赖的流程如下：\n  实例化A对象，并创建ObjectFactory存入三级缓存。\n  A在初始化时需要B对象，开始B的创建逻辑。\n  B实例化完成，也创建ObjectFactory存入三级缓存。\n  B需要注入A，通过三级缓存获取ObjectFactory生成A对象，存入二级缓存。\n  B通过二级缓存获得A对象后，B创建成功，存入一级缓存。\n  A对象初始化时，由于B已创建完成，可以直接注入B，A创建成功存入一级缓存。\n  清除二级缓存中的临时对象A。\n  9.构造方法出现了循环依赖怎么解决？ 由于构造函数是bean生命周期中最先执行的，Spring框架无法解决构造方法的循环依赖问题。可以使用@Lazy懒加载注解，延迟bean的创建直到实际需要时。\n10.SpringMVC的执行流程？ SpringMVC的执行流程包括以下步骤：\n  用户发送请求到前端控制器DispatcherServlet。\n  DispatcherServlet调用HandlerMapping找到具体处理器。\n  HandlerMapping返回处理器对象及拦截器（如果有）给DispatcherServlet。\n  DispatcherServlet调用HandlerAdapter。\n  HandlerAdapter适配并调用具体处理器（Controller）。\n  Controller执行并返回ModelAndView对象。\n  HandlerAdapter将ModelAndView返回给DispatcherServlet。\n  DispatcherServlet传给ViewResolver进行视图解析。\n  ViewResolver返回具体视图给DispatcherServlet。\n  DispatcherServlet渲染视图并响应用户。\n  11.Springboot自动配置原理？ Spring Boot的自动配置原理基于@SpringBootApplication注解，它封装了@SpringBootConfiguration、@EnableAutoConfiguration和@ComponentScan。@EnableAutoConfiguration是核心，它通过@Import导入配置选择器，读取META-INF/spring.factories文件中的类名，根据条件注解决定是否将配置类中的Bean导入到Spring容器中。\n12.Spring 的常见注解有哪些？ Spring的常见注解包括：\n  声明Bean的注解：@Component、@Service、@Repository、@Controller。\n  依赖注入相关注解：@Autowired、@Qualifier、@Resource。\n  设置作用域的注解：@Scope。\n  配置相关注解：@Configuration、@ComponentScan、@Bean。\n  AOP相关注解：@Aspect、@Before、@After、@Around、@Pointcut。\n  13.SpringMVC常见的注解有哪些？ SpringMVC的常见注解有：\n• @RequestMapping：映射请求路径。\n• @RequestBody：接收HTTP请求的JSON数据。\n• @RequestParam：指定请求参数名称。\n• @PathVariable：从请求路径中获取参数。\n• @ResponseBody：将Controller方法返回的对象转化为JSON。\n• @RequestHeader：获取请求头数据。\n• @PostMapping、@GetMapping等。\n14.Springboot常见注解有哪些？ Spring Boot的常见注解包括：\n• @SpringBootApplication：由@SpringBootConfiguration、@EnableAutoConfiguration和@ComponentScan组成。\n• 其他注解如@RestController、@GetMapping、@PostMapping等，用于简化Spring MVC的配置。\n15.MyBatis执行流程？ MyBatis的执行流程如下：\n  读取MyBatis配置文件mybatis-config.xml。\n  构造会话工厂SqlSessionFactory。\n  会话工厂创建SqlSession对象。\n  操作数据库的接口，Executor执行器。\n  Executor执行方法中的MappedStatement参数。\n  输入参数映射。\n  输出结果映射。\n  16.Mybatis是否支持延迟加载？ MyBatis支持延迟加载，即在需要用到数据时才加载。可以通过配置文件中的lazyLoadingEnabled配置启用或禁用延迟加载。\n17.延迟加载的底层原理知道吗？ 延迟加载的底层原理主要使用CGLIB动态代理实现：\n  使用CGLIB创建目标对象的代理对象。\n  调用目标方法时，如果发现是null值，则执行SQL查询。\n  获取数据后，设置属性值并继续查询目标方法。\n18.Mybatis的一级、二级缓存用过吗？ MyBatis的一级缓存是基于PerpetualCache的HashMap本地缓存，作用域为Session，默认开启。二级缓存需要单独开启，作用域为Namespace或mapper，默认也是采用PerpetualCache，HashMap存储。\n19.Mybatis的二级缓存什么时候会清理缓存中的数据？ 当作用域（一级缓存Session/二级缓存Namespaces）进行了新增、修改、删除操作后，默认该作用域下所有select中的缓存将被清空。\n微服务 1.Spring Cloud 5大组件有哪些？ 在早期，Spring Cloud的五大组件通常指的是：\n• Eureka：服务注册中心。\n• Ribbon：客户端负载均衡器。\n• Feign：声明式的服务调用。\n• Hystrix：服务熔断器。\n• Zuul/Gateway：API网关。\n随着Spring Cloud Alibaba的兴起，我们项目中也融入了一些阿里巴巴的技术组件：\n• 服务注册与配置中心：Nacos。\n• 负载均衡：Ribbon。\n• 服务调用：Feign。\n• 服务保护：Sentinel。\n• API网关：Gateway。\n2.服务注册和发现是什么意思？Spring Cloud 如何实现服务注册发现？ 服务注册与发现主要包含三个核心功能：服务注册、服务发现和服务状态监控。\n我们项目中采用了Eureka作为服务注册中心，它是Spring Cloud体系中的一个关键组件。\n• 服务注册：服务提供者将自己的信息（如服务名称、IP、端口等）注册到Eureka。\n• 服务发现：消费者从Eureka获取服务列表信息，并利用负载均衡算法选择一个服务进行调用。\n• 服务监控：服务提供者定期向Eureka发送心跳以报告健康状态；如果Eureka在一定时间内未接收到心跳，将服务实例从注册中心剔除。\n3.我看你之前也用过nacos，你能说下nacos与eureka的区别？ 在使用Nacos作为注册中心的项目中，我注意到Nacos与Eureka的共同点和区别：\n• 共同点：两者都支持服务注册与发现，以及心跳检测作为健康检查机制。\n• 区别：\na. Nacos支持服务端主动检测服务提供者状态，而Eureka依赖客户端心跳。\nb. Nacos区分临时实例和非临时实例，采用不同的健康检查策略。\nc. Nacos支持服务列表变更的消息推送，使服务更新更及时。\nd. Nacos集群默认采用AP模式，但在存在非临时实例时，会采用CP模式；而Eureka始终采用AP模式。\n4.你们项目负载均衡如何实现的？ 在服务调用过程中，我们使用Spring Cloud的Ribbon组件来实现客户端负载均衡。Feign客户端在底层已经集成了Ribbon，使得使用非常简便。\n当发起远程调用时，Ribbon首先从注册中心获取服务地址列表，然后根据预设的路由策略选择一个服务实例进行调用，常用的策略是轮询。\n5.Ribbon负载均衡策略有哪些？ Ribbon提供了多种负载均衡策略，包括：\n• RoundRobinRule：简单的轮询策略。\n• WeightedResponseTimeRule：根据响应时间加权选择服务器。\n• RandomRule：随机选择服务器。\n• ZoneAvoidanceRule：区域感知的负载均衡，优先选择同一区域中可用的服务器。\n6.如果想自定义负载均衡策略如何实现？ 自定义Ribbon负载均衡策略有两种方式：\n  创建一个类实现IRule接口，这将定义全局的负载均衡策略。\n  在客户端配置文件中指定特定服务调用的负载均衡策略，这将仅对该服务生效。\n  7.什么是服务雪崩，怎么解决这个问题？ 服务雪崩是指一个服务的失败导致整个链路的服务相继失败。我们通常通过服务降级和服务熔断来解决这个问题：\n• 服务降级：在请求量突增时，主动降低服务的级别，确保核心服务可用。\n• 服务熔断：当服务调用失败率达到一定阈值时，熔断机制会启动，防止系统过载。\n8.你们的微服务是怎么监控的？ 我们项目中采用了SkyWalking进行微服务监控：\n SkyWalking能够监控接口、服务和物理实例的状态，帮助我们识别和优化慢服务。 我们还设置了告警规则，一旦检测到异常，系统会通过短信或邮件通知相关负责  9.你们项目中有没有做过限流？怎么做的？ 在我们的项目中，由于面临可能的突发流量，我们采用了限流策略：\n• 版本1：使用Nginx进行限流，通过漏桶算法控制请求处理速率，按照IP进行限流。\n• 版本2：使用Spring Cloud Gateway的RequestRateLimiter过滤器进行限流，采用令牌桶算法，可以基于IP或路径进行限流。\n10.限流常见的算法有哪些？ 常见的限流算法包括：\n• 漏桶算法：以固定速率处理请求，平滑突发流量。\n• 令牌桶算法：按照一定速率生成令牌，请求在获得令牌后才被处理，适用于请求量有波动的场景。\n11.什么是CAP理论？ CAP理论是分布式系统设计的基础理论，包含一致性(Consistency)、可用性(Availability)和分区容错性(Partition tolerance)。在网络分区发生时，系统只能在一致性和可用性之间选择其一。\n12.为什么分布式系统中无法同时保证一致性和可用性？ 在分布式系统中，为了保证分区容错性，我们通常需要在一致性和可用性之间做出选择。如果系统优先保证一致性，可能需要牺牲可用性，反之亦然。\n13.什么是BASE理论？ BASE理论是分布式系统设计中对CAP理论中AP方案的延伸，强调通过基本可用、软状态和最终一致性来实现系统设计。\n14.你们采用哪种分布式事务解决方案？ 我们项目中使用了Seata的AT模式来解决分布式事务问题。AT模式通过记录业务数据的变更日志来保证事务的最终一致性。\n15.分布式服务的接口幂等性如何设计？ 我们通过Token和Redis来实现接口幂等性。用户操作时，系统生成一个Token并存储在Redis中，当用户提交操作时，系统会验证Token的存在性，并在验证通过后删除Token，确保每个Token只被处理一次。\n16.xxl-job路由策略有哪些？ xxl-job支持多种路由策略，包括轮询、故障转移和分片广播等。\n17.xxl-job任务执行失败怎么解决？ 面对任务执行失败，我们可以：\n  选择故障转移路由策略，优先使用健康的实例执行任务。\n  设置任务重试次数。\n  通过日志记录和邮件告警通知相关负责人。\n  18.如果有大数据量的任务同时都需要执行，怎么解决？ 我们可以通过部署多个实例并使用分片广播路由策略来分散任务负载。在任务执行代码中，根据分片信息和总数对任务进行分配。\n消息中间件 1.RabbitMQ如何保证消息不丢失？ 我们使用RabbitMQ来确保MySQL和Redis间数据双写的一致性，这要求我们实现消息的高可用性，具体措施包括：\n  开启生产者确认机制，确保消息能被送达队列，如有错误则记录日志并修复数据。\n  启用持久化功能，保证消息在未消费前不会在队列中丢失，需要对交换机、队列和消息本身都进行持久化。\n  对消费者开启自动确认机制，并设置重试次数。例如，我们设置了3次重试，若失败则将消息发送至异常交换机，由人工处理。\n  2.RabbitMQ消息的重复消费问题如何解决？ 我们遇到过消息重复消费的问题，处理方法是：\n• 设置消费者为自动确认模式，如果服务在确认前宕机，重启后可能会再次消费同一消息。\n• 通过业务唯一标识检查数据库中数据是否存在，若不存在则处理消息，若存在则忽略，避免重复消费。\n3.那你还知道其他的解决方案吗？ 是的，这属于幂等性问题，可以通过以下方法解决：\n• 使用Redis分布式锁或数据库锁来确保操作的幂等性。\n4. RabbitMQ中死信交换机了解吗？（RabbitMQ延迟队列有了解过吗？） 了解。我们项目中使用RabbitMQ实现延迟队列，主要通过死信交换机和TTL（消息存活时间）来实现。\n• 消息若超时未消费则变为死信，队列可绑定死信交换机，实现延迟功能。\n• 另一种方法是安装RabbitMQ的死信插件，简化配置，在声明交换机时指定为死信交换机，并设置消息超时时间。\n5.如果有100万消息堆积在MQ，如何解决？ 若出现消息堆积，可采取以下措施：\n  提高消费者消费能力，如使用多线程。\n  增加消费者数量，采用工作队列模式，让多个消费者并行消费同一队列。\n  扩大队列容量，使用RabbitMQ的惰性队列，支持数百万条消息存储，直接存盘而非内存。\n  6.RabbitMQ的高可用机制了解吗？ 我们项目在生产环境使用RabbitMQ集群，采用镜像队列模式，一主多从结构。\n• 主节点处理所有操作并同步给从节点，若主节点宕机，从节点可接替为主节点，但需注意数据同步的完整性。\n7.那出现丢数据怎么解决呢？ 使用仲裁队列，主从模式，基于Raft协议实现强一致性数据同步，简化配置，提高数据安全性。\n8. Kafka是如何保证消息不丢失？ Kafka保证消息不丢失的措施包括：\n  生产者使用异步回调发送消息，设置重试机制应对网络问题。\n  在Broker中通过复制机制，设置acks参数为all，确保消息在所有副本中都得到确认。\n  消费者手动提交消费成功的offset，避免自动提交可能导致的数据丢失或重复消费。\n  9. Kafka中消息的重复消费问题如何解决？ 通过以下方法解决Kafka中的重复消费问题：\n• 禁用自动提交offset，手动控制offset提交时机。\n• 确保消息消费的幂等性，例如通过唯一主键或分布式锁。\n10. Kafka是如何保证消费的顺序性？ Kafka默认不保证消息顺序性，但可以通过以下方法实现：\n• 将消息存储在同一个分区，通过指定分区号或相同的业务key来实现。\n11. Kafka的高可用机制了解吗？ Kafka的高可用性主要通过以下机制实现：\n• 集群部署，多broker实例，单点故障不影响整体服务。\n• 复制机制，每个分区有多个副本，leader和follower，leader故障时从follower中选举新leader。\n12. 解释一下复制机制中的ISR？ ISR（In-Sync Replicas）指与leader保持同步的follower副本。\n• 当leader故障时，优先从ISR中选举新leader，因为它们数据一致性更高。\n13. Kafka数据清理机制了解吗？ Kafka的数据清理包括：\n• 基于消息保留时间的清理。\n• 基于topic数据大小的清理，可配置删除最旧消息。\n14. Kafka中实现高性能的设计有了解过吗？ Kafka高性能设计包括：\n• 消息分区，提升数据处理能力。\n• 顺序读写，提高磁盘操作效率。\n• 页缓存，减少磁盘访问。\n• 零拷贝，减少数据拷贝和上下文切换。\n• 消息压缩，减少IO负载。\n• 分批发送，降低网络开销。\n常见集合 1.ArrayList源码分析 ArrayList底层是用动态的数组实现的\n• 初始容量\nArrayList初始容量为0，当第一次添加数据的时候才会初始化容量为10\n• 扩容逻辑\nArrayList在进行扩容的时候是原来容量的1.5倍，每次扩容都需要拷贝数组\n• 添加逻辑\n​\t￮ 确保数组已使用长度（size）加1之后足够存下下一个数据\n​\t￮ 计算数组的容量，如果当前数组已使用长度+1后的大于当前的数组长度，则调用grow方法扩容（原来的1.5倍）\n​\t￮ 确保新增的数据有地方存储之后，则将新元素添加到位于size的位置上。\n​\t￮ 返回添加成功布尔值。\n2.面试题-ArrayList list=new ArrayList(10)中的list扩容几次 该语句只是声明和实例了一个 ArrayList，指定了容量为 10，未扩容\n3.面试题-如何实现数组和List之间的转换 参考回答：\n• 数组转List ，使用JDK中java.util.Arrays工具类的asList方法\n• List转数组，使用List的toArray方法。无参toArray方法返回 Object数组，传入初始化长度的数组对象，返回该对象数组\n面试官再问：\n1，用Arrays.asList转List后，如果修改了数组内容，list受影响吗\n2，List用toArray转数组后，如果修改了List内容，数组受影响吗\n数组转List受影响\nList转数组不受影响\n再答：\n1，用Arrays.asList转List后，如果修改了数组内容，list受影响吗\nArrays.asList转换list之后，如果修改了数组的内容，list会受影响，因为它的底层使用的Arrays类中的一个内部类ArrayList来构造的集合，在这个集合的构造器中，把我们传入的这个集合进行了包装而已，最终指向的都是同一个内存地址\n2，List用toArray转数组后，如果修改了List内容，数组受影响吗\nlist用了toArray转数组后，如果修改了list内容，数组不会影响，当调用了toArray以后，在底层是它是进行了数组的拷贝，跟原来的元素就没啥关系了，所以即使list修改了以后，数组也不受影响\n4.面试题-ArrayList和LinkedList的区别是什么？ • 底层数据结构\n​\t￮ ArrayList 是动态数组的数据结构实现\n​\t￮ LinkedList 是双向链表的数据结构实现\n• 操作数据效率\n​\t￮ ArrayList按照下标查询的时间复杂度O(1)【内存是连续的，根据寻址公式】， LinkedList不支持下标查询\n​\t￮ 查找（未知索引）： ArrayList需要遍历，链表也需要链表，时间复杂度都是O(n)\n​\t￮ 新增和删除\n▪ ArrayList尾部插入和删除，时间复杂度是O(1)；其他部分增删需要挪动数组，时间复杂度是O(n)\n▪ LinkedList头尾节点增删时间复杂度是O(1)，其他都需要遍历链表，时间复杂度是O(n)\n• 内存空间占用\n​\t￮ ArrayList底层是数组，内存连续，节省内存\n​\t￮ LinkedList 是双向链表需要存储数据，和两个指针，更占用内存\n• 线程安全\n​\t￮ ArrayList和LinkedList都不是线程安全的\n​\t￮ 如果需要保证线程安全，有两种方案：\n​\t▪ 在方法内使用，局部变量则是线程安全的\n​\t▪ 使用线程安全的ArrayList和LinkedList\n5. 面试题-说一下HashMap的实现原理？ HashMap的数据结构： 底层使用hash表数据结构，即数组和链表或红黑树\n  当我们往HashMap中put元素时，利用key的hashCode重新hash计算出当前对象的元素在数组中的下标\n  存储时，如果出现hash值相同的key，此时有两种情况。\n​\ta. 如果key相同，则覆盖原始值；\n​\tb. 如果key不同（出现冲突），则将当前的key-value放入链表或红黑树中\n  获取时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。\n  面试官追问：HashMap的jdk1.7和jdk1.8有什么区别\n• JDK1.8之前采用的是拉链法。拉链法：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。\n• jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8） 时并且数组长度达到64时，将链表转化为红黑树，以减少搜索时间。扩容 resize( ) 时，红黑树拆分成的树的结点数小于等于临界值6个，则退化成链表\n6.面试题-HashMap的put方法的具体流程   判断键值对数组table是否为空或为null，否则执行resize()进行扩容（初始化）\n  根据键值key计算hash值得到数组索引\n  判断table[i]==null，条件成立，直接新建节点添加\n  如果table[i]==null ,不成立\n  4.1 判断table[i]的首个元素是否和key一样，如果相同直接覆盖value\n  4.2 判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对\\7. 4.3 遍历table[i]，链表的尾部插入数据，然后判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操 作，遍历过程中若发现key已经存在直接覆盖value\n  插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold（数组长度*0.75），如果超过，进行扩容。\n  7.面试题-讲一讲HashMap的扩容机制 • 在添加元素或初始化的时候需要调用resize方法进行扩容，第一次添加数据初始化数组长度为16，以后每次每次扩容都是达到了扩容阈值（数组长度 * 0.75）\n• 每次扩容的时候，都是扩容之前容量的2倍；\n• 扩容之后，会新创建一个数组，需要把老数组中的数据挪动到新的数组中\n​\t￮ 没有hash冲突的节点，则直接使用 e.hash \u0026amp; (newCap - 1) 计算新数组的索引位置\n​\t￮ 如果是红黑树，走红黑树的添加\n​\t￮ 如果是链表，则需要遍历链表，可能需要拆分链表，判断(e.hash \u0026amp; oldCap)是否为0，该元素的位置要么停留在原始位置，要么移动到原始位置+增加的数组大小这个位置上\n8.面试题-hashMap的寻址算法 首先获取key的hashCode值，然后右移16位 异或运算 原来的hashCode值，主要作用就是使原来的hash值更加均匀，减少hash冲突\n有了hash值之后，就很方便的去计算当前key的在数组中存储的下标，(n-1)\u0026amp;hash : 得到数组中的索引，代替取模，性能更好，数组长度必须是2的n次幂\n9.为何HashMap的数组长度一定是2的次幂？   计算索引时效率更高：如果是 2 的 n 次幂可以使用位与运算代替取模\n  扩容时重新计算索引效率更高： hash \u0026amp; oldCap == 0 的元素留在原来位置 ，否则新位置 = 旧位置 + oldCap\n  10.面试题-hashmap在1.7情况下的多线程死循环问题 在jdk1.7的hashmap中在数组进行扩容的时候，因为链表是头插法，在进行数据迁移的过程中，有可能导致死循环\n比如说，现在有两个线程\n线程一：读取到当前的hashmap数据，数据中一个链表，在准备扩容时，线程二介入\n线程二：也读取hashmap，直接进行扩容。因为是头插法，链表的顺序会进行颠倒过来。比如原来的顺序是AB，扩容后的顺序是BA，线程二执行结束。\n线程一：继续执行的时候就会出现死循环的问题。\n线程一先将A移入新的链表，再将B插入到链头，由于另外一个线程的原因，B的next指向了A，\n所以B-\u0026gt;A-\u0026gt;B,形成循环。\n当然，JDK 8 将扩容算法做了调整，不再将元素加入链表头（而是保持与扩容前一样的顺序），尾插法，就避免了jdk7中死循环的问题。\n11.面试题-HashSet与HashMap的区别 (1)HashSet实现了Set接口, 仅存储对象; HashMap实现了 Map接口, 存储的是键值对.\n(2)HashSet底层其实是用HashMap实现存储的, HashSet封装了一系列HashMap的方法. 依靠HashMap来存储元素值,(利用hashMap的key键进行存储), 而value值默认为Object对象. 所以HashSet也不允许出现重复值, 判断标准和HashMap判断标准相同, 两个元素的hashCode相等并且通过equals()方法返回true.\n12.面试题-HashTable与HashMap的区别 \r13.说一说Java提供的常见集合？ 在java中提供了两大类的集合框架，主要分为两类：\n第一个是Collection 属于单列集合，第二个是Map 属于双列集合\n• 在Collection中有两个子接口List和Set。在我们平常开发的过程中用的比较多像list接口中的实现类ArrarList和LinkedList。 在Set接口中有实现类HashSet和TreeSet。\n• 在map接口中有很多的实现类，平时比较常见的是HashMap、TreeMap，还有一个线程安全的map:ConcurrentHashMap\n14.hashmap是线程安全的吗 不是线程安全的, 我们可以采用ConcurrentHashMap进行使用，它是一个线程安全的HashMap.\n多线程 1.线程和进程的区别？ 当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。\nJava 中，线程作为最小调度单位，进程作为资源分配的最小单位。在 windows 中进程是不活动的，只是作为线程的容器\n二者对比\n• 进程是正在运行程序的实例，进程中包含了线程，每个线程执行不同的任务\n• 不同的进程使用不同的内存空间，在当前进程下的所有线程可以共享内存空间\n• 线程更轻量，线程上下文切换成本一般上要比进程上下文切换低(上下文切换指的是从一个线程切换到另一个线程)\n2.并行和并发有什么区别？ 现在都是多核CPU，在多核CPU下\n并发是同一时间应对多件事情的能力，多个线程轮流使用一个或多个CPU\n并行是同一时间动手做多件事情的能力，4核CPU同时执行4个线程\n3.创建线程的四种方式 在java中一共有四种常见的创建方式，分别是：继承Thread类、实现runnable接口、实现Callable接口、线程池创建线程。通常情况下，我们项目中都会采用线程池的方式创建线程。\n4.runnable 和 callable 有什么区别   Runnable 接口run方法没有返回值；Callable接口call方法有返回值，是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果\n  Callalbe接口支持返回执行结果，需要调用FutureTask.get()得到，此方法会阻塞主进程的继续往下执行，如果不调用不会阻塞。\n  Callable接口的call()方法允许抛出异常；而Runnable接口的run()方法的异常只能在内部消化，不能继续上抛\n  5.线程的 run()和 start()有什么区别？ start(): 用来启动线程，通过该线程调用run方法执行run方法中所定义的逻辑代码。start方法只能被调用一次。\nrun(): 封装了要被线程执行的代码，可以被调用多次。\n6.线程包括哪些状态，状态之间是如何变化的 在JDK中的Thread类中的枚举State里面定义了6中线程的状态分别是：新建、可运行、终结、阻塞、等待和有时限等待六种。\n关于线程的状态切换情况比较多。我分别介绍一下\n当一个线程对象被创建，但还未调用 start 方法时处于新建状态，调用了 start 方法，就会由新建进入可运行状态。如果线程内代码已经执行完毕，由可运行进入终结状态。当然这些是一个线程正常执行情况。\n如果线程获取锁失败后，由可运行进入 Monitor 的阻塞队列阻塞，只有当持锁线程释放锁时，会按照一定规则唤醒阻塞队列中的阻塞线程，唤醒后的线程进入可运行状态\n如果线程获取锁成功后，但由于条件不满足，调用了 wait() 方法，此时从可运行状态释放锁等待状态，当其它持锁线程调用 notify() 或 notifyAll() 方法，会恢复为可运行状态\n还有一种情况是调用 sleep(long) 方法也会从可运行状态进入有时限等待状态，不需要主动唤醒，超时时间到自然恢复为可运行状态\n7.新建 T1、T2、T3 三个线程，如何保证它们按顺序执行？ 可以这么做，在多线程中有多种方法让线程按特定顺序执行，可以用线程类的join()方法在一个线程中启动另一个线程，另外一个线程完成该线程继续执行。\n比如说：\n使用join方法，T3调用T2，T2调用T1，这样就能确保T1就会先完成而T3最后完成\n8.notify()和 notifyAll()有什么区别？ notifyAll：唤醒所有wait的线程\nnotify：只随机唤醒一个 wait 线程\n9.在 java 中 wait 和 sleep 方法的不同？ 共同点\n• wait() ，wait(long) 和 sleep(long) 的效果都是让当前线程暂时放弃 CPU 的使用权，进入阻塞状态\n不同点\n• 方法归属不同\n​\t￮ sleep(long) 是 Thread 的静态方法\n​\t￮ 而 wait()，wait(long) 都是 Object 的成员方法，每个对象都有\n• 醒来时机不同\n​\t￮ 执行 sleep(long) 和 wait(long) 的线程都会在等待相应毫秒后醒来\n​\t￮ wait(long) 和 wait() 还可以被 notify 唤醒，wait() 如果不唤醒就一直等下去\n​\t￮ 它们都可以被打断唤醒\n• 锁特性不同（重点）\n​\t￮ wait 方法的调用必须先获取 wait 对象的锁，而 sleep 则无此限制\n​\t￮ wait 方法执行后会释放对象锁，允许其它线程获得该对象锁（我放弃 cpu，但你们还可以用）\n​\t￮ 而 sleep 如果在 synchronized 代码块中执行，并不会释放对象锁（我放弃 cpu，你们也用不了）\n10.如何停止一个正在运行的线程？ 有三种方式可以停止线程\n• 使用退出标志，使线程正常退出，也就是当run方法完成后线程终止\n• 使用stop方法强行终止（不推荐，方法已作废）\n• 使用interrupt方法中断线程\n11.讲一下synchronized关键字的底层原理？ synchronized 底层使用的JVM级别中的Monitor 来决定当前线程是否获得了锁，如果某一个线程获得了锁，在没有释放锁之前，其他线程是不能或得到锁的。synchronized 属于悲观锁。\nsynchronized 因为需要依赖于JVM级别的Monitor ，相对性能也比较低。\nmonitor对象存在于每个Java对象的对象头中，synchronized 锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因\nmonitor内部维护了三个变量\n• WaitSet：保存处于Waiting状态的线程\n• EntryList：保存处于Blocked状态的线程\n• Owner：持有锁的线程\n只有一个线程获取到的标志就是在monitor中设置成功了Owner，一个monitor中只能有一个Owner\n在上锁的过程中，如果有其他线程也来抢锁，则进入EntryList 进行阻塞，当获得锁的线程执行完了，释放了锁，就会唤醒EntryList 中等待的线程竞争锁，竞争的时候是非公平的。\n12.synchronized关键字的底层原理-进阶 Java中的synchronized有偏向锁、轻量级锁、重量级锁三种形式，分别对应了锁只被一个线程持有、不同线程交替持有锁、多线程竞争锁三种情况。\n重量级锁：底层使用的Monitor实现，里面涉及到了用户态和内核态的切换、进程的上下文切换，成本较高，性能比较低。\n轻量级锁：线程加锁的时间是错开的（也就是没有竞争），可以使用轻量级锁来优化。轻量级修改了对象头的锁标志，相对重量级锁性能提升很多。每次修改都是CAS操作，保证原子性\n偏向锁：一段很长的时间内都只被一个线程使用锁，可以使用了偏向锁，在第一次获得锁时，会有一个CAS操作，之后该线程再获取锁，只需要判断mark word中是否是自己的线程id即可，而不是开销相对较大的CAS命令\n一旦锁发生了竞争，都会升级为重量级锁\n13.你谈谈 JMM（Java 内存模型） Java内存模型是Java虚拟机规范中定义的一种非常重要的内存模型。它的主要作用是描述Java程序中线程共享变量的访问规则，以及这些变量在JVM中是如何被存储和读取的，涉及到一些底层的细节。\n这个模型有几个核心的特点。首先，所有的共享变量，包括实例变量和类变量，都被存储在主内存中，也就是计算机的RAM。需要注意的是，局部变量并不包含在内，因为它们是线程私有的，所以不存在竞争问题。\n其次，每个线程都有自己的工作内存，这里保留了线程所使用的变量的工作副本。这意味着，线程对变量的所有操作，无论是读还是写，都必须在自己的工作内存中完成，而不能直接读写主内存中的变量。\n最后，不同线程之间不能直接访问对方工作内存中的变量。如果线程间需要传递变量的值，那么这个过程必须通过主内存来完成。\n14.CAS 你知道吗？ CAS的全称是： Compare And Swap(比较再交换);它体现的一种乐观锁的思想，在无锁状态下保证线程操作数据的原子性。\n• CAS使用到的地方很多：AQS框架、AtomicXXX类\n• 在操作共享变量的时候使用的自旋锁，效率上更高一些\nCAS的底层是调用的Unsafe类中的方法，都是操作系统提供的，其他语言实现\n15.请谈谈你对 volatile 的理解 volatile 是一个关键字，可以修饰类的成员变量、类的静态成员变量，主要有两个功能\n第一：保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的,volatile关键字会强制将修改的值立即写入主存。\n第二： 禁止进行指令重排序，可以保证代码执行有序性。底层实现原理是，添加了一个内存屏障，通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化\n16.什么是AQS？ AQS的话，其实就一个jdk提供的类AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架。\n内部有一个属性 state 属性来表示资源的状态，默认state等于0，表示没有获取锁，state等于1的时候才标明获取到了锁。通过cas 机制设置 state 状态\n在它的内部还提供了基于 FIFO 的等待队列，是一个双向列表，其中\n• tail 指向队列最后一个元素\n• head 指向队列中最久的一个元素\n其中我们刚刚聊的ReentrantLock底层的实现就是一个AQS。\n17.ReentrantLock的实现原理 ReentrantLock是一个可重入锁:，调用 lock 方 法获取了锁之后，再次调用 lock，是不会再阻塞，内部直接增加重入次数 就行了，标识这个线程已经重复获取一把锁而不需要等待锁的释放。\nReentrantLock是属于juc报下的类，属于api层面的锁，跟synchronized一样，都是悲观锁。通过lock()用来获取锁，unlock()释放锁。\n它的底层实现原理主要利用CAS+AQS队列来实现。它支持公平锁和非公平锁，两者的实现类似\n构造方法接受一个可选的公平参数（默认非公平锁），当设置为true时，表示公平锁，否则为非公平锁。公平锁的效率往往没有非公平锁的效率高。\n18.synchronized和Lock有什么区别 ? 第一，语法层面\n• synchronized 是关键字，源码在 jvm 中，用 c++ 语言实现，退出同步代码块锁会自动释放\n• Lock 是接口，源码由 jdk 提供，用 java 语言实现，需要手动调用 unlock 方法释放锁\n第二，功能层面\n• 二者均属于悲观锁、都具备基本的互斥、同步、锁重入功能\n• Lock 提供了许多 synchronized 不具备的功能，例如获取等待状态、公平锁、可打断、可超时、多条件变量，同时Lock 可以实现不同的场景，如 ReentrantLock， ReentrantReadWriteLock\n第三，性能层面\n• 在没有竞争时，synchronized 做了很多优化，如偏向锁、轻量级锁，性能不赖\n• 在竞争激烈时，Lock 的实现通常会提供更好的性能\n统合来看，需要根据不同的场景来选择不同的锁的使用。\n19.死锁产生的条件是什么？ 嗯，是这样的，一个线程需要同时获取多把锁，这时就容易发生死锁，举个例子来说：\nt1 线程获得A对象锁，接下来想获取B对象的锁\nt2 线程获得B对象锁，接下来想获取A对象的锁\n这个时候t1线程和t2线程都在互相等待对方的锁，就产生了死锁\n20.如何进行死锁诊断？ 我们只需要通过jdk自动的工具就能搞定\n我们可以先通过jps来查看当前java程序运行的进程id\n然后通过jstack来查看这个进程id，就能展示出来死锁的问题，并且，可以定位代码的具体行号范围，我们再去找到对应的代码进行排查就行了。\n21.ConcurrentHashMap ConcurrentHashMap 是一种线程安全的高效Map集合，jdk1.7和1.8也做了很多调整。\n• JDK1.7的底层采用是分段的数组+链表 实现\n• JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。\n在jdk1.7中 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一 种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构 的元素，每个 Segment 守护着一个HashEntry数组里的元素，当对 HashEntry 数组的数据进行修 改时，必须首先获得对应的 Segment的锁。\nSegment 是一种可重入的锁 ReentrantLock，每个 Segment 守护一个HashEntry 数组里得元 素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 锁\n在jdk1.8中的ConcurrentHashMap 做了较大的优化，性能提升了不少。首先是它的数据结构与jdk1.8的hashMap数据结构完全一致。其次是放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保 证并发安全进行实现，synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲 突，就不会产生并发 , 效率得到提升\n22.导致并发程序出现问题的根本原因是什么 Java并发编程有三大核心特性，分别是原子性、可见性和有序性。\n首先，原子性指的是一个线程在CPU中的操作是不可暂停也不可中断的，要么执行完成，要么不执行。比如，一些简单的操作如赋值可能是原子的，但复合操作如自增就不是原子的。为了保证原子性，我们可以使用synchronized关键字或JUC里面的Lock来进行加锁。\n其次，可见性是指让一个线程对共享变量的修改对另一个线程可见。由于线程可能在自己的工作内存中缓存共享变量的副本，因此一个线程对共享变量的修改可能不会立即反映在其他线程的工作内存中。为了解决这个问题，我们可以使用synchronized关键字、volatile关键字或Lock来确保可见性。\n最后，有序性是指处理器为了提高程序运行效率，可能会对输入代码进行优化，导致程序中各个语句的执行先后顺序与代码中的顺序不一致。虽然处理器会保证程序最终执行结果与代码顺序执行的结果一致，但在某些情况下我们可能需要确保特定的执行顺序。为了解决这个问题，我们可以使用volatile关键字来禁止指令重排。\n23.说一下线程池的核心参数（线程池的执行原理知道嘛） 在线程池中一共有7个核心参数：\n  corePoolSize 核心线程数目 - 池中会保留的最多线程数\n  maximumPoolSize 最大线程数目 - 核心线程+救急线程的最大数目\n  keepAliveTime 生存时间 - 救急线程的生存时间，生存时间内没有新任务，此线程资源会释放\n  unit 时间单位 - 救急线程的生存时间单位，如秒、毫秒等\n  workQueue - 当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建救急线程执行任务\n  threadFactory 线程工厂 - 可以定制线程对象的创建，例如设置线程名字、是否是守护线程等\n  handler 拒绝策略 - 当所有线程都在繁忙，workQueue 也放满时，会触发拒绝策略\n  拒绝策略有4种，当线程数过多以后，第一种是抛异常、第二种是由调用者执行任务、第三是丢弃当前的任务，第四是丢弃最早排队任务。默认是直接抛异常。\n24.线程池中有哪些常见的阻塞队列 Jdk中提供了很多阻塞队列，开发中常见的有两个：ArrayBlockingQueue和LinkedBlockingQueue\nArrayBlockingQueue和LinkedBlockingQueue是Java中两种常见的阻塞队列，它们在实现和使用上有一些关键的区别。\n首先，ArrayBlockingQueue是一个有界队列，它在创建时必须指定容量，并且这个容量不能改变。而LinkedBlockingQueue默认是无界的，但也可以在创建时指定最大容量，使其变为有界队列。\n其次，它们在内部数据结构上也有所不同。ArrayBlockingQueue是基于数组实现的，而LinkedBlockingQueue则是基于链表实现的。这意味着ArrayBlockingQueue在访问元素时可能会更快，因为它可以直接通过索引访问数组中的元素。而LinkedBlockingQueue则在添加和删除元素时可能更快，因为它不需要移动其他元素来填充空间。\n另外，它们在加锁机制上也有所不同。ArrayBlockingQueue使用一把锁来控制对队列的访问，这意味着读写操作都是互斥的。而LinkedBlockingQueue则使用两把锁，一把用于控制读操作，另一把用于控制写操作，这样可以提高并发性能。\n25.如何确定核心线程数 ① 高并发、任务执行时间短 \u0026ndash;\u0026gt;（ CPU核数+1 ），减少线程上下文的切换\n② 并发不高、任务执行时间长\n• IO密集型的任务 \u0026ndash;\u0026gt; (CPU核数 * 2 + 1)\n• 计算密集型任务 \u0026ndash;\u0026gt; （ CPU核数+1 ）\n③ 并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置，设置参考（2）\n26.线程池的种类有哪些 在jdk中默认提供了4中方式创建线程池\n第一个是：newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回 收空闲线程，若无可回收，则新建线程。\n第二个是：newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列 中等待。\n第三个是：newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。\n第四个是：newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任 务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。\n27.为什么不建议用Executors创建线程池 主要原因是如果使用Executors创建线程池的话，它允许的请求队列默认长度是Integer.MAX_VALUE，这样的话，有可能导致堆积大量的请求，从而导致OOM（内存溢出）。\n所以，我们一般推荐使用ThreadPoolExecutor来创建线程池，这样可以明确规定线程池的参数，避免资源的耗尽。\n28.线程池使用场景CountDownLatch、Future（你们项目哪里用到了多线程） 参考场景一：\nes数据批量导入\n在我们项目上线之前，我们需要把数据量的数据一次性的同步到es索引库中，但是当时的数据好像是1000万左右，一次性读取数据肯定不行（oom异常），如果分批执行的话，耗时也太久了。所以，当时我就想到可以使用线程池的方式导入，利用CountDownLatch+Future来控制，就能大大提升导入的时间。\n参考场景二：\n在我做那个xx电商网站的时候，里面有一个数据汇总的功能，在用户下单之后需要查询订单信息，也需要获得订单中的商品详细信息（可能是多个），还需要查看物流发货信息。因为它们三个对应的分别三个微服务，如果一个一个的操作的话，互相等待的时间比较长。所以，我当时就想到可以使用线程池，让多个线程同时处理，最终再汇总结果就可以了，当然里面需要用到Future来获取每个线程执行之后的结果才行\n参考场景三：\n《黑马头条》项目中使用的\n我当时做了一个文章搜索的功能，用户输入关键字要搜索文章，同时需要保存用户的搜索记录（搜索历史），这块我设计的时候，为了不影响用户的正常搜索，我们采用的异步的方式进行保存的，为了提升性能，我们加入了线程池，也就说在调用异步方法的时候，直接从线程池中获取线程使用\n29.如何控制某个方法允许并发访问线程的数量？ 在jdk中提供了一个Semaphore[seməfɔːr]类（信号量）\n它提供了两个方法，semaphore.acquire() 请求信号量，可以限制线程的个数，是一个正数，如果信号量是-1,就代表已经用完了信号量，其他线程需要阻塞了\n第二个方法是semaphore.release()，代表是释放一个信号量，此时信号量的个数+1\n30.谈谈你对ThreadLocal的理解 ThreadLocal 主要功能有两个，第一个是可以实现资源对象的线程隔离，让每个线程各用各的资源对象，避免争用引发的线程安全问题，第二个是实现了线程内的资源共享\n31.那你知道ThreadLocal的底层原理实现吗？ 在ThreadLocal内部维护了一个一个 ThreadLocalMap 类型的成员变量，用来存储资源对象\n当我们调用 set 方法，就是以 ThreadLocal 自己作为 key，资源对象作为 value，放入当前线程的 ThreadLocalMap 集合中\n当调用 get 方法，就是以 ThreadLocal 自己作为 key，到当前线程中查找关联的资源值\n当调用 remove 方法，就是以 ThreadLocal 自己作为 key，移除当前线程关联的资源值\n32.那关于ThreadLocal会导致内存溢出这个事情，了解吗？ 嗯，我之前看过源码，我想一下~~\n是因为ThreadLocalMap 中的 key 被设计为弱引用，它是被动的被GC调用释放key，不过关键的是只有key可以得到内存释放，而value不会，因为value是一个强引用。\n在使用ThreadLocal 时都把它作为静态变量（即强引用），因此无法被动依靠 GC 回收，建议主动的remove 释放 key，这样就能避免内存溢出。\n","date":"2024-10-20","permalink":"/posts/tech/java-0-audition-4/","series":["Java"],"tags":[""],"title":"Java面试准备4"},{"categories":["计算机"],"content":"教程的文档非常完善, 这里我只将比较容易忘记的东西记录一下.\nVue2 Vue2核心语法","date":"2024-10-16","permalink":"/posts/tech/js-1-vue/","series":["Js"],"tags":["","",""],"title":"Vue基础"},{"categories":["计算机"],"content":"JD 职位描述： 1、负责制定应用运维管理体系的标准、流程、规范及落地实施，探索、研究新的应用运维技术方向； 2、负责应用服务系统的整体规划、架构设计及优化等工作，保障业务系统性能、可用性与稳定性； 3、负责应用系统灾备体系的建立； 4、负责处理系统方面日常变更、控制突发情况，对疑难问题进行分析并解决； 5、参与设计和优化应用服务系统的监控报警系统、策略和实施。\n任职要求： 1、本科学士及以上，计算机科学，软件科学技术，电子信息工程等相关专业，应届毕业生； 2、有良好的Java基础知识，掌握Spring、SpringMVC、MyBatis、SpringBoot等主流框架技术的应用；具备良好的沟通交流能力、理解能力，条理清晰，认真负责，团队协作意识强；能够按要求撰写技术文档，有良好的工作计划制定和总结习惯；具有较强的学习和独立分析能力、工作责任心。\n个人介绍 我是xxx, 我来自xxxx大学, 今年23岁, 我熟悉Java语法，了解Spring，SpringMVC，Springboot等常见web框架，熟悉Mybatis及MybatisPlus开发过程. 熟悉MySQL数据库，能熟练地进行增删改查等常见操作, 能编写复杂的SQL语句, 了解Mysql性能优化, 掌握SpringCloud微服务技术, 掌握分布式事务, 多线程等高性能开发技术. 在校期间获通过大学英语四级, 获得过计算机三级信息安全技术, 数学建模等奖项和证书.\n知识准备 其他需要的查阅我之前的笔记即可.\n在校项目-问答系统 MyBatis SpringMVC开发流程 SpringBoot开发流程 使用的拦截器是HandlerInterceptor接口实现, 利用preHandle和afterCompletion做用户验证, 用户拦截和方向, 用户删除.\nSpringCloud 用户存储\n1private static final ThreadLocal\u0026lt;Long\u0026gt; tl = new ThreadLocal\u0026lt;\u0026gt;(); 拦截器实现GlobalFilter接口, 利用filter方法做拦截.\nJWT: 配置类实现keyPair方法利用加密文件和密码作为生成. 后面的keyPair来生成jwtSigner, 并且解密和加密都要用到.JWT.create()加密, JWT.of解密\nJava三大特性 封装, 继承, 多态.\n1、封装，就是将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问。\n2、继承，就是子类拥有父类的所有属性和方法，从而实现了实现代码的复用。\n3、多态，就是父类引用指向子类对象，从而产生多种形态。\n工作中异常怎么处理 统一的异常处理包, 定义各种的异常. 有一个父异常继承的RuntimeException\n工作中一般是用try catch处理异常而不是直接抛出去, 在catch部分会构造自己定义的异常, 然后写上异常的原因, 并且还可能发送日志或邮件进行记录.\nthrow和throws的区别 throws 和 throw 是 Java 中间的关键词，但它们的用法不同。\nthrows 关键字用于声明一种方法可能抛出的异常类型。它通常出现在方法的声明中，其次是一种或多种异常类型。在方法体内，可能会出现异常，但不会进行异常处理。调用此方法的代码需要异常处理。\nthrow 关键字用于手动抛出异常。它通常用于方法体内部，后面有一个异常对象。它表示代码运行过程中有特殊情况，需要立即抛出异常。\n总之，throws 用于声明可能抛出的异常， throw 用于手动抛出异常。\n八大排序算法 插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等\n  插入排序不说了.\n  希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。\n希尔排序的基本思想: 先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。\nhttps://www.runoob.com/data-structures/shell-sort.html\n  选择排序, 首先在未排序序列中找到最小(大)元素，存放到排序序列的起始位置, 再从剩余未排序元素中继续寻找最小(大)元素，然后放到已排序序列的末尾。\n  冒泡排序不说了.\n  归并排序将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。, 归并排序是递归算法的一个实例，这个算法中基本的操作是合并两个已排序的数组\n  快速排序不说了\n  堆排序, 堆是一个近似 完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。第一个非叶子节点，我们从它开始逐一向前分别把每个元素作为根节点进行 shift down 操作满足最大堆的性质。\n操作就是先把一个序列映射到堆上(完全二叉树) ,从第一个非叶子节点进行shift down, 如何从一个最大堆中取出一个元素，称为 shift down\nhttps://www.runoob.com/data-structures/heap-sort.html\n  基数排序是桶排序的扩展，它的基本思想是：将整数按位数切割成不同的数字，然后按每个位数分别比较。 具体做法是：将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。\n  List为什么输出内容而不是地址 Object类的toString()方法中,返回的是 getClass().getName() + \u0026quot;@\u0026quot; + Integer.toHexString(hashCode())也就是地址值,打印ArrayList对象没有输出地址值,便可知道ArrayList重写了toString()方法.\n不过这个重写是在外祖父那里重写的.\n分析源码:   使用Iterator迭代器判断集合中是否含有元素,没有的话就只返回一对\u0026quot;[]\u0026quot;\n  在循环外创建StringBuilder对象,先添加左方括号\n  循环集合,添加当前元素到StringBuilder对象\n  判断当前元素是否为最后一位,是则添加右方括号,执行StringBuilder的toString()方法并返回,\n不是则添加一个逗号一位空格,继续下一层循环\n  常量优化机制 https://blog.csdn.net/li847250110/article/details/132112931\n静态常量可以再编译器确定字面量，但常量并不一定在编译期就确定了, 也可以在运行时确定，所以 Java 针对某些情况制定了常量优化机制。\n1、给一个变量赋值，如果“=”号右边是常量的表达式没有一个变量，那么就会在编译阶段计算该表达式的结果。 2、然后判断该表达式的结果是否在左边类型所表示范围内。 3、如果在，那么就赋值成功，如果不在，那么就赋值失败。\n常量优化机制顾名思义，只能有常量参与表达式，不能有变量参与\n这个有很多方面. 这里贴案例自己理解.\n1byte b1 = 1 + 2; 2System.out.println(b1); 3// 输出结果 3 4 5byte b1 = 3; 6byte b2 = 4; 7byte b3 = b1 + b2; 8System.out.println(b3); // 程序报错 9 10byte b1 = 3; 11byte b2 = 4; 12byte b3 = b1 + b2; 13System.out.println(b3); // 程序报错 14byte b4 = b1 + 3; 15System.out.println(b4); // 程序报错 16 17byte b1 = 3; 18byte b3 = b1 + 4; 19System.out.println(b3); // 程序报错 20 21byte b1 = 127 + 2; 22System.out.println(b4); // 程序报错 23 24int num1 = 10; 25final int num2 = 10; 26byte var1 = num1 + 20; // 存在变量，编译报错 27byte var2 = num2 + 20; // 编译通过 28 29int a = 1; 30int b = 2; 31int c = a + b; 32System.out.println(c); 33 34 byte b=1; 35 byte c=2; 36 byte d=1+2;//编译通过正常执行 37 // byte e=b+c;//编译出错 38 byte e=(byte)(b+c);//强转之后不会出错 39 40 41byte var = 10; 42var = var + 20; // 编译报错，运算中存在变量 43var += 20; // 等效于: var = (short) (var + 20); 没有走常量优化机制，而是进行了类型转换 44 45String s1 = \u0026#34;abc\u0026#34;; 46String s2 = \u0026#34;a\u0026#34;+\u0026#34;b\u0026#34;+\u0026#34;c\u0026#34;; 47System.out.println(s1 == s2); //true 48 49String a = \u0026#34;a1\u0026#34;; 50String b = \u0026#34;a\u0026#34; + 1; 51System.out.println((a == b)); //result = true 52 53String a = \u0026#34;atrue\u0026#34;; 54String b = \u0026#34;a\u0026#34; + true; 55System.out.println((a == b)); //result = true 56 57String a = \u0026#34;a3.4\u0026#34;; 58String b = \u0026#34;a\u0026#34; + 3.4; 59System.out.println((a == b)); //result = true 60 61 62String s1 = \u0026#34;ab\u0026#34;; 63String s2 = \u0026#34;abc\u0026#34;; 64String s3 = s1 + \u0026#34;c\u0026#34;; 65System.out.println(s3 == s2); //false 66 67 为什么小数不能进行常量优化 HTTP和HTTPS的区别 1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。\n2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。\n3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。\n4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。\nTCP协议三次握手和四次挥手 三次握手(开始交流) 第一次：客户端向服务端发送连接请求报文段，标识为syn（建立连接），产生一个序列号seq=x，表明传送数据时的第一个数据字节序号为 x\n第二次：服务端的TCP 收到连接请求报文段后，如果同意，则发挥连接同意报文\n服务端在连接同意报文中使用俩个标识SYN和ACK，其随机序列号为seq=y,确认序列号为ack=x+1\n第三次：客户端收到服务端的报文，发送确认报文ACK，随机序列号为seq=x+1，ack=y+1\n四次挥手(挥手再见) TCP是基于全双工通信的，所以双方都可以主动释放连接。 四次挥手的意义就在于，当 A 发送完最后一条数据之后，但可能B还有未发送给A 的数据。 所以A在发送完收据后可以请求释放连接，此时B给与A响应，告诉A我知道你想断开连接，此时A还可以继续接收B发送的信息。 在B处理完工作后，也请求释放连接。A同意后，就断开连接。 这样可以保证数据正常可靠的交互。\n第一次：数据传输结束后，通信双方都可以释放连接\n假设A已经向B传输完数据，A就可以发生释放连接报文段，并停止发送数据，主动关闭TCP连接\nA 连接释放报文首部 FIN，其序列号 seq = u，等待 B 的确认。\n第二次：B收到后，发送确认报文，意思是我收到了确认号 ack = u+1，而这个报文段自己的序号为seq = v\n从A 到 B 这个方向的连接就释放了，TCP 连接处于半关闭状态。B 若发送数据,A仍需要接收\n第三次：当B发送完数据后，就可以释放连接。\nB 发出的连接释放报文 的 FIN，序号为w，ack仍为u+1\n第四次： A 收到连接释放报文后，必须发出确认。确认好 ack = w +1，序号seq = u+1。\n(ack都是在seq的基础上+1, 而sql要么是新生成的, 要么是ack的.)\n如何遍历map数据   使用 for-each 循环遍历 Map.Entry\n1for (Map.Entry\u0026lt;String, Integer\u0026gt; entry : map.entrySet()) { 2 System.out.println(\u0026#34;Key: \u0026#34; + entry.getKey() + \u0026#34;, Value: \u0026#34; + entry.getValue()); 3}   使用 for-each 循环遍历 keySet\n1for (String key : map.keySet()) { 2 Integer value = map.get(key); 3 System.out.println(\u0026#34;Key: \u0026#34; + key + \u0026#34;, Value: \u0026#34; + value); 4 }   使用 Iterator 遍历 Map.Entry\n1Iterator\u0026lt;Map.Entry\u0026lt;String, Integer\u0026gt;\u0026gt; iterator = map.entrySet().iterator(); 2 while (iterator.hasNext()) { 3 Map.Entry\u0026lt;String, Integer\u0026gt; entry = iterator.next(); 4 System.out.println(\u0026#34;Key: \u0026#34; + entry.getKey() + \u0026#34;, Value: \u0026#34; + entry.getValue()); 5 }   使用 Stream API 遍历 Map\n1map.entrySet().stream() 2 .forEach(entry -\u0026gt; System.out.println(\u0026#34;Key: \u0026#34; + entry.getKey() + \u0026#34;, Value: \u0026#34; + entry.getValue())); 3 } 4   HashMap为什么要扩容 HashMap的默认大小是16。\n当HashMap里面的元素个数超过临界值的时候会自动触发扩容。等于负载因子 乘以 容量大小，负载因子的默认值是0.75，而容量大小默认是16,。也就是说，第1次扩容的动作会在元素个数达到12的时候触发，扩容的大小是原来的2倍。HashMap的最大容量是Integer.MAX_VALUE也就是2的31次方减1。\n由于动态扩容机制的存在，所以我们在实际应用的时候，最好在集合初始化的时候明确去指定集合的大小，从而避免频繁扩容带来性能上的消耗。\nJVM内存模型 方法区, 虚拟机栈, 本地方法栈, 堆(新生代, 老年代), 程序计数器\n工作中SQL如何优化的  对insert, 分成多个insert, 按主键顺序插入.同时手动事务提交. 或者用load指令 对主键, 降低主键长度, 插入数据尽量顺序插入, 尽量不要使用UUID做主键或者其他自然主键, 如身份证, 业务操作避免对主键的修改. 对order by, 根据排序字段建立合适的索引, 多字段排序时, 遵循最左前缀法则. 尽量使用覆盖索引, 多字段排序, 一个升序一个降序, 此时需要注意联合所以在创建时的规则, 如果不可避免的出现filesort, 大数据量排序时, 可以适当增大排序缓冲区大小 对于group by, 还是根据分组字段创建索引, 准寻最左前缀法则 对于limit分页, 一般分页查询时, 通过创建覆盖索引能够较好地提高性能, 可以通过覆盖查询+子查询的形式进行优化 count, count(*) ≈ count(1) \u0026gt; count(主键) \u0026gt; count(字段) update, Innodb的行锁是针对索引加的锁, 不是针对记录加的锁, 使用的条件一定要有索引不然就是表锁; 该索引不能失效, 否则行锁变为列锁  Spring和SpringMVC的区别(实现原理) Spring是一个综合性的应用程序开发框架，提供了依赖注入、面向切面编程、事务管理等功能，旨在简化企业级应用程序的开发。而Spring MVC是Spring框架中的一个模块，用于Web应用程序的开发，实现了MVC（Model-View-Controller）模式。\nSpring的核心功能是IoC容器和AOP，它可以帮助开发者管理对象之间的依赖关系，实现松耦合的应用程序设计。而Spring MVC的核心功能是控制器、视图解析器等Web相关组件，用于协调请求和响应之间的关系，实现Web应用程序的开发。\nSpring是一个综合性的框架，可以与其他模块集成，如Hibernate、iBatis、JMS、JDBC等。而Spring MVC是基于Spring功能之上添加的Web框架，它已经集成了这些模块的功能，使得开发者可以更快速地开发Web应用程序。\n为什么用SpringBoot, 去掉SSM框架 编码更简单(与第三方框架快速整合), 配置变得更简单(Application.yaml, 不需要多个配置文件), 部署更简单(启动类Application一键部署, 不需要tomcat).\nSpringMVC, SpringBoot, SpringCloud三者区别 Spring和SpringMVC：Spring是一站式轻量级java开发框架，其核心是控制反转（IOC）和面向切面（AOP），为开发WEB层而开发的WEB(springMvc)、业务层(Ioc)、持久层(jdbcTemplate)SpringMVC是Spring基础上的MVC框架，主要处理web开发的路径映射和视图渲染，属于spring框架中web层开发的一部分；\nSpringMVC VS SpringBoot：SpringMVC属于企业WEB开发的MVC框架，包括前端视图开发、文件配置、后台接口逻辑开发等，XML、config等配置比较复杂；与SpringMVC框架相比，SpringBoot框架更注重微服务后台接口的开发，而不是前端视图的开发；\nSpringBoot和SpringCloud：SpringBoot采用默认大于配置的概念，集成了快速开发的多个Spring插件，自动过滤不需要配置的多余插件，简化了项目的开发配置过程，在一定程度上取消了xml配置，是一套快速配置开发的脚手架，单个微服务可以快速开发；SpringCloud的大部分功能插件都是基于SpringBoot实现的。SpringCloud注重整体微服务的整合和管理，整合和管理多个SpringBoot单个微服务；SpringCloud依赖于SpringBoot开发，SpringBoot可以独立开发；\n@Autowired和@resource区别 1.来源不同 @Autowired 和 @Resource 来自不同的“父类”，其中 @Autowired 是 Spring 定义的注解，而 @Resource 是 Java 定义的注解\n2.依赖查找顺序不同 依赖注入的功能，是通过先在 Spring IoC 容器中查找对象，再将对象注入引入到当前类中。而查找有分为两种实现：按名称（byName）查找或按类型（byType）查找，其中 @Autowired 和 @Resource 都是既使用了名称查找又使用了类型查找，但二者进行查找的顺序却截然相反。 @Autowired 先根据类型（byType）查找，如果存在多个（Bean）再根据名称（byName）进行查找； @Resource 先根据名称（byName）查找，如果（根据名称）查找不到，再根据类型（byType）进行查找。\n3.支持的参数不同\n4.依赖注入的支持不同 @Autowired 支持属性注入、构造方法注入和 Setter 注入，而 @Resource 只支持属性注入和 Setter 注入\nRedis怎么用的, Redis分布式锁 ES如何同步数据 开发项目流程","date":"2024-08-13","permalink":"/posts/tech/java-0-audition-3/","series":["Java"],"tags":[""],"title":"Java面试准备3"},{"categories":["计算机"],"content":"题目来源: https://www.nowcoder.com/\n好像是以选择题的形式, 所以暂时准备选择题.\n刷了一下感觉没什么意思, 还是搞算法吧.\n京东2019春招京东Java开发类试卷   在对问题的解空间树进行搜索的方法中，一个结点有多次机会成为活结点的是: 回溯法\n  京东商城plus会员的消费记录金额分别为900，512，613，700，810，若采用选择排序算法对其进行从小到大的排序，第三趟排序结果为：512，613，700，900，810\n(关于选择排序: 给定一个数组arr,其长度为n; 第一次从 arr[0] 到 arr[n-1] 中选取一个最值（按照需求，可以是最大值，可以是最小值，下同）与arr[0]进行交换; 第二次从arr[1] 到 arr[n-1] 中选取一个最值与arr[1]进行交换； 以此类推，直到arr[n-2]到arr[n-1]中选出最值交换后即完成排序。)\n  线性链表中的各元素在存储空间中的位置不一定是连续的，且各元素的存储顺序也是任意的\n  关于TCP协议的描述，错误的是可提供多播服务, 广播和多播仅应用于UDP；TCP是一个面向连接的协议.\n  在 bash shell 环境下，当一命令正在执行时，按下 control-Z 会将前台任务转入后台\n  对象间存在一对多关系，当一个对象被修改时，则会自动通知它的依赖对象，采用观察者模式设计模式最好 (观察者模式：对象间存在一对多关系，如果一个对象被修改时，会自动通知它的依赖对象。)\n  关于redis说法错误的是分区可以让Redis管理更大的内存. Redis Cluster在设计中没有使用一致性哈希(Consistency Hashing),而是使用数据分片引入哈希槽(hash slot)来实现\n  元数据区区域不属于新生代. Java 中的堆是 JVM 所管理的最大的一块内存空间，主要用于存放各种类的实例对象。 在 Java 中，堆被划分成两个不同的区域：新生代 ( Young )、老年代 ( Old )。新生代 ( Young ) 又被划分为三个区域：Eden、From Survivor、To Survivor。这样划分的目的是为了使 JVM 能够更好的管理堆内存中的对象，包括内存的分配以及回收。\n  程序:\n1int a =100,b=50,c=a---b,d=a---b; 2 System.out.println(a); 3 System.out.println(b); 4 System.out.println(c); 5 System.out.println(d); 输出98 50 50 49, 这样看: a\u0026ndash; -b, a\u0026ndash; -b.\n  JVM内存不包含Heap Frame. 包含Heap, Stacks, PC寄存器\n  java有8种基本类型，请问byte、int、long、char、float、double、boolean各占1 4 8 2 4 8 1字节.\n  程序:\n1Integer a = 1; 2Integer b = 1; 3Integer c = 500; 4Integer d = 500; 5System.out.print(a == b); 6System.out.print(c == d); 返回true、false. Integer类型在-128\u0026ndash;\u0026gt;127范围之间是被缓存了的，也就是每个对象的内存地址是相同的，赋值就直接从缓存中取，不会有新的对象产生，而大于这个范围，将会重新创建一个Integer对象，也就是new一个对象出来，当然地址就不同了，也就！=；\n  java8中，HashMap类用到了解决哈希冲突的开放定址法\n  当我们需要所有线程都执行到某一处，才进行后面的的代码执行我们可以使用CyclicBarrier. CountDownLatch 是等待一组线程执行完，才执行后面的代码。此时这组线程已经执行完。 CyclicBarrier 是等待一组线程至某个状态后再同时全部继续执行线程。此时这组线程还未执行完。\n  volatile能保证数据的可见性，但不能完全保证数据的原子性，synchronized即保证了数据的可见性也保证了原子性. volatile关键字是线程同步的轻量级实现，所以volatile性能肯定比synchronized关键字要好。但是volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块。实际开发中使用 synchronized 关键字的场景还是更多一些。\n多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞\nvolatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证。\nvolatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized关键字解决的是多个线程之间访问资源的同步性。\n  在方法中，修改一个基础类型的参数不会影响原始参数值; 在方法中，改变一个对象参数的引用不会影响到原始引用(Java中方法的参数传递都是值传递); 在方法中，修改一个对象的属性会影响原始对象参数; 在方法中，修改集合和Maps的元素会影响原始集合参数.\n  spring默认使用jdk动态代理，那么下面配置\u0026lt;aop:aspectj-autoproxy proxy-target-class=\u0026ldquo;true\u0026rdquo;/\u0026gt;是开启强制使用cglib代理\n  算法的基本要素有对数据对象的运算和操作和算法的控制结构.\n  执行以下shell语句，可以生成/test文件的是（假定执行前没有/test文件）：touch /test, a=\\touch /test, \u0026gt;/test\n  不合法的shell头是(不合法指运行会报错)：!#/bin/bas (如果不是#!开头的话默认都是认为是注释的)\n  可以用来获取shell脚本参数的是$1, $*\n  Redis支持的数据类型是 String hash list set sortedset\n  数据结构 数组  长度为n 的非空顺序表，若在第i个位置插入新的元素X，则i的取值范围是 1≤i≤n+1，需要移动的元素个数为n-i+1 数组A[8][10] 中（下标均从0开始）， 每个元素的长度为3个字节，按列存储时，元素A[4][7]的起始地址为（SA为数组存储时的首地址）SA+180 稀疏矩阵压缩的存储方法是三元组, 十字链表.  字符串   执行以下代码段(程序已包含所有必需的头文件)会输出4, 3\n1 char a[] = \u0026#34;abc\u0026#34;; 2 char b[] = {\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;}; 3 printf(\u0026#34;%d, %d\u0026#34;, sizeof(a), sizeof(b)); 不同的是数组a的长度是4个字符，而数组b的长度为3个字符，因为字符串后面会有一个'\\0\u0026rsquo;作为结束符\n  有如下一段代码，The phrase of PRAISE has 42 letters and occupies 43 memory cells.是该段代码的正确输出。\n1int main(){ 2 printf(\u0026#34;The phrase of PRAISE has %zd letters \u0026#34;,strlen(PRAISE)); 3 printf(\u0026#34;and occupies %zd memory cells.\u0026#34;,sizeof(PRAISE)); 4 return 0; 5} 使用strlen可得到字符串中包括空格和标点符号在内的字符数。\n使用sizeof运算符，得到的数会更大，因为它会把字符串末尾不可见的空字符也计算在内\n  设栈的初始状态为空，当字符序列 \u0026ldquo;a3_\u0026rdquo; 作为栈的输入时，输出长度为 3 的且可以用作 C 语言标识符的字符串序列有3个。(C语言的标识符不能以数字开头，去除3a_和3_a 答案为3)\n  已知串 S= \u0026ldquo;babab \u0026ldquo;, 其 Next 数值序列为01123.\nNext数值序列需要计算字符串前缀和后缀最长匹配相同的长度加一而得。\n第1位一定是0\n看S第一位“b” ，没有前缀和后缀 所以一般第2位一定是1（0+1）；\n看S.substring（0,2）“ba” 前缀b后缀a，相等长度为0，第3位是1（0+1）；\n看S.substring（0,3）“bab” 前缀b=后缀b，相等长度为1，第4位是2（1+1）；\n看S.substring（0,4）“baba” 前缀ba=后缀ba，相等长度为2，第5位是3（2+1）；\n则S的Next数值序列为 01123\n  Java中，String类型的数据存放有两种情况；\n如果是String s=“nowcoder”,则是放在字符串常量池中。\n如果是String ss=new String(\u0026ldquo;nowcoder\u0026rdquo;)，则是放在堆中。\n  由 4 个 \u0026ldquo;1\u0026rdquo; 和 4 个 \u0026ldquo;0\u0026rdquo; 组成的 8 位二进制补码，能表示的最小整数是：-121. 最大和最小分别是01111000 10000111,那么10000111的原码是11111001为-121\n  已知一段文本有1382个字符，使用了1382个字节进行存储，这段文本全部是由a、b、c、d、e这5个字符组成，a出现了354次，b出现了483次，c出现了227次，d出现了96次，e出现了232次，对这5个字符使用哈夫曼（Huffman）算法进行编码，则\nA正确，Huffman树就是求最优解。可以有多套方案，但最终每套方案生成的编码长度都相同且都是最优解。\nB错误，我们可以将左子树定为1右子树定为0也可以反之，不同的方案获得的编码值是不同的，但每个字符的编码长度是固定的。\nC正确，不同的方案影响的只是通向节点的路径为0还是1，而不会影响Huffman树的层次结构\nD正确，生成了Huffman树之后，我们就能看到，出现频率越高的节点越靠近根，深度越小即编码值尾数越短；出现频率越低的节点越远离根，深度越大即编码位数越长。\n  字符串是一种对象, 是一种数据类型, 是一种引用数据类型.\n  链表   关于线性表的说法不正确的是线性表中的每个结点都有且只有一个直接前趋和直接后继。\n线性表中的数据元素可以是数字、字符、记录等不同类型。(Object类)\n线性表中包含的数据元素个数不是任意的。(顺序表提前分配好空间)\n存在这样的线性表：表中各结点都没有直接前趋和直接后继。(空表, 单元素表)\n是正确的.\n  某线性表中最常用的操作是在最后一个元素之后插入一个元素和删除第一个元素,则采用仅有尾指针的单循环链表存储方式最节省运算时间。\n  栈  链栈与顺序栈相比，其特点之一是通常不会出现栈满的情况。采用链栈不必预先估计栈的最大容量，只要系统有可用空间，就不会溢出。 new 创建对象时，对象的内存和指向对象的指针分别分配在堆区，栈区 堆：自己做菜自己吃，什么时候收盘子自己知道，但是可能会浪费（产生碎片），因为可能自己一个人吃不完。 桟：公司食堂，你吃饭由食堂工作人员帮你打饭和分配位置，吃完了工作人员帮你收盘子。你浪费粮食（碎片）那是不可能的，因为食堂会把碎片拿去喂猪。 局部变量是分配在栈上的，new出来的对象是分配在堆上的 用俩个栈模拟实现一个队列，如果栈的容量分别是O和P(O\u0026gt;P)，那么模拟实现的队列最大容量是2P+1  队列   用链接方式存储的队列，在进行删除运算时头、尾指针可能都要修改.\n1\u0026gt; 当有多于一个节点时，链表表示的队列的删除操作只需要修改头指针即可，将头指针定义为head=head.next 此时不需要修改尾指针；\n2\u0026gt; 当队列只有一个节点时，该节点既是头又是尾，如果head==tail 则需要修改尾指针将队列置空。\n  已知循环队列存储在一维数组A[0..n-1]中，且队列非空时 front 和 rear 分别指向队头和队尾元素。若初始时队列为空，且要求第 1 个进入队列的元素存储在 A[0]处，则初始时 front和 rear 的值分别是0， n-1.\n当进元素时，rear将后移，以便指向新的队尾元素。出队时，front后移，更新指向新的队头。\n反推，front不用动，但是rear要退一个位置，往哪退？按照循环，第一个元素位置可以直接到最后一个位置上，因此，如图所示。所以在数组中初态就是0，n-1.\n  某带链的队列初始状态为 front=rear=NULL 。经过一系列正常的入队与退队操作后， front=rear=10 。该队列中的元素个数为1.\n初始时 front=rear=0 , 插入第 1 个元素时， rear+1 指向该元素， front+1 也指向该元素，插入第 2 个元素时 rear+1 ， front 不变，删除 1 个元素时 front+1 。即 front=rear 不为空时带链的队列中只有一个元素。\n  基础算法 复杂度   设某堆中有 n 个结点，则在该堆中插入一个新结点的时间复杂度为 O(log2n)\n  归并排序法的最好时间复杂度和此情况下的空间复杂度分别是O(nlogn) 和O(n)\n  一个算法所需时间由下述递归方程表示：T(n)=2T(n/2)+n, 该算法的时间复杂度是O(n*log(n))\n  给定一个递归算法的时间复杂度表达式，为T(n)=4T(n/2)+3n^2+2n , 则该算法的时间复杂度为O(n^2 * logn)\n(master公式: T(N)=a*T(N/b) + O(N^d), 则当logba \u0026lt; d时, O(N^d)); 当logba\u0026gt;d, O(N^logba); 当logba=d, O(N^d * logN) ) logba是以b为底a的对数.\n   排序   归并排序平均时间复杂度为O(nlogn)\n选择排序平均时间复杂度为O(n^2)\n希尔排序平均时间复杂度为O(n^1.5)\n堆排序平均时间复杂度为O(nlogn)\n冒泡排序平均时间复杂度O(n^2)\n  插入排序是一种最简单的排序方法，它的基本操作是将一个记录插入到已排好序的有序表中，从而得到一个新的、记录数增1的有序表。\n冒泡排序每轮排序从前往后扫，如果当前位置的数比其后面相邻的数大，则交换两个位置的数。\n希尔排序为插入排序的改进，先将序列分成若干个子序列进行直接插入排序，待整个序列中的记录“基本有序”是，再对全体记录进行依次直接插入排序。\n快速排序从未排序序列中选择一个元素，该元素将当前参加排序的那些元素分成前后两个部分，前一部分中所有元素都小于等于所选元素，后一部分中所有元素都大于等于所选元素，而所选元素处在排序的最终位置。\n  采用递归方式对顺序表进行快速排序, 递归次数与每次划分后得到的分区处理顺序无关\n  基本有序的情况下：快排最慢，堆排最快。\n直接插入排序是数据越有序越快，最快时间复杂度可达到O(n) .\n选择排序无论何时都是O（n^2）\n归并排序固定O(n*log n)，有序只是减少了元素交换次数。\n快速排序越有序越慢，它要从后到前遍历找比基准小的，时间复杂度达到O(n)\n  精俭排序，即一对数字不进行两次和两次以上的比较，是“精俭排序”的是插入排序, 归并排序\n  查找 哈希   设哈希表长m=13,哈希函数H(key)=key MOD 11。表中已有4个节点:addr(16)=5,addr(28)=6,addr(84)=7,addr(19)=8，其余地址为空,如用线性探测再散列处理冲突，则关键字为38的地址为9\n  假设把整数关键码K散列到有N个槽的散列表，h(k)=k mod N是好的散列函数, 而h(k)=(k + Random(N )) mod N；Random(N)返回一个0到N-1的整数不是. 使用随机函数可以使得数更均匀随机地分布在各个槽中，但当查找时由于散列函数是个随机函数所以得到的值对应的槽内可能压根没有放关键码k，可能会使得查找失败。\n  一个线性序列（30，14，40，63，22，5），假定采用散列函数Hash(key)=key%7来计算散列地址，将其散列存储在A[0~6]中，采用链地址法解决冲突。若查找每个元素的概率相同，则查找成功的平均查找长度是4/3.\n  线程安全的map在JDK 1.5及其更高版本环境 有哪几种方法可以实现:\nMap map = new ConcurrentHashMap();\nMap map = Collections.synchronizedMap(new HashMap());\n1.HashMap,TreeMap 未进行同步考虑，是线程不安全的。\n2.HashTable 和 ConcurrentHashMap 都是线程安全的。区别在于他们对加锁的范围不同，HashTable 对整张Hash表进行加锁，而ConcurrentHashMap将Hash表分为16桶(segment)，每次只对需要的桶进行加锁。\n3.Collections 类提供了synchronizedXxx()方法，可以将指定的集合包装成线程同步的集合。比如， List list = Collections.synchronizedList(new ArrayList()); Set set = Collections.synchronizedSet(new HashSet());\n  递归   求解第n个斐波那契数的递归写法，分析它的时间复杂度是O(2^N)\n1int func(unsigned int n) 2{ 3 if(n\u0026lt;2) 4 return n; 5 return fabonaci(n-1) + fabonaci(n-2); 6}   计算机基础 设计模式   如果需要在不影响其他对象的情况下，以动态，透明的方式给对象添加职责，应该选择装饰模式.\n  假设一个电源总开关可以控制四盏灯、一个风扇、一台空调和一台电视机的启动和关闭。通过该电源总开关可以同时控制上述所有电器设备，可以使用外观模式来模拟设计该系统。\n  不同级别的用户对同一对象拥有不同的访问权利或某个客户端不能直接操作到某个对象，但又必须和那个对象有所互动，这种情况最好使用Proxy模式设计模式。\n  KFC套餐一般包含主食（如汉堡、鸡肉卷等）和饮料（如果汁、可乐等）等组成部分，不同的套餐有不同的组成部分，而KFC的服务员可以根据顾客的要求，一步一步装配这些组成部分，构造一份完整的套餐，然后返回给顾客。可以使用建造者模式描述KFC如何创建套餐。\n  创建型模式关注的是对象创建\n  共享网络设备模拟：很多网络设备都是支持共享的，如交换机、集线器等，多台终端计算机可以连接同一台网络设备，并通过该网络设备进行数据转发。共享网络设备可以使用享元模式模拟共享网络设备的设计原理。\n  策略模式和模板模式的联系与区别 策略模式和模板模式在某些应用场景下可以互换。 模板模式使用的是继承关系实现，策略模式使用的是组合关系实现。 模板模式倾向于把解决问题过程定义为一个完整框架，把过程中的若干实现步骤延迟到子类中实现。\n  用户已经有一个两相插座，最的又买了一个三相插座。现在用户想使用新的三相插座来使用三相的洗衣机和二相插座的电视机，这种问题可以使用适配器模式模式来进行设计。\n  在模拟毛笔的使用过程中提供了大中小3种型号的画笔，够绘制5种不同颜色。我们可以使用桥接来模拟实现模拟毛笔的使用。\n  关于简单工厂模式与工厂方法模式\n1、简单工厂模式中包含判断什么对象的逻辑，而工厂方法模式则需要调用者判断要实例化什么具体类型的工厂进而创建出想要的对象。当增加新类时，简单工厂模式需要修改工厂类，而工厂方法模式不需要，因此工厂方法模式遵守了开闭原则，而简单工厂模式没遵守。\n2、简单工厂模式因为采用了静态方法，所以不利于继承，而工厂方法模式恰恰相反，需要利用到继承来从抽象工厂中派生出各种各样的具体工厂。\n3、工厂模式就是为了消除if else\n  工厂模式可理解为：当客户获取产品时，工厂模式作为获取产品的接口。\n1、简单工厂模式：由接口直接负责获取产品\n2、工厂方法模式：客户必须清楚地指出想获取哪种产品；由接口的子类负责获取产品\n3、抽象工厂模式：客户不知道其想获取哪种产品；由接口中判断调用哪个子类，通过子类获取产品。\n  网络基础  www.tsinghua.edu.cn   cn：顶级域名\nedu：二级域名\ntsinghua：三级域名\nwww：主机名（万维网主机）\n DNS（端口53）同时占用UDP和TCP是公认的，DNS在进行区域传输或者响应报文超过512字节的时候使用TCP协议，其它时候则使用UDP协议。\n  IP数据报分片在信源机或者路由器，重组在目的机\n  一台交换机具有 24 个 10/100Mbps 全双工端口和 2 个 1000Mbps 全双工端口，如果所有的端口都工作在全双工状态，那么交换机总带宽等于8.8Gbps。\n  数据库   设有两个数据库表，父表和子表之间是一对多的联系，为控制子表和父表的关联，可以设置\u0026quot;参照完整性规则\u0026rdquo;，为此要求这两个表在父表连接字段上建立主索引，在子表连接字段上建立普通索引.\n  Mysql中表student_table(id,name,birth,sex)，插入如下记录：\n(\u0026lsquo;1004\u0026rsquo; , \u0026lsquo;张三\u0026rsquo; ,\u0026lsquo;2000-08-06\u0026rsquo; , \u0026lsquo;男\u0026rsquo;); (\u0026lsquo;1009\u0026rsquo; , \u0026lsquo;李四\u0026rsquo;, \u0026lsquo;2000-01-01\u0026rsquo;, \u0026lsquo;男\u0026rsquo;); (\u0026lsquo;1010\u0026rsquo; , \u0026lsquo;李四\u0026rsquo;, \u0026lsquo;2001-01-01\u0026rsquo;, \u0026lsquo;男\u0026rsquo;); (\u0026lsquo;1006\u0026rsquo; , \u0026lsquo;王五\u0026rsquo;, \u0026lsquo;2000-08-06\u0026rsquo; , \u0026lsquo;女\u0026rsquo;); (\u0026lsquo;1008\u0026rsquo; , \u0026lsquo;张三\u0026rsquo;, \u0026lsquo;2002-12-01\u0026rsquo;, \u0026lsquo;女\u0026rsquo;); (\u0026lsquo;1012\u0026rsquo; , \u0026lsquo;张三\u0026rsquo;, \u0026lsquo;2001-12-01\u0026rsquo;, \u0026lsquo;女\u0026rsquo;); (\u0026lsquo;1011\u0026rsquo; , \u0026lsquo;李四\u0026rsquo;, \u0026lsquo;2002-08-06\u0026rsquo; , \u0026lsquo;女\u0026rsquo;);\n执行\nselect t1.,t2. from ( select * from student_table where sex = \u0026lsquo;男\u0026rsquo; ) t1 right join (select * from student_table where sex = \u0026lsquo;女\u0026rsquo;)t2 on t1.name = t2.name ; 的结果行数是5\n1）不论左右连接，两表排序都是先写的放在左边，后写的放在右边 2）左右连接中，以谁为主表，则其信息全部保存。从表中有多于一项符合条件的，则额外重复一次主表从而列出全部从表情况\n  ACCESS中表和数据库的关系是一个数据库可以包含多个表\n  3NF消除主属性对码的部分和传递函数依赖规范化为BCNF。\n  数据库三级模式体系结构的划分，有利于保持数据库的 数据独立性\n  在高并发的线上事务中，几乎无法避免锁等待或死锁的产生\n  有关系 R 和 S ， R －（ R － S ）的运算等价于R∩S\n  左连接时，结果集的行数可能大于左表的行数\n  概念数据模型是现实世界到信息世界的第一层抽象。 数据结构模型是对现实世界进行的第二层抽象。\n  操作系统  相比于单道程序设计（内存中仅有一道作业），多道程序设计按照一定的作业调度算法将作业队列中的作业调入内存，使他们共享CPU和各种资源。因此需要更大的内存以容纳超过一道的作业。 不管系统中是否有线程，进程都是拥有资源的独立单位. 用户级线程切换不涉及内核，在进程的时间片内，由用户程序控制线程的切换，然后使用进程获取的资源. 对于普通的操作系统，未引入线程的话，进程是系统进行资源分 配和调度的独立单位。在多处理机操作系统中，引入线程后，进程是资源的分配单 位或者叫做资源的容器，线程是处理机的调度单位。 renice命令可以改变进程的优先级 使用一个信号量协调6个进程对4个同类临界资源的访问, 信号量值可以出现-2 到 4 连续分配方式可能产生外部碎片，可以考虑采用“紧凑”的方法将内存中所有作业进行移动，从而使得外部碎片集中在一起形成一个大的分区。为了使移动后的作业能正常运行，需要进行动态重定位. 为了实现设备独立性，在操作系统中，用户在使用I/O设备时，通常采用逻辑设备名 软链接也叫符号链接, 如果原始文件被删除，所有指向它的软链接也都被破坏, 软链接指明了原始文件的位置，用户需要对原始文件的位置有访问权限才可以使用, 软链接可以跨文件系统，可以指向远程文件系统的文件 页表的作用是实现从页号到物理块号的地址映射 32位处理器是指处理器的数据总线是32位的 静态重定位的时机是程序装入时 在段式存储管理中，一个段是一个不定长的连续区域。  Java   抽象类必须有“abstract class”修饰, 抽象类是可以实现接口的，而且抽象类也可以继承自抽象类 , 抽象类指有abstract修饰的class，其可以包含抽象方法，也可以不包含 , 抽象类和接口都是不能被实例化的，只有具体的类才可以被实例化\n  下面程序的运行结果是pongping\n1public static void main(String args[]) { 2 3 Thread t = new Thread() { 4 public void run() { 5 pong(); 6 } 7 }; 8 9 t.run(); 10 System.out.print(\u0026#34;ping\u0026#34;); 11} 12 13 static void pong() { 14 System.out.print(\u0026#34;pong\u0026#34;); 15 } 16 17 t.run是调用的Thead类中的run()方法，t.start才是执行线程，所以这题就是执行普通run()方法，先输出pong，在输出ping。 t.start是另起线程，与当前线程同时竞争cpu资源，结果存在不确定性\n  Log4j的日志打印级别不可以在运行时重新设置\n  方法重载：同一类中的相同的方法名，参数和返回值均可不同。 方法重写：之类对父类已经实现的方法重新定义。\n  int a = \u0026lsquo;2\u0026rsquo;,这种定义与int a = 2是完全不同的\nint a = \u0026lsquo;2\u0026rsquo;中的数字2使用单引号来表示字符2，字符2对用的ascii码值是50，因此这种情况下，a的值是50\nint a = 2中的数字2表示了数字本身，这种情况下，a的值是2\n  创建并启动线程的过程为：定义线程-\u0026gt;实例化线程-\u0026gt;启动线程。\n定义线程有两种方式，一种是继承java.lang.Thread类，一种是实现java.lang.Runnable接口。这两种方式实例化线程区别在于，如果是继承了Thread类，直接new一个对象就可以了，如果是实现了Runnable接口的类，则需要用Thread的构造方法new Thread(new MyRunnable()).start()\n  CMS垃圾回收器在初始标记, 重新标记阶段是没用用户线程参与的\n  事务隔离级别是由数据库系统实现的\n  new URL()时必须捕获检查异常，但这个异常是由于字符串格式和URL不符导致的，与网址是否存在无关。URL的toString方法返回字符串，无论网址是否存在。\n  抽象类中可以有普通成员变量，接口中没有普通成员变量。抽象类和接口中都可以包含静态成员常量。一个类可以实现多个接口，但只能继承一个抽象类. 抽象类中可以包含非抽象的普通方法，接口中的方法必须是抽象的，不能有非抽象的普通方法。\n  java中创建对象有以下几种方法：\n1.用new语句创建对象，这是最常用的创建对象的方式。\n  ​ 2.运用反射手段，调用java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法。 3.调用对象的clone()方法。 4.运用反序列化手段，调用java.io.ObjectInputStream对象的readObject()方法.   下面的输出结果是false\n1public class Demo { 2 public static void main(String args[]) 3 { 4 String str=new String(\u0026#34;hello\u0026#34;); 5 if(str==\u0026#34;hello\u0026#34;) 6 { 7 System.out.println(\u0026#34;true\u0026#34;); 8 } 9 else { 10 System.out.println(\u0026#34;false\u0026#34;); 11 } 12 } 13} ==判断的是对象引用地址是否相同， String str=new String(\u0026ldquo;hello\u0026rdquo;); 这句话new了一个新的String对象，所以地址与\u0026quot;hello\u0026quot;字符串常量的地址不同，答案为false 如果判断字符串是否相等应给用str.equals(\u0026ldquo;hello\u0026rdquo;)方法\n  ArrayList list = new ArrayList(20);中的list扩充0次. Arraylist默认数组大小是10，扩容后的大小是扩容前的1.5倍，最大值小于Integer 的最大值减8，如果新创建的集合有带初始值，默认就是传入的大小，也就不会扩容\n  以下代码结果是代码可以编译运行，输出“AB.B”。\n1public class foo { 2 public static void main(String sgf[]) { 3 4 StringBuffer a=new StringBuffer(\u0026#34;A\u0026#34;); 5 6 StringBuffer b=new StringBuffer(\u0026#34;B\u0026#34;); 7 8 operate(a,b); 9 10 System.out.println(a+\u0026#34;.\u0026#34;+b); 11 } 12 static void operate(StringBuffer x,StringBuffer y) { 13 x.append(y); 14 y=x; 15 } 16} a,b,x,y就是四个指针. “=”, y就指向了x所指向的目标即是a指向的对象，因此原来b所指向的目标并没有发生任何改变。\n  下列程序运行的结果good and gbc\n1public class Example{ 2 String str = new String(\u0026#34;good\u0026#34;); 3 char[ ] ch = { \u0026#39;a\u0026#39; , \u0026#39;b\u0026#39; , \u0026#39;c\u0026#39; }; 4 public static void main(String args[]){ 5 Example ex = new Example(); 6 ex.change(ex.str,ex.ch); 7 System.out.print(ex.str + \u0026#34; and \u0026#34;); 8 System.out.print(ex.ch); 9 } 10 public void change(String str,char ch[ ]){ 11 str = \u0026#34;test ok\u0026#34;; 12 ch[0] = \u0026#39;g\u0026#39;; 13 } 14} 首先说下String确实是个不可变对象，这个不可变是JDK特有的，写JAVA的人特意针对的\n但是这与本题无关，题目中的形参str只是原引用ex.str的一个引用副本，传的是一个副本地址值，这个值与ex.str地址值是不一样的,但是它们同时指向了堆中的对象new String(\u0026ldquo;good\u0026rdquo;)，当你在函数中改变形参也就是地址的副本值也就是这句str=\u0026ldquo;test ok\u0026quot;只是将副本地址指向常量\u0026quot;test ok\u0026rdquo;，并没有改变原ex.str的指向方向，它还是指向对象new String(\u0026ldquo;good\u0026rdquo;)的\nchar数组与String一样传的也是地址的副本，但是关键是形参ch它没有新的指向 ch[0]只是ch在指向原对象时改变了对象的内部结构, 所以在ex.ch指向与它是同一个对象的情况下当然也会随之变化\n  静态方法中没有this关键词，因为静态方法是和类同时被加载的，而this是随着对象的创建存在的，静态比对象优先存在. 静态可以访问静态，但静态不能访问非静态而非静态可以访问静态。\n在静态方法中可直接调用本类的静态方法，也可以通过类名.静态方法名的方式来调用其他类的静态方法\n静态方法不能直接调用实例方法和对象，但可以通过在静态方法中创建类的实例的方式间接调用。\n  HashMap是非线程安全的，其对应的线程安全类是HashTable\nVector(相当于一个线程安全的List), StringBuffer(相当于一个线程安全的StringBuilder), Properties是线程安全的\n  interface中的方法默认为public abstract 的 ，变量默认为public static final\n接口中不允许有static类型的方法\nJDK8及以后，允许我们在接口中定义static方法和default方法。\n在jdk8之前，interface之中可以定义变量和方法，变量必须是public、static、final的，方法必须是public、abstract的。这些修饰符都是默认的\n ","date":"2024-08-08","permalink":"/posts/tech/java-0-audition-2/","series":["Java"],"tags":[""],"title":"Java面试准备2"},{"categories":["计算机"],"content":"参考资料:\nhttps://www.bilibili.com/video/BV1NY411P7VX?vd_source=0885d58575f3c82f15a5a40588fe0cd5\nhttps://github.com/HelloWorld521/swagger2-boot-starter/tree/master/swagger2-boot-starter\nhttps://www.cnblogs.com/progor/p/13297904.html\nhttps://blog.csdn.net/cj151525/article/details/140099389\n一, SpringBoot自动配置原理 自动装配和自动配置 自动配置(Auto-Configuration): 基于引入的依赖Jar包, 对SpringBoot应用进行自动配置.\n自动装配(Autowire): Spring中的依赖注入.\n另外, 配置类(Configuration Class)有广义和狭义之分:\n 广义: 被注解@Component直接或间接修饰的某个类, 常说的Spring组件, 其中包括了@Configuration类 狭义: 特指被注解@Configuration所修饰的某个类, 又称为@Configuration类  SpringBoot的启动流程  创建一个ApplicationContext实例, 即我们常说的IoC容器. 将主类(primaryClass)注册到IoC容器中(简单但重要的第一步). 源配置类: 通常是main方法所在的类, 会被@SpringBootApplication所修饰, 我们又称之为主类. 递归加载并处理所有的配置类. 自动配置就属于其中一环. 实例化所有的单例Bean(Singleton Bean). 实例化所有的单例Bean. 依赖注入和自动装配就属于其中的环节. 如果是web应用, 则启动web服务器(如Tomcat)  SpringBoot加载配置类的流程  处理@ComponentScan: 根据@ComponentScan扫描制定的package. 处理@Import: 得到一系列被导入的配置类 处理@Bean方法 处理@Import导入的ImportBeanDefinitionRegistrar 加入到一个全局的配置类集合中 将配置类本身注册到IoC容器中 处理配置类中的@Bean方法, 将其返回类型注册到IoC容器中 处理通过@Import导入的ImportBeanDefinitionRegistrar  SpringBoot加载配置类的方式 @ComponentScan: 对指定的package进行扫描, 找到符合条件的类, 默认是搜索被注解@Component修饰的配置类; 通过属性basePackages或basePackageClasses指定要进行扫描的package; 未指定package则默认扫描当前@ComponentScan所修饰的类所在的package.\n例:\n1@ComponentScan 2 3@ComponentScan(basePackages={\u0026#34;cn.anyuanwai.code\u0026#34;, \u0026#34;cn.memset.code\u0026#34;}) 4 5@ComponentScan( 6 excludeFilters = {@Filter( 7 type = FilterType.CUSTOM, 8 classes = {TypeExcludeFilter.class} 9), @Filter( 10 type = FilterType.CUSTOM, 11 classes = {AutoConfigurationExcludeFilter.class} 12)} 13) @Import: 提供了一种显示地从其他地方加载配置类的方式, 这样可以避免使用性能较差得到组件扫描(Component Scan). 支持导入:\n  导入普通类(效果类似于这个普通类被注解@Component)\n1@Configuration 2//ConfigA里有Bean方法. 3//这样之后ConfigA和ConfigB都可以作为Bean使用了. 4@Import(ConfigA.class) 5public class ConfigB{ 6 7}   导入选择器接口ImportSelector的实现类(ImportSelector有selectImports方法返回值是一个数组, 每一个元素分别代表一个将被导入的配置类的全限定名, 利用该特性我们可以给IoC容器动态地导入多个配置类)\n1public class ZooImportSelector implements ImportSelector{ 2\t@Override 3\tpublic String[] selectImports(AnnotationMetadata metadata){ 4 return new String[]{\u0026#34;cn.memset.ZooConfig\u0026#34;}; 5\t} 6} 1//配置类 2//这样ZooConfig和ZooConfig里面的Bean都在容器中. 3@Configuration 4@Import({ZooImportSelector.class}) 5public class ConfigB{ 6 7}   导入注册器接口ImportBeanDefinitionRegistrar的实现类(通过它可以手动将多个BeanDefinition注册到IoC容器, 实现个性化的定制)\n1public class ZooRegistrar implements ImportBeanDefinitionRegistrar{ 2\t@Override 3\tpublic void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry){ 4 //手动注入Dog 5 bd.setBeanClass(Dog.class); 6 registry.registerBeanDefinition(\u0026#34;dog\u0026#34;, bd); 7\t} 8} 1//配置类 2//这样Bean Dog在容器中. 3@Configuration 4@Import({ZooImportSelector.class}) 5public class ConfigB{ 6 7}   关于加载配置类这几种方式\n @ComponentScan需要记住jar包中的package名称, 不方便 @Import导入普通类,需要记住第三方Jar包中具体的类名才能导入, 不方便 @Import导入注册器ImportBeanDefinitionRegistrar是对@Bean方法的一个补充,针对BeanDefinition层面的. 只有ImportBeanDefinitionRegistrar导入选择器方便点.  SpringBoot自动配置原理剖析 \r@SpringBootApplication修饰的类会被@Configuration间接修饰, 即源配置类\nSpringBoot框架会对源配置类的package进行组件扫描(ComponentScan)\nSpringBoot框架最终会导入AutoConfigurationImportSelector来实现自动配置\nAutoConfigurationImportSelector如何优雅实现自动配置呢? 用户只需导入jar包即可, 至于jar包有哪些自动配置类, 类名是什么都不用关心. 这恰好是Java SPI的优点. Spring框架中有个SpringFactories机制, 它是Java SPI设计思想的延伸和扩展, 自动配置就借助它实现.\nSpringFactories机制 核心逻辑是从classpath中读取所有Jar包中的配置文件META_INF/spring.factories, 然后根据key从配置文件中解析处对应的value.\n通过类SpringFactoriesLoader, 返回一个类名的集合, 可以根据实际需求对这些类名进行下一步处理.\n当然这是spring2的机制, spring3中目录META_INF/spring.factories改变为/META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports\nAutoConfigurationImportSelector整体逻辑 AutoConfigurationImportSelector中的selectImports方法中的getAutoConfigurationEntry是自动配置的入口方法. 在getAutoConfigurationEntry中:\n 获取annotationMetadata的注解@EnableAutoConfiguration的属性 从资源文件spring.factories中获取EnableAutoConfiguration对应的所有的类(getCandidateConfigurations中基于是SpringFactories机制) 通过在注解@EnableAutoConfiguration设置exclude的相关属性, 可以排除指定的自动配置类 根据注解@Confitional来判断是否需要排除某些自动配置类 触发AutoConfiguration导入的相关时间.  总结 \r理解Redis自动配置 spring-boot-starter-data-redis依赖了spring-boot-starter和spring-data-redis(工具类库Jar包, 定义了RedisTemplate等常用类), spring-boot-starter依赖了spring-boot-autoconfigure是SpringBoot内置的自动配置列的Jar包, 包含了spring.factories文件, 这里面就有很多redis的自动配置类类名.\n二, SpringBoot自动配置实战案例 什么是Starter Starter是一站式服务(one-step)的依赖jar包:\n 包含Spring以及相关技术(比如Redis)的所有依赖 提供了自动配置的功能, 开箱即用 提供了良好的依赖管理, 避免了包遗漏, 版本冲突的问题  Starter的结构图 \rStarter项目主要由两个模块构成: starter module和autoConfigure module(里面又包括自动配置类, 配置文件spring.factories, 自定义的配置项). starter module会依赖第三方组件的Jar包, 而autoConfigure module是可选依赖(Optional)第三方Jar包的.\n可选依赖(Optional的作用: 阻断依赖传递.\n如项目A可选依赖项目B, 那么使用Maven编译项目A时, 会将项目B添加到项目A的classpath中 ,此时可选依赖和普通依赖的表现是一致的\n这时如果项目X依赖于项目A, 使用Maven编译项目X时, 项目B是不会被添加到项目X的classpath中的, 除非项目X直接依赖项目B.\nSwagger的配置类 添加依赖包:\n1 \u0026lt;dependency\u0026gt; 2 \u0026lt;groupId\u0026gt;io.springfox\u0026lt;/groupId\u0026gt; 3 \u0026lt;artifactId\u0026gt;springfox-swagger2\u0026lt;/artifactId\u0026gt; 4 \u0026lt;version\u0026gt;2.9.2\u0026lt;/version\u0026gt; 5 \u0026lt;/dependency\u0026gt; 6 \u0026lt;dependency\u0026gt; 7 \u0026lt;groupId\u0026gt;io.springfox\u0026lt;/groupId\u0026gt; 8 \u0026lt;artifactId\u0026gt;springfox-swagger-ui\u0026lt;/artifactId\u0026gt; 9 \u0026lt;version\u0026gt;2.9.2\u0026lt;/version\u0026gt; 10 \u0026lt;/dependency\u0026gt; 配置类:\n1package com.example.config; 2 3import org.springframework.context.annotation.Bean; 4import org.springframework.context.annotation.Configuration; 5import springfox.documentation.builders.ApiInfoBuilder; 6import springfox.documentation.builders.PathSelectors; 7import springfox.documentation.builders.RequestHandlerSelectors; 8import springfox.documentation.service.ApiInfo; 9import springfox.documentation.spi.DocumentationType; 10import springfox.documentation.spring.web.plugins.Docket; 11import springfox.documentation.swagger2.annotations.EnableSwagger2; 12 13 14@Configuration // 标明是配置类 15@EnableSwagger2 //开启swagger功能 16public class SwaggerConfig { 17 @Bean 18 public Docket createRestApi() { 19 return new Docket(DocumentationType.SWAGGER_2) // DocumentationType.SWAGGER_2 固定的，代表swagger2 20// .groupName(\u0026#34;分布式任务系统\u0026#34;) // 如果配置多个文档的时候，那么需要配置groupName来分组标识 21 .apiInfo(apiInfo()) // 用于生成API信息 22 .select() // select()函数返回一个ApiSelectorBuilder实例,用来控制接口被swagger做成文档 23 .apis(RequestHandlerSelectors.basePackage(\u0026#34;com.example.controller\u0026#34;)) // 用于指定扫描哪个包下的接口 24 .paths(PathSelectors.any())// 选择所有的API,如果你想只为部分API生成文档，可以配置这里 25 .build(); 26 } 27 28 /** 29* 用于定义API主界面的信息，比如可以声明所有的API的总标题、描述、版本 30* @return 31*/ 32 private ApiInfo apiInfo() { 33 return new ApiInfoBuilder() 34 .title(\u0026#34;XX项目API\u0026#34;) // 可以用来自定义API的主标题 35 .description(\u0026#34;XX项目SwaggerAPI管理\u0026#34;) // 可以用来描述整体的API 36 .termsOfServiceUrl(\u0026#34;\u0026#34;) // 用于定义服务的域名 37 .version(\u0026#34;1.0\u0026#34;) // 可以用来定义版本。 38 .build(); // 39 } 40} 41 进行Swagger的自动配置 spring.factories:\n1org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\ 2com.moming.swagger.autoconfigure.Swagger2AutoConfiguration 配置文件:\n1package com.moming.swagger.properties; 2 3import lombok.Data; 4import org.springframework.boot.context.properties.ConfigurationProperties; 5import org.springframework.context.annotation.Configuration; 6import org.springframework.context.annotation.DependsOn; 7import org.springframework.context.annotation.Import; 8import org.springframework.stereotype.Component; 9 10import java.util.LinkedHashMap; 11import java.util.Map; 12 13/** 14* 读取 application 配置文件 15* 16* @author hjy 17**/ 18@Data 19@Component 20@ConfigurationProperties(\u0026#34;swagger2\u0026#34;) 21public class Swagger2Properties { 22 23 /** 24* 分组 25*/ 26 private Map\u0026lt;String, GroupInfo\u0026gt; groups = new LinkedHashMap\u0026lt;\u0026gt;(); 27 28 29 @Data 30 public static class GroupInfo { 31 /** 32* swagger 会解析的包路径 33*/ 34 private String basePackage; 35 36 /** 37* title 38*/ 39 private String title; 40 41 /** 42* swagger 组相关说明 43*/ 44 private String description; 45 } 46} 47 自动配置类:\n1package com.moming.swagger.autoconfigure; 2 3import com.moming.swagger.properties.Swagger2Properties; 4import org.springframework.beans.BeansException; 5import org.springframework.beans.factory.BeanFactory; 6import org.springframework.beans.factory.BeanFactoryAware; 7import org.springframework.beans.factory.config.ConfigurableBeanFactory; 8import org.springframework.context.annotation.Bean; 9import org.springframework.context.annotation.Configuration; 10import springfox.documentation.builders.ApiInfoBuilder; 11import springfox.documentation.builders.PathSelectors; 12import springfox.documentation.builders.RequestHandlerSelectors; 13import springfox.documentation.service.ApiInfo; 14import springfox.documentation.spi.DocumentationType; 15import springfox.documentation.spring.web.plugins.Docket; 16import springfox.documentation.swagger2.annotations.EnableSwagger2; 17 18import java.util.ArrayList; 19import java.util.List; 20 21/** 22* 1. 读取配置文件 23* 2. 将配置文件内容赋值到 swagger 的 Docket 对象 24* 3. 将 Docket 依次注入到 bean 中 （需要实现 BeanFactoryAware 获取beanFatory） 25* 关键是对组的操作 26* 27* @author hjy 28**/ 29@Configuration 30@EnableSwagger2 31public class Swagger2AutoConfiguration implements BeanFactoryAware { 32 33 private BeanFactory beanFactory; 34 35 /** 36* 获取 beanFactroy 37* @param beanFactory beanFactory 38* @throws BeansException BeansException 39*/ 40 @Override 41 public void setBeanFactory(BeanFactory beanFactory) throws BeansException { 42 this.beanFactory = beanFactory; 43 } 44 45 @Bean 46 public Swagger2Properties properties() { 47 return new Swagger2Properties(); 48 } 49 50 51 @Bean(\u0026#34;createRestOpenApi\u0026#34;) 52 public List\u0026lt;Docket\u0026gt; createRestOpenApi(Swagger2Properties properties) { 53 ConfigurableBeanFactory configurableBeanFactory = (ConfigurableBeanFactory) beanFactory; 54 List\u0026lt;Docket\u0026gt; docketList = new ArrayList\u0026lt;\u0026gt;(); 55 // swagger 配置 56 for (String groupName : properties.getGroups().keySet()) { 57 Swagger2Properties.GroupInfo groupInfo = properties.getGroups().get(groupName); 58 String basePackage = groupInfo.getBasePackage(); 59 Docket docket = new Docket(DocumentationType.SWAGGER_2) 60 .groupName(groupName) 61 .apiInfo(openApiInfo(groupInfo)) 62 .select() 63 .apis(RequestHandlerSelectors.basePackage(basePackage)) 64 .paths(PathSelectors.any()) 65 .build(); 66 docketList.add(docket); 67 // docket 加入 IOC 容器 68 configurableBeanFactory.registerSingleton(groupName, docket); 69 } 70 return docketList; 71 } 72 73 74 private ApiInfo openApiInfo(Swagger2Properties.GroupInfo groupInfo) { 75 return new ApiInfoBuilder() 76 .title(groupInfo.getTitle()) 77 .description(groupInfo.getDescription()) 78 .version(\u0026#34;1.0\u0026#34;) 79 .build(); 80 } 81 82 83} 84 他这里相比普通的配置多了些东西. 它实现了BeanFactoryAware接口, 这样Spring 容器会在 bean 的初始化 过程中自动调用这个方法，并传入当前的 BeanFactory 实例, 然后就可以利用BeanFactory将docket加入到ioc容器了.\n可能是它这里为了便捷配置接口组, 所以采用的是List形式.\nKnife4j","date":"2024-08-03","permalink":"/posts/tech/java-6-autoconfiguration/","series":["Java"],"tags":["","",""],"title":"项目: Swagger的自动装配"},{"categories":["计算机"],"content":"字符串搜索 主串A: a, b, c, d, e, f, g\n模式串B: c, d, e\n判断B是否在A中, 存在返回在A中的下标, 不存在返回-1\n再如: A: ABCABCAABCABCD; B: ABCABCD; 返回值7.\nBF: 暴力破解 复杂度O( (n-m)*m )\n1//BF:暴力破解 2 int BF(String A, String B){ 3 int aLength = A.length(); 4 int bLength = B.length(); 5 //这里aLength - bLength稍微优化了一下 6 for (int i = 0; i \u0026lt;= aLength - bLength; i++) { 7 int j; 8 for (j = 0; j \u0026lt; bLength; j++) { 9 if (A.charAt(i+j) != B.charAt(j)){ 10 break; 11 } 12 } 13 //需要判断上面的子循环什么时候将B完整遍历了一遍 14 //当j=B.length时, 刚好执行了最后一次j++ 15 if(j == B.length()){ 16 return i; 17 } 18 } 19 return -1; 20 } RK算法: hash算法 基于BF进行优化, 将A中的字符串按照顺序截取B字符串的长度: abc, bcd, cde, def, efg. 进行hash运算然后与B的hash值进行比较. 时间复杂度: O(m*n), hash算法参与字符串位数, 主串长度相关.\n优化: hash算法: 按26进制取和, abc=1+2+3=6, 进行量化. 每个子串的hash值是前一个子串的hash值-前串最小下标对应字母的值+本串最大下标字母对应的值.\n此时间复杂度为O(n), 只与主串长度相关, 但hash冲突极端情况下退化为BF\n1//RK:hash算法 2 static int RK(String A, String B){ 3 int aLength = A.length(); 4 int bLength = B.length(); 5 int bCode = B.hashCode(); 6 for (int i = 0; i \u0026lt;= aLength - bLength; i++) { 7 String aSub = A.substring(i, i + bLength); 8 if(aSub.hashCode() == bCode){ 9 //防止hash碰撞 10 int j; 11 for (j = 0; j \u0026lt; bLength; j++) { 12 if (aSub.charAt(j) != B.charAt(j)){ 13 return -1; 14 } 15 } 16 if (j == bLength){ 17 return i; 18 } 19 } 20 } 21 return -1; 22 } 23 24 //RK: hash算法 优化hash 25 static int hashCode(String string){ 26 int hashCode = 0; 27 //初始化字母表 28 HashMap\u0026lt;Character, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); 29 int base = (int)\u0026#39;A\u0026#39;-1; 30 for (char c=\u0026#39;A\u0026#39;; c\u0026lt;=\u0026#39;Z\u0026#39;; c++){ 31 map.put(c, (int)c-base); 32 } 33 for (char c=\u0026#39;a\u0026#39;; c\u0026lt;=\u0026#39;z\u0026#39;; c++){ 34 map.put(c, (int)c-base); 35 } 36 37 for (int i = 0; i \u0026lt; string.length(); i++) { 38 hashCode += map.get(string.charAt(i)); 39 } 40 return hashCode; 41 } BM算法 1.坏字符规则: 从右往左匹配, 找到A中第一个不匹配的字符(坏字符), 将B串右移, 直到出现与A串坏字符对齐的字符, 再从右往左寻找坏字符. 如果B串中没有该坏字符, 则直接移到该坏字符的下一位即可.\n例如A串:ABCABCAABCABCD; B串ABCDBC. A串前6个为ABCABC, 初始从右往左匹配, 这时B串的C与A串该位置的C对应, 继续匹配B, 然后B串中的D与A串中的对应位置A不匹配, 出现换字符.\n1ABCABCAABCABCD 2ABCDBC 于是右移B串, 第一个与A坏字符对应的B串位置就是第一个字母, 现在变成了\n1ABCABCAABCABCD 2 ABCDBC B串往右移动了两格. 又开始从右往左寻找坏字符, 这时第一个B与C就冲突了, 于是又开始右移, 对齐这个坏字符:\n1ABCABCAABCABCD 2 ABCDBC B串往右移动一格后坏字符对齐, 又开始从右往左寻找坏字符, A与D出现冲突, 右移:\n1ABCABCAABCABCD 2 ABCDBC B串右移三格. 这一次再移动一格就到头了, 不行.\n坏字符规则是从右往左比较的, 并且这个移动规则保证了跳过多余的比较同时又不会遗留.\n2.好后缀规则: 从右往左匹配, 找到坏字符(坏字符后面的串是匹配的, 是好串), 往左寻找B中是否还有该好后缀, 如果有, 将B右移到该位置与A好后缀进行对齐. 重复该规则. 如果B串往右没有该好后缀, 则右移到好后缀的往右错一位的位置, 重复该规则. 避免B串的前缀与好后缀的后缀匹配\n还是以上面为例:\n1ABCABCAABCABCD 2ABCDBC 这时好串是BC, 往前寻找发现还有这个好后缀, 于是进行对齐:\n1ABCABCAABCABCD 2 ABCDBC 这时坏字符是第一个, 没有好串, 只有先对齐了:\n1ABCABCAABCABCD 2 ABCDBC 有好串了, 继续\n1ABCABCAABCABCD 2 ABCDBC 在移动就超过长度了, 于是没有匹配的.\n再举有匹配的一例:\n1ABCABCAABCABCD 2ABCABCD 3开始位置0; 坏字符下标:6; 需要移位:3; 4 5ABCABCAABCABCD 6 ABCABCD 7开始位置3; 坏字符下标:6; 需要移位:1; 8 9ABCABCAABCABCD 10 ABCABCD 11开始位置4; 坏字符下标:6; 需要移位:3 12 13ABCABCAABCABCD 14 ABCABCD 15开始位置7; 无坏字符. 两种规则综合使用, 哪种移动的位数多使用哪种\n时间复杂度: O(n/m), 最坏O(m*n)\n1//BM 2 static int BM(String A, String B){ 3 int aLength = A.length(); 4 int bLength = B.length(); 5 //每次操作结束后A串对齐B串的标志位 6 int index = 0; 7 while (true) { 8 for (int j = bLength-1; j \u0026gt; 0; j--) { 9 //出现坏字符 10 if (A.charAt(index + j) != B.charAt(j)){ 11 Boolean ifHaveBad = false; 12 for (int i = j; i \u0026gt; 0; i--) { 13 //B串中有坏字符 14 if (A.charAt(index + j) == B.charAt(i)){ 15 ifHaveBad = true; 16 index += j-i; 17 break; 18 } 19 } 20 21 if (!ifHaveBad){ 22 //B串中没有坏字符, 应移位到坏字符下一位 23 index += j; 24 } 25 26 //如果已经不能再移位了, 说明没有匹配的. 27 if (aLength - index \u0026lt; bLength) return -1; 28 29 //移位, 进行下一次规则循环比较. 30 break; 31 } 32 //在B串一次循环中没有一次进入if分支, 说明全部匹配 33 return index; 34 } 35 } 36 } KMP算法 前缀: 字符串A=B+S, S非空, 那么B就是A的前缀\n后缀: 字符串A=S+B, S非空, 那么B是A的后缀\nPMT值: 前缀集合和后缀集合的交集中, 最长元素的长度\n部分匹配表: PMT值集合, 字符串的所有前缀的PMT值\nperfix数组: 每一个下标位置对应一个PMT值, 组成的数组\nnext数组: perfix向右移一个下标位置, 组成next数组\n\r这个PMT值就是我们每次找到坏字符后, pattern字符串需要移动的距离.\n求next数组:\n1//KMP: next数组生成 2 static void getNext(char[] pattern, int[]next){ 3 //next数组其余位置默认是0. 4 next[0] = -1; 5 int i = 0, j = -1; 6 7 while (i \u0026lt; pattern.length){ 8 //每当j=-1时, 就是说明当前子串已经找完了. 9 if(j == -1){ 10 i++; 11 j++; 12 }else if(pattern[i] == pattern[j]){ 13 i++; 14 j++; 15 //这时i位置上的值赋值的是i-1位置上的KMP值, 错位了. 16 next[i] = j; 17 }else { 18 //当字母不匹配后回到这里, j慢慢缩小直到-1. 19 j = next[j]; 20 } 21 } 22 } 以ABCABCD串解释如何求出next数组.\n1.默认情况下i=0, j=-1, 这时刚好寻找下标为0子串的KMP值, 这是肯定为0的, 所以我们进行i++,j++.\n1ABCABCD 2ABCABCD 2.现在变成了i=1, j=0; 由于此时B != A, 说明子串AB的KMP值为0, 于是将j赋值为-1, 这样i就会++. 表明这个位置没有匹配的, 仍需要移动\n1ABCABCD 2 ABCABCD 3.现在i=1, j=-1, 又变成i=2, j=0, C!=A, 第一个仍然不匹配, 继续\n1ABCABCD 2 ABCABCD 4.现在i=3, j=0, 匹配了, 将next[4] = 1, i++, j++后继续匹配, next[5] = 2, i++, j++后继续匹配, next[6] = 3, 当i=6, j=3时, 不匹配了, 又回到j=0了, 然后j=-1, 最后i = 7 = pattern的长度了.\n1ABCABCD 2 ABCABCD 最后一个问题, j = next[j];是否一定会让j变成-1, 有没有例外情况? 我们举例来看看:\n1如果串是: ABCABCDABCDA 2 3ABCABCDABCDA 4 ABCABCDABCDA 5这时i=10 j=3时不匹配, 那么j=next[3]=0 初步估计这个next数组是越来越大的, 因为子串的长度在不断增大, KMP值越来越大, 所以它总会收敛于-1的.\n算法本体:\n1//KMP 2 static int search(char[] str, char[] pattern, int[] next){ 3 int i = 0; 4 int j = 0; 5 6 while (i \u0026lt; str.length \u0026amp;\u0026amp; j \u0026lt; pattern.length){ 7 if (j == -1 || str[i] == pattern[j]){ 8 i++; 9 j++; 10 }else { 11 //不匹配了 , 就往后移动. 12 //所以下标0的-1也是移动的手段, 13 j = next[j]; 14 } 15 } 16 17 //如果j最后一直到了最后都和i匹配, 说明找到了. 18 if (j == pattern.length){ 19 return i - j; 20 }else { 21 return -1; 22 } 23 } 测试:\n1public static void main(String[] args) { 2 String A = \u0026#34;ABCABCAABCABCD\u0026#34;; 3 String B = \u0026#34;ABCABCD\u0026#34;; 4 System.out.println(BF(A, B)); 5 System.out.println(RK(A, B)); 6 //System.out.println(hashCode(B)); 7 System.out.println(BM(A,B)); 8 9 int[] next = new int[B.length()]; 10 getNext(B.toCharArray(), next); 11 int i = search(A.toCharArray(), B.toCharArray(), next); 12 System.out.println(Arrays.toString(next)); 13 System.out.println(i); 14 System.out.println(A.indexOf(B)); 15 } 打家劫舍 动态规划三要素:\n 最优子结构: 每一个问题的最优解都包含子问题的最优解(n的最优依赖的是n-1的最优) 递推公式(状态转移方程): 找问题的规律, 解和前面解的关系 重叠子问题  初始问题 问题: 小偷偷钱, 不能偷相邻的房间. 给定一个代表每个房屋存放金额的非负整数数组, 计算你不触动警报装置的情况下, 一夜能偷窃到的最高金额\n输入: [1,2,3,1] 输出:4\n输入:[2,7,9,3,1] 输出12\n1public class Rob { 2 3 public static void main(String[] args) { 4 int[] num = new int[]{100, 2, 1, 100}; 5 int index = num.length -1; 6 System.out.println(maxMoney(num, index)); 7 System.out.println(maxMoney2(num)); 8 } 9 10 11 static int maxMoney(int[] num, int index){ 12 if (num == null || index \u0026lt; 0){ 13 return 0; 14 } 15 if (index == 0){ 16 return num[index]; 17 } 18 return Math.max(maxMoney(num, index-1), num[index]+maxMoney(num, index-2)); 19 } 20 21 static int maxMoney2(int[] num){ 22 //健壮性 23 int length = num.length; 24 if (num == null || length == 0){ 25 return 0; 26 } 27 if (length == 1){ 28 return num[length-1]; 29 } 30 31 //dp数组, 存放以及计算的值, 优化计算 32 int[] dp = new int[num.length]; 33 dp[0] = num[0]; 34 dp[1] = Math.max(num[0], num[1]); 35 for (int i = 2; i \u0026lt;length; i++) { 36 dp[i] = Math.max(dp[i-1], dp[i-2]+num[i]); 37 } 38 39 return dp[length-1]; 40 } 41 42 //优化空间复杂度, 只放两个位置. 43 static int maxMoney3(int[] num){ 44 //健壮性 45 int length = num.length; 46 if (num == null || length == 0){ 47 return 0; 48 } 49 if (length == 1){ 50 return num[length-1]; 51 } 52 53 //只需要两个变量, 优化空间复杂度从O(n)到O(1) 54 int first = num[0]; 55 int second = Math.max(num[0], num[1]); 56 for (int i = 2; i \u0026lt;length; i++) { 57 int temp = second; 58 second = Math.max(second, first+num[i]); 59 first = temp; 60 } 61 62 return second; 63 } 64} 65 首尾相连 街道房间是圆形的. 第一个和最后一个也算是相邻的.\n由于第一个和最后一个是互斥的, 于是分解为两个子问题: 第一个房子到倒数第二个房子的最优解, 与第二个房子到最后一个房子的最优解. 分别求出来比较大小.\n1public static void main(String[] args) { 2 int[] num = new int[]{100, 2, 1, 100}; 3 System.out.println(Math.max( 4 maxMoney4(num, 0, num.length-2), 5 maxMoney4(num, 1, num.length-1) 6 )); 7 } 8 9 10//将下标作为变量, 分别进行最优解运算. 11 static int maxMoney4(int[] num, int start, int end){ 12 //健壮性 13 int length = num.length; 14 if (num == null || length == 0){ 15 return 0; 16 } 17 if (length == 1){ 18 return num[length-1]; 19 } 20 21 //只需要两个变量, 优化空间复杂度从O(n)到O(1) 22 int first = num[start]; 23 int second = Math.max(num[start], num[start+1]); 24 for (int i = start+2; i \u0026lt;= end; i++) { 25 int temp = second; 26 second = Math.max(second, first+num[i]); 27 first = temp; 28 } 29 30 return second; 31 } 二叉树 父子关系就是相邻的情况.\n1public static void main(String[] args) { 2 TreeNode node5 = new TreeNode(1, null, null); 3 TreeNode node4 = new TreeNode(3, null, null); 4 TreeNode node3 = new TreeNode(3, null, node5); 5 TreeNode node2 = new TreeNode(2, null, node4); 6 TreeNode node1 = new TreeNode(3, node2, node3); 7 //传入根节点 8 int[] dfs = dfs(node1); 9 System.out.println(Math.max(dfs[0], dfs[1])); 10 } 11 12 13//深度优先算法 14 public static int[] dfs(TreeNode node){ 15 //int[]两个值, 一是选了这个节点select的最优解,第二个是没选这个节点not select的最优解 16 if (node == null){ 17 //如果是null节点, 选与不选结果都是1. 18 return new int[]{0,0}; 19 } 20 int[] l = dfs(node.left); 21 int[] r = dfs(node.right); 22 //选这个节点意味着不能选下面的节点 23 int select = node.val + l[1] + r[1]; 24 //不选这个节点意味着选子节点, 选子节点最大的情况. 25 int notSelect = Math.max(l[0], l[1]) + Math.max(r[0], r[1]); 26 return new int[]{select, notSelect}; 27 } 反转链表 1.迭代 用变量保存当前节点和下一个节点的信息, 以此赋值.\n1public class ReverseList { 2 3 public static void main(String[] args) { 4 ListNode node5 = new ListNode(5, null); 5 ListNode node4 = new ListNode(4, node5); 6 ListNode node3 = new ListNode(3, node4); 7 ListNode node2 = new ListNode(2, node3); 8 ListNode node1 = new ListNode(1, node2); 9 ListNode iterate = iterate(node1); 10 } 11 12 static class ListNode{ 13 int val; 14 ListNode next; 15 16 public ListNode(int val, ListNode next){ 17 this.val = val; 18 this.next = next; 19 } 20 } 21 22 public static ListNode iterate(ListNode head){ 23 //保存前一个节点 24 ListNode pre = null; 25 //保存当前节点 26 ListNode curr = head; 27 ListNode next; 28 while (curr != null){ 29 //先保存下一个节点的信息, 避免被覆盖 30 next = curr.next; 31 //在pre还未指向新的pre之前给自己赋值 32 curr.next = pre; 33 pre = curr; 34 curr = next; 35 } 36 return pre; 37 } 38 39 40} 41 2.递归 以相似的方式重复, 类似于树结构, 从最里面开始遍历.\n1public static ListNode recursion(ListNode head){ 2 if (head == null || head.next == null){ 3 return head; 4 } 5 //从最后往前修改 6 ListNode new_head = recursion(head.next); 7 head.next.next = head; // 后一个指向前一个 8 head.next = null; //断原来的链 9 return new_head; 10 } 素数个数统计 1.暴力算法 对每个数字x继续筛选, 看x是否会被小于根号x的数字整除. 可以用i * i \u0026lt; x 表示根号.\n1public class PrimeSearch { 2 3 4 public static int bf(int x){ 5 int count = 0; 6 for (int i = 2; i \u0026lt;= x; i++) { 7 count += isPrime(i) ? 1 : 0; 8 } 9 return count; 10 } 11 12 private static boolean isPrime(int i) { 13 for (int j = 2; j * j \u0026lt;= i; j++) { 14 if (i % j == 0){ 15 return false; 16 } 17 } 18 return true; 19 } 20} 21 2.埃氏筛选 埃氏筛选: 找到一个质数, 立刻将这个质数所有的倍数都淘汰为合数.\n1 public static int eratosthenes(int n){ 2 int count = 0; 3 //由于数组下标的因素, 设置为n+1 4 Boolean[] isPrime = new Boolean[n+1]; //初始化为false 5 Arrays.fill(isPrime, true); //所有默认为true 6 for (int i = 2; i \u0026lt;= n; i++) { 7 if (isPrime[i]){ 8 count++; 9 //排除所有这个质数的倍数的合数. 10 for (int j = i*i; j \u0026lt;= n; j+=i) { 11 isPrime[j] = false; 12 } 13 } 14 } 15 return count; 16 } 删除排序数组中的重复项 一个有序数组nums, 原地删除重复出现的元素, 使每个元素只出现一次, 返回删除后数组的新长度\n不能使用额外的数组空间, 必须在原地修改数组并在使用O(1)额外空间的条件下完成.\n输入: [0,1,2,2,3,3,4]\n输出: 5\nJava中没有数组元素删除操作, 删除了只能置为null. 或者只能新建数组拷贝.\n双指针算法: i(慢指针)和j(快指针)依次指向第一个和第二个, 如果他们对应元素不相等, 则都+1; 如果对应元素相等, 那么j+1; 如果是相等之后出现了不相等, 那么这时将j所在位置的元素赋值给i+1所在位置的元素(nums[i+1]=nums[j]); 如果j到了最后一个, 则返回i.\n1public class SortedArrayDuplicates { 2 3 public static void main(String[] args) { 4 System.out.println( 5 removeDuplicates(new int[]{0,1,2,2,2,3,3,4}) 6 ); 7 } 8 9 public static int removeDuplicates(int[] nums){ 10 if (nums.length == 0){ 11 return 0; 12 } 13 14 int i = 0; 15 for (int j = 1; j \u0026lt; nums.length; j++) { 16 //当不相等时, 如果是挨着的, 那么nums[i] = nums[j];无影响 17 //如果不是挨着的, 那么会将重复的元素赋值为下一个不重复的元素 18 if (nums[i] != nums[j]){ 19 i++; 20 nums[i] = nums[j]; 21 } 22 } 23 24 return i + 1; 25 } 26} 27 寻找数组的中心下标 给定一个整数数组nums, 返回数组\u0026quot;中心下标\u0026quot;的方法, 不存在返回-1, 有多个则返回最靠近左边的那个.\n中心下标是数组的一个下标, 其左侧的所有元素相加的和等于右侧所有元素相加的和. 中心下标可能出现在数组的两端.\n这道题的关键是理解题意, 左边等于右边, 这是不包括当前位置的值的. 于是思路有\n  轮到下标为i元素时, 判断0+1+..+i-1+ i 是否等于 sum - 0 - 1 - (i-1). 双方都加一个当前元素等于没有加.\n1public static int pivotIndex(int[] nums){ 2 int sumMinusPrev = Arrays.stream(nums).sum(); 3 int leftPlusCurr = 0; 4 for (int i = 0; i \u0026lt; nums.length; i++) { 5 leftPlusCurr += nums[i]; 6 if (leftPlusCurr == sumMinusPrev){ 7 return i; 8 } 9 sumMinusPrev -= nums[i]; 10 } 11 return -1; 12 }   既然左边右边是相等的, 那么2*(0+1+2+\u0026hellip;+i-1) + i = sum总和.\n1public static int pivotIndex2(int[] nums){ 2 int sum = Arrays.stream(nums).sum(); 3 int ima = 0; 4 for (int i = 0; i \u0026lt; nums.length; i++){ 5 if (ima * 2 + nums[i] == sum){ 6 return i; 7 } 8 ima += nums[i]; 9 } 10 return -1; 11 }   验证:\n1public static void main(String[] args) { 2 System.out.println(pivotIndex(new int[]{1,7,3,6,5,6})); 3 System.out.println(pivotIndex2(new int[]{1,7,3,6,5,6})); 4 } X的平方根 不使用sqrt函数, 得到x的平方根的整数部分.\n二分法 寻找i * i \u0026lt; x 但 (i+1)*(i+1) \u0026gt; x的值, 使用二分法缩减寻找次数.\n1public static int binarySearch(int x){ 2 int index = -1; 3 int lP = 0, rP = x; 4 while (lP \u0026lt;= rP){ 5 //计算新的左右指针的中间值 6 int mid = (lP + rP) / 2; 7 if (mid * mid \u0026lt;= x){ 8 lP = mid + 1; 9 //取小值 10 index = mid; 11 }else { 12 rP = mid - 1; 13 } 14 15 } 16 return index; 17 } 牛顿迭代 原理: x/n 与 n的均值比他们原来更趋近于根号x.\n原本的牛顿迭代是迭代选取的点对应切线与x轴交点的值(x1 = x0 - f(x0)/df(x0)),\n这里相当于是求x^2-x0=0方程的根, 化简之后就是(i + x/i)/2, 和牛顿迭代一致.\n1public static int newton(int x){ 2 //第一个参数值无所谓, 越接近根号x, 则迭代次数越少. 3 return (int)sqrt(x, x); 4 } 5 6 public static double sqrt(double i, int x){ 7 double res = (i + x/i)/2; 8 if (res == i){ 9 return res; 10 }else { 11 sqrt(res, x); 12 } 13 } 数组中三个数的最大乘积 整形数组nums, 在数组中找出由三个数字组成的最大乘积, 并输出.\n当数组全为整数时, 最大乘积为前三个最大的数的乘积;\n当数组有一个负数时, 最大乘积为前三个最大的数的乘积;\n当数组由两个及以上的负数时, 最大乘积为前三个最大的数的乘积 和 最大的数与两个最小的数的乘积之大者.\n先排序后计算 算法复杂度取决于排序算法.\n1public static int sortAndCalc(int[] nums){ 2 int length = nums.length; 3 Arrays.sort(nums); 4 return Math.max( 5 nums[0]*nums[1]*nums[length-1], 6 nums[length-1]*nums[length-2]*nums[length-3] 7 ); 8 } 线性扫描: 只找出前三最大和前二最小 1public static int getMax3AndMin2(int[] nums){ 2 int max1 = Integer.MIN_VALUE, max2 = Integer.MIN_VALUE, max3 = Integer.MIN_VALUE; 3 int min1 = Integer.MAX_VALUE, min2 = Integer.MAX_VALUE; 4 for (int num : nums){ 5 if (num \u0026gt; max1){ 6 max3 = max2; 7 max2 = max1; 8 max1 = num; 9 }else if (num \u0026gt; max2){ 10 max3 = max2; 11 max2 = num; 12 }else if (num \u0026gt; max3){ 13 max3 = num; 14 } 15 16 if (num \u0026lt; min1){ 17 min2 = min1; 18 min1 = num; 19 }else if (num \u0026lt; min2){ 20 min2 = num; 21 } 22 } 23 24 return Math.max( 25 max1*max2*max3, 26 max1*min1*min2 27 ); 28 } 两数之和\u0026ndash;无序数组 给定整数数组nums, 从中寻找两个数满足他们之和为给定目标target.\n不可重复使用元素, 返回两数的下标值, 以数组形式返回.\n可以使用暴力算法.\n或者利用map记录扫描过的数及下标. 这样空间复杂度会稍高.\n1import java.util.Arrays; 2import java.util.HashMap; 3import java.util.Map; 4 5public class TwoNumberForSum { 6 7 public static void main(String[] args) { 8 System.out.println( 9 Arrays.toString(solution(new int[]{1, 2, 3, 4, 5, 6}, 10)) 10 ); 11 } 12 13 14 public static int[] solution(int[] nums, int target){ 15 Map\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); 16 for (int i = 0; i \u0026lt; nums.length; i++) { 17 if (map.containsKey(target - nums[i])){ 18 return new int[]{map.get(target - nums[i]), i}; 19 } 20 map.put(nums[i], i); 21 } 22 return new int[0]; 23 } 24} 25 两数之和\u0026ndash;有序数组 二分查找 遍历左边的界限, 在界限之中应用二分查找target-nums[i]的数.\n1public static int[] twoSearch(int[] nums, int target){ 2 for (int i = 0; i \u0026lt; nums.length; i++) { 3 int low = nums[i], high = nums.length - 1; 4 while (low \u0026lt;= high){ 5 int mid = (low + high) / 2; 6 if (nums[mid] == target - nums[i]){ 7 return new int[]{i, mid}; 8 }else if (nums[mid] \u0026gt; target - nums[i]){ 9 high = mid - 1; 10 }else { 11 low = mid + 1; 12 } 13 } 14 } 15 return new int[0]; 16 } 双指针 前提是有序.\n1public static int[] twoPointer(int[] nums, int target){ 2 int low = 0, high = nums.length - 1; 3 while (low \u0026lt; high){ 4 int sum = nums[low] + nums[high]; 5 if (sum == target){ 6 return new int[]{low, high}; 7 }else if (sum \u0026gt; target){ 8 high--; 9 }else { 10 low++; 11 } 12 } 13 return new int[0]; 14 } 计算斐波那契数列 0, 1, 1, 2, 3, 5, 8, \u0026hellip;. 后一项等于前面两项的和.\n暴力递归 直接递归, 这样有些项存在严重的重复计算.\n1public static int BFRecursion(int num){ 2 if (num == 0) return 0; 3 if (num == 1) return 1; 4 return BFRecursion(num - 1) + BFRecursion(num - 2); 5 } 去重递归 用空间保存计算过的项. 时间O(n) 空间O(n)\n1public static int SavedRecursion(int num){ 2 //由于第一个是0, 所以需要多一个空间. 3 int[] saveArr = new int[num + 1]; 4 return Recursion(saveArr, num); 5 } 6 7 private static int Recursion(int[] saveArr, int num) { 8 if (num == 0) return 0; 9 if (num == 1) return 1; 10 //如果之前这个位置已经被运算, 直接返回. 11 if (saveArr[num] != 0) return saveArr[num]; 12 saveArr[num] = Recursion(saveArr, num - 1) + Recursion(saveArr, num - 2); 13 return saveArr[num]; 14 } 双指针迭代 只需要两个位置保存, 节省了空间至O(1)\n1public static int TwoPointer(int num){ 2 if (num == 0) return 0; 3 if (num == 1) return 1; 4 int first = 1, second = 0; 5 for (int i = 2; i \u0026lt;= num; i++) { 6 int temp = first; 7 first = first + second; 8 second = temp; 9 } 10 return first; 11 } 排列硬币 n枚硬币, 将他们排列为阶梯形状, 第k行有k枚硬币.\n给定一个数字n, 找出可形成完整阶梯行的总行数. 就是可以剩, 不需要全部用完.\n暴力迭代 啥也不管, 一行一行地排\n1public static int arrangeCoinBF(int n){ 2 for (int i = 1; i \u0026lt; n; i++) { 3 n -= i; 4 if (n \u0026lt; i + 1){ 5 return i; 6 } 7 } 8 return -1; 9 } 二分查找 行数必定在0到n之间, 查找这之中满足求和=n的值, 找不到就返回最大的行使求和\u0026lt;n.\n1public static int arrangeCoinSearch(int n){ 2 int low = 0, high = n - 1; 3 while (low \u0026lt; high){ 4 int mid = (low + high) / 2; 5 int predict = ((mid + 1) * mid) / 2; 6 if (n == predict){ 7 return mid; 8 }else if (n \u0026lt; predict){ 9 high = mid - 1; 10 }else { 11 low = mid + 1; 12 } 13 } 14 return low; 15 } 牛顿迭代 给定总数n求行数x, 由于 (x^2 + x) /2= n, 想求对应的x, 实际上是函数f(x) = (x^2 + x) /2 - n的根, 于是可以采用牛顿迭代, 每次迭代x1 = x0 - f(x0)/df(x0) = (x0^2 + 2n)/(2x0+1), 如果从n开始迭代, 则第一次为\n1public static double newtonRecursion(int n, int res){ 2 res = (res * res + 2 * n) / (res * 2 + 1); 3 if (res * res + res == 2 * n){ 4 return res; 5 }else { 6 return newtonRecursion(n, res); 7 } 8 } 环形链表 给定额链表, 判断链表中是否有环(如果链表有某个节点可以通过连续跟踪next指针再次到该节点, 就存在环). 存在环返回true, 否则返回false.\n内部类:\n1//内部类 2 static class ListNode{ 3 int val; 4 ListNode next; 5 6 public ListNode(int val, ListNode next){ 7 this.val = val; 8 this.next = next; 9 } 10 } 11 12 public static void main(String[] args) { 13 ListNode node5 = new ListNode(5, null); 14 ListNode node4 = new ListNode(4, node5); 15 ListNode node3 = new ListNode(3, node4); 16 ListNode node2 = new ListNode(2, node3); 17 ListNode node1 = new ListNode(1, node2); 18 //node5.next = node3; 19 20 System.out.println(isCycle(node1)); 21 System.out.println(isCycleTwoPointer(node1)); 22 } 普通循环 时间O(n), 空间O(n)\n1public static Boolean isCycle(ListNode head){ 2 HashSet\u0026lt;ListNode\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); 3 while (head != null){ 4 if (!set.add(head)){ 5 return true; 6 } 7 head = head.next; 8 } 9 return false; 10 } 双指针 如果快指针和慢指针可以重叠, 说明存在环; 如果快指针到达了null, 说明没有环.\n时间O(n), 空间O(1)\n1public static Boolean isCycleTwoPointer(ListNode head){ 2 if (head == null || head.next == null) return false; 3 ListNode slow = head; 4 ListNode fast = head.next; 5 while (fast.next != null \u0026amp;\u0026amp; fast.next.next != null){ 6 if (slow == fast) return true; 7 slow = slow.next; 8 fast = fast.next.next; 9 } 10 return false; 11 } 合并两个有序数组 两个有序整数数组nums1和nums2, 将nums2合并到nums1中, 使nums1成为一个有序数组. nums1和nums2元素个数分别为m和n, 假设nums1的空间大小等于m+n.\n合并后排序 取决于排序的时间复杂度O(N*logN), 不消化额外空间\n1//m为nums1实际元素个数, n为nums2实际元素个数 2 public static int[] mergeAndSort(int[] nums1, int m, int[] nums2, int n){ 3 //将数组2拷贝至数组1的后面. 4 System.arraycopy(nums2, 0, nums1, m, n); 5 //排序, 复杂度取决于排序的复杂度, 为N*logN 6 Arrays.sort(nums1); 7 return nums1; 8 } 双指针 需要消耗O(n)的空间\n1public static int[] compareAndInsert(int[] nums1, int m, int[] nums2, int n){ 2 //要求返回nums1, 所以我们需要处理一下. 3 int[] num1Copy = new int[m]; 4 System.arraycopy(nums1, 0, num1Copy, 0, m); 5 int pointerNum1 = 0, pointerNum2 = 0; 6 int i = 0; 7// int[] res = new int[m+n]; 8 9 while (pointerNum1 \u0026lt; m \u0026amp;\u0026amp; pointerNum2 \u0026lt; n){ 10 //被选中的才会++, 且是先用后++. 11 nums1[i++] = num1Copy[pointerNum1] \u0026lt; nums2[pointerNum2] ? num1Copy[pointerNum1++] : nums2[pointerNum2++]; 12// if (nums1[pointerNum1] \u0026gt; nums2[pointerNum2]){ 13// res[i] = nums2[pointerNum2]; 14// pointerNum2++; 15// }else { 16// res[i] = nums1[pointerNum1]; 17// pointerNum1++; 18// } 19// i++; 20 } 21 if (pointerNum2 \u0026lt; n){ 22 System.arraycopy(nums2, pointerNum2, nums1, pointerNum1 + pointerNum2, m + n - pointerNum2 -pointerNum1); 23 } 24 if (pointerNum1 \u0026lt; m){ 25 System.arraycopy(num1Copy, pointerNum1, nums1, pointerNum1 + pointerNum2, m + n - pointerNum2 -pointerNum1); 26 } 27 return nums1; 28 } 倒着排 1 public static int[] reverseMerge(int[] nums1, int m, int[] nums2, int n) { 2 int p1 = m - 1, p2 = n-1; 3 int i = m+n-1; 4 5 while (p1 \u0026gt;= 0 \u0026amp;\u0026amp; p2 \u0026gt;= 0) { 6 nums1[i--] = nums1[p1] \u0026gt; nums2[p2] ? nums1[p1--] : nums2[p2--]; 7 } 8 //有两种情况, 1是nums2下标先走完至-1, 这时无序任何操作 9 //2是nums1下标先走完至-1, 这是nums2还有额外的元素需要复制 10 System.arraycopy(nums2, 0, nums1, 0, p2 + 1); 11 return nums1; 12 } 子数组最大平均数 给一个整数数组, 找出平均数最大且长度为k的下标连续的子数组, 并输出该最大平均数.\n输入: [1,12,-5,-6,50,3], k=4\n输出: 12.75\n最大平均数 (12-5-6+50)/4=12.75\n滑动窗口 是双指针的特例:\n1public static double twoPointer(int[] nums, int k){ 2 int pl = 0, pr = k-1; 3 int maxSum = 0; 4 for (int i = pl; i \u0026lt;= pr; i++) { 5 maxSum += nums[i]; 6 } 7 8 while (pr \u0026lt; nums.length - 1){ 9 int tempSum = maxSum -nums[pl] + nums[pr+1]; 10 if (tempSum \u0026gt; maxSum) maxSum = tempSum; 11 pl++; 12 pr++; 13 } 14 15 return 1.0 * maxSum/k; 16 } 由于长度固定, 故只需要一个指针:\n1public static double slideWindow(int[] nums, int k){ 2 int sum = 0; 3 for (int i = 0; i \u0026lt; k; i++) { 4 sum += nums[i]; 5 } 6 int max = sum; 7 8 for (int i = k; i \u0026lt; nums.length; i++) { 9 sum = sum - nums[i-k] + nums[i]; 10 max = Math.max(sum, max); 11 } 12 13 return 1.0 * max/4; 14 } 二叉树的最小深度 最小深度是从根节点到最近叶子节点的最短路径上的节点数量.\n深度优先 先找到叶子节点, 然后从叶子节点往上找, 计算每个节点的最小深度(取左右叶子节点较小的那个+1.\n空间复杂度O(logN) 取决于树的深度, 时间复杂度O(N)\n1\tpublic static int minDepth(TreeNode root) { 2 //空节点 3 if (root == null) return 0; 4 //叶子节点 5 if (root.left == null \u0026amp;\u0026amp; root.right == null) return 1; 6 7 int min = Integer.MAX_VALUE; 8 //寻找左右子节点中最小的深度 9 if (root.left != null) min = Math.min(min, minDepth(root.left)); 10 if (root.right != null) min = Math.min(min, minDepth(root.right)); 11 12 //最后加上本节点的1返回. 13 return min + 1; 14 } 广度优先 一层一层遍历, 遍历到的第一个叶子节点就是最小深度.\n空间复杂度取决于队列O(N), 时间复杂度O(N)\n1public static int minWidth(TreeNode root){ 2 if (root == null) return 0; 3 4 //由于队列的性质, 它是广度遍历. 遍历完同一层才会遍历下一层 5 Queue\u0026lt;TreeNode\u0026gt; queue = new LinkedList\u0026lt;TreeNode\u0026gt;(); 6 root.setDeep(1); 7 //入队 8 queue.offer(root); 9 10 while (!queue.isEmpty()){ 11 //出队 12 TreeNode node = queue.poll(); 13 14 //遍历到根节点直接返回 15 if (node.left == null \u0026amp;\u0026amp; node.right == null){ 16 return node.deep; 17 } 18 19 if (node.left != null) { 20 node.left.setDeep(node.getDeep() + 1); 21 queue.offer(node.left); 22 } 23 if (node.right != null){ 24 node.right.setDeep(node.getDeep() + 1); 25 queue.offer(node.right); 26 } 27 } 28 29 //非正常退出 30 return -1; 31 } 最长连续递增序列 给定一个未排序的整数数组, 找到最长且连续递增的子序列, 并返回该序列的长度.\n方式一: 记录当前序列的开始位置, 如果后面的数字小于这个序列最后一个数, 则更新开始下标.\n方式二: 直接记录最大序列的长度和当前序列的长度.\n1public class MaxSeq { 2 3 public static void main(String[] args) { 4 System.out.println(findLength(new int[]{1,2,3,2,3,4,3,4,5,6,7})); 5 } 6 7 public static int findLength(int[] nums){ 8 int start = 0; 9 int max = 0; 10 for (int i = 1; i \u0026lt; nums.length; i++) { 11 if (nums[i] \u0026lt; nums[i-1]) start = i; 12 max = Math.max(max, i - start + 1); 13 } 14 return max; 15 } 16} 17 柠檬水找零 每杯柠檬水5美元, 顾客排队买, 顾客只会付5, 10, 20美元, 必须给顾客正确找零. 一开始手里面没有任何零钱, 如果能正确找零返回true, 否则返回false.\n分析: 对于顾客付的5美元, 直接收下; 对于顾客付的10美元, 只能找5美元; 对于20美元, 可以三个5, 也可以10+5, 但是为了局部最优, 最好10+5. 因为这里5是万能的, 尽量减少使用.\n1public class LemonWater { 2 3 public static void main(String[] args) { 4 System.out.println(isCanGiveChange(new int[]{5,5,5,20})); 5 6 } 7 8 public static boolean isCanGiveChange(int[] nums){ 9 //5和10的票子数量 10 int fiveNum = 0, tenNum = 0; 11 for (int num: nums) { 12 switch (num){ 13 case 5: 14 fiveNum++; 15 break; 16 case 10: 17 if (fiveNum \u0026gt; 0){ 18 fiveNum--; 19 tenNum++; 20 }else 21 return false; 22 break; 23 case 20: 24 if (fiveNum \u0026gt; 0 \u0026amp;\u0026amp; tenNum \u0026gt; 0){ 25 fiveNum--; 26 tenNum--; 27 }else if (fiveNum \u0026gt;= 3){ 28 fiveNum -= 3; 29 }else 30 return false; 31 } 32 } 33 34 return true; 35 } 36} 37 三角形的最大周长 给一个正数数组arr, 返回由其3个数组成的, 面积不为0的三角形的周长可能的最大值.\n直接找最大和的三个数, 看看是否能形成三角形, 不行就减少最大数继续. 因为既然最大的三个数不行, 那么前两最大的数和任何一个数都不行了, 所以只能往下找.\n1import java.util.Arrays; 2 3public class Triangle { 4 5 public static void main(String[] args) { 6 System.out.println(maxPerimeter(new int[]{3,6,3,2})); 7 } 8 9 public static int maxPerimeter(int[] nums){ 10 Arrays.sort(nums); 11 for (int i = nums.length - 1; i \u0026gt;= 2 ; i--) { 12 if (nums[i-1] + nums[i-2] \u0026gt; nums[i]){ 13 return nums[i] + nums[i-1] + nums[i-2]; 14 } 15 } 16 return 0; 17 } 18} 19 二叉树遍历 前序 递归实现 1//前序:根左右 2 public static void preorder(TreeNode root){ 3 if (root == null) return; 4 5 System.out.println(root.val); 6 preorder(root.left); 7 preorder(root.right); 8 } 中序 递归实现 1 //中序 2 public static void midorder(TreeNode root){ 3 if (root == null) return; 4 5 if (root.left != null){ 6 preorder(root.left); 7 } 8 9 System.out.println(root.val); 10 11 if (root.right != null){ 12 preorder(root.right); 13 } 14 15 } 后序 递归实现 1//后序 2 public static void postorder(TreeNode root){ 3 if (root == null) return; 4 5 if (root.left != null){ 6 preorder(root.left); 7 } 8 9 if (root.right != null){ 10 preorder(root.right); 11 } 12 13 System.out.println(root.val); 14 } 层序 递归实现 1//层序遍历 2 //这个参数i代表的第几层, 由于树不是完全的, 所以一定之间会有null值 3 public static void levelorder(TreeNode root, int i, ArrayList list){ 4 if (root == null) return; 5 6 int length = list.size(); 7 //为防止数组越界, 这里提前填充至i. 8 if (length \u0026lt;= i){ 9 for (int j = 0; j \u0026lt;= i - length; j++) { 10 list.add(length+j, null); 11 } 12 } 13 14 list.set(i, root.val); 15 levelorder(root.left, 2*i, list); 16 levelorder(root.right, 2*i+1, list); 17 } ","date":"2024-07-28","permalink":"/posts/tech/java-5-algorithm/","series":["Java"],"tags":["","",""],"title":"算法刷题"},{"categories":["计算机"],"content":"面向对象高级一 权限修饰符    修饰符 在本类中 同一个包下的其他类里 任意包下的子类里 任意包下的任意类里     private √      缺省 √ √     protected √ √ √    public √ √ √ √    说明: protected修饰的方法可以在任意包下的子类里访问, 但是这个子类对应的实例是不能访问的.\n方法重写规则  使用@Override注解可以帮忙检查是否书写错误 重写父类方法, 子类方法访问权限大于等于父类该方法权限(public\u0026gt;protected\u0026gt;缺省) 重写方法返回值, 必须与被重写方法的返回值类型一样, 或者范围更小 私有方法, 静态方法不能被重写  个人理解这些规则的目的是为了兼容性和安全性.\n子类构造器 子类的全部构造器, 都会默认先调用父类的无参构造器(super()), 再执行自己. 如果父类没有无参构造器, 必须在子类构造器第一行手写super(\u0026hellip;) 调用父类的有参构造器.\n集合框架 \r总结:\r  如果希望记住元素的添加顺序，需要存储重复的元素，又要频繁的根据索引查询数据？\n用ArrayList集合（有序、可重复、有索引），底层基于数组的。（常用）\n  如果希望记住元素的添加顺序，且增删首尾数据的情况较多？\n用LinkedList集合（有序、可重复、有索引），底层基于双链表实现的。\n  如果不在意元素顺序，也没有重复元素需要存储，只希望增删改查都快？\n用HashSet集合（无序，不重复，无索引），底层基于哈希表实现的。 （常用）\n  如果希望记住元素的添加顺序，也没有重复元素需要存储，且希望增删改查都快？\n用LinkedHashSet集合（有序，不重复，无索引）， 底层基于哈希表和双链表。\n  如果要对元素进行排序，也没有重复元素需要存储？且希望增删改查都快？\n用TreeSet集合，基于红黑树实现。\n  Collection接口下有list和set接口, list有序 可重复 有索引, set无序，不重复，无索引.\nCollection接口 特有方法  add(): 添加元素 clear(): 清除集合的元素 isEmpty(): 判断集合是否为空 Size(): 获取集合的大小 contains(Object obj): 判断是否包含 remove(Object obj): 删除元素,有多个删除第一个 toArray(): 将集合转为数组 addAll(Collection): 将一个集合的全部数据倒入到另一个集合中去  1\tCollection\u0026lt;String\u0026gt; c = new ArrayList\u0026lt;\u0026gt;(); // 多态写法 2 // 1.public boolean add(E e)：添加元素, 添加成功返回true。 3 c.add(\u0026#34;java1\u0026#34;); 4 c.add(\u0026#34;java1\u0026#34;); 5 c.add(\u0026#34;java2\u0026#34;); 6 c.add(\u0026#34;java2\u0026#34;); 7 c.add(\u0026#34;java3\u0026#34;); 8 System.out.println(c); 9 10 // 2.public void clear()：清空集合的元素。 11 //c.clear(); 12 //System.out.println(c); 13 14 // 3.public boolean isEmpty()：判断集合是否为空 是空返回true,反之。 15 System.out.println(c.isEmpty()); // false 16 17 // 4.public int size()：获取集合的大小。 18 System.out.println(c.size()); 19 20 // 5.public boolean contains(Object obj)：判断集合中是否包含某个元素。 21 System.out.println(c.contains(\u0026#34;java1\u0026#34;)); // true 22 System.out.println(c.contains(\u0026#34;Java1\u0026#34;)); // false 23 24 // 6.public boolean remove(E e)：删除某个元素:如果有多个重复元素默认删除前面的第一个！ 25 System.out.println(c.remove(\u0026#34;java1\u0026#34;)); 26 System.out.println(c); 27 28 // 7.public Object[] toArray()：把集合转换成数组 29\t//泛型的原因在运行时会擦除, 不能确保集合里都是字符串, 所以是Object数组. 30 Object[] arr = c.toArray(); 31 System.out.println(Arrays.toString(arr)); 32 33\t//这种方式必须确保集合里面都是字符串 34 String[] arr2 = c.toArray(new String[c.size()]); 35 System.out.println(Arrays.toString(arr2)); 36 37 System.out.println(\u0026#34;--------------------------------------------\u0026#34;); 38 // 把一个集合的全部数据倒入到另一个集合中去。 39 Collection\u0026lt;String\u0026gt; c1 = new ArrayList\u0026lt;\u0026gt;(); 40 c1.add(\u0026#34;java1\u0026#34;); 41 c1.add(\u0026#34;java2\u0026#34;); 42 Collection\u0026lt;String\u0026gt; c2 = new ArrayList\u0026lt;\u0026gt;(); 43 c2.add(\u0026#34;java3\u0026#34;); 44 c2.add(\u0026#34;java4\u0026#34;); 45 c1.addAll(c2); // 就是把c2集合的全部数据倒入到c1集合中去。 46 System.out.println(c1); 47 System.out.println(c2); 遍历 1.使用迭代器, iterator()方法返回一个迭代器 迭代器方法:\n boolean hasNext() 询问当前位置是否有元素存在 E next() 获取当前位置的元素, 并同时将迭代器对象指向下一个元素处.  1\tCollection\u0026lt;String\u0026gt; c = new ArrayList\u0026lt;\u0026gt;(); 2 c.add(\u0026#34;赵敏\u0026#34;); 3 c.add(\u0026#34;小昭\u0026#34;); 4 c.add(\u0026#34;素素\u0026#34;); 5 // c.add(\u0026#34;灭绝\u0026#34;); 6 System.out.println(c); 7 // c = [赵敏, 小昭, 素素] 8 // it 9 10 // 使用迭代器遍历集合 11 // 1、从集合对象中获取迭代器对象。 12 Iterator\u0026lt;String\u0026gt; it = c.iterator(); 13// System.out.println(it.next()); 14// System.out.println(it.next()); 15// System.out.println(it.next()); 16// System.out.println(it.next()); 17 // System.out.println(it.next()); // 出现异常的 18 19 // 2、我们应该使用循环结合迭代器遍历集合。 20 while (it.hasNext()){ 21 String ele = it.next(); 22 System.out.println(ele); 23 24 } 2.使用for循环, 本质是迭代器遍历集合. 也可以用来遍历数组 1\tCollection\u0026lt;String\u0026gt; c = new ArrayList\u0026lt;\u0026gt;(); 2 c.add(\u0026#34;赵敏\u0026#34;); 3 c.add(\u0026#34;小昭\u0026#34;); 4 c.add(\u0026#34;素素\u0026#34;); 5 c.add(\u0026#34;灭绝\u0026#34;); 6 System.out.println(c); 7 // c = [赵敏, 小昭, 素素, 灭绝] 8 // ele 9 10 // 使用增强for遍历集合或者数组。 11 for (String ele : c) { 12 System.out.println(ele); 13 } 14 15 String[] names = {\u0026#34;迪丽热巴\u0026#34;, \u0026#34;古力娜扎\u0026#34;, \u0026#34;稀奇哈哈\u0026#34;}; 16 for (String name : names) { 17 System.out.println(name); 18 } 3.Lambda表达式遍历 1\tCollection\u0026lt;String\u0026gt; c = new ArrayList\u0026lt;\u0026gt;(); 2 c.add(\u0026#34;赵敏\u0026#34;); 3 c.add(\u0026#34;小昭\u0026#34;); 4 c.add(\u0026#34;殷素素\u0026#34;); 5 c.add(\u0026#34;周芷若\u0026#34;); 6 System.out.println(c); 7 // [赵敏, 小昭, 殷素素, 周芷若] 8 // s 9 10 // default void forEach(Consumer\u0026lt;? super T\u0026gt; action): 结合Lambda表达式遍历集合： 11 //forEach是Iterable的方法, Collection是Iterable的子接口. 12 c.forEach(new Consumer\u0026lt;String\u0026gt;() { 13 @Override 14 public void accept(String s) { 15 System.out.println(s); 16 } 17 }); 18 19 //@FunctionalInterface函数式注解, 可以将匿名内部类替换为Lambda表达式. 20 c.forEach((String s) -\u0026gt; { 21 System.out.println(s); 22 }); 23 24 c.forEach(s -\u0026gt; { 25 System.out.println(s); 26 }); 27 28 //只有一行可以去掉大括号 29 c.forEach(s -\u0026gt; System.out.println(s) ); 30 31 //函数引用, 前后参数一样的情况下可以用方法引用. System.out这个对象调用println这个方法. 32 c.forEach(System.out::println ); List接口 特有方法  add(int index, E element): 指定位置插入元素, 如果位置已有元素也不会覆盖, 就是中间插, 别的挤旁边了. E remove(int index): 删除指定位置的元素, 返回被删除的值 E set(int index, E element): 修改指定索引处的元素, 返回被修改的元素 E get(int index): 返回指定索引处的元素  1\t// 1.创建一个ArrayList集合对象（有序、可重复、有索引） 2 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); // 一行经典代码 3 list.add(\u0026#34;蜘蛛精\u0026#34;); 4 list.add(\u0026#34;至尊宝\u0026#34;); 5 list.add(\u0026#34;至尊宝\u0026#34;); 6 list.add(\u0026#34;牛夫人\u0026#34;); 7 System.out.println(list); // [蜘蛛精, 至尊宝, 至尊宝, 牛夫人] 8 9 // 2.public void add(int index, E element): 在某个索引位置插入元素。 10 list.add(2, \u0026#34;紫霞仙子\u0026#34;); 11 System.out.println(list); 12 13 // 3.public E remove(int index): 根据索引删除元素,返回被删除元素 14 System.out.println(list.remove(2)); 15 System.out.println(list); 16 17 // 4.public E get(int index): 返回集合中指定位置的元素。 18 System.out.println(list.get(3)); 19 20 // 5.public E set(int index, E element): 修改索引位置处的元素,修改成功后，会返回原来的数据 21 System.out.println(list.set(3, \u0026#34;牛魔王\u0026#34;)); 22 System.out.println(list); 遍历方式 1.Collection支持的它也支持 2.for循环遍历(索引遍历) 1\tList\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); 2 list.add(\u0026#34;糖宝宝\u0026#34;); 3 list.add(\u0026#34;蜘蛛精\u0026#34;); 4 list.add(\u0026#34;至尊宝\u0026#34;); 5 6 //（1）for循环 7 for (int i = 0; i \u0026lt; list.size(); i++) { 8 // i = 0 1 2 9 String s = list.get(i); 10 System.out.println(s); 11 } 12 13 //（2）迭代器。 14 Iterator\u0026lt;String\u0026gt; it = list.iterator(); 15 while (it.hasNext()) { 16 System.out.println(it.next()); 17 } 18 19 //（3）增强for循环（foreach遍历） 20 for (String s : list) { 21 System.out.println(s); 22 } 23 24 //（4）JDK 1.8开始之后的Lambda表达式 25 list.forEach(s -\u0026gt; { 26 System.out.println(s); 27 }); ArrayList的底层原理 特点: 基于数组实现  查询速度快(是根据索引查询数据快): 查询数据通过地址值和索引定位, 查询任意数据耗时相同 删除效率低: 可能需要把后面很多的数据进行前移 添加效率极低:可能需要把后面很多数据后移, 或者需要对数组扩容  底层原理  利用无参构造创建ArrayList时, 底层创建一个长度为0的数组 添加第一个元素时, 底层创建一个新的长度为10的数组 存满时, 扩容至1.5倍 如果一次添加多个数据, 同时即使扩容1.5被也放不下, 那么新创建数组的长度就以刚刚装满为准.  实用场景 适合: 查询数据较多, 或者数据量不是很大时\n不适合: 数据量大的同时又需要频繁进行增删操作.\nLinkedList底层原理 特点: 基于双链表实现 查询慢, 增删相对较快. 对首尾元素进行增删改查的速度是极快的.\n新增方法  addFirst(E e): 开头插入元素, push一样 addLast(E e): 追加元素至末尾, pop一样 E get First(): 返回第一个元素 E get Last(): 返回最后一个元素 E removeFirst(): 从列表中删除并返回第一个元素 E removeLast(): 从列表中删除并返回最后一个元素  应用场景 设计队列:\n1\t// 1、创建一个队列。 2 LinkedList\u0026lt;String\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); 3 // 入队 4 queue.addLast(\u0026#34;第1号人\u0026#34;); 5 queue.addLast(\u0026#34;第2号人\u0026#34;); 6 queue.addLast(\u0026#34;第3号人\u0026#34;); 7 queue.addLast(\u0026#34;第4号人\u0026#34;); 8 System.out.println(queue); 9 // 出队 10 System.out.println(queue.removeFirst()); 11 System.out.println(queue.removeFirst()); 12 System.out.println(queue.removeFirst()); 13 System.out.println(queue); 14 System.out.println(\u0026#34;--------------------------------------------------\u0026#34;); 设计栈:\n1 // 2、创建一个栈对象。 2 LinkedList\u0026lt;String\u0026gt; stack = new LinkedList\u0026lt;\u0026gt;(); 3 // 压栈(push) 4 stack.push(\u0026#34;第1颗子弹\u0026#34;); 5 stack.push(\u0026#34;第2颗子弹\u0026#34;); 6 stack.push(\u0026#34;第3颗子弹\u0026#34;); 7 stack.push(\u0026#34;第4颗子弹\u0026#34;); 8 System.out.println(stack); 9 // 出栈(pop) 10 System.out.println(stack.pop()); 11 System.out.println(stack.pop()); 12 System.out.println(stack); Set接口 set下的实现类增删改查都快.\n HashSet: 无序, 不重复, 无索引 LinkedHashSet: 有序(按添加顺序), 不重复, 无索引 TreeSet: 排序(默认升序), 不重复, 无索引  set几乎没有新增的功能, 都是用Collection的.\n1\t// 1、创建一个Set集合的对象 2 //Set\u0026lt;Integer\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); // 创建了一个HashSet的集合对象 一行经典代码 HashSet: 无序 不重复 无索引 3 Set\u0026lt;Integer\u0026gt; set = new LinkedHashSet\u0026lt;\u0026gt;(); // 有序 不重复 无索引 4// Set\u0026lt;Integer\u0026gt; set = new TreeSet\u0026lt;\u0026gt;(); // 可排序（升序） 不重复 无索引 5 set.add(666); 6 set.add(555); 7 set.add(555); 8 set.add(888); 9 set.add(888); 10 set.add(777); 11 set.add(777); 12 System.out.println(set); HashSet底层原理 Java中每个对象都有个哈希值, 使用hashCode方法返回一个哈希值, 范围是-21亿多到+21亿多. 不同的对象哈希值有可能会相同(哈希碰撞)\nHashSet是基于哈希表实现的, 哈希表是一种增删改查性能都较好的数据结构\n在Jdk8之前哈希表=数组+链表; 在Jdk8开始, 哈希表=数组+链表+红黑树.\njdk8之前:\n 创建一个默认长度16的数组, 默认加载因子0.75, 数组名table 使用元素的哈希值对数组长度求余, 计算存入位置 如果该位置为null, 直接存入 如果该位置不为null, 调用equals方法比较是否相等, 不相等则存入数组(jdk8之前新元素存入数组老元素挂下面; jdk8开始新元素挂老元素下面) 当占满了16(数组长度)*0.75(加载因子)个位置, 数组就开始扩容, 扩大约两倍, 防止链表过长影响查询效率.  jdk8开始, 当链表长度超过8, 同时数组长度\u0026gt;=64时, 自动将链表转成红黑树.\n需了解的树结构  二叉树: 度小于等于2的数 二叉搜索(查找)树: 小的放左边, 大的放右边, 一样的不放. 可能会出现变成链表的情况. 平衡二叉树: 满足查找二叉树规则情况下, 使这棵树尽量变矮. 红黑树: 可以自平衡的二叉树  HashSet去重复 要让HashSet将内容一样的两个对象认为是重复的去重的话, 需要重写hashCode和equals方法.\n1\t// 只要两个对象内容一样就返回true 2 @Override 3 public boolean equals(Object o) { 4 if (this == o) return true; 5 if (o == null || getClass() != o.getClass()) return false; 6 Student student = (Student) o; 7 return age == student.age \u0026amp;\u0026amp; Double.compare(student.height, height) == 0 \u0026amp;\u0026amp; Objects.equals(name, student.name); 8 } 9 10 // 只要两个对象内容一样，返回的哈希值就是一样的。 11 @Override 12 public int hashCode() { 13 // 姓名 年龄 身高计算哈希值的 14 return Objects.hash(name, age, height); 15 } LinkedHashSet底层原理 基于哈希表(数组, 链表, 红黑树)实现. 每个元素额外多了一个双链表机制记录它前后元素的位置. 所以可以有序. 但额外占内存\nTresSet 底层是基于红黑树实现的排序\n 对于数值, 按数值本身大小排序 对于字符串, 按首字母编号升序排序 对于自定义类型, 默认无法直接排序  自定义排序规则 方式一: 自定义类实现Comparable接口, 重写compareTo方法\n1\t@Override 2 public int compareTo(Student o) { 3 // 如果认为左边对象大于右边对象返回正整数 4 // 如果认为左边对象小于右边对象返回负整数 5 // 如果认为左边对象等于右边对象返回0 6 // 需求：按照年龄升序排序、 7 return this.age - o.age; 8 } 方式二: 调用TreeSet有参构造器, 设置Comparator对象\n(Double.compare比较小数, 返回整数.)\n1\tSet\u0026lt;Integer\u0026gt; set1 = new TreeSet\u0026lt;\u0026gt;(); 2 set1.add(6); 3 set1.add(5); 4 set1.add(5); 5 set1.add(7); 6 System.out.println(set1); 7 8 // TreeSet就近选择自己自带的比较器对象进行排序 9// Set\u0026lt;Student\u0026gt; students = new TreeSet\u0026lt;\u0026gt;(new Comparator\u0026lt;Student\u0026gt;() { 10// @Override 11// public int compare(Student o1, Student o2) { 12// // 需求：按照身高升序排序 13// return Double.compare(o1.getHeight() , o2.getHeight()); 14// } 15// }); 16 Set\u0026lt;Student\u0026gt; students = new TreeSet\u0026lt;\u0026gt;(( o1, o2) -\u0026gt; Double.compare(o1.getHeight() , o2.getHeight())); 17 students.add(new Student(\u0026#34;蜘蛛精\u0026#34;,23, 169.7)); 18 students.add(new Student(\u0026#34;紫霞\u0026#34;,22, 169.8)); 19 students.add(new Student(\u0026#34;至尊宝\u0026#34;,26, 165.5)); 20 students.add(new Student(\u0026#34;牛魔王\u0026#34;,22, 183.5)); 21 System.out.println(students); 注意\n 这里既规定了大小, 也规定了相等, 而相等是不存放的. 如果两者都规定了, TreeSet就近选择自己自带的比较器对象进行排序 默认是升序, 如果想要降序只需要将返回值相应地设反即可(大就返回负数).  集合并发修改异常问题 使用集合的remove方法删除的是第一个元素, 这导致出现错位的问题.\n解决方案: 1. 使用迭代器自带的删除方法\n​\t2. for循环倒着删除, 或者每次删除后下标减1.\n1public static void main(String[] args) { 2 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); 3 list.add(\u0026#34;王麻子\u0026#34;); 4 list.add(\u0026#34;小李子\u0026#34;); 5 list.add(\u0026#34;李爱花\u0026#34;); 6 list.add(\u0026#34;张全蛋\u0026#34;); 7 list.add(\u0026#34;晓李\u0026#34;); 8 list.add(\u0026#34;李玉刚\u0026#34;); 9 System.out.println(list); 10 // [王麻子, 小李子, 李爱花, 张全蛋, 晓李, 李玉刚] 11 12 // 需求：找出集合中全部带“李”的名字，并从集合中删除。 13// Iterator\u0026lt;String\u0026gt; it = list.iterator(); 14// while (it.hasNext()){ 15// String name = it.next(); 16// if(name.contains(\u0026#34;李\u0026#34;)){ 17// list.remove(name); 18// } 19// } 20// System.out.println(list); 21 22 // 使用for循环遍历集合并删除集合中带李字的名字 23 // [王麻子, 小李子, 李爱花, 张全蛋, 晓李, 李玉刚] 24 // [王麻子, 李爱花, 张全蛋, 李玉刚] 25 // i 26// for (int i = 0; i \u0026lt; list.size(); i++) { 27// String name = list.get(i); 28// if(name.contains(\u0026#34;李\u0026#34;)){ 29// list.remove(name); 30// } 31// } 32// System.out.println(list); 33 34 System.out.println(\u0026#34;---------------------------------------------------------\u0026#34;); 35 // 怎么解决呢？ 36 // 使用for循环遍历集合并删除集合中带李字的名字 37 // [王麻子, 小李子, 李爱花, 张全蛋, 晓李, 李玉刚] 38 // [王麻子, 张全蛋] 39 // i 40 for (int i = 0; i \u0026lt; list.size(); i++) { 41 String name = list.get(i); 42 if(name.contains(\u0026#34;李\u0026#34;)){ 43 list.remove(name); 44 i--; 45 } 46 } 47 System.out.println(list); 48 // 倒着去删除也是可以的。 49 50 // 需求：找出集合中全部带“李”的名字，并从集合中删除。 51 Iterator\u0026lt;String\u0026gt; it = list.iterator(); 52 while (it.hasNext()){ 53 String name = it.next(); 54 if(name.contains(\u0026#34;李\u0026#34;)){ 55 // list.remove(name); // 并发修改异常的错误。 56 it.remove(); // 删除迭代器当前遍历到的数据，每删除一个数据后，相当于也在底层做了i-- 57 } 58 } 59 System.out.println(list); 60 61 // 使用增强for循环遍历集合并删除数据，没有办法解决bug. 62// for (String name : list) { 63// if(name.contains(\u0026#34;李\u0026#34;)){ 64// list.remove(name); 65// } 66// } 67// System.out.println(list); 68 69// list.forEach(name -\u0026gt; { 70// if(name.contains(\u0026#34;李\u0026#34;)){ 71// list.remove(name); 72// } 73// }); 74// System.out.println(list); 75 } Collections工具类 可变参数, 可以不传也可以传多个(type\u0026hellip; var), 在方法内部就是一个数组, 支持数组的方法.\n关于＜? super T＞:理解Java泛型的复杂写法＜? super T＞,＜? extend T＞ , 大概＜? super T＞代指T及T的父类; ＜? extend T＞指T及T的子类.\n  1public static \u0026lt;T\u0026gt; boolean addAll(Collection\u0026lt;? super T\u0026gt; c, T...elements)：为集合批量添加数据   1public static void shuffle(List\u0026lt;?\u0026gt; list)：打乱List集合中的元素顺序。   1public static \u0026lt;T\u0026gt; void sort(List\u0026lt;T\u0026gt; list)：对List集合中的元素进行升序排序。   1public static \u0026lt;T\u0026gt; void sort(List\u0026lt;T\u0026gt; list， Comparator\u0026lt;? super T\u0026gt; c): 对List集合中元素，按照比较器对象指定的规则进行排序   1\t// 1、public static \u0026lt;T\u0026gt; boolean addAll(Collection\u0026lt;? super T\u0026gt; c, T...elements)：为集合批量添加数据 2 List\u0026lt;String\u0026gt; names = new ArrayList\u0026lt;\u0026gt;(); 3 Collections.addAll(names, \u0026#34;张三\u0026#34;, \u0026#34;王五\u0026#34;, \u0026#34;李四\u0026#34;, \u0026#34;张麻子\u0026#34;); 4 System.out.println(names); 5 6 // 2、public static void shuffle(List\u0026lt;?\u0026gt; list)：打乱List集合中的元素顺序。 7 Collections.shuffle(names); 8 System.out.println(names); 9 10 // 3、 public static \u0026lt;T\u0026gt; void sort(List\u0026lt;T\u0026gt; list)：对List集合中的元素进行升序排序。 11 List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); 12 list.add(3); 13 list.add(5); 14 list.add(2); 15 Collections.sort(list); 16 System.out.println(list); 17 18 List\u0026lt;Student\u0026gt; students = new ArrayList\u0026lt;\u0026gt;(); 19 students.add(new Student(\u0026#34;蜘蛛精\u0026#34;,23, 169.7)); 20 students.add(new Student(\u0026#34;紫霞\u0026#34;,22, 169.8)); 21 students.add(new Student(\u0026#34;紫霞\u0026#34;,22, 169.8)); 22 students.add(new Student(\u0026#34;至尊宝\u0026#34;,26, 165.5)); 23 // Collections.sort(students); 24 // System.out.println(students); 25 26 // 4、public static \u0026lt;T\u0026gt; void sort(List\u0026lt;T\u0026gt; list， Comparator\u0026lt;? super T\u0026gt; c): 对List集合中元素，按照比较器对象指定的规则进行排序 27 Collections.sort(students, new Comparator\u0026lt;Student\u0026gt;() { 28 @Override 29 public int compare(Student o1, Student o2) { 30 return Double.compare(o1.getHeight(), o2.getHeight()); 31 } 32 }); 33 System.out.println(students); Map接口 \r特点(都是由键决定的, 对值没有要求):\n HashMap: 无序, 不重复, 无索引 LinkedHashMap: 有序, 不重复, 无索引 TreeMap: 按照大小默认升序, 不重复, 无索引  1\tpublic static void main(String[] args) { 2 // Map\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); // 一行经典代码。 按照键 无序，不重复，无索引。 3 Map\u0026lt;String, Integer\u0026gt; map = new LinkedHashMap\u0026lt;\u0026gt;(); // 有序，不重复，无索引。 4 map.put(\u0026#34;手表\u0026#34;, 100); 5 map.put(\u0026#34;手表\u0026#34;, 220); // 后面重复的数据会覆盖前面的数据（键） 6 map.put(\u0026#34;手机\u0026#34;, 2); 7 map.put(\u0026#34;Java\u0026#34;, 2); 8 map.put(null, null); 9 System.out.println(map); 10 11 Map\u0026lt;Integer, String\u0026gt; map1 = new TreeMap\u0026lt;\u0026gt;(); // 可排序，不重复，无索引 12 map1.put(23, \u0026#34;Java\u0026#34;); 13 map1.put(23, \u0026#34;MySQL\u0026#34;); 14 map1.put(19, \u0026#34;李四\u0026#34;); 15 map1.put(20, \u0026#34;王五\u0026#34;); 16 System.out.println(map1); 17 } Map的常用方法  put添加元素: 无序, 不重复, 无索引 public int size(): 获取集合的大小 public void clear(): 清空集合 public boolean isEmpty(): 判断集合是否为空, 为空返回true public V get(Object key): 根据键获取对应值 public V remove(Object key): 根据键删除整个元素(删除键会返回键的值) public boolean containsKey(Object key): 判断是否包含某个键 , 包含返回true public boolean containsValue(Object value): 判断是否包含某个值 public Set keySet(): 获取Map集合的全部键 public Collection values(): 获取Map集合的全部值 putAll把其他Map集合的数据倒入到自己集合中来  1\tpublic static void main(String[] args) { 2 // 1.添加元素: 无序，不重复，无索引。 3 Map\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); 4 map.put(\u0026#34;手表\u0026#34;, 100); 5 map.put(\u0026#34;手表\u0026#34;, 220); 6 map.put(\u0026#34;手机\u0026#34;, 2); 7 map.put(\u0026#34;Java\u0026#34;, 2); 8 map.put(null, null); 9 System.out.println(map); 10 // map = {null=null, 手表=220, Java=2, 手机=2} 11 12 // 2.public int size():获取集合的大小 13 System.out.println(map.size()); 14 15 // 3、public void clear():清空集合 16 //map.clear(); 17 //System.out.println(map); 18 19 // 4.public boolean isEmpty(): 判断集合是否为空，为空返回true ,反之！ 20 System.out.println(map.isEmpty()); 21 22 // 5.public V get(Object key)：根据键获取对应值 23 int v1 = map.get(\u0026#34;手表\u0026#34;); 24 System.out.println(v1); 25 System.out.println(map.get(\u0026#34;手机\u0026#34;)); // 2 26 System.out.println(map.get(\u0026#34;张三\u0026#34;)); // null 27 28 // 6. public V remove(Object key)：根据键删除整个元素(删除键会返回键的值) 29 System.out.println(map.remove(\u0026#34;手表\u0026#34;)); 30 System.out.println(map); 31 32 // 7.public boolean containsKey(Object key): 判断是否包含某个键 ，包含返回true ,反之 33 System.out.println(map.containsKey(\u0026#34;手表\u0026#34;)); // false 34 System.out.println(map.containsKey(\u0026#34;手机\u0026#34;)); // true 35 System.out.println(map.containsKey(\u0026#34;java\u0026#34;)); // false 36 System.out.println(map.containsKey(\u0026#34;Java\u0026#34;)); // true 37 38 // 8.public boolean containsValue(Object value): 判断是否包含某个值。 39 System.out.println(map.containsValue(2)); // true 40 System.out.println(map.containsValue(\u0026#34;2\u0026#34;)); // false 41 42 // 9.public Set\u0026lt;K\u0026gt; keySet(): 获取Map集合的全部键。 43 Set\u0026lt;String\u0026gt; keys = map.keySet(); 44 System.out.println(keys); 45 46 // 10.public Collection\u0026lt;V\u0026gt; values(); 获取Map集合的全部值。 47 Collection\u0026lt;Integer\u0026gt; values = map.values(); 48 System.out.println(values); 49 50 // 11.把其他Map集合的数据倒入到自己集合中来。(拓展) 51 Map\u0026lt;String, Integer\u0026gt; map1 = new HashMap\u0026lt;\u0026gt;(); 52 map1.put(\u0026#34;java1\u0026#34;, 10); 53 map1.put(\u0026#34;java2\u0026#34;, 20); 54 Map\u0026lt;String, Integer\u0026gt; map2 = new HashMap\u0026lt;\u0026gt;(); 55 map2.put(\u0026#34;java3\u0026#34;, 10); 56 map2.put(\u0026#34;java2\u0026#34;, 222); 57 map1.putAll(map2); // putAll：把map2集合中的元素全部倒入一份到map1集合中去。 58 System.out.println(map1); 59 System.out.println(map2); 60 } 遍历 1. 先获取全部键, 再找值 1for (String key : keys) { 2 // 根据键获取对应的值 3 double value = map.get(key); 4 System.out.println(key + \u0026#34;=====\u0026gt;\u0026#34; + value); 5 } 2. 将键值对看做整体遍历 将键值对封装成一个entry对象, 然后用getKey和getValue取里面的键值.\n1\t// 1、调用Map集合提供entrySet方法，把Map集合转换成键值对类型的Set集合 2 Set\u0026lt;Map.Entry\u0026lt;String, Double\u0026gt;\u0026gt; entries = map.entrySet(); 3 for (Map.Entry\u0026lt;String, Double\u0026gt; entry : entries) { 4 String key = entry.getKey(); 5 double value = entry.getValue(); 6 System.out.println(key + \u0026#34;----\u0026gt;\u0026#34; + value); 7 } 3.Lambda遍历 1map.forEach(( k, v) -\u0026gt; { 2 System.out.println(k + \u0026#34;----\u0026gt;\u0026#34; + v); 3 }); HashMap底层原理 HashMap和HashSet底层原理一模一样, 都是基于哈希表实现, 这是因为Set系列的底层就是基于Map实现, 只是Set只需要键数据, 不需要值数据. 算位置时都是根据键算的, 每个位置放的都是一个Entry对象.\nLinkedHashMap底层原理 底层数据结构依然是基于哈希表实现的, 只是每个键值对元素又额外的多了一个双链表的机制记录元素顺序(保证有序). 实际上: 原来学习的LinkedHashSet集合的底层原理就是LinkedHashMap.\nTreeMap TreeMap跟TreeSet集合的底层原理是一样的，都是基于红黑树实现的排序。\nTreeMap 集合同样也支持两种方式来指定排序规则\n 让类实现Comparable接口，重写比较规则。 TreeMap集合有一个有参数构造器，支持创建Comparator比较器对象，以便用来指定比较规则。  Stream流 初识Stream流 使用stream()方法获得流对象, 然后filter过滤, 其中的s表示对每个列表中的元素进行过滤. 最后使用collect方法传入Collectors.toList()将其转化为列表.\n1\tpublic static void main(String[] args) { 2 List\u0026lt;String\u0026gt; names = new ArrayList\u0026lt;\u0026gt;(); 3 Collections.addAll(names, \u0026#34;张三丰\u0026#34;,\u0026#34;张无忌\u0026#34;,\u0026#34;周芷若\u0026#34;,\u0026#34;赵敏\u0026#34;,\u0026#34;张强\u0026#34;); 4 System.out.println(names); 5 // names = [张三丰, 张无忌, 周芷若, 赵敏, 张强] 6 // name 7 8 // 找出姓张，且是3个字的名字，存入到一个新集合中去。 9 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); 10 for (String name : names) { 11 if(name.startsWith(\u0026#34;张\u0026#34;) \u0026amp;\u0026amp; name.length() == 3){ 12 list.add(name); 13 } 14 } 15 System.out.println(list); 16 17 // 开始使用Stream流来解决这个需求。 18 List\u0026lt;String\u0026gt; list2 = names.stream().filter(s -\u0026gt; s.startsWith(\u0026#34;张\u0026#34;)) 19 .filter(a -\u0026gt; a.length()==3).collect(Collectors.toList()); 20 System.out.println(list2); 21 } 获取Stream流 对于List和Set, 调用stream方法即可. 对于Map, 需要分开键值对, 或者直接调用entrySet得到Entry对象的集合再使用Stream\nArrays和Stream类都提供了静态方法来创建Stream: Arrays.stream(), Stream.of().\n这里还使用了Stream的foreach方法对stream进行遍历.\n1\tpublic static void main(String[] args) { 2 // 1、如何获取List集合的Stream流？ 3 List\u0026lt;String\u0026gt; names = new ArrayList\u0026lt;\u0026gt;(); 4 Collections.addAll(names, \u0026#34;张三丰\u0026#34;,\u0026#34;张无忌\u0026#34;,\u0026#34;周芷若\u0026#34;,\u0026#34;赵敏\u0026#34;,\u0026#34;张强\u0026#34;); 5 Stream\u0026lt;String\u0026gt; stream = names.stream(); 6 7 // 2、如何获取Set集合的Stream流？ 8 Set\u0026lt;String\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); 9 Collections.addAll(set, \u0026#34;刘德华\u0026#34;,\u0026#34;张曼玉\u0026#34;,\u0026#34;蜘蛛精\u0026#34;,\u0026#34;马德\u0026#34;,\u0026#34;德玛西亚\u0026#34;); 10 Stream\u0026lt;String\u0026gt; stream1 = set.stream(); 11 stream1.filter(s -\u0026gt; s.contains(\u0026#34;德\u0026#34;)).forEach(s -\u0026gt; System.out.println(s)); 12 13 // 3、如何获取Map集合的Stream流？ 14 Map\u0026lt;String, Double\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); 15 map.put(\u0026#34;古力娜扎\u0026#34;, 172.3); 16 map.put(\u0026#34;迪丽热巴\u0026#34;, 168.3); 17 map.put(\u0026#34;马尔扎哈\u0026#34;, 166.3); 18 map.put(\u0026#34;卡尔扎巴\u0026#34;, 168.3); 19 20 Set\u0026lt;String\u0026gt; keys = map.keySet(); 21 Stream\u0026lt;String\u0026gt; ks = keys.stream(); 22 23 Collection\u0026lt;Double\u0026gt; values = map.values(); 24 Stream\u0026lt;Double\u0026gt; vs = values.stream(); 25 26 Set\u0026lt;Map.Entry\u0026lt;String, Double\u0026gt;\u0026gt; entries = map.entrySet(); 27 Stream\u0026lt;Map.Entry\u0026lt;String, Double\u0026gt;\u0026gt; kvs = entries.stream(); 28 kvs.filter(e -\u0026gt; e.getKey().contains(\u0026#34;巴\u0026#34;)) 29 .forEach(e -\u0026gt; System.out.println(e.getKey()+ \u0026#34;--\u0026gt;\u0026#34; + e.getValue())); 30 31 // 4、如何获取数组的Stream流？ 32 String[] names2 = {\u0026#34;张翠山\u0026#34;, \u0026#34;东方不败\u0026#34;, \u0026#34;唐大山\u0026#34;, \u0026#34;独孤求败\u0026#34;}; 33 Stream\u0026lt;String\u0026gt; s1 = Arrays.stream(names2); 34 Stream\u0026lt;String\u0026gt; s2 = Stream.of(names2); 35 } Stream流的中间方法 返回的也是stream, 所以支持链式编程.\n  filter: 过滤, 滤出满足条件的元素\n  sorted: 默认升序. 如果是复杂的对象需要提供比较器, 第一个大于第二个返回正数就是升序\n(对于小数创建比较器, 由于比较器返回的必须是整数, 因此使用Double.compare方法很便利)\n  limit(long maxSize): 取出前面的maxSize个元素\n  skip(long n): 跳过前面n个元素, 还剩size()-n个元素.\n  map: 映射, 将一个东西用另一个东西来表示.\n  distinct: 去重复, 内部使用hashCode和equals比较.\n  concat: 合并两个流为一个, 两个流里面的元素可以不一样, 返回object流.\n  1\tpublic static void main(String[] args) { 2 List\u0026lt;Double\u0026gt; scores = new ArrayList\u0026lt;\u0026gt;(); 3 Collections.addAll(scores, 88.5, 100.0, 60.0, 99.0, 9.5, 99.6, 25.0); 4 // 需求1：找出成绩大于等于60分的数据，并升序后，再输出。 5 scores.stream().filter(s -\u0026gt; s \u0026gt;= 60).sorted().forEach(s -\u0026gt; System.out.println(s)); 6 7 List\u0026lt;Student\u0026gt; students = new ArrayList\u0026lt;\u0026gt;(); 8 Student s1 = new Student(\u0026#34;蜘蛛精\u0026#34;, 26, 172.5); 9 Student s2 = new Student(\u0026#34;蜘蛛精\u0026#34;, 26, 172.5); 10 Student s3 = new Student(\u0026#34;紫霞\u0026#34;, 23, 167.6); 11 Student s4 = new Student(\u0026#34;白晶晶\u0026#34;, 25, 169.0); 12 Student s5 = new Student(\u0026#34;牛魔王\u0026#34;, 35, 183.3); 13 Student s6 = new Student(\u0026#34;牛夫人\u0026#34;, 34, 168.5); 14 Collections.addAll(students, s1, s2, s3, s4, s5, s6); 15 // 需求2：找出年龄大于等于23,且年龄小于等于30岁的学生，并按照年龄降序输出. 16 students.stream().filter(s -\u0026gt; s.getAge() \u0026gt;= 23 \u0026amp;\u0026amp; s.getAge() \u0026lt;= 30) 17 .sorted((o1, o2) -\u0026gt; o2.getAge() - o1.getAge()) 18 .forEach(s -\u0026gt; System.out.println(s)); 19 20 // 需求3：取出身高最高的前3名学生，并输出。 21 students.stream().sorted((o1, o2) -\u0026gt; Double.compare(o2.getHeight(), o1.getHeight())) 22 .limit(3).forEach(System.out::println); 23 System.out.println(\u0026#34;----------------------------------------------------------------\u0026#34;); 24 25 // 需求4：取出身高倒数的2名学生，并输出。 s1 s2 s3 s4 s5 s6 26 students.stream().sorted((o1, o2) -\u0026gt; Double.compare(o2.getHeight(), o1.getHeight())) 27 .skip(students.size() - 2).forEach(System.out::println); 28 29 // 需求5：找出身高超过168的学生叫什么名字，要求去除重复的名字，再输出。 30 students.stream().filter(s -\u0026gt; s.getHeight() \u0026gt; 168).map(Student::getName) 31 .distinct().forEach(System.out::println); 32 33 // distinct去重复，自定义类型的对象（希望内容一样就认为重复，重写hashCode,equals） 34 students.stream().filter(s -\u0026gt; s.getHeight() \u0026gt; 168) 35 .distinct().forEach(System.out::println); 36 37 Stream\u0026lt;String\u0026gt; st1 = Stream.of(\u0026#34;张三\u0026#34;, \u0026#34;李四\u0026#34;); 38 Stream\u0026lt;String\u0026gt; st2 = Stream.of(\u0026#34;张三2\u0026#34;, \u0026#34;李四2\u0026#34;, \u0026#34;王五\u0026#34;); 39 Stream\u0026lt;String\u0026gt; allSt = Stream.concat(st1, st2); 40 allSt.forEach(System.out::println); 41 } Stream流的终结方法  forEach: 每个进行遍历. count: 返回stream里面的元素个数. max: 返回装有最大值的一个容(Optional), 必要时提供比较器. 最后使用get()取出 min: 找最小值. 其余同上  收集Stream流  collect: 将流处理后的结果收集到一个指定的集合中 toArray: 收集到一个数组中. 默认是Object数组, 如果希望是其他类型需要显式提供  收集方式:\n Collections.toList() Collections.toSet(): 自动去重复, 去重依赖于hashCode和equals. Collections.toMap(): 需要提供键和值.  注意, 流只能使用一个, 在被收集之后就关闭了.\n1public static void main(String[] args) { 2 List\u0026lt;Student\u0026gt; students = new ArrayList\u0026lt;\u0026gt;(); 3 Student s1 = new Student(\u0026#34;蜘蛛精\u0026#34;, 26, 172.5); 4 Student s2 = new Student(\u0026#34;蜘蛛精\u0026#34;, 26, 172.5); 5 Student s3 = new Student(\u0026#34;紫霞\u0026#34;, 23, 167.6); 6 Student s4 = new Student(\u0026#34;白晶晶\u0026#34;, 25, 169.0); 7 Student s5 = new Student(\u0026#34;牛魔王\u0026#34;, 35, 183.3); 8 Student s6 = new Student(\u0026#34;牛夫人\u0026#34;, 34, 168.5); 9 Collections.addAll(students, s1, s2, s3, s4, s5, s6); 10 // 需求1：请计算出身高超过168的学生有几人。 11 long size = students.stream().filter(s -\u0026gt; s.getHeight() \u0026gt; 168).count(); 12 System.out.println(size); 13 14 // 需求2：请找出身高最高的学生对象，并输出。 15 Student s = students.stream().max((o1, o2) -\u0026gt; Double.compare(o1.getHeight(), o2.getHeight())).get(); 16 System.out.println(s); 17 18 // 需求3：请找出身高最矮的学生对象，并输出。 19 Student ss = students.stream().min((o1, o2) -\u0026gt; Double.compare(o1.getHeight(), o2.getHeight())).get(); 20 System.out.println(ss); 21 22 // 需求4：请找出身高超过170的学生对象，并放到一个新集合中去返回。 23 // 流只能收集一次。 24 List\u0026lt;Student\u0026gt; students1 = students 25 .stream() 26 .filter(a -\u0026gt; a.getHeight() \u0026gt; 170) 27 .collect(Collectors.toList()); 28 System.out.println(students1); 29 30 Set\u0026lt;Student\u0026gt; students2 = students 31 .stream() 32 .filter(a -\u0026gt; a.getHeight() \u0026gt; 170) 33 .collect(Collectors.toSet()); 34 System.out.println(students2); 35 36 // 需求5：请找出身高超过170的学生对象，并把学生对象的名字和身高，存入到一个Map集合返回。 37// Map\u0026lt;String, Double\u0026gt; map = students 38// .stream() 39// .filter(a -\u0026gt; a.getHeight() \u0026gt; 170) 40// .distinct() 41// .collect(Collectors.toMap(a -\u0026gt; a.getName(), a -\u0026gt; a.getHeight())); 42 43 Map\u0026lt;String, Student\u0026gt; map = students 44 .stream() 45 .filter(a -\u0026gt; a.getHeight() \u0026gt; 170) 46 .distinct() 47 .collect(Collectors.toMap(a -\u0026gt; a.getName(), a -\u0026gt; a)); 48 System.out.println(map); 49 50 // Object[] arr = students.stream().filter(a -\u0026gt; a.getHeight() \u0026gt; 170).toArray(); 51 // Student[] arr = students.stream().filter(a -\u0026gt; a.getHeight() \u0026gt; 170).toArray(len -\u0026gt; new Student[len]); 52 Student[] arr = students.stream().filter(a -\u0026gt; a.getHeight() \u0026gt; 170).toArray(Student[]::new); 53 System.out.println(Arrays.toString(arr)); 54 } 我感觉stream编程里面很多都可以使用方法引用, 这时Lambda表达式都多余了. Lambda表达式里面的变量随便设置.\nJava高级 反射 获取类的字节码: Class对象  静态方法: 类名.class 调用Class的方法forName, 填入类的名称 调用Object类的方法getClass, 需要现有这个类的对象, 然后: 对象.getClass()  一个类的Class对象只有一个, 不同方式获取的Class对象指向的是同一地址.\n1\tpublic static void main(String[] args) throws Exception { 2 Class c1 = Student.class; 3 System.out.println(c1.getName()); // 全类名 4 System.out.println(c1.getSimpleName()); // 简名：Student 5 6 Class c2 = Class.forName(\u0026#34;com.itheima.d2_reflect.Student\u0026#34;); 7 System.out.println(c1 == c2); 8 9 Student s = new Student(); 10 Class c3 = s.getClass(); 11 System.out.println(c3 == c2); 12 } 由Class获取类的构造器并初始化对象 属于Class类的方法:\n getConstructors: 获取全部构造器(只能获取public修饰的) getDeclaredConstructors: 获取全部构造器(只要存在就能拿到) getConstructor(Class\u0026lt;?\u0026gt;): 获取某个构造器(只能获取public修饰的), 需要时填入对应方法对应参数的字节码. getDeclaredConstructor(Class\u0026lt;?\u0026gt;): 获取某个构造器(只要存在就能拿到), 需要时填入对应方法对应参数的字节码.  一般就用getDeclaredConstructor(s), 都可以得到.\n获取类的构造器的作用是初始化一个对象返回, 下面的Constructor对象的方法:\n T newInstance(Object\u0026hellip; initargs): 调用构造器, 传入对应需要的参数, 完成对象初始化并返回. setAccessible(boolean): 设置为true, 表示禁止检查访问控制(暴力反射)  构造器有个泛型, 不指定的话返回的都是Object类, 需要强转.\n1@Test 2 public void testGetConstructors(){ 3 // 1、反射第一步：必须先得到这个类的Class对象 4 Class c = Cat.class; 5 // 2、获取类的全部构造器 6 // Constructor[] constructors = c.getConstructors(); 7 Constructor[] constructors = c.getDeclaredConstructors(); 8 // 3、遍历数组中的每个构造器对象 9 for (Constructor constructor : constructors) { 10 System.out.println(constructor.getName() + \u0026#34;---\u0026gt;\u0026#34; 11 + constructor.getParameterCount()); 12 } 13 } 14 15 @Test 16 public void testGetConstructor() throws Exception { 17 // 1、反射第一步：必须先得到这个类的Class对象 18 Class c = Cat.class; 19 // 2、获取类的某个构造器：无参数构造器 20 Constructor constructor1 = c.getDeclaredConstructor(); 21 System.out.println(constructor1.getName() + \u0026#34;---\u0026gt;\u0026#34; 22 + constructor1.getParameterCount()); 23 constructor1.setAccessible(true); // 禁止检查访问权限 24 Cat cat = (Cat) constructor1.newInstance(); 25 System.out.println(cat); 26 27 AtomicInteger a; 28 29 30 // 3、获取有参数构造器 31 Constructor constructor2 = 32 c.getDeclaredConstructor(String.class, int.class); 33 System.out.println(constructor2.getName() + \u0026#34;---\u0026gt;\u0026#34; 34 + constructor2.getParameterCount()); 35 constructor2.setAccessible(true); // 禁止检查访问权限 36 Cat cat2 = (Cat) constructor2.newInstance(\u0026#34;叮当猫\u0026#34;, 3); 37 System.out.println(cat2); 38 39 } 由Class获取类的成员变量并赋值和取值 属于Class类的方法:\n Field[] getFields(): 获取类的全部成员变量(只能获取public修饰的) Field[] getDeclaredFields(): 获取类的全部成员变量(只要存在就能拿到) Field getField(String name): 获取类的某个成员变量(只能获取public修饰的) Field getDeclaredField(String name): 获取类的某个成员变量(只要存在就能拿到)  获取成员变量是用来赋值和取值, 下面的方法Field对象的\n set(Object obj, Object value): 赋值, 第一个参数是对象实例, 第二个是赋值的内容 get(Object obj): 取值, 传入对应对象. setAccessible: 设置禁止检查访问控制  1\t@Test 2 public void testGetFields() throws Exception { 3 // 1、反射第一步：必须是先得到类的Class对象 4 Class c = Cat.class; 5 // 2、获取类的全部成员变量。 6 Field[] fields = c.getDeclaredFields(); 7 // 3、遍历这个成员变量数组 8 for (Field field : fields) { 9 System.out.println(field.getName() + \u0026#34;---\u0026gt; \u0026#34;+ field.getType()); 10 } 11 // 4、定位某个成员变量 12 Field fName = c.getDeclaredField(\u0026#34;name\u0026#34;); 13 System.out.println(fName.getName() + \u0026#34;---\u0026gt;\u0026#34; + fName.getType()); 14 15 Field fAge = c.getDeclaredField(\u0026#34;age\u0026#34;); 16 System.out.println(fAge.getName() + \u0026#34;---\u0026gt;\u0026#34; + fAge.getType()); 17 18 // 赋值 19 Cat cat = new Cat(); 20 fName.setAccessible(true); // 禁止访问控制权限 21 fName.set(cat, \u0026#34;卡菲猫\u0026#34;); 22 System.out.println(cat); 23 24 // 取值 25 String name = (String) fName.get(cat); 26 System.out.println(name); 27 } 由Class获取类的成员方法并 属于Class类的方法:\n Method[] getMethods(): 获取类的全部成员方法(只能获取public修饰的) Method[] getDeclaredMethods(): 获取类的全部成员方法(只要存在) Method[] getMethod(String name, Class\u0026lt;?\u0026gt;\u0026hellip; ): 获取类的某个成员方法(只能获取public修饰的), 第一个参数是方法名. 对于某些方法重载, 需要填入参数的字节码对象才能定位. Method[] getDeclaredMethod(String name, Class\u0026lt;?\u0026gt;\u0026hellip; ): 获取类的某个成员方法(只要存在), 第一个参数是方法名. 对于某些方法重载, 需要填入参数的字节码对象才能定位.  获取类的成员方法是执行方法, 下面是Method类的方法:\n Object invoke(Object, Object\u0026hellip; args): 触发某个对象该方法的执行. 第一个参数是对象实例. setAccessible: 设置禁止检查访问控制  1\t@Test 2 public void testGetMethods() throws Exception { 3 // 1、反射第一步：先得到Class对象。 4 Class c = Cat.class; 5 // 2、获取类的全部成员方法。 6 Method[] methods = c.getDeclaredMethods(); 7 // 3、遍历这个数组中的每个方法对象 8 for (Method method : methods) { 9 System.out.println(method.getName() + \u0026#34;---\u0026gt;\u0026#34; 10 + method.getParameterCount() + \u0026#34;----\u0026gt;\u0026#34; 11 + method.getReturnType()); 12 } 13 // 4、获取某个方法对象 14 Method run = c.getDeclaredMethod(\u0026#34;run\u0026#34;); // 拿run方法，无参数的 15 System.out.println(run.getName() + \u0026#34;---\u0026gt;\u0026#34; 16 + run.getParameterCount() + \u0026#34;----\u0026gt;\u0026#34; 17 + run.getReturnType()); 18 19 Method eat = c.getDeclaredMethod(\u0026#34;eat\u0026#34;, String.class); 20 System.out.println(eat.getName() + \u0026#34;---\u0026gt;\u0026#34; 21 + eat.getParameterCount() + \u0026#34;----\u0026gt;\u0026#34; 22 + eat.getReturnType()); 23 24 Cat cat = new Cat(); 25 run.setAccessible(true); // 禁止检查访问权限 26 Object rs = run.invoke(cat); // 调用无参数的run方法，用cat对象触发调用的。 27 System.out.println(rs); 28 29 eat.setAccessible(true); // 禁止检查访问权限 30 String rs2 = (String) eat.invoke(cat, \u0026#34;鱼儿\u0026#34;); 31 System.out.println(rs2); 32 } 都有setAccessible是因为Constructor, Field, Method类的父类都有AccessibleObject, 里面就有setAccessible.\n作用, 应用场景  得到一个类的全部成分然后操作 可以破坏封装性 适合做Java的框架, 基于反射设计通用的功能.  需求: 将对象的字段名和对应的值都保存到文件中\n1\t// 目标：保存任意对象的字段和其数据到文件中去 2 public static void saveObject(Object obj) throws Exception { 3 PrintStream ps = new PrintStream(new FileOutputStream(\u0026#34;junit-reflect-annotation-proxy-app\\\\src\\\\data.txt\u0026#34;, true)); 4 // obj是任意对象，到底有多少个字段要保存。 5 Class c = obj.getClass(); 6 String cName = c.getSimpleName(); 7 ps.println(\u0026#34;---------------\u0026#34; + cName + \u0026#34;------------------------\u0026#34;); 8 // 2、从这个类中提取它的全部成员变量 9 Field[] fields = c.getDeclaredFields(); 10 // 3、遍历每个成员变量。 11 for (Field field : fields) { 12 // 4、拿到成员变量的名字 13 String name = field.getName(); 14 // 5、拿到这个成员变量在对象中的数据。 15 field.setAccessible(true); // 禁止检查访问控制 16 String value = field.get(obj) + \u0026#34;\u0026#34;; 17 ps.println(name + \u0026#34;=\u0026#34; + value); 18 } 19 ps.close(); 20 } 注解 让别的程序根据注解信息决定怎么执行该程序\n自定义注解 1public @interface 注解名称{ 2\tpublic 属性类型 属性名() default 默认值; 3} 比如:\n1public @interface MyTest1 { 2 String aaa(); 3 boolean bbb() default true; 4 String[] ccc(); 5} 在其他类使用注解时, 需要添加上这些属性的值:\n1@MyTest1(aaa=\u0026#34;牛魔王\u0026#34;, ccc={\u0026#34;HTML\u0026#34;, \u0026#34;Java\u0026#34;}) 2// @MyTest2(value = \u0026#34;孙悟空\u0026#34;) 3//@MyTest2(\u0026#34;孙悟空\u0026#34;) 4//@MyTest2(value = \u0026#34;孙悟空\u0026#34;, age = 1000) 5@MyTest2(\u0026#34;孙悟空\u0026#34;) 6public class AnnotationTest1 { 7 @MyTest1(aaa=\u0026#34;铁扇公主\u0026#34;, bbb=false, ccc={\u0026#34;Python\u0026#34;, \u0026#34;前端\u0026#34;, \u0026#34;Java\u0026#34;}) 8 public void test1(){ 9 10 } 11 12 public static void main(String[] args) { 13 14 } 15} 注意: value属性, 如果只有一个value属性的情况下, 使用value属性的时候可以省略value名称不写!! l但是如果有多个属性, 且多个属性没有默认值, 那么value名称是不能省略的.\n1public @interface MyTest2 { 2 String value(); // 特殊属性 3 int age() default 23; 4} 注解的原理 注解本质是一个接口, Java中所有注解都是继承了Annotation接口的, 而@注解其实就是一个实现类对象, 实现了该注解以及Annotaion接口.\n上面的MyTest1注解经过编译后变成了:\n1public interface MyTest1 extends Annotaion{ 2\tpublic abstract String aaa(); 3\tpublic abstract boolean bbb(); 4\tpublic abstract String[] ccc(); 5} 元注解 修饰注解的注解\n@Target注解: 声明被修饰的注解只能在哪些位置使用\n TYPE: 类, 接口 FIELD: 成员变量 METHOD: 成员方法 PARAMETER: 方法参数 CONSTRUCTOR: 构造器 LOCAL_VARIABLE: 局部变量  如@Target(ElementType.TYPE)就只能用在类或接口上, 其余的都不行.\n@Retention: 声明注解的保留周期\n SOURCE: 只作用在源码阶段, 字节码文件中不存在 CLASS(默认): 保留到字节码文件阶段, 运行阶段不存在 RUNTIME(开发常用): 一直保留到运行阶段  如@Retention(RetentionPolicy.RUNTIME)代码修饰的这个注解运行时也能看到.\n1@Target({ElementType.TYPE, ElementType.METHOD}) // 当前被修饰的注解只能用在类上，方法上。 2@Retention(RetentionPolicy.RUNTIME) // 控制下面的注解一直保留到运行时 3public @interface MyTest3 { 4} 1@MyTest3 2public class AnnotationTest2 { 3 4 // @MyTest3 5 private String name; 6 7 @MyTest3 8 public void test(){ 9 10 } 11} 注解的解析 判断类上, 方法上, 成员变量上等地方是否存在注解, 并将注解的内容解析出来.\n要解析谁上面的注解, 就应先把谁拿到; 解析类上的先拿Class对象, 解析方法上的拿Method对象.\nClass, Method, Field, Constructor都实现了AnnotatedElement接口, 它们都有解析注解的能力.\n Annotaion[] getDeclaredAnnotaions(): 获取当前对象上的注解 T getDeclaredAnnotaion(Class\u0026lt;T\u0026gt; annotaionClass): 获取指定的注解对象 boolean isAnnotaionPresent(Class\u0026lt;Annotaion\u0026gt; annotaionClass): 判断某个对象上是否存在某个注解  1@Test 2 public void parseClass(){ 3 // 1、先得到Class对象 4 Class c = Demo.class; 5 // 2、解析类上的注解 6 // 判断类上是否包含了某个注解 7 if(c.isAnnotationPresent(MyTest4.class)){ 8 MyTest4 myTest4 = 9 (MyTest4) c.getDeclaredAnnotation(MyTest4.class); 10 System.out.println(myTest4.value()); 11 System.out.println(myTest4.aaa()); 12 System.out.println(Arrays.toString(myTest4.bbb())); 13 } 14 } 15 16 @Test 17 public void parseMethod() throws Exception { 18 // 1、先得到Class对象 19 Class c = Demo.class; 20 Method m = c.getDeclaredMethod(\u0026#34;test1\u0026#34;); 21 // 2、解析方法上的注解 22 // 判断方法对象上是否包含了某个注解 23 if(m.isAnnotationPresent(MyTest4.class)){ 24 MyTest4 myTest4 = 25 (MyTest4) m.getDeclaredAnnotation(MyTest4.class); 26 System.out.println(myTest4.value()); 27 System.out.println(myTest4.aaa()); 28 System.out.println(Arrays.toString(myTest4.bbb())); 29 } 30 } 模拟junit 注解就是标记程序, 让其他程序根据注解信息决定如何对待它们.\n1public class AnnotationTest4 { 2 // @MyTest 3 public void test1(){ 4 System.out.println(\u0026#34;===test1====\u0026#34;); 5 } 6 7 @MyTest 8 public void test2(){ 9 System.out.println(\u0026#34;===test2====\u0026#34;); 10 } 11 12 @MyTest 13 public void test3(){ 14 System.out.println(\u0026#34;===test3====\u0026#34;); 15 } 16 17 @MyTest 18 public void test4(){ 19 System.out.println(\u0026#34;===test4====\u0026#34;); 20 } 21 22 public static void main(String[] args) throws Exception { 23 AnnotationTest4 a = new AnnotationTest4(); 24 // 启动程序！ 25 // 1、得到Class对象 26 Class c = AnnotationTest4.class; 27 // 2、提取这个类中的全部成员方法 28 Method[] methods = c.getDeclaredMethods(); 29 // 3、遍历这个数组中的每个方法，看方法上是否存在@MyTest注解，存在 30 // 触发该方法执行。 31 for (Method method : methods) { 32 if(method.isAnnotationPresent(MyTest.class)){ 33 // 说明当前方法上是存在@MyTest，触发当前方法执行。 34 method.invoke(a); 35 } 36 } 37 } 38} 动态代理 对象嫌身上干的事太多的话, 可以通过代理转义部分职责\n对象有什么方法想被代理. 代理一定要有对应的方法.\n规范: 对象想被代理需创建一个对应的接口, 并实现这个接口. 之后代理方法返回的就是这个接口\n首先通过Proxy.newProxyInstance创建一个代理对象, 该方法有三个参数. 第三个参数是一个回调函数, 之后之后代理对象完成原本对象方法时会先进入这个回调方法, 我们就在这个回调方法里面做功能添加. 原本方法会返回值就return出去.\n创建代理对象的方法:\n1public class ProxyUtil { 2 public static Star createProxy(BigStar bigStar){ 3 /* newProxyInstance(ClassLoader loader, 4Class\u0026lt;?\u0026gt;[] interfaces, 5InvocationHandler h) 6参数1：用于指定一个类加载器 7参数2：指定生成的代理长什么样子，也就是有哪些方法 8参数3：用来指定生成的代理对象要干什么事情 9*/ 10 // Star starProxy = ProxyUtil.createProxy(s); 11 // starProxy.sing(\u0026#34;好日子\u0026#34;) starProxy.dance() 12 Star starProxy = (Star) Proxy.newProxyInstance(ProxyUtil.class.getClassLoader(), 13 new Class[]{Star.class}, new InvocationHandler() { 14 @Override // 回调方法 15 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { 16 // 代理对象要做的事情，会在这里写代码 17 if(method.getName().equals(\u0026#34;sing\u0026#34;)){ 18 System.out.println(\u0026#34;准备话筒，收钱20万\u0026#34;); 19 }else if(method.getName().equals(\u0026#34;dance\u0026#34;)){ 20 System.out.println(\u0026#34;准备场地，收钱1000万\u0026#34;); 21 } 22 return method.invoke(bigStar, args); 23 } 24 }); 25 return starProxy; 26 } 27} 实体类\n1public class BigStar implements Star{ 2 private String name; 3 4 public BigStar(String name) { 5 this.name = name; 6 } 7 8 public String sing(String name){ 9 System.out.println(this.name + \u0026#34;正在唱：\u0026#34; + name); 10 return \u0026#34;谢谢！谢谢！\u0026#34;; 11 } 12 13 public void dance(){ 14 System.out.println(this.name + \u0026#34;正在优美的跳舞~~\u0026#34;); 15 } 16} 测试\n1public class Test { 2 public static void main(String[] args) { 3 BigStar s = new BigStar(\u0026#34;杨超越\u0026#34;); 4 Star starProxy = ProxyUtil.createProxy(s); 5 6 String rs = starProxy.sing(\u0026#34;好日子\u0026#34;); 7 System.out.println(rs); 8 9 starProxy.dance(); 10 } 11} 应用: 利用代理模式实现AOP, 测试方法耗时.\n1public static UserService createProxy(UserService userService){ 2 UserService userServiceProxy = (UserService) Proxy.newProxyInstance(ProxyUtil.class.getClassLoader(), 3 new Class[]{UserService.class}, new InvocationHandler() { 4 @Override 5 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { 6 7 if(method.getName().equals(\u0026#34;login\u0026#34;) || method.getName().equals(\u0026#34;deleteUsers\u0026#34;)|| 8 method.getName().equals(\u0026#34;selectUsers\u0026#34;)){ 9 long startTime = System.currentTimeMillis(); 10 11 Object rs = method.invoke(userService, args); 12 13 long endTime = System.currentTimeMillis(); 14 System.out.println(method.getName() + \u0026#34;方法执行耗时：\u0026#34; + (endTime - startTime)/ 1000.0 + \u0026#34;s\u0026#34;); 15 return rs; 16 }else { 17 Object rs = method.invoke(userService, args); 18 return rs; 19 } 20 } 21 }); 22 return userServiceProxy; 23 } ","date":"2024-06-13","permalink":"/posts/tech/java-4-basic/","series":["Java"],"tags":["","",""],"title":"Java基础查漏补缺"},{"categories":["计算机"],"content":"SQL语法 DDL DDL 数据库操作 1SHOW DATABASES; -- 查询所有数据库 2SELECT DATABASE(); -- 查询当前数据库 3CREATE DATABASE IF NOT EXISTS learndatabase DEFAULT CHARSET utf8mb4; -- 创建数据库 4USE learndatabase; -- 使用数据库 5DROP DATABASE IF EXISTS learndatabase; -- 删除数据库 DDL 表结构 1SHOW TABLES; -- 查询数据库所有的表 2DESC tableName; -- 查询表结构 3SHOW CREATE TABLE tableName; -- 查询表的建表语句 4 5CREATE TABLE tableName( -- 创建表 6 id INT COMMENT \u0026#39;编号\u0026#39;, 7 name VARCHAR(50) COMMENT \u0026#39;姓名\u0026#39;, 8 age INT COMMENT \u0026#39;年龄\u0026#39;, 9 gender VARCHAR(1) COMMENT \u0026#39;性别\u0026#39; 10) COMMENT \u0026#39;用户表\u0026#39;; 11 12ALTER TABLE tableName ADD nickname VARCHAR(20) COMMENT \u0026#39;昵称\u0026#39;; -- 修改表,添加字段 13alter table tb add date DATE comment \u0026#39;入职日期\u0026#39;; 14ALTER TABLE tableName CHANGE nickname username VARCHAR(30) COMMENT \u0026#39;用户名\u0026#39;; -- 修改字段名,同时修改字段类型 15ALTER TABLE tableName MODIFY username CHAR(30); -- 修改数据类型 16ALTER TABLE tableName DROP username; -- 删除字段username 17 18ALTER TABLE tableName RENAME TO tb; -- 修改表名 19 20DROP TABLE IF EXISTS tableName; -- 删除表 21TRUNCATE TABLE tableName; -- 删除表,重新创建该表;其实就是清空数据 数据类型 三大类:数值,字符串,日期.\n TINYINT 1byte 取值在-128,127,无符号在0,255. 于是age字段就可以这样: age TINYINT UNSIGNED DOUBLE(4,1) 最长4为,允许出现1位小数 于是成绩字段score DOUBLE(4,1) CHAR 定长字符串,性能高,没有的部分用空格填补,适合用变化不大的字段,如gender CHAR(1) VARCHAR 变长字符串,对于字符串长度变化很大的字段比较适合,如 username VARCHAR(50) DATE是年月日 TIME是时分秒 YEAR就是年; DATETIME是年月日时分秒, birthday DATE TIMESTAMP也是年月日时分秒,但是最大范围是2038年  DML DML 数据操作语言INSERT UPDATE DELETE\nDML INSERT 添加字符串,日期要加引号; 数据范围要符合要求\n1-- 选择字段插入 2INSERT INTO tb(id, name, age, gender, username, date) VALUES (1, \u0026#39;赵四\u0026#39;, 13, \u0026#39;男\u0026#39;, \u0026#39;四娘\u0026#39;, \u0026#39;2001-05-28\u0026#39;); 3-- 全部字段插入 4insert into tb values (1, \u0026#39;张三\u0026#39;, 15, \u0026#39;女\u0026#39;, \u0026#39;三爹\u0026#39;, \u0026#39;2005-05-05\u0026#39;); 5-- 插入多条数据 6insert into tb values (3, \u0026#39;王五\u0026#39;, 29, \u0026#39;女\u0026#39;, \u0026#39;五爹\u0026#39;, \u0026#39;1998-12-15\u0026#39;),(4, \u0026#39;李四\u0026#39;, 30, \u0026#39;男\u0026#39;, \u0026#39;四爹\u0026#39;, \u0026#39;1970-01-30\u0026#39;); DML UPDATE 1-- 修改 2update tb set date=\u0026#39;2010-09-01\u0026#39; where name=\u0026#39;赵四\u0026#39;; 3update tb set id=2, date=\u0026#39;2001-05-28\u0026#39; where username=\u0026#39;三爹\u0026#39;; 4-- 没有加where, 改所有数据 5update tb set date=\u0026#39;2000-01-01\u0026#39; DML DELETE 1-- 删除 2delete from tb where id=1 and name=\u0026#39;赵四\u0026#39;; 3-- 删除索引 4delete from tb; DQL DQL 数据查询语言\n select 字段列表 from 表名列表 where 条件列表 group by 分组字段列表 having 分组后的条件列表 order by 排序字段列表 limit 分页参数  1-- 查询多个字段 2select id, name from tb; 3-- 查询所有, 写*效率不高,最好写出所有字段,清晰明了 4select * from tb; 5-- 设置别名 6select id as \u0026#39;爱迪\u0026#39;, name as \u0026#39;姓名\u0026#39; from tb; 7-- 查询去重 8select distinct * from tb; 条件查询  \u0026gt;=, \u0026lt;, \u0026lt;= , = , !=(\u0026lt;\u0026gt;), between and, in, like(_单个字符,%任意字符), is null  1-- and or not, \u0026amp;\u0026amp; || ! 2select * from tb where age = 13; 3select * from tb where age \u0026lt; 20; 4select * from tb where age \u0026lt;= 20; 5select * from tb where username is null ; -- 查询没有username字段的数据 6select * from tb where username is not null ; -- 查询有username字段的数据 7select * from tb where age != 13; 8select * from tb where age \u0026lt;\u0026gt; 13; 9select * from tb where age \u0026lt;= 20 \u0026amp;\u0026amp; age \u0026gt;= 10; 10select * from tb where age \u0026lt;= 20 and age \u0026gt;= 10; 11select * from tb where age between 10 and 20; -- between and 包括最大值和最小值 12select * from tb where age=10 or age=13 or age=20; 13select * from tb where age in(10,13,20); -- age在in里面的数其一即可 14select * from tb where name like \u0026#39;__\u0026#39;; -- 查询姓名只有两个字符的数据 15select * from tb where username like \u0026#39;%x\u0026#39;; -- 查询username最后一位是x的数据 聚合函数 聚合函数,将一列数据作为整体, 纵向计算\ncount-数量, max min, avg-平均值, sum-求和\n1-- 聚合函数不计算null值 2select sum(age) from tb; 3select count(1) from tb; 4select count(*) from tb; 5select avg(age) from tb; 6select max(age) from tb; 7select sum(age) from tb where id=1; 分组查询 分组查询 group by, 分组之后一般查询分组字段和聚合函数, 其他的无意义\n1select gender, count(*) from tb group by gender; -- 根据性别分组,分组后统计数量,相当于对每个组分别处理 2select gender, avg(age) from tb group by gender; -- 性别分组,统计男女的平均年龄 3 4-- where在分组前进行过滤, having在分组后过滤,having可以对聚合函数过滤,where不行. 5-- 虽然组合在一起的sql语句很麻烦,但是一步一步地加条件来看,就不麻烦了,sql就是在简单查询结果基础上一步一步处理的. 6-- 先where得到有条件的表,然后group by得到两行分组后的数据,最后对这两行数据进行having筛选. 7select gender, count(*) from tb where age\u0026lt;= 30 and age \u0026gt;= 10 group by gender having count(*) \u0026gt; 2; 8-- 给聚合起别名 9select gender, count(*) as gender_count from tb where age\u0026lt;= 30 and age \u0026gt;= 10 group by gender having gender_count \u0026gt; 2; 排序查询 排序查询 order by\norder by多字段,当第一个字段相同则按照第二个字段排序, asc升序 desc降序\n1select * from tb order by age asc; 2select * from tb order by age desc; 3select * from tb order by date desc; 4-- 先按照age升序,age相同再按照date降序排序 5select * from tb order by age asc ,date desc; 分页查询 1-- 分页查询 limit 起始索引,查询记录数 2-- 起始索引从0开始, 起始索引=(查询页码-1)*每页记录数 3-- 如果是第一页数据,可以省略 4select * from tb limit 0, 2; 5select * from tb limit 2, 3; DQL执行顺序:\n编写顺序: select from where group by having order by limit\n执行顺序: from where group by having select order by limit\nDCL DCL 数据控制语言 管理用户,控制访问\nDCL 管理用户 1-- 查询用户 2use mysql; 3select * from user; 4-- 创建用户 用户名@主机名 后面是密码,创建的用户没有权限 5-- 创建用户bnaod,只能在当前主机访问,密码password 6create user \u0026#39;bnaod\u0026#39;@\u0026#39;localhost\u0026#39; identified by \u0026#39;password\u0026#39;; 7-- 创建用户,在任意主机访问 8create user \u0026#39;bnaod\u0026#39;@\u0026#39;%\u0026#39; identified by \u0026#39;password\u0026#39;; 9-- 修改用户密码 10alter user \u0026#39;bnaod\u0026#39;@\u0026#39;localhost\u0026#39; identified with mysql_native_password by \u0026#39;newpassword\u0026#39;; 11-- 删除用户 12drop user \u0026#39;bnaod\u0026#39;@\u0026#39;localhost\u0026#39;; DCL 权限控制 1-- 查询权限 2show grants for \u0026#39;bnaod\u0026#39;@\u0026#39;localhost\u0026#39;; 3-- 授予权限 on后接数据库名.表名 *代替全部 如*.*表示所有数据库的所有表 后面是用户 4grant all on learndatabase.* to \u0026#39;bnaod\u0026#39;@\u0026#39;localhost\u0026#39;; 5-- 撤销权限 6revoke all on learndatabase.* from \u0026#39;bnaod\u0026#39;@\u0026#39;localhost\u0026#39;; 函数 字符串函数  concat字符串拼接函数, lower转小写, upper转大写\\ lpad(str,n,pad) 左填充,用字符串pad对str左边填充,达到n长度 rpad(str,n,pad) 右填充,用字符串pad对str右边填充,达到n长度 trim 去掉字符串头部和尾部的空格 substring(str,start,len)返回字符串str从start位置起的len个长度的字符串  1select concat(\u0026#39;hello\u0026#39;, \u0026#39; mysql\u0026#39;); 2select lower(\u0026#39;HEllo\u0026#39;); 3select upper(\u0026#39;HEllo\u0026#39;); 4select lpad(\u0026#39;01\u0026#39;, 5, \u0026#39;@\u0026#39;); 5select rpad(\u0026#39;01\u0026#39;, 5, \u0026#39;@\u0026#39;); 6select trim(\u0026#39; HELLO MYSQL \u0026#39;); 7select substring(\u0026#39;HELLO,MYSQL\u0026#39;, 1, 5); -- 这个不是字符串下标,就是单纯的第一个 8-- 将编号补成5位数,如1-\u0026gt;00001 9select lpad(id, 5, \u0026#39;0\u0026#39;) from tb; 数值函数  ceil(x) 向上取整 floor(x) 向下取整 mod(x,y) 返回x/y的模 rand() 返回0~1的随机数 round(x,y) 对x四舍五入,保留y位小数  1select ceil(1.1); 2select floor(1.1); 3select mod(3,4); 4select mod(4,4); 5select rand(); 6select round(pi(), 7); 7-- 生成6位随机验证码 8select lpad(1000000 * round(rand(),6), 6, \u0026#39;0\u0026#39;); 日期函数  curdate() 当前日期 curtime() 当前时间 now() 当前日期+时间 year(date) 取得date的年 month(date) 取得date的月 day(date) 取得date的日 date_add(date, INTERVAL expr type) 返回日期/时间加上一个时间间隔expr后的时间值 datediff(date1, date2) 返回结束date1和起始date2之间的天数(day)  1select curdate(); 2select curtime(); 3select now(); 4select year(now()); 5select year(date) from tb; 6select month(date) from tb; 7select day(date) from tb; 8select date_add(now(), INTERVAL 70 DAY ); 9select date_add(now(), INTERVAL 70 MONTH ); 10select date_add(now(), INTERVAL 70 YEAR ); 11select datediff(now(), \u0026#39;2001-05-28\u0026#39;); 12select datediff(now(), \u0026#39;1992-08-17\u0026#39;); 13-- 员工入职天数降序排列 14select datediff(now(), date) as jointime from tb order by jointime desc ; 流程控制函数  if(value, t, f) ifnull(value1, value2) 如果value1不为空返回value1,否则返回value2 case when [val1] then [res1] else [default] end 如果val1为true,返回res1,\u0026hellip;,否则返回default 这个相对于if elseif结构 case [expr] when [val1] then [res1] else [default] end 如果expr等于val1返回res1,\u0026hellip;.,否则返回default 这个相对于switch结构  1select if(true, \u0026#39;ok\u0026#39;, \u0026#39;error\u0026#39;); 2select if(false, \u0026#39;ok\u0026#39;, \u0026#39;error\u0026#39;); 3 4select ifnull(\u0026#39;ok\u0026#39;, \u0026#39;default\u0026#39;); 5select ifnull(\u0026#39;\u0026#39;, \u0026#39;default\u0026#39;); 6select ifnull(null, \u0026#39;default\u0026#39;); 7 8select case when true then \u0026#39;res1\u0026#39; else \u0026#39;default\u0026#39; end; 9 10-- 查询员工年龄,如果大于50就显示老毕登, 如果大于15就显示中壁灯, 如果小于15就显示小壁灯 11select id, 12 name, 13 (case when age\u0026gt;=50 then \u0026#39;老毕登\u0026#39; when age\u0026gt;=15 then\u0026#39;中壁灯\u0026#39; else \u0026#39;小壁灯\u0026#39; end) as nickname 14from tb ; 约束 这些东西idea可以直接图像界面改动.\n 非空约束 不能为null NOT NULL 唯一约束 数据是唯一的 UNIQUE 主键约束 一行数据唯一标识,要求非空且唯一 PRIMARY KEY 默认约束 未指定该字段的值,则采用默认值 DEFAULT 检查约束 保证字段满足一个条件 CHECK 外键约束 用来建立两个表的连接 FOREIGN KEY  1create table user( 2 id int primary key auto_increment, -- 主键,且自动增长 3 name varchar(10) not null unique , -- 不为null,唯一 4 age int check ( age \u0026gt; 0 and age \u0026lt;= 120 ), -- 年龄在0到120之间 5 status char(1) default \u0026#39;1\u0026#39;, -- 默认为1 6 gender char(1) 7) comment \u0026#39;user table\u0026#39; 8 9desc user; 10 11insert into user(name, age, status, gender) values (\u0026#39;tom1\u0026#39;, 19, \u0026#39;1\u0026#39;, \u0026#39;男\u0026#39;), (\u0026#39;tom2\u0026#39;, 31, \u0026#39;0\u0026#39;, \u0026#39;男\u0026#39;); 12insert into user(name, age, status, gender) values (null, 20,\u0026#39;1\u0026#39;,\u0026#39;女\u0026#39;); 13insert into user(name, age, status, gender) values (\u0026#39;tom1\u0026#39;, 20,\u0026#39;1\u0026#39;,\u0026#39;女\u0026#39;); 14insert into user(name, age, status, gender) values (\u0026#39;tom3\u0026#39;, -1,\u0026#39;1\u0026#39;,\u0026#39;女\u0026#39;); 15insert into user(name, age, gender) values (\u0026#39;tom3\u0026#39;, 23,\u0026#39;女\u0026#39;); 外键 有外键的是子表,关联的是父表, 建立外键保证数据的一致性和完整性.\n1-- 准备 2create table dept( 3 id int auto_increment primary key , 4 name varchar(50) not null 5); 6insert into dept(id, name) VALUES (1,\u0026#39;研发部\u0026#39;),(2,\u0026#39;市场部\u0026#39;),(3,\u0026#39;财务部\u0026#39;),(4,\u0026#39;销售部\u0026#39;),(5,\u0026#39;总经办\u0026#39;); 7alter table user add dept_id int; 8alter table user add manager_id int; 9insert into user(id, name, age, status, gender, dept_id) values (null, \u0026#39;jerry2\u0026#39;, 73, \u0026#39;0\u0026#39;, \u0026#39;女\u0026#39;, null); 10 11-- 添加外键.在创建表时额外添加一行, 也可以额外修改 12-- constraint [外键名称] foreign key (外键字段名) references 主表(主表列名) 13alter table user add constraint fk_user_dept_id foreign key (dept_id) references dept(id); 14-- 这样父表的字段不能直接删除,因为有子表外键关联 15-- 删除外键 16-- alter table 表名 drop foreign key 外键名称; 17alter table user drop foreign key fk_user_dept_id; 删除更新行为  no action/restrict 父表中有更新和删除行为,检测有对应外键,有就不允许删除/更新 cascade 父表删除/更新,有外键,那么也会删除/更新在子表的记录 set null 父表删除,有外键的话,将子表的值设置为null(要求该外键可以为null) set default 父表数据变成,子表将外键设置默认值(innodb不支持)  1-- constraint [外键名称] foreign key (外键字段名) references 主表(主表列名) on update cascade on delete cascade 2-- on update在更新时要进行的行为,on delete在删除时要进行的行为 3alter table user add constraint fk_user_dept_id foreign key (dept_id) references dept(id) on update cascade on delete cascade; 4alter table user add constraint fk_user_dept_id foreign key (dept_id) references dept(id) on update set null on delete set null ; 多表查询 一对多,就是一个外键\n多对多,需要维护一个中间表,两个外键\n一对一,用作单表拆分,维护一个外键,而且该外键字段需要设置unique,保证它是一对一.\n1-- 进行笛卡尔积, 组合的所有情况 2select * from user,dept; 3-- 消除笛卡尔积, 加一个条件, 这里没有外键也可以 4select * from user,dept where dept_id = dept.id; 连接查询   内连接:查询AB交集\n1-- 隐式内连接 2-- select 字段列表 from 表1,表2 where 条件; 3-- 显示内连接 4-- select 字段列表 from 表1 inner join 表2 on 连接条件; 5-- 查询员工姓名,关联的部门 6select user.name, dept.name from user, dept where user.dept_id=dept.id; -- 隐式内连接 7select u.name, d.name from user u, dept d where u.dept_id=d.id; -- 取别名 8select u.name, d.name from user u inner join dept d on u.dept_id=d.id; -- 显式内连接   左外连接:查询左表的所有数据,包括AB交集\n  右外连接:查询右表的所有数据,包括AB交集\n1-- 左外连接 完全包含左表(即便没有外键值),还有交集 2-- select 字段列表 from 表1 left [outer] join 表2 on 条件; 3-- 右外连接 完全包含右表(即便没有外键值),还有交集 4-- select 字段列表 from 表1 right [outer] join 表2 on 条件; 5select u.*, d.name from user u left outer join dept d on d.id = u.dept_id; -- 左外 6select d.*, u.name from user u right outer join dept d on d.id = u.dept_id; -- 右外 7select d.*, u.name from dept d left join user u on d.id = u.dept_id; -- 将右外改为左外   自连接:当前表与自身连接查询\n1-- 自连接 2-- select 字段列表 from 表A 别名A join 表A 别名B ON 条件; 3-- 查询员工及其所属领导(员工和领导在同一表中), 将他们看做两张表,员工表和领导表 4select u1.name, u2.name from user u1 join user u2 on u1.manager_id=u2.id; 5-- 即便没有领导也查询 6select u1.name, u2.name from user u1 left join user u2 on u1.manager_id=u2.id;   联合查询 1-- 联合查询 union union all,将多次查询的结果合并起来, 列数必须保持一致 2-- select from union [all] select from 3-- 将年龄小于50岁 和 状态为1 的员工查询出来 4select * from user where age \u0026lt; 50 union all select * from user where status = 1; -- 结果有重复,直接将查询结果合并 5select * from user where age \u0026lt; 50 union select * from user where status = 1; -- 结果没重复,合并后去重 子查询 子查询, 在select中嵌套select,又称嵌套查询\n这部分最重要的就是一部分一部分来, 查询一个阶段再将结果作为另一个阶段\n1select * from t1 where column1=(select column1 from t2) 外部可以是select/update/insert/delete 子查询分类:\n  标量子查询(结果为单值), 操作符一般是\u0026gt; \u0026gt;= 之类\n1-- 查询单个部门的员工信息,(select id from dept where name = \u0026#39;研发部\u0026#39;)只有一条记录 2select * from user where dept_id=(select id from dept where name = \u0026#39;研发部\u0026#39;);   列子查询, 操作符是in, not in, any/some, all\n1-- any some是任意有一个满足即可 2-- all是子查询返回的列表的所有值都要满足 3-- 查询两个部门的员工信息 4select * from user where dept_id in (select id from dept where name = \u0026#39;研发部\u0026#39; or name = \u0026#39;市场部\u0026#39;); 5-- 查询比市场部所有人年龄都小的员工 6select * from user where age \u0026lt; all (select age from user where dept_id=(select id from dept where name = \u0026#39;总经办\u0026#39;));   行子查询, 操作符= \u0026lt;\u0026gt; in not in\n1-- 查询和编号2员工的年龄与状态相同的员工,行元素对应 2select * from user where (age, status) = (select age, status from user where id=1); 3-- 表子查询,操作符in 4-- 查询与编号1,编号2员工的年龄和状态相同的员工,也是每一行对应一个,用in 5select * from user where (age, status) in (select age, status from user where id=1 or id=2); 6-- 查询年龄小于50的员工信息和部门信息 7select e.*, d.* from (select * from user where age \u0026lt; 50) e left join dept d on e.dept_id = d.id;   事务 准备:\n1create table account( 2 id int auto_increment primary key , 3 name varchar(50) , 4 money int 5); 6insert into account(id, name, money) VALUES (null, \u0026#39;lisan\u0026#39;, 2000); 7insert into account(id, name, money) VALUES (null, \u0026#39;wangsan\u0026#39;, 2000); 8-- 恢复数据 9update account set money = 2000 where name = \u0026#39;lisan\u0026#39; or name = \u0026#39;wangsan\u0026#39;; 10-- 查询lisan余额 11select * from account where name=\u0026#39;lisan\u0026#39;; 12-- 转账操作 13update account set money = money - 1000 where name = \u0026#39;lisan\u0026#39;; 14update account set money = money + 1000 where name = \u0026#39;wangsan\u0026#39;; 管理事务 方式一 1-- 查看事务的提交方式 2select @@autocommit; 3-- 设置为手动提交, 0为手动,1为自动 4set @@autocommit = 0; -- 设置为手动 5set @@autocommit = 1; -- 设置为自动 6-- 操作 7update account set money = money - 1000 where name = \u0026#39;lisan\u0026#39;; 8update account set money = money + 1000 where name = \u0026#39;wangsan\u0026#39;; 9-- 提交事务 10commit; 11-- 回滚事务, 如果出错了就回滚 12rollback; 方式二 1-- 开启事务 2start transaction; 3begin; 4-- 提交事务 5commit; 6-- 回滚 7rollback; 事务的四大特性ACID  原子性atomicity: 不可分割的最小操作,一起成功,一起失败 一致性consistency: 事务完成,数据保持一致状态,比如余额是一定的 隔离性isolation: 数据库提供的隔离机制, 事务不受外部并发操作影响独立环境执行 持久性durability: 事务一旦提交或回滚, 对数据的改变是永久的  并发事务问题  脏读:事务读取来另一个事务没有提交的数据 不可重复读: 事务先后读取同一数据,两次读取的数据不同 幻读:查询时没有这行数据,但是插入时又存在这行数据  事务的隔离级别  read uncommitted 脏读会出现 不可重复读会出现 幻读会出现 性能最高 read committed(oracle默认) 脏读不会出现 repeatable read(mysql默认) 脏读,不可重复读不会出现 serializable 脏读,不可重复读,幻读不会出现 性能最差  事务隔离级别越高,数据越安全,性能越低.\n1-- 查看事务隔离级别 2select @@transaction_isolation; 3-- 设置事务隔离级别 4-- set [session|global] transaction isolation level {read uncommitted|read committed|repeatable read|serializable}; 5set session transaction isolation level serializable ; 6set session transaction isolation level repeatable read ; 模拟并发问题 模拟脏读 1-- 模拟脏读 2-- 窗口1 3set session transaction isolation level read uncommitted ; 4start transaction ; 5select * from account; -- 这时候可以看到lisan减了1000块,就是因为可以读到未提交的(read uncommitted) 6-- 窗口2 7start transaction ; 8update account set money = money - 1000 where name=\u0026#39;lisan\u0026#39;; 模拟不可重复读 1-- 模拟不可重复读 2-- 窗口1 3set session transaction isolation level read committed ; 4start transaction ; 5select * from account; -- 在commit之前查询 6select * from account; -- 在commit之后查询, 可以查询到变更的. 7commit ; 8-- 窗口2 9start transaction ; 10update account set money = money + 1000 where name=\u0026#39;lisan\u0026#39;; 11commit ; 模拟幻读 1-- 模拟幻读 2-- 窗口1 3set session transaction isolation level repeatable read ; 4start transaction ; 5select * from account where id=3; -- 1查不到 6insert into account(id, name, money) VALUES (null, \u0026#39;zangsan\u0026#39;, 3000); -- 4这边后执行,发现插入不了 7select * from account where id=3; -- 5再次查询,还是没有, 这是因为已经解决了不可重复读了. 8-- 窗口2 9start transaction ; 10insert into account(id, name, money) VALUES (null, \u0026#39;zangsan\u0026#39;, 3000); -- 2这边先insert 11commit ; -- 3先提交,这时已经有这一行了. 索引 mysql体系结构: 连接池(授权认证), 服务层(sql接口,sql分析优化,函数执行), 引擎层(数据存储和提取), 存储层\n存储引擎: 存储数据,建立索引,更新/查询数据等技术的视线方式. 存储引擎是基于表的而不是库.\n1-- 查询建表语句,默认innodb 2show create table account; 3# CREATE TABLE `account` ( 4# `id` int NOT NULL AUTO_INCREMENT, 5# `name` varchar(50) DEFAULT NULL, 6# `money` int DEFAULT NULL, 7# PRIMARY KEY (`id`) 8# ) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci 9 10-- 查询当前数据库支持的存储引擎 11show engines; 12-- 创建表,指定引擎为MyISAM 13create table my_myisam( 14 id int auto_increment primary key, 15 name varchar(50) 16)engine = MyISAM; 17-- 创建表,指定引擎为MEMORY 18create table my_memory( 19 id int auto_increment primary key , 20 name varchar(50) 21)engine = Momory; 存储引擎的特点   innodb是mysql5.5之后默认的存储引擎, 特点:DML遵循ACID模型,支持事务; 行级锁,提高并发性能; 支持外键foreign key 文件:xxx.ibd, 每张表都会对应一个表空间文件,存储改变的表结构(frm,sdi),数据和索引. 逻辑存储结构:一个表空间TableSpace包含很多Segment段,一个段包含很多Extent区,一个区包含很多Page页,一个页包含很多Row行(行数据). 一个row包含trx id,roll pointer, col1, col2, 适用于并发条件下要求数据的一致性, 除了插入查询还有很多的更新删除操作\n  MyISAM, mysql早期的默认存储引擎. 不支持事务,不支持外键, 支持表锁, 不支持行锁,访问速度快 文件: sdi表结构信息,myd数据,myi索引 读操作和插入操作为主, 更新和删除较少时选用\n  Memory, 存储在内存,只能作为临时表或缓存 内存存放,访问速度快, hash索引 通常做缓存\n  innodb与MyISAM区别:innodb支持外键,是行锁,支持事务.MyISAM是表锁\n索引 索引: 高效获取数据的数据结构(有序)\n优点:提高检索效率,降低数据库io成本;通过索引进行排序,降低数据排序的成本\n缺点:费空间,提高了查询效率但是降低了更新效率\n索引结构 有B+Tree索引(常见), Hash索引(性能高,不支持范围查询),R-tree(空间索引),Full-text(全文索引)\n二叉树:顺序插入时形成链表,层级深\n红黑树:自平衡二叉树,但是数据量大的时候层级也深.\nB-Tree(多路平衡查找), 从下面往上面走的.\nB+Tree:相比B-Tree,所有的元素会出现的叶子结点(向上分裂的同时保留自己),叶子节点会形成单向链表\nMySQL在B+Tree的基础上,将叶子节点的链表变为了双向循环链表,提高区间访问性能.\nHash索引:将键值换算成Hash值,映射在对应的槽位,存储在Hash表中.如果Hash冲突就增加链表.(就是HashSet原理), 只能用于对等比较= in,不能范围查询; 无法排序; 查询效率高. Memory支持hash索引.\n索引分类 主键索引(primary, 只能有一个), 唯一索引(unique), 常规索引, 全文索引(fulltext)\n根据存储形式分类:聚集索引(数据存储和索引一块,叶子结点保存行数据,必须要,只能有一个), 二级索引(数据和索引分开, 叶子结点是主键,可以多个)\n索引选取规则:\n 如果存在主键, 主键索引就是聚集索引 没有主键, 选取第一个unique唯一索引作为聚集索引 都没有,Innodb自动生成rowid作为隐藏的聚集索引  如select * from user where name = \u0026lsquo;li\u0026rsquo;; 先从二级索引找主键,再从聚集索引找数据.这就是回表查询\n索引语法 1-- 创建索引 create [unique|fulltext] index index_name on table_name (index_col_name,..) 2-- 查看索引 show index from table_name; 3show index from learndatabase.user; 4-- 删除索引 drop index index_name on table_name; 5-- 为name字段创建索引,该字段可能重复(常规索引) 6create index idx_user_name on user(name); 7-- 为phone创建唯一索引(唯一索引, 单列索引) 8create unique index idx_user_phone on user(phone); 9-- 为多个字段创建索引(联合索引),使用最频繁的字段放左侧(最左前缀原则) 10create index idx_user_name_phone_age on user(name, phone, age); SQL性能分析 SQL执行频率 1-- show [session|global] status; 2-- 查看select, update, delete, insert等执行次数 3show global status like \u0026#39;Com_______\u0026#39;; 慢查询日志 慢查询日志: 记录执行时间超过指定参数long_time_query,默认10秒的日志\n记录位置: /var/lib/mysql/localhost-slow.log\n默认没有开启,在MySQL配置文件/etc/my.cnf配置, slow_query_log=1 1表示开, long_time_query=2 2秒\n1-- 查看是否开启 2show variables like \u0026#39;slow_query_log\u0026#39;; 查看时间耗费 show profiles能够在做sql优化的时候帮助我们了解时间耗费到哪去了\nhave_profiling参数查看是否支持profile\n1select @@have_profiling; 2-- 查看是否开启 3select @@profiling; 4-- 设置开启 5set profiling = 1; 6-- 查看耗时情况 7show profiles; 8-- 查看指定query_id的sql语句每个阶段的耗时情况 9-- show profile for query [query_id]; 10show profile for query 3; 查看sql语句的执行计划 explain[/desc] 查看sql语句的执行计划, 如何执行的\n1explain select * from learndatabase.user where age \u0026lt; 50;  id字段:id相同,执行顺序从上往下, id越大越先执行 select_type:SIMPLE简单表(不使用表连接或子查询),primary(主查询,即外层的查询), union(union中第二个或者后面的查询语句), subquery(select或where之后包含的子查询) type:连接类型. 性能由好到坏是NULL(不查任何表), system, const(唯一索引), eq_ref, ref(非唯一性索引), range, index(扫描索引), all(全表扫描) possible_key:可能用到的索引 key:实际用到的索引 key_len:使用索引的字节数 rows:必须要执行查询的行数 filtered:返回结果的行数占需读取行数的百分比,越大越好  索引使用 1-- 验证索引效率:先执行一条没有索引的sql,再创建索引再执行 2select * from tb_sku where sn=\u0026#39;100001\u0026#39;; 3create index idx_sku_sn on tb_sku(sn); 4select * from tb_sku where sn=\u0026#39;100001\u0026#39;; 最左前缀法则: 查询从索引最左列开始, 并且不跳过索引中的列; 如果跳过某列, 索引将部分失效(后面的字段失效)\n1-- 假设创建了联合索引且顺序为profession,age,status,那么 2explain select * from user where profession=\u0026#39;软件工程\u0026#39; and age=31 and status=\u0026#39;0\u0026#39;; -- 会用到索引,所有字段都走索引 3explain select * from user where profession=\u0026#39;软件工程\u0026#39; and age=31; -- 会用到索引,所有字段都走索引 4explain select * from user where profession=\u0026#39;软件工程\u0026#39; -- 会用到索引,所有字段都走索引 5explain select * from user where age=31 and status=\u0026#39;0\u0026#39;; -- 不会用到索引 6explain select * from user where profession=\u0026#39;软件工程\u0026#39; and status=\u0026#39;0\u0026#39;; -- 只有profession会用到索引 7explain select * from user where age=31 and profession=\u0026#39;软件工程\u0026#39; and status=\u0026#39;0\u0026#39;; -- 会用到索引,这个sql语句的顺序无关,只需要存在 范围查询: 联合索引中, 出现范围查询(\u0026lt;.\u0026gt;),那么范围查询右侧的列索引失效\n1explain select * from user where profession=\u0026#39;软件工程\u0026#39; and age\u0026lt;31 and status=\u0026#39;0\u0026#39;; -- profession和age走索引,status不走 2explain select * from user where profession=\u0026#39;软件工程\u0026#39; and age\u0026lt;=31 and status=\u0026#39;0\u0026#39;; -- 都走,其实只有=那里都走 索引失效 1-- 索引列运算操作, 会导致索引失效 2explain select * from user where substring(phone, 10, 2) = \u0026#39;15\u0026#39;; -- 没用索引 3-- 字符串没加引号, 会导致索引失效 4explain select * from user where name = lisan; 5explain select * from user where profession=\u0026#39;软件工程\u0026#39; and age=31 and status=0; -- status没有走索引 6-- 模糊查询, 如果仅仅是尾部模糊, 索引不会失效; 头部模糊匹配会失效 7explain select * from user where profession like \u0026#39;软件%\u0026#39;; -- 走索引 8explain select * from user where profession like \u0026#39;%软件\u0026#39;; -- 不走 9explain select * from user where profession like \u0026#39;%件%\u0026#39;; -- 不走 10-- or连接的条件: 前面列有索引,后面列没索引,那么索引都不会用到; 只有都有索引才会用到 11explain select * from user where phone=\u0026#39;17712312310\u0026#39; or age=13; -- age没索引,所以没有用任何索引 12-- 数据分布影响: 如果MySQL评估使用索引比全表更慢,则不使用索引 13explain select * from user where phone\u0026gt;\u0026#39;17700000000\u0026#39;; -- 绝大部分数据都满足,这时就没用索引 14explain select * from user where phone is not null; -- 绝大部分都满足,没走索引 15explain select * from user where phone is null; -- 绝大部分都不满足,走索引 SQL提示 给mysql说想要什么索引(如果有多个可用的)之类,达到优化操作的目的\n1-- 比如既有单个索引,又有联合索引的情况. 2-- use index: 建议用哪个索引 ignore index: 不用哪个索引 force index:必须用哪个索引 3explain select * from user use index(idx_user_pro) where profession=\u0026#39;软件工程\u0026#39;; 4explain select * from user ignore index(idx_user_pro) where profession=\u0026#39;软件工程\u0026#39;; 5explain select * from user force index(idx_user_pro) where profession=\u0026#39;软件工程\u0026#39;; 覆盖索引 查询使用索引, 并且需要返回的列, 在该索引中已经全部能够找到, 这样只需要查联合索引即可, 不需要回表查询\n所以需要减少select *的使用, 这样可以提高效率\n1-- 如现有索引profession, age, status的联合索引 2explain select id, profession, age, status from user where profession=\u0026#39;软件工程\u0026#39; and age=31 and stauts=\u0026#39;0\u0026#39;; -- 效率高 3explain select id, profession, age, status, name from user where profession=\u0026#39;软件工程\u0026#39; and age=31 and stauts=\u0026#39;0\u0026#39;; -- 效率低 前缀索引 索引很长的字符串,让索引变得很大,查询时浪费大量磁盘IO. 此时将字符串的一部分前缀建立索引,节约索引空间\n1create index idx_xxxx on table_name(column(n)); 前缀长度的选取: 根据选择性决定. 选择性是不重复的所有值比上记录总数, 选择性越高效率越高, 唯一索引的选择性是1.\n一般是根据需求选择, 不需要必须选择性为1, 0.9的效率也可以.\n1select count(distinct email) / count(*) from tb_user; -- 全部字段的选择性 2select count(distinct substring(email, 1, 5)) / count(*) from tv_user; -- email字段截取前5个的选择性 在查询的时候, 查索引, 然后回表对比是否一致; 继续查索引链表的下一个看看是否一致. 这是以时间换空间.\n总结 单列索引和联合索引的选择: 存在多个查询条件, 考虑针对查询字段建立索引时, 建议建立联合索引\n索引设计原则:\n 数据量大(一百万), 查询频繁建立索引 常作为查询条件where, 排序order by, 分组group by操作的字段建立索引 尽量选择区分度高(效率高)的列作为索引, 尽量建立唯一索引 字符串类型字段,长度长的话可以建立前缀索引 尽量使用联合索引. 查询时联合索引很多时候可以覆盖索引, 节省存储空间, 避免回表 控制索引数量, 索引越多, 维护代价越大, 影响增删改效率 如果索引列不能存储NULL值, 创建表时使用NOT NULL约束它. 当优化器知道每列是否包含null值时, 它可以更好确定那个索引最有效用于查询  SQL优化 插入数据, insert优化   批量插入, 一次性插入500-1000条, 特别大量的插入分成多个insert\n1insert into tb_test values (1,\u0026#39;tom\u0026#39;), (2,\u0026#39;cat\u0026#39;), (3,\u0026#39;jerry\u0026#39;);   手动事务提交\n1start transaction ; 2insert into ; 3insert into ; 4commit ;   主键顺序插入\n  使用load指令(大批量数据)\n1①连接mysql加参数--local-infile 2mysql --local-infile -u root -p 3②设置全局参数local_file为1, 开启从本地加载文件导入数据的开关 4set global local_infile =1; 5③执行load指令. fields terminated by \u0026#39;,\u0026#39;表示列之间的分隔符, lines terminated by \u0026#39;\\n\u0026#39;表示行数据的分隔符 6load data local infile \u0026#39;/root/sql1.log\u0026#39; into table \u0026#39;tb_user\u0026#39; fields terminated by \u0026#39;,\u0026#39; lines terminated by \u0026#39;\\n\u0026#39;;   主键优化 页分裂: 当一个数据插入到页已经满的地方时, 就会页分裂. 这时复制后50%到另一个页里面, 然后将数据插入另一个页, 最后再修改页指针执行新的页\n页合并: 当删除一行记录, 并没有真正地被物理删除, 只是标记删除并且它的空间允许其他记录使用. 当删除页达到MERGE_THRESHOLD(默认页50%), Innodb开始寻找最靠近的页 看看是否可以将两个页合并以优化空间使用.\n主键设计原则:\n 尽量降低主键长度(辅助索引叶子节点挂的都是主键, 会导致空间占用很多) 插入数据尽量顺序插入, 选择使用AUTO_INCREMENT自增主键 尽量不要使用UUID做主键或者其他自然主键, 如身份证 业务操作避免对主键的修改.  order by 优化 using filesort: 通过表的索引或全表扫描, 读取满足条件的数据行, 然后在排序缓冲区sort buffer中完成排序操作.\n所有不是通过索引直接返回排序结果的排序都叫filesort排序, 覆盖索引是前提.\nusing index: 通过有序索引顺序扫描直接返回有序数据, 不需要额外排序, 操作效率高.\n1explain select id, age, phone from tb_user order by age, phone -- 没有索引时, using filesort 2 3create index idx_user_age_phone_aa on tb_user(age, phone); -- 创建两个升序索引 4explain select id, age, phone from tb_user order by age, phone; -- 有索引时, using index 5 6explain select * from tb_user order by age, phone; -- 没用索引, using filesort, 这时不是覆盖查询了, 回表了. 7 8explain select id, age, phone from tb_user order by age desc, phone desc; -- 反向利用索引, using index 9 10explain select id, age, phone from tb_user order by age asc, phone desc; -- 没有用到索引 using filesort 11 12create index idx_user_age_phone_ad on tb_user(age asc, phone desc); -- 创建一个升序,一个降序索引 13explain select id, age, phone from tb_user order by age asc, phone desc; -- 用到索引 using index OrderBy优化:\n 根据排序字段建立合适的索引, 多字段排序时, 遵循最左前缀法则. 尽量使用覆盖索引 多字段排序, 一个升序一个降序, 此时需要注意联合所以在创建时的规则, show index中的collation就是排序规则,A升D降 如果不可避免的出现filesort, 大数据量排序时, 可以适当增大排序缓冲区大小sort_buffer_size(默认256k)  group by 优化 1explain select profession, count(*) from tb_user group by profession; -- 没有查询的时候, 用临时表 2create index idx_user_pro_age_sta on tb_user(profession, age, status); -- 创建联合索引 3explain select profession, count(*) from tb_user group by profession; -- 用了联合索引 4explain select age, count(*) from tb_user group by age; -- 违反最左前缀法则, 用到临时表 5explain select profession, age, count(*) from tb_user group by profession, age; -- 用联合索引 6explain select age, count(*) from tb_user where profession=\u0026#39;软件工程\u0026#39; group by age; -- 用到联合索引, 最左前缀 limit优化 limit 1000000, 10 此时MySQL需要排序前1000010条记录, 仅仅返回1000000-1000010的记录, 其他丢弃\n一般分页查询时, 通过创建覆盖索引能够较好地提高性能, 可以通过覆盖查询+子查询的形式进行优化\n1select * from tb_sku limit 1000000, 10; -- 19s 2select t.* from tb_sku t, (select id from tb_sku order by id limit 1000000, 10) a where t.id = a.id; -- 11s 3 count优化 MyISAM引擎把一个表总行数存在了磁盘上, 因此执行count(*)的时候直接返回这个数, 效率很高\nInnodb执行count(*)需要把数据一行行从引擎里面读出来, 累积计数.\n  count()是一个聚合函数, 对于返回结果集, 一行行判断. 如果count函数的参数不是null, 累计数+1, 否则不加. 最后返回累计值\n  count(*): Innodb并不会把全部字段取出来, 专门做了优化, 不取值, 服务层直接按行进行累加.\n  count(1): Innodb遍历整张表, 但不取值, 服务层对于返回的每一行, 放一个数'1\u0026rsquo;进去, 直接按行进行累加. 当然其他数都可以\n  count(主键): Innodb遍历整张表, 把每一行的主键id取出来, 返回服务层, 服务层拿到主键直接按行进行累加(主键没有null)\n  count(字段): 没有not null的字段, 取出来之后到服务层, 服务层需要判断是否是null, 不为null计数累加\n  count(字段): 有not null的字段, 取出来之后到服务层, 服务层直接按行进行累加\n  效率: count(*) ≈ count(1) \u0026gt; count(主键) \u0026gt; count(字段)\nupdate优化 Innodb的行锁是针对索引加的锁, 不是针对记录加的锁, 使用的条件一定要有索引不然就是表锁; 该索引不能失效, 否则行锁变为列锁\n1-- 使用主键索引 2update student set no=\u0026#39;20010101\u0026#39; where id=1; -- 此时事务加的行锁, 对其他并发事务修改其他行没有影响 3update student set no=\u0026#39;20010101\u0026#39; where name=\u0026#39;韦一笑\u0026#39;; -- 当name字段没有索引时,此时加的是表锁, 对表的其他行均不能使用update变更 视图 1-- 视图 2-- 介绍: 视图是一种虚拟存在的表. 视图中的数据并不在数据库中实际存在, 行和列数据来定义自定义视图的查询中使用的表, 并且是在使用视图时动态生成的 3-- 作用: 1.简单:简化用户对数据的理解, 也可以简化他们的操作. 那些被经常使用的查询可以被定义为视图 4-- 2.安全:数据库可以授权,但不能授权到数据库特定的行和列上. 通过视图用户只能查询和修改他们所能见到的数据 5-- 3.数据独立: 视图可帮助用户屏蔽真实表结构带来的影响. 6 7-- 创建: create [or replace] view 视图名称[(列名列表)] as select语句 [with [cascaded|local] check option] 8create or replace view stu_v_1 as select id,name from student where id\u0026lt;=10; 9-- 查询: 查看视图创建语句 show create view 视图名称; 10-- 查看视图数据 select * from 视图名称....; 11show create view stu_v_1; 12select * from stu_v_1; 13select * from stu_v_1 where id\u0026lt;3; 14-- 修改: 方式一:create [or replace] view 视图名称[(列名列表)] as select语句 [with [cascaded|local] check option] 15-- 方式二:alter view 视图名称[(列名列表)] as select语句 [with [cascaded|local] check option] 16create or replace view stu_v_1 as select id,name,no from student where id\u0026lt;=10; 17alter view stu_v_1 as select id,name from student where id\u0026lt;=10; 18-- 删除: drop view [if exist] 视图名称 [,视图名称]... 19drop view if exists stu_v_1; 20 21 22-- 检查选项 with [cascaded|local] check option 23-- 当使用with check option子句创建视图, mysql会通过视图检查正在更改的每个行, 如插入,删除,更新, 使其符合试图定义 24-- mysql允许基于另一个视图创建视图, 它还会检查依赖视图中的规则以保持一致性. 为了确定检查范围提供了两个选项cascaded和local, 默认cascaded 25-- 没有check的视图, 可以随便插入数据 26create or replace view stu_v_1 as select id, name from student where id \u0026lt;= 10; 27insert into stu_v_1 values (30, \u0026#39;tom\u0026#39;); -- 可以插入 28-- 普通的with check option的作用: 29create or replace view stu_v_1 as select id, name from student where id \u0026lt;= 10 with local check option ; 30insert into stu_v_1 values (6,\u0026#39;tom\u0026#39;); -- 可以插入,满足要求 31insert into stu_v_1 values (13,\u0026#39;tom\u0026#39;); -- 不能插入, 不满足\u0026lt;=10的要求 32-- cascaded选项, 级联的意思, 就是向下的视图不管有没有check选项都要检查 33create or replace view stu_v_1 as select id, name from student where id \u0026lt;= 20; -- 视图1, 没有check 34create or replace view stu_v_2 as select id, name from stu_v_1 where id \u0026gt;= 10 with cascaded check option ; -- 视图2, 级联检查 35insert into stu_v_2 values (7,\u0026#39;tom\u0026#39;); -- 不行, 不满足视图2的要求 36insert into stu_v_2 values (30,\u0026#39;tom\u0026#39;); -- 不行, 不满足视图1的要求 37insert into stu_v_2 values (15,\u0026#39;tom\u0026#39;); -- 可以 38-- 再在基础上新增一个视图3, 这时cascaded不会影响上层视图 39create or replace view stu_v_3 as select id, name from stu_v_2 where id \u0026gt;= 15; 40insert into stu_v_3 values (11,\u0026#39;tom\u0026#39;); -- 满足视图1和2的要求, 可以. 视图3的要求没有check所以条件无所谓 41insert into stu_v_3 values (17,\u0026#39;tom\u0026#39;); -- 满足要求, 可以 42insert into stu_v_3 values (28,\u0026#39;tom\u0026#39;); -- 不满足 43-- LOCAL选项: 它只影响本视图, 不会影响上下. 44 45-- 视图的更新: 要使视图更新, 视图中的行与基础表的行之间必须存在一对一的关系 46-- 视图包含以下任一项 视图不可更新 47-- 1.聚合函数或窗口函数(sum, min, max count等) 48-- 2.distinct 49-- 3.group by 50-- 4.having 51-- 5.union或union all 52 53 54-- 视图案例 55-- 1.为了保证数据库安全, 开发人员在操作tb_user表时, 只能看到用户的基本字段,屏蔽手机号和邮箱两个字段 56create view tb_user_view as select id, name, profession, gender, status, create_time from tb_user; 57select * from tb_user_view; 58-- 2.查询学生选修的课程(三表联查),为了简化操作,定义视图 59create view tb_stu_cource_view as select s.name student_name, s.no student_no, c.name course_name from student s, student_course sc, course c where s.id=sc.studentid and sc.courseid=c.id; 存储过程/函数/触发器 1-- 存储过程: 事先经过编译并存储在数据库中的一段SQL语句的集合, 调用存储过程可以简化应用开发人员的很多工作, 2-- 减少数据在数据库和应用服务器之间的传输,对提高数据处理的效率有好处 3-- 存储过程的思想很简单, 就是数据库SQL语言层面的代码封装与重用 4-- 特点: 封装复用; 可以接收参数, 返回数据; 减少网络交互提升效率 5 6 7-- 创建存储过程 8# create procedure 存储过程名称([参数列表]) 9# begin 10# -- sql语句 11# end; 12create procedure p1() 13begin 14 select count(*) from user; 15end; 16-- 如果在命令行中创建存储过程, 需要指定sql语句的结束符, 通过delimiter 17-- delimiter $$ 设置结束以$$结束 18# create procedure p1() 19# begin 20# select count(*) from user; 21# end$$ 22 23-- 调用 24-- call 名称([参数]); 25call p1(); 26-- 查看存储过程 27-- select * from information_schema.ROUTINES where ROUTINE_SCHEMA=\u0026#39;数据库名字\u0026#39;; -- 查询指定数据库存储过程及状态信息 28-- show create procedure 存储过程名称; -- 查询某个存储过程定义 29select * from information_schema.ROUTINES where ROUTINE_SCHEMA=\u0026#39;bbs\u0026#39;; 30show create procedure p1; 31-- 删除 32-- drop procedure if exists 存储过程名称; 33drop procedure if exists p1; 34 35 36-- 变量 37 38-- 系统变量是是MySQL服务器提供的, 不是用户定义的, 属于服务器层面. 分为全局变量(global)和会话变量(session) 39-- 全局变量在所有MySQL会话都有效, 会话变量只在当前会话有效 40-- 查看系统变量, 默认都是session 41-- 查看所有系统变量 show [global|session] variables; 42-- 通过模糊匹配查看变量 show [global|session] variables like \u0026#39;....\u0026#39;; 43-- 查看指定变量 select @@[global|session]系统变量名; 44show variables ; 45show session variables ; 46show global variables ; 47show variables like \u0026#39;auto%\u0026#39;; 48show global variables like \u0026#39;auto%\u0026#39;; 49select @@autocommit; 50select @@session.autocommit; 51select @@global.autocommit; 52 53-- 设置系统变量, MySQL服务重启后, 所设置的全局变量会失效, 要想不失效,可以在/etc/my.cnf中配置 54-- set [session|global] 系统变量名=值; 55-- set @@[session|global] 系统变量名=值; 56set session autocommit = 0; 57set global autocommit = 0; 58 59-- 用户定义变量: 不用提前声明, 用的时候直接用@变量名 60-- 作用域是当前会话, 其他会话用不了. 61-- 赋值, 推荐使用:=, 因为=可以作为比较运算符 62-- set @var_name =expr [,@var_name=expr]...; 63-- set @var_name :=expr [,@var_name:=expr]...; 64-- select @var_name :=expr [,@var_name :=expr] ...; 65-- select 字段名 into @var_name from 表名; 66set @caonima=\u0026#39;cnm\u0026#39;; 67set @mygender:=\u0026#39;男\u0026#39;, @myhobby:=\u0026#39;java\u0026#39;; 68select @cnm:=\u0026#39;red\u0026#39;; 69select count(*) into @usercount from learndatabase.user; 70-- 使用 71-- select @var_name; 72select @caonima; 73select @mygender, @myhobby, @usercount; 74select @abc; -- 没声明赋值,结果是null 75 76-- 局部变量: 需要定义的在局部生效的变量, 访问需要declare声明. 可用作存储过程的局部变量和输入参数 77-- 局部变量的范围是在其内声明的begin and块. 78-- 声明, 没有@符号了 79-- declare 变量名 变量类型 [default...]; 80-- 变量类型: int, bigint, char, varchar, date, time等 81-- 赋值, 没有@符号. 82-- set 变量名=值; 83-- set 变量名:=值; 84-- select 字段 into 变量名 from 表名; 85create procedure p2() 86begin 87 declare stu_count int default 0; 88 select count(*) into stu_count from learndatabase.user; 89 select stu_count; 90end; 91call p2(); 92 93 94-- 流程控制结构 95-- if语法 96# if 条件1 then 97# ... 98# elseif 条件2 then 99# ... 100# else 101# ... 102# end if; 103create procedure p3() 104begin 105 declare score int default 59; 106 declare result varchar(10); 107 108 if score \u0026gt;= 85 then 109 set result:=\u0026#39;优秀\u0026#39;; 110 elseif score \u0026gt;=60 then 111 set result:=\u0026#39;及格\u0026#39;; 112 else 113 set result:=\u0026#39;不及格\u0026#39;; 114 end if; 115 116 select result; 117end; 118 119call p3(); 120 121-- 参数 122-- 类型: IN 作为输入的参数, 需要调用时传值, 此为默认 123-- OUT 作为输出的参数, 该参数可以作为返回值 124-- INOUT 既可以作为输入, 也可以作为输出的参数 125# create procedure 存储过程名称([in/out/inout 参数名 参数类型]) 126# begin 127# -- sql 128# end; 129-- 判断成绩的存储过程 130create procedure p4(in score int, out result varchar(10)) 131begin 132 if score \u0026gt;= 85 then 133 set result:=\u0026#39;优秀\u0026#39;; 134 elseif score \u0026gt;=60 then 135 set result:=\u0026#39;及格\u0026#39;; 136 else 137 set result:=\u0026#39;不及格\u0026#39;; 138 end if; 139end; 140call p4(90, @result); 141select @result; 142 143-- 将传入的200分制的分数, 换算成100分制的分数 144create procedure p5(inout score double) 145begin 146 set score:=score * 0.5; 147end; 148set @score:=199.8; 149call p5(@score); 150select @score; 151 152-- case 153-- 语法1 154# case case_value 155# when when_value1 then statement_list1 -- 当case_value=value1时执行when之后的sql语句 156# [when when_value2 then statement_list2]... 157# [else statement_list] -- 都不满足时执行的sql语句 158# end case; 159-- 语法2 160# case 161# when search_condition1 then statement_list1 -- 当search_condition1为true时执行 162# [when search_condition2 then statement_list2]... 163# [else statement_list] -- 都不满足时执行的sql语句 164# end case; 165-- 根据传入的月份,判断月份所属的季节 166create procedure p6(in month int) 167begin 168 declare result varchar(10); 169 case 170 when month \u0026gt;= 1 and month \u0026lt;= 3 then set result:=\u0026#39;第一季度\u0026#39;; 171 when month \u0026gt;= 4 and month \u0026lt;= 6 then set result:=\u0026#39;第二季度\u0026#39;; 172 when month \u0026gt;= 7 and month \u0026lt;= 9 then set result:=\u0026#39;第三季度\u0026#39;; 173 when month \u0026gt;= 10 and month \u0026lt;= 12 then set result:=\u0026#39;第四季度\u0026#39;; 174 else set result:=\u0026#39;错误输入!\u0026#39;; 175 end case; 176 select concat(\u0026#39;输入的月份为\u0026#39;, month, \u0026#39;, 它所属的季度为: \u0026#39;, result); 177end; 178call p6(4); 179 180-- while循环: 有条件的循环, 满足条件才循环 181# while 条件 DO 182# sql...; 183# end while; 184-- 计算1累加到n 185create procedure p7(in count int) 186begin 187 declare i int default 1; 188 declare res int default 0; 189 while i \u0026lt;= count do 190 set res := res + i; 191 set i := i + 1; 192 end while; 193 select res; 194end; 195 196create procedure p7(in count int) 197begin 198 declare res int default 0; 199 while count \u0026gt; 0 do 200 set res := res + count; 201 set count := count - 1; 202 end while; 203 select res; 204end; 205drop procedure p7; 206call p7(100); 207 208-- repeat循环: 满足循环退出 209# repeat 210# sql...; 211# until 条件; -- 当条件为真,退出循环 212# end repeat; 213-- 1加到n 214create procedure p8(in count int) 215begin 216 declare res int default 0; 217 repeat 218 set res:=res+count; 219 set count:=count-1; 220 until count \u0026lt;0 end repeat; 221 select res; 222end; 223call p8(10); 224 225-- loop循环: 简单循环, 如果不增加退出循环条件那么就是死循环, 它配合leave和iterate使用 226-- leave: 退出循环 227-- iterate: 必须用在循环中, 作用是跳过当前循环剩下语句进入下循环 228# [begin_label:] loop -- 指定标识label 229# sql...; 230# leave label; -- 退出循环 231# iterate label; -- 跳到下次循环 232# end loop [end_label]; 233-- 实现1累加n 234create procedure p9(in count int) 235begin 236 declare res int default 0; 237 loop_label: loop 238 set res := res + count; 239 set count := count - 1; 240 if count \u0026lt;= 0 then 241 leave loop_label; 242 end if; 243 end loop loop_label; 244 select res; 245end; 246call p9(100); 247-- 计算1-n的偶数累加 248create procedure p10(in count int) 249begin 250 declare res int default 0; 251 if count % 2 = 1 then 252 set count:= count -1; 253 end if; 254 odd_sum:loop 255 set res := res + count; 256 set count := count - 2; 257 if count \u0026lt;= 0 then 258 leave odd_sum; 259 end if; 260 end loop odd_sum; 261 select res; 262end; 263 264create procedure p10(in count int) 265begin 266 declare res int default 0; 267 odd_sum: loop 268 if count \u0026lt;= 0 then 269 leave odd_sum; 270 end if; 271 if count % 2 = 1 then 272 set count := count - 1; 273 iterate odd_sum; 274 end if; 275 set res := res + count; 276 set count := count - 1; 277 end loop odd_sum; 278 select res; 279end; 280 281drop procedure p10; 282call p10(10); 283 284 285-- 游标: 存储查询结果集的数据类型, 在存储过程和函数中可以使用游标对结果集进行循环处理 286-- 声明游标: declare 游标名称 cursor for 查询语句; 287-- 打开游标: open 游标名称; 288-- 获取游标记录: fetch 游标名称 into 变量[,变量]; 289-- 关闭游标: close 游标名称; 290-- 案例: 根据传入的参数uage, 查询用户表中所有年龄小于uage的用户姓名name和专业profession, 然后将name和profession插入新表 291create procedure p11(in uage int) 292begin 293 declare uname varchar(100); 294 declare ugender char(1); 295 declare u_cursor cursor for select name, gender from learndatabase.user where age \u0026lt;= uage; 296 297 drop table if exists tb_user_gender; 298 create table if not exists tb_user_gender( 299 id int primary key auto_increment, 300 name varchar(100), 301 gender char(1) 302 ); 303 open u_cursor; 304 while true do -- 这里不知道什么时候结束 305 fetch u_cursor into uname, ugender; 306 insert into tb_user_gender values (null, uname, ugender); 307 end while; 308 close u_cursor; 309 310end; 311 312-- 条件处理程序(异常): 定义在流程控制结构执行过程中遇到的问题时相应的处理步骤 313-- declare handler_action handler for condition_value[,condition_value] ... statement; 314-- handler_action: continue:继续执行当前程序, exit:终止执行当前程序 315-- condition_value: sqlstate sqlstate_value: 状态码, 如02000 316-- sqlwarning: 所有以01开头的sqlstate代码的简写 317-- not found: 所有以02开头的sqlstate代码的简写 318-- sqlexception: 所有没有被sqlwarning和not found捕获的sqlstate代码的简写 319create procedure p11(in uage int) 320begin 321 declare uname varchar(100); 322 declare ugender char(1); 323 declare u_cursor cursor for select name, gender from learndatabase.user where age \u0026lt;= uage; 324 declare exit handler for sqlstate \u0026#39;02000\u0026#39; close u_cursor; -- 满足状态码为02000触发退出, 退出时将游标关闭 325 -- declare exit handler for not found close u_cursor; 326 327 drop table if exists tb_user_gender; 328 create table if not exists tb_user_gender( 329 id int primary key auto_increment, 330 name varchar(100), 331 gender char(1) 332 ); 333 open u_cursor; 334 while true do -- 现在最后一次循环后, 下面的语句会报错, 被handler抓取退出. 335 fetch u_cursor into uname, ugender; 336 insert into tb_user_gender values (null, uname, ugender); 337 end while; 338 close u_cursor; 339 340end; 341call p11(30); 342 343 344-- 存储函数: 有返回值的存储过程, 参数只能是in类型的. 345# create function 函数名称([参数列表]) 346# returns type [characteristic...] 347# begin 348# --sql 349# return ... ; 350# end; 351-- characteristic说明: 352-- determinstic:相同的输入总是产生相同的结果 353-- no sql:不包含sql语句 354-- reads sql data:包含读取sql的语句, 不包含写入数据的语句 355-- 案例: 1累加到n 356create function fun1(n int) 357returns int deterministic 358begin 359 declare res int default 0; 360 while n\u0026gt;0 do 361 set res:=res+n; 362 set n:=n-1; 363 end while; 364 return res; 365end; 366 367 368-- 触发器: 在insert/update/delete之前或之后, 触发并执行触发器中定义的sql语句集合 369-- 确保数据完整性, 日志记录, 数据校验等操作. 370-- 使用别名old和new来引用触发器中发生变化的记录内容 371-- insert触发器:new表示将要或已经新增的数据 372-- update触发器:old表示修改之前的数据, new表示将要或已经修改后的数据 373-- delete触发器:old表示将要或已经删除掉的数据 374-- 现在只支持行级触发器(每行触发一次), 不支持语句级触发器(不管影响多少行,只执行一次) 375 376-- 创建触发器 377# create trigger trigger_name 378# before/after insert/update/delete 379# on tbl_name for each row -- 行级触发器 380# begin 381# trigger_statement; 382# end; 383-- 查看 384show triggers ; 385-- 删除 386# drop trigger [schama_name.]trigger_name; -- 没有指定数据库名默认为当前数据库 387 388-- 需求, 记录tb_user表数据变更日志, 插入到日志表user_logs中, 包含增加,修改,删除 389create table user_logs( 390 id int(11) not null auto_increment, 391 operation varchar(20) not null , 392 operation_time datetime not null , 393 operation_id int(11) not null , 394 operation_params varchar(500) , 395 primary key (`id`) 396)engine =innodb default charset =utf8; 397 398-- 定义三个触发器 399--insert触发器 400create trigger insert_trigger 401 after insert on learndatabase.user for each row 402begin 403 insert into user_logs(id, operation, operation_time, operation_id, operation_params) values 404 (null, \u0026#39;insert\u0026#39;, now(), new.id, concat(\u0026#39;插入的数据内容: \u0026#39;, new.id, new.name, new.gender, new.gender)); 405end; 406show triggers ; 407drop trigger insert_trigger; 408insert into learndatabase.user values (null, \u0026#39;rurushu\u0026#39;, 38, 1, \u0026#39;男\u0026#39;, 3, 5); 409-- update触发器 410create trigger update_trigger 411 after insert on learndatabase.user for each row 412begin 413 insert into user_logs(id, operation, operation_time, operation_id, operation_params) values 414 (null, \u0026#39;update\u0026#39;, now(), new.id, concat(\u0026#39;更新前数据: \u0026#39;, old.id, old.name, old.gender, old.gender, 415 \u0026#39;更新后数据: \u0026#39;, new.id, new.name, new.gender, new.gender)); 416end; 417-- delete触发器 418create trigger delete_trigger 419 after insert on learndatabase.user for each row 420begin 421 insert into user_logs(id, operation, operation_time, operation_id, operation_params) values 422 (null, \u0026#39;delete\u0026#39;, now(), old.id, concat(\u0026#39;删除前数据: \u0026#39;, old.id, old.name, old.gender, old.gender)); 423end; 锁 分类: 全局锁, 表级锁, 行级锁.\n全局锁 全局锁: 对整个数据库实例加锁, 加锁后处于只读状态, 后续的DML写, DDL, 已经更新操作的事务提交语句都被阻塞\n使用场景: 做全库的逻辑备份 从而获取一致性视图, 保证数据完整性\u0026hellip;\n1flush tables with read lock ; 2mysqldump -uroot -proot learndatabase \u0026gt; learndatabase.sql 3unlock tables ; 特点:\n 主库备份, 备份期间不能执行更新操作, 业务基本停摆 从库备份, 备份期间不能执行主库同步过来的二进制日志, 导致主从延迟  Innodb中, 备份时加上参数\u0026ndash;single-transaction参数来完成不加锁的一致性数据备份(快照读实现)\n1mysqldump --single-transaction -uroot -proot learndatabase \u0026gt; learndatabase.sql 表级锁 表级锁: 发生锁冲突的概率最高, 并发度最低. 应用在MyISAM,Innodb,BDB等存储引擎\n分类: 表锁, 元数据锁, 意向锁\n表锁 表锁: 分为表共享读锁(read lock, 所有客户端只能读不能写), 表独占写锁(write lock, 只有自己能读能写, 别的客户端不能读不能写)\n1-- 加锁 2lock tables 表名... read/write 3-- 释放锁 4unlock tables 或者 客户端断开连接 元数据锁 元数据锁: 系统自动控制不需要显示使用, 访问一张表自动加上. 主要是维护表元数据的一致性,有活动事务时不可对元数据进行写入操作\n元数据大概就是表结构\n在MySQL5.5后, 对表进行增删改查,加MDL读锁(共享);当对表结构变更时,加MDL写锁(排它), 这两个锁是冲突的.\n比如两个终端,事务1使用了select加MDL读锁,那么事务2使用alter就会等待,因为这两个锁是排斥的,加不了MDL写锁.\n1-- 查看元数据锁 2select object_type, object_schema, object_name, lock_type, lock_duration from performance_schema.metadata_locks; 意向锁 意向锁: 为了避免DML在执行时加的行锁和表锁的冲突(不能同时加),Innodb中引入了意向锁, 使得表锁不用检查每行数据是否加锁,使用意向锁减少表锁的检查\n意向共享锁(IS):由select\u0026hellip; lock in share mode添加; 与表锁共享锁(read)兼容,与表锁排它锁(write)互斥.\n意向排它锁(IX):由insert,update,delete,select\u0026hellip;for update添加; 与表锁共享锁和表锁排它锁都互斥, 这样就可以保证数据一致性.\n意向锁之间不会互斥\n1-- 例子: 2select * from learndatabase.user lock in share mode ; -- 这句话加上行锁共享锁和意向共享锁 3lock tables learndatabase.user read; -- 这时可以加表共享读锁, 因为这两个锁兼容; 都可以读嘛 4lock tables learndatabase.user write; -- 这时不能加表独占写锁, 互斥的; 因为如果允许的话, 别个就可以改数据了,读的东西不一致. 1begin ; -- 客户端1开启事务 2update learndatabase.user set gender=\u0026#39;女\u0026#39; where id=1; -- 加上行锁和意向排它锁 3lock tables learndatabase.user read; -- 客户端2加锁, 不行 4lock tables learndatabase.user write; -- 客户端2加锁, 不行 1-- 查看意向锁及行锁的加锁情况 2select object_schema, object_name, index_name, lock_type, lock_mode, lock_data from performance_schema.data_locks; 行级锁 行级锁: 发生锁冲突的概率最低, 并发度最高, 应用在Innodb中.\nInnodb的数据是基于索引组织的, 行锁是往索引上的索引项加锁, 不是对记录加锁\n行级锁分为三类:\n 行锁(record lock): 锁定单行记录, 防止其他事务进行update, delete. 在rc(read committed),rr(repeatable read)隔离级别下都支持 间隙锁(gap lock): 锁定记录与记录之间的间隙(不含记录), 确保索引记录间隙不变, 防止其他事务在这个间隙insert,产生幻读, 在rr隔离级别下都支持. 临键锁(next-key lock): 行锁和间隙锁的组合, 同时锁住数据,并锁住数据前面的间隙gap.在rr隔离级别下支持, 防止幻读  这些锁和事务的隔离级别相辅相成.\n行锁 Innodb实现了两种类型行锁:\n 共享锁(s): 允许一个事务去读一行, 阻止其他事务获得相同数据集的排它锁, commit后就释放了(防不可重复读, 脏读) 排它锁(x): 允许获取排它锁的事务更新数据, 阻止其他事务获得相同数据集的共享锁和排它锁.  1-- insert, update, delete 获得排它锁, 系统自动加锁不需要控制 2-- select 不加任何锁 3-- select ... lock in share mode 共享锁 4-- select ... for update 排它锁 5select * from learndatabase.user where id=1; -- id=1这一行的共享锁, 那么其他事务对这一行数据不能获得排它锁 6update stu set name=\u0026#39;lei\u0026#39; where id=1; -- 排它锁 针对唯一索引进行检索时, 对已存在的记录进行等值匹配, 将会自动优化为行锁.\nInnodb的行锁是针对索引加的锁, 不通过索引条件检索数据, 那么Innodb将对表的所有记录加锁, 行锁升级为表锁.\nupdate优化的原理就是这个:\n1update stu set name =\u0026#39;lei\u0026#39; where name=\u0026#39;lily\u0026#39;; -- 事务1,第8行数据. 加的表锁.因为此时name没有索引,没有走索引 2update stu set name=\u0026#39;lei\u0026#39; where id=1; -- 事务2, 即便是第一行数据也不能更改, 因为这时已经是表锁了. 1-- 查询行锁 2select object_schema, object_name, index_name, lock_type, lock_mode, lock_data from performance_schema.data_locks; 间隙锁/临键锁 1-- 1. 索引上给等值查询(唯一索引), 给不存在的记录加锁, 优化为间隙锁 2update stu set age = 10 where id = 5; -- 事务1 表中只有3和8,之间没有数据, 这时加间隙锁, 锁住(3.8]这个空隙 3insert into stu values (7,\u0026#39;lili\u0026#39;, 8); -- 事务2 这时再往里插入, 插入不了被锁住了. 4 5-- 2. 索引上的等值查询(普通索引), 向右遍历时最后一个值不满足查询条件时, next-key lock退化为间隙 6-- 这里age字段就不是唯一索引可能有多个相同的值, 那么它会加11及后面17之间的锁(11后就是17) 7create index index_idx_stu_age on stu(age); 8select * from stu where age = 11 lock in share mode ; -- 事务1, 首先对3记录加共享行锁S,其次还要对17加临键锁,锁住本身和其间隙, 防止幻读 9 10-- 3. 索引上的范围查询(唯一索引), 会访问到不满足条件的第一个值为止. 11select * form stu where id \u0026gt; 30; -- 唯一索引范围查询. 假设查出来的有31 50 ,那么会给31加S锁, 还会给50加临键锁, 还会将50到正无穷也加S锁 12-- 间隙锁的目的是防止其他事务插入间隙, 间隙锁可以共存, 一个事务采用的间隙锁不会阻止另一个事务在同一间隙采用间隙锁. Innodb引擎/事务原理/MVCC 1-- Innodb引擎 2-- 逻辑存储结构 3-- 表空间tablespace: ibd文件, 一个mysql实例可以对应多个表空间, 用于存储记录, 索引等数据. 4-- 段segment: 分为数据段, 索引段, 回滚段. Innodb是索引组织表, 数据段就是B+Tree的叶子结点, 索引段即为B+Tree的非叶子节点. 段用来管理多个Extent区 5-- 区extent: 表空间的单元结构, 每个区的大小为1m, 默认情况下, Innodb存储引擎页大小为16k, 即一个区中一共有64个连续的页. 6-- 页page: 是Innodb存储引擎磁盘管理的最小单元, 每个页的大小默认是16kb. 为了保证页的连续性, Innodb存储引擎每次从磁盘申请4-5个区 7-- 行row: Innodb存储引擎数据是按行进行存放的. 行的数据结构: 8-- Trx_id: 每次对每条记录进行改动时, 都会把对应的事务id赋值给trx_id隐藏列 9-- Roll_pointer: 每次对每条记录进行改动时, 都会把旧的版本写入到undo日志中, 然后这个隐藏列就相当于一个指针, 可以用它找到该记录修改前的信息 10-- col1, col2, ... 11 12 13-- 架构 14-- 内存架构 15-- 1.buffer pool: 缓冲池是主内存的一个区域, 里面可以缓存磁盘上经常操作的真实数据, 在执行增删改查操作时, 先操作缓冲池中的数据(没有数据就从磁盘加载并缓存) 16-- 然后再以一定频率刷新到磁盘, 从而减少磁盘io, 加快处理速度. 17-- 缓冲池以页page为单位, 底层采用链表数据结构管理page, page分为三类: 18-- free page: 空闲page, 没有使用过 19-- clean page: 被使用page, 数据没有被修改过 20-- dirty page: 脏页, 被使用page, 数据被修改过, 页中数据与磁盘数据产生了不一致 21-- 2.change buffer: 更改缓冲区(针对非唯一二级索引页), 在执行DML语句时, 如果这些数据page没有在buffer pool中, 不会直接操作磁盘, 而会将数据变更 22-- 存在更改缓冲区change buffer中, 在未来数据被读取时, 再将数据合并恢复到buffer pool中, 然后再将合并后的数据刷新到磁盘中 23-- 好处: 与聚集索引不同, 二级索引通常是非唯一的, 并且以相对随机的顺序插入二级索引. 同样删除和更新可能会影响索引树种不相邻的二级索引页, 如果每次都 24-- 操作磁盘, 会造成大量磁盘io, 有了change buffer之后, 我们可以在缓冲池中进行合并处理, 减少磁盘io 25-- 3.adaptive hash index: 自适应哈希索引, 用于优化对buffer pool数据的查询. Innodb存储引擎会监控对表上各索引页的查询, 如果观察到hash索引可以 26-- 提升速度, 则建立hash索引, 称之为自适应hash索引. 27-- 自适应哈希索引, 无需人工干预, 是系统根据情况自动完成 28-- 参数adaptive_hash_index 29-- 4.log buffer: 日志缓冲区, 用来保存要写入到磁盘中的log日志数据(redo log, undo log), 默认大小16MB, 日志缓存区的日志会定期刷新到磁盘中. 如果 30-- 需要更新,插入,删除许多行的事务, 增加日志缓冲区的大小可以节省磁盘io 31-- 参数innodb_log_buffer_size: 缓冲区大小, innodb_flush_log_at_trx_commit: 日志刷新到磁盘的时机(0:每秒将日志写入并刷新到磁盘; 1:日志在每次事务提交时写入并刷新到磁盘; 2:日志在每次事务提交后写入,并每秒刷新到磁盘一次) 32 33 34-- 磁盘架构 35-- 这些文件系统里面都可以找得到. 36-- System tablespace: 系统表空间是更改缓冲区的存储区域, 如果表是在系统表空间而不是每一个表文件或通用表空间中创建的, 它也可能包含表和索引数据 37-- 参数:innodb_data_file_path 38-- File-per-table tablespace: 每个表的文件表空间包含单个Innodb表的数据和索引, 并存储在文件系统上的单个数据文件中. 39-- 参数:innodb_file_per_table 40-- general tablespace: 通用表空间, 需要通过create tablespace语法创建通用表空间, 在创建表时, 可以指定该表空间. 41create tablespace ts_name add datafile \u0026#39;file_name.ibd\u0026#39; engine =innodb; 42create table a(id int primary key auto_increment, name varchar(10))engine =innodb tablespace ts_name; 43-- undo tablespace: 撤销表空间, mysql实例在初始化时会自动创建两个默认的undo表空间(undo_001,undo_002)初始大小为16M, 用于存储undo log日志. 44-- temporary tablespace: 临时表空间, Innodb使用会话临时表空间和全局临时表空间,存储用户创建的临时表等数据. 45-- doublewirte buffer files: 双写缓冲区, Innodb将数据页从buffer pool刷新到磁盘前, 为了保证数据安全, 先将数据写入双写缓冲区文件中, 便于系统异常时恢复数据. 46-- redo log: 重做日志, 用来实现事务持久性. 该日志由两部分组成:重做日志缓冲(redo log buffer, 内存中), 重做日志文件(redo log, 磁盘中, ib_logfile0, ib_logfile1), 47-- 当事务提交之后会把所有修改信息都会存到该日志中, 用于在刷新脏页到磁盘时发生错误进行数据恢复. 这文件循环写, 事务提交里面的数据没有意义了 48 49 50-- 后台线程 51-- 1. master thread: 核心后台线程, 负责调度其他线程, 还负责将缓冲池中的数据异步刷新到磁盘中, 保持数据一致性, 还包括脏页的刷新, 合并插入缓存, undo页的回收 52-- 2. io thread: Innodb引擎中大量使用了aio来处理io请求, 可以极大提升数据库性能, 而io thread主要负责这些io请求的回调. 53-- read thread: 默认4个, 负责读操作 54-- write thread: 默认4个, 负责写操作 55-- log thread: 默认1个, 负责将日志缓冲区刷新到磁盘 56-- insert buffer thread: 默认1个, 负责将写缓冲区的内容刷新到磁盘 57-- 查看Innodb引擎的状态信息, 里面有线程信息 58show engine innodb status ; 59-- 3. purge thread: 用于回收事务已经提交的undo log. 事务提交后undo log可能不用了,用它回收. 60-- 4. page cleaner thread: 协助master thread刷新脏页到磁盘的线程, 减轻master thread的压力, 减少阻塞. 61 62 63-- 事务原理 64-- 事务的原子性, 一致性, 持久性由redo log和undo log保证 65-- 事务的隔离性由锁和MVCC(多版本并发控制)保证 66 67-- redo log(保证持久性) 68-- redo log: 重做日志, 记录的是事务提交时数据页的物理修改, 用来实现事务持久性. 该日志由两部分组成:重做日志缓冲(redo log buffer, 内存中), 重做日志文件(redo log, 磁盘中), 69-- 当事务提交之后会把所有修改信息都会存到该日志中, 用于在刷新脏页到磁盘时发生错误进行数据恢复. 这文件循环写, 事务提交, 里面的数据没有意义了 70-- 流程: 对缓冲区buffer pool数据进行增删改, 这时页面变成脏页, 同时将增删改的数据记录在redolog buffer记录数据页物理变化, 事务提交时将log buffer刷新到磁盘文件中ib_logfile0/1 71-- 之后脏页刷新到磁盘. 如果脏页刷新到磁盘失败了, 可以通过redo log恢复 72 73-- undo log(保证原子性) 74-- 回滚日志, 用于记录数据被修改前的信息, 作用包含两个:提供回滚和MVCC 75-- undo log和redo log记录物理日志不一样, 它是逻辑日志. 可以认为当delete一条记录时, undo log中会记录一条对应的insert记录, 反制一番, 当update一条记录时, 76-- 它记录一条对应相反的update记录. 当执行rollback时, 就可以从undo log中逻辑记录读取到相应的内容并进行回滚 77-- undo log销毁: undo log在事务执行时产生, 事务提交时, 并不会立即删除undo log, 因为这些日志可能还用于mvcc 78-- undo log存储: undo log采用段的方式进行管理和记录, 存放在rollback segment回滚段中, 内部包含1024个undo log segment 79 80 81 82-- MVCC 83-- 基本概念 84-- 当前读: 读取的是记录的最新版本, 读取时还要保证其他并发事务不能修改当前记录, 会对读取的记录进行加锁. 85-- 如select ... lock in share mode(共享锁), select ... for update , update, insert, delete(排它锁)都是一种当前读 86begin; 87select * from learndatabase.user; -- 在别的事务commit之前和之后去读到的都是同样的数据, 可重复读 88select * from learndatabase.user lock in share mode ; -- 别的事务commit之后可以读取到最新的数据. 89-- 快照读: 简单的select(不加锁)就是快照读, 快照读, 读取的是记录数据的可见版本, 有可能是历史数据, 不加锁, 是非阻塞读 90begin; 91select * from learndatabase.user; -- 在别的事务commit之前去读,生成一个快照 92select * from learndatabase.user; -- 在别的事务commit之后读, 依旧读的是之前的快照 93-- read committed: 每次select都生成一个快照读 94-- repeatable read: 开启事务后第一个select语句才是快照读的地方. 95-- serializable: 快照读退化成当前读, 每次读取都会加锁. 96-- MVCC: 维护一个数据的多个版本, 使得读写操作没有冲突, 快照读为mysql实现MVCC提供了一个非阻塞读功能, 还需要依赖与数据库记录中的三个隐式字段, undo log日志, readview. 97 98 99-- 实现原理 100-- 记录中的隐藏字段 101-- 1.DB_TRX_ID: 最近修改事务ID. 记录插入这条记录或最后一次修改该记录的事务ID(事务ID是从1自增的) 102-- 2.DB_ROLL_PTR: 回滚指针. 指向这条记录的上一个版本, 用于配合undo log, 指向上个版本. 103-- 3.DB_ROW_ID: 隐藏主键. 当表结构没有指定主键时会生成该隐藏字段. 104-- 查看隐藏字段 105ibd2sdi user.ibd 106 107-- uodo log: 回滚日志, 在insert, update, delete的时候产生的便于数据回滚的日志 108-- 当insert时, 产生的undo log只在回滚时需要, 在事务提交后便被立即删除 109-- 当update, delete时, undo log不止在回滚时需要, 在快照读时也需要, 不会被立刻删除 110 111-- undo log版本链 112-- 不同事务或相同事务对同一条记录进行修改, 会导致该记录的undo log生成一条记录版本链表, 头部是最新的旧记录, 尾部是最早的旧记录. 113-- undo log记得是旧记录的所有东西, 里面就包括了DB_ROLL_PTR指针, 所以旧记录的该字段指向的是下一条旧记录 114 115-- readview: 读视图. 是快照读sql执行的MVCC提取数据的依据, 记录并维护系统当前活跃的事务(未提交的)id 116-- 包含四个核心字段: 117-- 1.m_ids:当前活跃的事物ID集合(没有commit的事务id) 118-- 2.min_trx_id: 最小活跃事物ID(m_ids中的最小值) 119-- 3.max_trx_id: 预分配事务ID, 当前最大事务ID+1(事务是自增的, 下一个就是+1) 120-- 4.creator_trx_id: readview创建者的事务ID. 121-- 版本链数据访问规则: (trx_id代表当前这条记录对应的事务的id, 就是db_trx_id) 122-- 1. trx_id == creatr_trx_id时 可以访问该版本. (说明数据是当前事务更改的) 123-- 2. trx_id \u0026lt; min_trx_id时 可以访问该版本 (说明事务已经提交了) 124-- 3. trx_id \u0026gt; max_trx_id时 不可以访问该版本. (说明该事务是在readview生成后才开启, 这里感觉可以取等) 125-- 4. min_trx_id \u0026lt;= trx_id \u0026lt;= max_trx_id且trx_id不在m_ids中 可以访问该版本 (说明数据已经提交) 126-- 不同的隔离级别, 生成readview的时机不同: 127-- read committed: 在事务中每次执行快照读时生成readview 128-- repeatable read: 仅在事务第一次执行快照读时生成readview, 后续复用该readview 129 130-- 原理分析(rc级别) 131-- read committed: 在事务中每次执行快照读时生成readview 132-- 简单来说就沿着undo log日志, 从新往旧每一条记录的db_trx_id去和规则作对比, 如果都不能访问则沿着版本链往下继续找直到满足条件为止. 133-- 原理分析(rr级别) 134-- 与rr唯一不同就是两次查询的readview不同罢了. 所以rc两次查询可能不同, rr都是一样的. 可重复读嘛 ","date":"2024-05-25","permalink":"/posts/tech/java-2-mysql/","series":["Java"],"tags":["","",""],"title":"MySQL学习笔记"},{"categories":["计算机"],"content":"说明 这里记录不需要在代码中记录\u0026amp;已经存在的笔记的知识点.\n代码的知识点已经打包:\n同时还有一份在线文档:\n需要复习的时候三个部分同时查阅.\nMybatisPlus 实现基本的CRUD 为了简化单表CRUD，MybatisPlus提供了一个基础的BaseMapper接口，其中已经实现了单表的CRUD. 就是mapper中什么都不需要写, 就已经可以进行基本的CRUD了.\n1public interface UserMapper extends BaseMapper\u0026lt;User\u0026gt; { 2} 1\t@Test 2 void testInsert() { 3 User user = new User(); 4 user.setId(5L); 5 user.setUsername(\u0026#34;Lucy\u0026#34;); 6 user.setPassword(\u0026#34;123\u0026#34;); 7 user.setPhone(\u0026#34;18688990011\u0026#34;); 8 user.setBalance(200); 9 user.setInfo(\u0026#34;{\\\u0026#34;age\\\u0026#34;: 24, \\\u0026#34;intro\\\u0026#34;: \\\u0026#34;英文老师\\\u0026#34;, \\\u0026#34;gender\\\u0026#34;: \\\u0026#34;female\\\u0026#34;}\u0026#34;); 10 user.setCreateTime(LocalDateTime.now()); 11 user.setUpdateTime(LocalDateTime.now()); 12 userMapper.insert(user); 13 } 只需要继承BaseMapper就能省去所有的单表CRUD\nUserMapper在继承BaseMapper的时候指定了一个泛型, 泛型中的User就是与数据库对应的PO.\nMybatisPlus就是根据PO实体的信息来推断出表的信息，从而生成SQL的。默认情况下：\n MybatisPlus会把PO实体的类名驼峰转下划线作为表名 MybatisPlus会把PO实体的所有变量名驼峰转下划线作为表的字段名，并根据变量类型推断字段类型 MybatisPlus会把名为id的字段作为主键  常见注解 如果默认的实现与实际场景不符，MybatisPlus提供了一些注解便于我们声明表信息。\n@TableName  描述：表名注解，标识实体类对应的表 使用位置：实体类  还可以指定一些属性, 其中autoResultMap适用于类与类嵌套时, 自动结果集映射.\n@TableId  描述：主键注解，标识实体类中的主键字段 使用位置：实体类的主键字段  支持两个属性：\n   属性 类型 必须指定 默认值 描述     value String 否 \u0026quot;\u0026quot; 表名   type Enum 否 IdType.NONE 指定主键类型    IdType比较常见的有三种：\n AUTO：利用数据库的id自增长 INPUT：手动生成id ASSIGN_ID：雪花算法生成Long类型的全局唯一id，这是默认的ID策略  @TableField  描述：普通字段注解  一般情况下我们并不需要给字段添加@TableField注解，一些特殊情况除外：\n 成员变量名与数据库字段名不一致 成员变量是以isXXX命名，按照JavaBean的规范，MybatisPlus识别字段时会把is去除，这就导致与数据库不符。 成员变量名与数据库一致，但是与数据库的关键字冲突。使用@TableField注解给字段名添加转义字符：``  例:\n1mybatisplus通过扫描实体类, 并基于反射获取实体类信息作为数据库表信息 2实现CRUD数据库表信息的约定: 31. 类名驼峰转下划线作为数据库表名, 如userName的类对应的数据库就是user_name 42. 名为id的字段作为主键 53. 变量名驼峰转下划线违表的字段名, 如createTime字段在数据库表中的字段就是create_time 6 7符合约定的不用配置直接用, 不符合约定需自定义表名和字段名, 通过注解: 8@TableName指定表名 @TableId指定主键 @TableField指定字段 9 10这个在pojo中定义, 如 11@TableName(\u0026#34;tb_user\u0026#34;) 12public class User { 13// idtype枚举中代表了主键的三种类型: 14// 1. AUTO: 自增长 15// 2. INPUT: 通过set方法自动输入 16// 3. ASSIGN_ID: 分配ID,mp提供的IdentifierGenerator的nextID生成id, 不需要手动提供. 这是默认策略 17 @TableId(value = \u0026#34;index\u0026#34;, type = IdType.AUTO) 18 private Long id; 19// 使用@TableField的场景 20// 1. 成员变量名与数据库的字段名不一致 21// 2. 成员变量以is开头且是布尔值, 如is_married会被解析为married 22// 3. 成员变量名与数据库关键字冲突, order就是关键字 23// 4. 成员变量不是数据库字段, 下面的address字段数据库中没有. 24 @TableField(\u0026#34;username\u0026#34;) 25 private String name; 26 @TableField(\u0026#34;is_married\u0026#34;) 27 private Boolean isMarried; 28 @TableField(\u0026#34;`order`\u0026#34;) 29 private Integer order; 30 @TableField(exist = false) 31 private String address; 32} 核心功能 为了实现复杂的SQL需要用到核心功能.\n条件构造器 是为了代替where语句. BaseMapper中提供的相关方法除了以id作为where条件以外，还支持更加复杂的where条件。这些方法中的参数中的Wrapper就是条件构造的抽象类. Wrapper的子类AbstractWrapper提供了where中包含的所有条件构造方法, 而QueryWrapper在AbstractWrapper的基础上拓展了一个select方法，允许指定查询字段, UpdateWrapper在AbstractWrapper的基础上拓展了一个set方法，允许指定SQL中的SET部分. 所以我们根据需要选择不同的wrapper实现类.\n条件构造器wrapper: 主键的查询无法满足要求, 需要用wrapper满足更复杂的sql需求, 定义where条件等.\n queryWrapper来代替select, delete, update中的where部分 updateWrapper通常在set语句比较特殊才使用 lambda的wrapper支持lambda  queryWrapper(应对复杂的where) 查询名字带o的, 存款大于等于1000的人的id,名字, 信息, 收入\nselect id,username,info,balance from user where username like ? and balance \u0026gt;= ?\n1 @Test 2 void testQueryWrapper(){ 3// 1. 构建查询条件 4 QueryWrapper\u0026lt;User\u0026gt; wrapper = new QueryWrapper\u0026lt;User\u0026gt;() 5 .select(\u0026#34;id\u0026#34;, \u0026#34;username\u0026#34;, \u0026#34;info\u0026#34;, \u0026#34;balance\u0026#34;) 6 .like(\u0026#34;username\u0026#34;, \u0026#34;o\u0026#34;) 7 .ge(\u0026#34;balance\u0026#34;, 1000); 8// 2. 查询 9 List\u0026lt;User\u0026gt; users = userMapper.selectList(wrapper); 10 users.forEach(System.out::println); 11 } 12// eq是等于, ne不等于, gt大于, ge大于等于, lt小于, le小于等于 更新时使用queryWrapper\n将名字为jack的人的存款设置为2000\nupdate user set balance=2000 where username=\u0026ldquo;jack\u0026rdquo;\n1 @Test 2 void testUpdateByQueryWrapper(){ 3// 1. 要更新的数据, user中非null字段都会作为set语句 4 User user = new User(); 5 user.setBalance(2000); 6// 2.更新的条件 7 QueryWrapper\u0026lt;User\u0026gt; wrapper = new QueryWrapper\u0026lt;User\u0026gt;().eq(\u0026#34;username\u0026#34;, \u0026#34;jack\u0026#34;); 8// 3.执行更新 9 userMapper.update(user, wrapper); 10 } UpdateWrapper(应对复杂的set) 基于BaseMapper中的update方法更新时只能直接赋值，对于一些复杂的需求就难以实现。\n将id为1,2,4的用户余额减200\nupdate user set balance = balance - 200 where id in (1,2,4)\nSET的赋值结果是基于字段现有值的，这个时候就要利用UpdateWrapper中的setSql功能了\n1 void testUpdateWrapper(){ 2 List\u0026lt;Long\u0026gt; ids = List.of(1L,2L,4L); 3 UpdateWrapper\u0026lt;User\u0026gt; wrapper = new UpdateWrapper\u0026lt;User\u0026gt;() 4 .setSql(\u0026#34;balance = balance - 200\u0026#34;) 5 .in(\u0026#34;id\u0026#34;, ids); 6 userMapper.update(null, wrapper); 7 } LambdaWrapper(为了解字符串魔法值) 无论是QueryWrapper还是UpdateWrapper在构造条件的时候都需要写死字段名称，会出现字符串魔法值(“字符串魔法值”通常指的是硬编码在代码中的字符串常量，这些常量没有明确的意义或者上下文，可能难以理解和维护)。这在编程规范中显然是不推荐的。\n其中一种办法是基于变量的gettter方法结合反射技术。因此我们只要将条件对应的字段的getter方法传递给MybatisPlus，它就能计算出对应的变量名了。而传递方法可以使用JDK8中的方法引用和Lambda表达式。\n因此MybatisPlus又提供了一套基于Lambda的Wrapper，包含两个：\n  LambdaQueryWrapper\n  LambdaUpdateWrapper\n  分别对应QueryWrapper和UpdateWrapper\n1// 使用Lambda的wrapper来接触硬编码模式, 这样里面没有字符串了 2 3 void testLambdaQueryWrapper(){ 4// 1. 构建查询条件 5 LambdaQueryWrapper\u0026lt;User\u0026gt; wrapper = new LambdaQueryWrapper\u0026lt;User\u0026gt;() 6 .select(User::getId, User::getUsername, User::getInfo, User::getBalance) 7 .like(User::getUsername, \u0026#34;o\u0026#34;) 8 .ge(User::getBalance, 1000); 9// 2. 查询 10 List\u0026lt;User\u0026gt; users = userMapper.selectList(wrapper); 11 users.forEach(System.out::println); 12 } 自定义SQL 语句\n1UpdateWrapper\u0026lt;User\u0026gt; wrapper = new UpdateWrapper\u0026lt;User\u0026gt;() 2 .setSql(\u0026#34;balance = balance - 200\u0026#34;) 3 .in(\u0026#34;id\u0026#34;, ids); 中, 这种写法在某些企业也是不允许的，因为SQL语句最好都维护在持久层，而不是业务层。就当前案例来说，由于条件是in语句，只能将SQL写在Mapper.xml文件，利用foreach来生成动态SQL。 这实在是太麻烦了。假如查询条件更复杂，动态SQL的编写也会更加复杂。\n所以，MybatisPlus提供了自定义SQL功能，可以让我们利用Wrapper生成查询条件，再结合Mapper.xml编写SQL\n基本用法 利用mp的wrapper构建复杂的where条件, 然后自己定义sql语句中剩下的部分\n  基于wrapper构建where条件\n  在mapper接口方法参数中用param注解声明变量名称, 必须是ew\n  自定义sql, 并使用wrapper条件(这个可以在xml中, 也可以在接口中用注解写) 使用${ew.customSqlSegment}调用mp的where条件\n  这样做是为了满足不在业务层编写sql, 同时享受mp生成sql条件这种便利, 上面的sql是在业务层写sql了.\n1@Test 2 void testCustomSqlUpdate(){ 3// 1.更新条件 4 List\u0026lt;Long\u0026gt; ids = List.of(1L, 2L, 4L); 5 int amount = 200; 6// 2.定义条件 7 QueryWrapper\u0026lt;User\u0026gt; wrapper = new QueryWrapper\u0026lt;User\u0026gt;().in(\u0026#34;id\u0026#34;, ids); 8// 3. 调用自定义sql方法 9 userMapper.updateBalanceByIds(wrapper, amount); 10 } 1public interface UserMapper extends BaseMapper\u0026lt;User\u0026gt; { 2 @Select(\u0026#34;UPDATE user SET balance = balance - #{money} ${ew.customSqlSegment}\u0026#34;) 3 void deductBalanceByIds(@Param(\u0026#34;money\u0026#34;) int money, @Param(\u0026#34;ew\u0026#34;) QueryWrapper\u0026lt;User\u0026gt; wrapper); 4} 或者\n1\u0026lt;update id=\u0026#34;updateBalanceByIds\u0026#34;\u0026gt; 2 UPDATE user SET balance = balance - #{amount} ${ew.customSqlSegment} 3\u0026lt;/update\u0026gt; 多表查询 理论上来讲MyBatisPlus是不支持多表查询的，不过我们可以利用Wrapper中自定义条件结合自定义SQL来实现多表查询的效果。 例如，我们要查询出所有收货地址在北京的并且用户id在1、2、4之中的用户 要是自己基于mybatis实现SQL，大概是这样的：\n1\u0026lt;select id=\u0026#34;queryUserByIdAndAddr\u0026#34; resultType=\u0026#34;com.itheima.mp.domain.po.User\u0026#34;\u0026gt; 2 SELECT * 3 FROM user u 4 INNER JOIN address a ON u.id = a.user_id 5 WHERE u.id 6 \u0026lt;foreach collection=\u0026#34;ids\u0026#34; separator=\u0026#34;,\u0026#34; item=\u0026#34;id\u0026#34; open=\u0026#34;IN (\u0026#34; close=\u0026#34;)\u0026#34;\u0026gt; 7 #{id} 8 \u0026lt;/foreach\u0026gt; 9 AND a.city = #{city} 10 \u0026lt;/select\u0026gt; 可以看出其中最复杂的就是WHERE条件的编写，如果业务复杂一些，这里的SQL会更变态。\n但是基于自定义SQL结合Wrapper的玩法，我们就可以利用Wrapper来构建查询条件，然后手写SELECT及FROM部分，实现多表查询。\n查询条件这样来构建：\n1@Test 2void testCustomJoinWrapper() { 3 // 1.准备自定义查询条件 4 QueryWrapper\u0026lt;User\u0026gt; wrapper = new QueryWrapper\u0026lt;User\u0026gt;() 5 .in(\u0026#34;u.id\u0026#34;, List.of(1L, 2L, 4L)) 6 .eq(\u0026#34;a.city\u0026#34;, \u0026#34;北京\u0026#34;); 7 8 // 2.调用mapper的自定义方法 9 List\u0026lt;User\u0026gt; users = userMapper.queryUserByWrapper(wrapper); 10 11 users.forEach(System.out::println); 12} 然后在UserMapper中自定义方法：\n1@Select(\u0026#34;SELECT u.* FROM user u INNER JOIN address a ON u.id = a.user_id ${ew.customSqlSegment}\u0026#34;) 2List\u0026lt;User\u0026gt; queryUserByWrapper(@Param(\u0026#34;ew\u0026#34;)QueryWrapper\u0026lt;User\u0026gt; wrapper); 当然，也可以在UserMapper.xml中写SQL：\n1\u0026lt;select id=\u0026#34;queryUserByIdAndAddr\u0026#34; resultType=\u0026#34;com.itheima.mp.domain.po.User\u0026#34;\u0026gt; 2 SELECT * FROM user u INNER JOIN address a ON u.id = a.user_id ${ew.customSqlSegment} 3\u0026lt;/select\u0026gt; Service接口 MybatisPlus不仅提供了BaseMapper，还提供了通用的Service接口及默认实现，封装了一些常用的service模板方法。 通用接口为IService，默认实现为ServiceImpl\nCRUD 新增:\n save是新增单个元素 saveBatch是批量新增 saveOrUpdate是根据id判断，如果数据存在就更新，不存在则新增 saveOrUpdateBatch是批量的新增或修改  删除:\n removeById：根据id删除 removeByIds：根据id批量删除 removeByMap：根据Map中的键值对为条件删除 remove(Wrapper\u0026lt;T\u0026gt;)：根据Wrapper条件删除 ~~removeBatchByIds~~：暂不支持  修改:\n updateById：根据id修改 update(Wrapper\u0026lt;T\u0026gt;)：根据UpdateWrapper修改，Wrapper中包含set和where部分 update(T，Wrapper\u0026lt;T\u0026gt;)：按照T内的数据修改与Wrapper匹配到的数据 updateBatchById：根据id批量修改  查询一条Get:\n getById：根据id查询1条数据 getOne(Wrapper\u0026lt;T\u0026gt;)：根据Wrapper查询1条数据 getBaseMapper：获取Service内的BaseMapper实现，某些时候需要直接调用Mapper内的自定义SQL时可以用这个方法获取到Mapper  查询多条List:\n listByIds：根据id批量查询 list(Wrapper\u0026lt;T\u0026gt;)：根据Wrapper条件查询多条数据 list()：查询所有  计数Count:\n count()：统计所有数量 count(Wrapper\u0026lt;T\u0026gt;)：统计符合Wrapper条件的数据数量  getBaseMapper：\n当我们在service中要调用Mapper中自定义SQL时，就必须获取service对应的Mapper，就可以通过这个方法\n基本用法 ①由于Service中经常需要定义与业务有关的自定义方法，因此我们不能直接使用IService，而是自定义Service接口，然后继承IService以拓展方法。同时，让自定义的Service实现类继承ServiceImpl，这样就不用自己实现IService中的接口了。\n1.首先，定义IUserService，继承IService：\n1package com.itheima.mp.service; 2 3public interface IUserService extends IService\u0026lt;User\u0026gt; { 4 // 拓展自定义方法 5} 2.然后，编写UserServiceImpl类，继承ServiceImpl，实现UserService：\n1package com.itheima.mp.service.impl; 2 3@Service 4public class UserServiceImpl extends ServiceImpl\u0026lt;UserMapper, User\u0026gt; 5 implements IUserService { 6} ②快速实现下面4个接口：\n   编号 接口 请求方式 请求路径 请求参数 返回值     1 新增用户 POST /users 用户表单实体 无   2 删除用户 DELETE /users/{id} 用户id 无   3 根据id查询用户 GET /users/{id} 用户id 用户VO   4 根据id批量查询 GET /users 用户id集合 用户VO集合    1@Api(tags = \u0026#34;用户管理接口\u0026#34;) 2@RequestMapping(\u0026#34;/users\u0026#34;) 3@RestController 4@RequiredArgsConstructor 5public class UserController { 6 7// 这里spring不推荐自动注入, 我们用构造函数代替, 将字段设置为final然后再类上加注解@RequiredArgsConstructor就可以自动生成了 8// @Autowired 9// private IUserService userService; 10 private final IUserService userService; 11 12// 对于简单的逻辑, 直接调用原生的service方法就行了, 对于复杂的业务逻辑需要自定义service, 对于复杂的sql需要自定义mapper并调用 13 @ApiOperation(\u0026#34;新增用户接口\u0026#34;) 14 @PostMapping 15 public void saveUser(@RequestBody UserFormDTO userDTO){ 16// 1. 利用hutu工具中的BeanUtil将DTO拷贝到PO 17 User user = BeanUtil.copyProperties(userDTO, User.class); 18// 2.新增 19 userService.save(user); 20 } 21 22 @ApiOperation(\u0026#34;删除用户接口\u0026#34;) 23 @DeleteMapping(\u0026#34;{id}\u0026#34;) 24 public void deleteUserById(@ApiParam(\u0026#34;用户id\u0026#34;) @PathVariable(\u0026#34;id\u0026#34;) Long id){ 25 userService.removeById(id); 26 } 27 28 @ApiOperation(\u0026#34;根据id查询用户接口\u0026#34;) 29 @GetMapping(\u0026#34;{id}\u0026#34;) 30 public UserVO queryUserById(@ApiParam(\u0026#34;用户id\u0026#34;) @PathVariable(\u0026#34;id\u0026#34;) Long id){ 31// User user = userService.getById(id); 32//// 将po拷贝到vo 33// return BeanUtil.copyProperties(user, UserVO.class); 34 return userService.queryUserAndAddressById(id); 35 } 36 37 @ApiOperation(\u0026#34;根据ids批量查询用户接口\u0026#34;) 38 @GetMapping 39 public List\u0026lt;UserVO\u0026gt; queryUserByIds(@ApiParam(\u0026#34;用户id集合\u0026#34;) @RequestParam(\u0026#34;ids\u0026#34;) List\u0026lt;Long\u0026gt; ids){ 40// List\u0026lt;User\u0026gt; user = userService.listByIds(ids); 41//// 将po拷贝到vo 42// return BeanUtil.copyToList(user, UserVO.class); 43 return userService.queryUserAndAddressByIds(ids); 44 } 45} ③不过，一些带有业务逻辑的接口则需要在service中自定义实现了。例如下面的需求：\n 根据id扣减用户余额  这看起来是个简单修改功能，只要修改用户余额即可。但这个业务包含一些业务逻辑处理：\n 判断用户状态是否正常 判断用户余额是否充足  这些业务逻辑都要在service层来做，另外更新余额需要自定义SQL，要在mapper中来实现。因此，我们除了要编写controller以外，具体的业务还要在service和mapper中编写。\n首先在UserController中定义一个方法：\n1@ApiOperation(\u0026#34;根据id扣减用户余额\u0026#34;) 2@PutMapping(\u0026#34;/{id}/document/{money}\u0026#34;) 3public void deductMoneyById( 4 @ApiParam(\u0026#34;用户id\u0026#34;) @PathVariable(\u0026#34;id\u0026#34;) Long id, 5 @ApiParam(\u0026#34;扣减的金额\u0026#34;) @PathVariable(\u0026#34;money\u0026#34;) Integer money){ 6 userService.deductBalance(id, money); 7} 然后是UserService接口：\n1public interface IUserService extends IService\u0026lt;User\u0026gt; { 2 void deductBalance(Long id, Integer money); 3} 最后是UserServiceImpl实现类：\n1//我们的service接口继承IService, 然后我们service接口实现类继承IService接口的实现类ServiceImpl, 这样就不需要一一实现就可以用了 2@Service 3public class IUserServiceImpl extends ServiceImpl\u0026lt;UserMapper, User\u0026gt; implements IUserService { 4 5 @Override 6 public void deductBalance(Long id, Integer money) { 7 //1.查询用户 8 //调用的方法, 自己就是service不需要注入额外的service. 9// User user = this.getById(id); 10 User user = getById(id); 11 //2.校验用户状态 12 //反向校验保证不会出现if嵌套 13 if(user == null || user.getStatus() == UserStatus.FROZEN){ 14 throw new RuntimeException(\u0026#34;用户状态异常\u0026#34;); 15 } 16 //3.校验余额是否充足 17 if(user.getBalance() \u0026lt; money){ 18 throw new RuntimeException(\u0026#34;用户余额不足\u0026#34;); 19 } 20 //4.扣减余额 update user set balance = balance - money where id = id; 21 //service不写sql, 去mapper中写. 22 //如果要使用mapper在父类serviceimpl中已经注入base mapper了可以直接用 23 baseMapper.deductBalance(id, money); 24 } 25} 最后是mapper：\n1public interface UserMapper extends BaseMapper\u0026lt;User\u0026gt; { 2 @Update(\u0026#34;update user set balance = balance - #{money} where id = #{id}\u0026#34;) 3 void deductBalance(@Param(\u0026#34;id\u0026#34;) Long id, @Param(\u0026#34;money\u0026#34;) Integer money); 4} Lambda(结合服务层与wrapper) IService中还提供了Lambda功能来简化我们的复杂查询及更新功能。\n案例一：实现一个根据复杂条件查询用户的接口，查询条件如下：\n name：用户名关键字，可以为空 status：用户状态，可以为空 minBalance：最小余额，可以为空 maxBalance：最大余额，可以为空  在UserController中定义一个controller方法：\n1@GetMapping(\u0026#34;/list\u0026#34;) 2@ApiOperation(\u0026#34;根据id集合查询用户\u0026#34;) 3public List\u0026lt;UserVO\u0026gt; queryUsers(UserQuery query){ 4 // 1.组织条件 5 String username = query.getName(); 6 Integer status = query.getStatus(); 7 Integer minBalance = query.getMinBalance(); 8 Integer maxBalance = query.getMaxBalance(); 9 LambdaQueryWrapper\u0026lt;User\u0026gt; wrapper = new QueryWrapper\u0026lt;User\u0026gt;().lambda() 10 .like(username != null, User::getUsername, username) 11 .eq(status != null, User::getStatus, status) 12 .ge(minBalance != null, User::getBalance, minBalance) 13 .le(maxBalance != null, User::getBalance, maxBalance); 14 // 2.查询用户 15 List\u0026lt;User\u0026gt; users = userService.list(wrapper); 16 // 3.处理vo 17 return BeanUtil.copyToList(users, UserVO.class); 18} 在组织查询条件的时候，我们加入了 username != null 这样的参数，意思就是当条件成立时才会添加这个查询条件，类似Mybatis的mapper.xml文件中的\u0026lt;if\u0026gt;标签。这样就实现了动态查询条件效果了。\n不过，上述条件构建的代码太麻烦了。 因此Service中对LambdaQueryWrapper和LambdaUpdateWrapper的用法进一步做了简化。我们无需自己通过new的方式来创建Wrapper，而是直接调用lambdaQuery和lambdaUpdate方法：\n基于Lambda查询：\n1@ApiOperation(\u0026#34;根据复杂条件批量查询用户接口\u0026#34;) 2 @GetMapping(\u0026#34;/list\u0026#34;) 3 public List\u0026lt;UserVO\u0026gt; queryUsers(UserQuery query){ 4 List\u0026lt;User\u0026gt; user = userService.queryUsers( 5 query.getName(), query.getStatus(), query.getMinBalance(), query.getMaxBalance()); 6// 将po拷贝到vo 7 return BeanUtil.copyToList(user, UserVO.class); 8 } 1//查询用户姓名, 状态, 存款余额介于最大和最小之间的用户 2 @Override 3 public List\u0026lt;User\u0026gt; queryUsers(String name, Integer status, Integer minBalance, Integer maxBalance) { 4 //IService的lambda查询, 这个查询条件替代mapper中的复杂的语句, 当条件满足时才去添加对应的sql语句 5 //lambdaQuery,直接将wrapper和查询一步到位.不需要单独new wrapper. 6 return lambdaQuery() 7 .like(name != null, User::getUsername, name) 8 .eq(status != null, User::getStatus, status) 9 .ge(minBalance != null, User::getBalance, minBalance) 10 .le(maxBalance != null, User::getBalance, maxBalance) 11 .list(); // 相应返回一个就写one(),分页写page(),数目写count(),列表写list() 12 } IService中的lambdaUpdate方法可以非常方便的实现复杂更新业务。\n案例二:\n改造根据id修改用户余额的接口，要求如下\n 如果扣减后余额为0，则将用户status修改为冻结状态（2）  也就是说我们在扣减用户余额时，需要对用户剩余余额做出判断，如果发现剩余余额为0，则应该将status修改为2，这就是说update语句的set部分是动态的。\n1//修改用户余额接口, 要求对用户状态校验, 用户余额校验, 如果扣减口为0了则修改状态为冻结状态(2) 2 @Override 3 @Transactional 4 public void deductBalance(Long id, Integer money) { 5 //1.查询用户 6 //调用的方法, 自己就是service不需要注入额外的service. 7// User user = this.getById(id); 8 User user = getById(id); 9 //2.校验用户状态 10 //反向校验保证不会出现if嵌套 11 if(user == null || user.getStatus() == UserStatus.FROZEN){ 12 throw new RuntimeException(\u0026#34;用户状态异常\u0026#34;); 13 } 14 //3.校验余额是否充足 15 if(user.getBalance() \u0026lt; money){ 16 throw new RuntimeException(\u0026#34;用户余额不足\u0026#34;); 17 } 18 //4.扣减余额 update user set balance = balance - money where id = id; 19 //service不写sql, 去mapper中写. 20 //如果要使用mapper在父类serviceimpl中已经注入base mapper了可以直接用 21 //baseMapper.deductBalance(id, money); 22 int remainBalance = user.getBalance() - money; 23 lambdaUpdate() 24 .set(User::getBalance, remainBalance) 25 .set(remainBalance == 0, User::getStatus, UserStatus.FROZEN) 26 .eq(User::getId, id) 27 // 构建条件 28 .eq(User::getBalance, user.getBalance()) //乐观锁. 有并发安全风险, 当最后查到的余额等于用户的余额才update 29 .update(); // 最后执行update 30 } 优化批量新增(批处理功能) 测试逐条插入数据和MybatisPlus的批处理(saveBatch):\n1//普通的for循环添加10万条数据 2//相对于10万次网络请求, 很慢 3@Test 4void testSaveOneByOne(){ 5 long b = System.currentTimeMillis(); 6 for (int i = 0; i \u0026lt; 100000; i++) { 7 userService.save(buildUser(i)); 8 } 9 long e = System.currentTimeMillis(); 10 System.out.println(\u0026#34;cost time: \u0026#34; + (e-b)); 11} 12//使用IService添加10万数据 13//预编译成1000条sql语句, 一次性提交1000条, 相对于100次网络请求 14//但是1000条sql还是慢了,想办法变成一条sql, 只需要添加一条mysql配置,让引擎来完成:rewriteBatchedStatements=true 15//拼接到yaml配置jdbcurl后面. 16@Test 17void testSaveBatch(){ 18 //每次批量插入1000条 19 ArrayList\u0026lt;User\u0026gt; users = new ArrayList\u0026lt;\u0026gt;(1000); 20 long b = System.currentTimeMillis(); 21 for (int i = 0; i \u0026lt; 100000; i++) { 22 users.add(buildUser(i)); 23 if(i%1000 == 0){ 24 userService.saveBatch(users); 25 users.clear(); 26 } 27 } 28} 可以看到使用了批处理以后，比逐条新增效率提高了10倍左右，性能还是不错的。\nMybatisPlus的批处理是基于PrepareStatement的预编译模式，然后批量提交，最终在数据库执行时还是会有多条insert语句，逐条插入数据。如果想要得到最佳性能，最好是将多条SQL合并为一条:\n1Preparing: INSERT INTO user ( username, password, phone, info, balance, create_time, update_time ) VALUES ( ?, ?, ?, ?, ?, ?, ? ) 2Parameters: user_1, 123, 18688190001, \u0026#34;\u0026#34;, 2000, 2023-07-01, 2023-07-01 3Parameters: user_2, 123, 18688190002, \u0026#34;\u0026#34;, 2000, 2023-07-01, 2023-07-01 4Parameters: user_3, 123, 18688190003, \u0026#34;\u0026#34;, 2000, 2023-07-01, 2023-07-01 5 6 7INSERT INTO user ( username, password, phone, info, balance, create_time, update_time ) 8VALUES 9(user_1, 123, 18688190001, \u0026#34;\u0026#34;, 2000, 2023-07-01, 2023-07-01), 10(user_2, 123, 18688190002, \u0026#34;\u0026#34;, 2000, 2023-07-01, 2023-07-01), 11(user_3, 123, 18688190003, \u0026#34;\u0026#34;, 2000, 2023-07-01, 2023-07-01), 12(user_4, 123, 18688190004, \u0026#34;\u0026#34;, 2000, 2023-07-01, 2023-07-01); MySQL的客户端连接参数中有这样的一个参数：rewriteBatchedStatements。顾名思义，就是重写批处理的statement语句。\n这个参数的默认值是false，我们需要修改连接参数，将其配置为true\n修改项目中的application.yml文件，在jdbc的url后面添加参数\u0026amp;rewriteBatchedStatements=true:\n1spring:2datasource:3url:jdbc:mysql://127.0.0.1:3306/mp?useUnicode=true\u0026amp;characterEncoding=UTF-8\u0026amp;autoReconnect=true\u0026amp;serverTimezone=Asia/Shanghai\u0026amp;rewriteBatchedStatements=true4driver-class-name:com.mysql.cj.jdbc.Driver5username:root6password:MySQL123再次测试插入10万条数据，可以发现速度有非常明显的提升.\n在ClientPreparedStatement的executeBatchInternal中，有判断rewriteBatchedStatements值是否为true并重写SQL的功能\n扩展功能 代码生成(解决重复性工作) 在使用MybatisPlus以后，基础的Mapper、Service、PO代码相对固定，重复编写也比较麻烦。因此MybatisPlus官方提供了代码生成器根据数据库表结构生成PO、Mapper、Service等相关代码。只不过代码生成器同样要编码使用，也很麻烦。\n在Idea的plugins市场中搜索并安装MyBatisPlus插件, 然后重启你的Idea即可使用。\n刚好数据库中还有一张address表尚未生成对应的实体和mapper等基础代码。我们利用插件生成一下。 首先需要配置数据库地址，在Idea顶部菜单中，找到other，选择Config Database, 在弹出的窗口中填写数据库连接的基本信息\n点击OK保存。然后再次点击Idea顶部菜单中的other，然后选择Code Generator\n在弹出的表单中填写信息：\n\r最终，代码自动生成到指定的位置了\n静态工具(预防循环依赖) 有的时候Service之间也会相互调用，为了避免出现循环依赖问题，MybatisPlus提供一个静态工具类：Db，其中的一些静态方法与IService中方法签名基本一致，也可以帮助我们实现CRUD功能.\n需求：改造根据id用户查询的接口，查询用户的同时返回用户收货地址列表\n1//根据用户id查询用户,还要查询address表上对应用户的地址列表 2@Override 3public UserVO queryUserAndAddressById(Long id) { 4 //1.查询用户 5 User user = getById(id); 6 if(user == null || user.getStatus() == UserStatus.FROZEN){ 7 throw new RuntimeException(\u0026#34;用户状态异常\u0026#34;); 8 } 9 //2.查询地址 10 //使用静态方法查询. 因为如果userService注入addressService,之后addressService也会因为需求注入userService,会出现循环依赖 11 //为了解决循环依赖, 使用静态方法Db完成需求 12 List\u0026lt;Address\u0026gt; addresses = Db.lambdaQuery(Address.class) //添加需要查询类的字节码 13 .eq(Address::getUserId, id).list();//多个地址用list()返回多个. 14 //3.封装po成vo 15 //3.1先将user po装维vo 16 UserVO userVO = BeanUtil.copyProperties(user, UserVO.class); 17 //3.2转地址vo 18 if(CollUtil.isNotEmpty(addresses)){ 19 userVO.setAddresses(BeanUtil.copyToList(addresses, AddressVO.class)); 20 } 21 return userVO; 22} 在查询地址时，我们采用了Db的静态方法，因此避免了注入AddressService，减少了循环依赖的风险。\n逻辑删除 对于一些比较重要的数据，我们往往会采用逻辑删除的方案，即：\n 在表中添加一个字段标记数据是否被删除 当删除数据时把标记置为true 查询时过滤掉标记为true的数据  一旦采用了逻辑删除，所有的查询和删除逻辑都要跟着变化，非常麻烦。\n为了解决这个问题，MybatisPlus就添加了对逻辑删除的支持。\n注意，只有MybatisPlus生成的SQL语句才支持自动的逻辑删除，自定义SQL需要自己手动处理逻辑删除。\n配置逻辑删除字段：\n1mybatis-plus:2global-config:3db-config:4logic-delete-field:deleted#全局逻辑删除的实体的字段名,字段类型可以是boolean,integer.指定数据表里有的字段5logic-delete-value:1#逻辑已删除值(默认1)6logic-not-delete-value:0#逻辑未删除值(默认0)测试： 我们执行一个删除操作：\n1@Test 2void testDeleteByLogic() { 3 // 删除方法与以前没有区别 4 addressService.removeById(59L); 5} 方法与普通删除一模一样，但是底层的SQL逻辑变为update. 查询也会附加where条件.\n通用枚举 User类中有一个用户状态字段, 像这种字段我们一般会定义一个枚举，做业务判断的时候就可以直接基于枚举做比较。但是我们数据库采用的是int类型，对应的PO也是Integer。因此业务操作时必须手动把枚举与Integer转换，非常麻烦。\n因此，MybatisPlus提供了一个处理枚举的类型转换器，可以帮我们把枚举类型与数据库类型自动转换。\n定义枚举 1package com.itheima.mp.enums; 2 3import com.baomidou.mybatisplus.annotation.EnumValue; 4import lombok.Getter; 5 6@Getter 7public enum UserStatus { 8 NORMAL(1, \u0026#34;正常\u0026#34;), 9 FREEZE(2, \u0026#34;冻结\u0026#34;) 10 ; 11 private final int value; 12 private final String desc; 13 14 UserStatus(int value, String desc) { 15 this.value = value; 16 this.desc = desc; 17 } 18} 然后把User类中的status字段从Integer改为UserStatus 类型.\n要让MybatisPlus处理枚举与数据库类型自动转换，我们必须告诉MybatisPlus，枚举中的哪个字段的值作为数据库值。 MybatisPlus提供了@EnumValue注解来标记枚举属性\n1@Getter //getter注解加get方法 2public enum UserStatus { 3 NORMAL(1,\u0026#34;正常\u0026#34;), 4 FROZEN(2,\u0026#34;冻结\u0026#34;), 5 ; 6 @EnumValue //enumValue注解,标明枚举类型中与数据表对应的字段的属性. 这样对于Po的枚举类型变量和数据表字段就可以转化了. 7 private final int value; 8 //前端返回是SpringMVC中Jackson处理的 9 @JsonValue //这个注解是用作前端返回的,. 于是返回的是正常或冻结.这样前端返回这个字段的时候就会返回对应的desc信息 10 private final String desc; 11 12 UserStatus(int value, String desc) { 13 this.value = value; 14 this.desc = desc; 15 } 16} 配置枚举处理器 在application.yaml文件中添加配置：\n1mybatis-plus:2configuration:3default-enum-type-handler:com.baomidou.mybatisplus.core.handlers.MybatisEnumTypeHandler定义枚举的展示字段 为了使页面查询结果也是枚举格式，我们需要修改UserVO中的status属性为UserStatus\n并且，在UserStatus枚举中通过@JsonValue注解标记JSON序列化时展示的字段.\nJSON类型处理器(实体类与数据库字符串的转化) MybatisPlus提供了很多特殊类型字段的类型处理器，解决特殊字段类型与数据库类型转换的问题。例如处理JSON就可以使用JacksonTypeHandler处理器。\n创建实体 1@Data 2@NoArgsConstructor //无参构造 3@AllArgsConstructor(staticName = \u0026#34;of\u0026#34;) //有参构造, 提供静态方法of,这样可以类名+静态方法名构造类. 4public class UserInfo { 5 private Integer age; 6 private String intro; 7 private String gender; 8} 使用类型处理器 就是在需要的字段上面添加注解@TableField并制定类型处理器.\n1@TableField(typeHandler = JacksonTypeHandler.class) //自定义类型处理器, 在需要的字段添加. 这样就可以实现json数据和类的转化 2private UserInfo info; 这样, 传过来的字符串会被正确处理为对象.\n插件功能 MybatisPlus提供了很多的插件功能，进一步拓展其功能。目前已有的插件有：\n PaginationInnerInterceptor：自动分页 TenantLineInnerInterceptor：多租户 DynamicTableNameInnerInterceptor：动态表名 OptimisticLockerInnerInterceptor：乐观锁 IllegalSQLInnerInterceptor：sql 性能规范 BlockAttackInnerInterceptor：防止全表更新与删除  注意： 使用多个分页插件的时候需要注意插件定义顺序，建议使用顺序如下：\n 多租户,动态表名 分页,乐观锁 sql 性能规范,防止全表更新与删除  分页插件 在未引入分页插件的情况下，MybatisPlus是不支持分页功能的，IService和BaseMapper中的分页方法都无法正常起效。 所以，我们必须配置分页插件。\n配置分页插件 新建一个配置类\n1@Configuration 2public class MyBatisConfig { 3 4 @Bean 5 public MybatisPlusInterceptor mybatisPlusInterceptor(){ 6 MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); 7 //1.创建分页插件 8 PaginationInnerInterceptor paginationInnerInterceptor = new PaginationInnerInterceptor(DbType.MYSQL); 9 //1.1配置最大查询数目 10 paginationInnerInterceptor.setMaxLimit(1000L); 11 //2.添加插件 12 interceptor.addInnerInterceptor(paginationInnerInterceptor); 13 return interceptor; 14 } 15} 使用分页API 1//分页查询测试 2 @Test 3 void testPageQuery(){ 4 int pageNo = 1, pageSize=2; //从1开始, 每次查2条 5 //1.准备分页条件 6 //1.1分页条件 7 Page\u0026lt;User\u0026gt; page = Page.of(pageNo, pageSize); 8 //1.2排序条件 9 page.addOrder(new OrderItem(\u0026#34;balance\u0026#34;, true)); 10 page.addOrder(new OrderItem(\u0026#34;id\u0026#34;, true)); 11 //2.查询 12 Page\u0026lt;User\u0026gt; p = userService.page(page); 13 //3.解析结果 14 long total = p.getTotal();//总条数 15 System.out.println(\u0026#34;total: \u0026#34; + total); 16 long pages = p.getPages();//总页数 17 System.out.println(\u0026#34;pages: \u0026#34; + pages); 18 List\u0026lt;User\u0026gt; records = p.getRecords(); //记录 19 records.forEach(System.out::println); 20 21 22 } 通用分页实体 实体 分页条件不仅仅用户分页查询需要，以后其它业务也都有分页查询的需求。因此建议将分页查询条件单独定义为一个PageQuery实体, 让我们的UserQuery继承这个实体, 这样其他业务需要分页查询只需要继承PageQuery实体, 然后新增自己需要的字段.\nPageQuery:\n1@Data 2@ApiModel(description = \u0026#34;分页查询实体\u0026#34;) 3public class PageQuery { 4 @ApiModelProperty(\u0026#34;页码\u0026#34;) 5 private Integer pageNo = 1; 6 7 @ApiModelProperty(\u0026#34;页码\u0026#34;) 8 private Integer pageSize = 5; 9 10 @ApiModelProperty(\u0026#34;排序字段\u0026#34;) 11 private String sortBy ; 12 13 @ApiModelProperty(\u0026#34;是否升序\u0026#34;) 14 private Boolean isAsc = true; 15 16 //封装service层的构建分页查询条件的代码.前面这个\u0026lt;T\u0026gt;是定义的,因为用不了对象的泛型 17 public \u0026lt;T\u0026gt; Page\u0026lt;T\u0026gt; toMpPage(OrderItem ... items){ 18 //1.分页条件 19 Page\u0026lt;T\u0026gt; page = Page.of(pageNo, pageSize) ; 20 //1.排序条件 21 if(StrUtil.isNotBlank(sortBy)){ 22 //用户给出了需要排序的字段 23 page.addOrder(new OrderItem(sortBy, isAsc)); 24 }else if(items != null){ 25 //没有给出, 则默认按更新时间排序 26 page.addOrder(items) ; 27 } 28 return page; 29 } 30 31 //再补充一个默认的方法,直接就用create_time默认排序 32 public \u0026lt;T\u0026gt; Page\u0026lt;T\u0026gt; toMpPageDefaultSortByCreate(){ 33 return toMpPage(new OrderItem(\u0026#34;create_time\u0026#34;, isAsc)); 34 } 35 36 //再补充一个默认的方法,直接就用update_time默认排序 37 public \u0026lt;T\u0026gt; Page\u0026lt;T\u0026gt; toMpPageDefaultSortByUpdate(){ 38 return toMpPage(new OrderItem(\u0026#34;update_time\u0026#34;, isAsc)); 39 } 40 41 //直接只需要传递排序字段和升序降序. 42 public \u0026lt;T\u0026gt; Page\u0026lt;T\u0026gt; toMpPage(String defaultSortBy, Boolean defaultAsc){ 43 return toMpPage(new OrderItem(defaultSortBy, defaultAsc)); 44 } 45} UserQuery:\n1//@EqualsAndHashCode 注解用于自动生成 equals 和 hashCode 方法。 2@EqualsAndHashCode(callSuper = true) 3@Data 4@ApiModel(description = \u0026#34;用户查询条件实体\u0026#34;) 5public class UserQuery extends PageQuery{ 6 @ApiModelProperty(\u0026#34;用户名关键字\u0026#34;) 7 private String name; 8 @ApiModelProperty(\u0026#34;用户状态：1-正常，2-冻结\u0026#34;) 9 private Integer status; 10 @ApiModelProperty(\u0026#34;余额最小值\u0026#34;) 11 private Integer minBalance; 12 @ApiModelProperty(\u0026#34;余额最大值\u0026#34;) 13 private Integer maxBalance; 14} 分页实体PageDTO, 用来装返回的结果:\n1@Data 2@ApiModel(description = \u0026#34;分页结果\u0026#34;) 3public class PageDTO\u0026lt;T\u0026gt; { 4 @ApiModelProperty(\u0026#34;总条数\u0026#34;) 5 private Long total; 6 @ApiModelProperty(\u0026#34;总页数\u0026#34;) 7 private Long pages; 8 @ApiModelProperty(\u0026#34;集合\u0026#34;) 9 private List\u0026lt;T\u0026gt; list; 10 11 //构建自己,使用static直接调用 12 //类的泛型只能对象用, 需要定义泛型 13 //这个方法使用的前提是转化的对象字段名一样, 可以少但是要一样,因为它使用了BeanUtil.copyToList. 14 //不一样只能自己完成PO到VO的转化, 于是提供一个函数式接口Function\u0026lt;PO,VO\u0026gt; convertor, 前一个是接受参数,后一个是返回参数 15 public static \u0026lt;PO,VO\u0026gt; PageDTO\u0026lt;VO\u0026gt; of(Page\u0026lt;PO\u0026gt; p, Function\u0026lt;PO,VO\u0026gt; convertor){ 16 PageDTO\u0026lt;VO\u0026gt; dto = new PageDTO\u0026lt;\u0026gt;(); 17 //3.1总条数 18 dto.setTotal(p.getTotal()); 19 //3.2总页数 20 dto.setPages(p.getPages()); 21 //3.3当前数据 22 List\u0026lt;PO\u0026gt; records = p.getRecords(); 23 if(CollUtil.isEmpty(records)){ 24 //空的就放空列表 25 dto.setList(Collections.emptyList()); 26 return dto; 27 } 28 //3.4拷贝User的VO 29// dto.setList(BeanUtil.copyToList(records, clazz)); //参数列表加Class\u0026lt;VO\u0026gt; clazz 30 dto.setList(records.stream().map(convertor).collect(Collectors.toList())); 31 //4.返回 32 return dto; 33 } 34} 开发接口 Controller:\n1@ApiOperation(\u0026#34;根据条件分页批量查询用户接口\u0026#34;) 2 @GetMapping(\u0026#34;/page\u0026#34;) 3 public PageDTO\u0026lt;UserVO\u0026gt; queryUsersPages(UserQuery query){ 4 return userService.queryUsersPage(query); 5 } service:\n1//分页查询复杂条件的用户.定义了多个实体: PageDTO返回的, PageQuery查询实体,UserQuery继承了PageQuery.这样不管是什么分页查询很多代码可以复用 2 @Override 3 public PageDTO\u0026lt;UserVO\u0026gt; queryUsersPage(UserQuery query) { 4 String name = query.getName(); 5 Integer status = query.getStatus(); 6 //1.构建查询条件 7 Page\u0026lt;User\u0026gt; page = query.toMpPageDefaultSortByUpdate(); 8// //下面的代码封装到PageQuery里(将和业务关系不大的代码封装) 9// //1.1分页条件 10// Page\u0026lt;User\u0026gt; page = Page.of(query.getPageNo(), query.getPageSize()) ; 11// //1.2排序条件 12// if(StrUtil.isNotBlank(query.getSortBy())){ 13// //用户给出了需要排序的字段 14// page.addOrder(new OrderItem(query.getSortBy(), query.getIsAsc())); 15// }else { 16// //没有给出, 则默认按更新时间排序 17// page.addOrder(new OrderItem(\u0026#34;update_time\u0026#34;, query.getIsAsc())); 18// } 19 20 //2.分页查询 21 Page\u0026lt;User\u0026gt; p = lambdaQuery() 22 .like(name != null, User::getUsername, name) 23 .eq(status != null, User::getStatus, status) 24 .page(page); 25 26 //3.封装VO结果 27// return PageDTO.of(p, user -\u0026gt; BeanUtil.copyProperties(user, UserVO.class)); 28 return PageDTO.of(p, user -\u0026gt; { 29 //对于PO和VO字段不一致的情况作处理 30 //1.拷贝基础属性 31 UserVO vo = BeanUtil.copyProperties(user, UserVO.class); 32 //2.处理特殊逻辑 33 vo.setUsername(vo.getUsername().substring(0,vo.getUsername().length()-2) + \u0026#34;**\u0026#34;); //隐藏用户名后两位 34 return vo; 35 }); 36// 封装将po转vo的代码到PageDTO并抽象能够通用. 37// PageDTO\u0026lt;UserVO\u0026gt; dto = new PageDTO\u0026lt;\u0026gt;(); 38// //3.1总条数 39// dto.setTotal(p.getTotal()); 40// //3.2总页数 41// dto.setPages(p.getPages()); 42// //3.3当前数据 43// List\u0026lt;User\u0026gt; records = p.getRecords(); 44// if(CollUtil.isEmpty(records)){ 45// //空的就放空列表 46// dto.setList(Collections.emptyList()); 47// return dto; 48// } 49// //3.4拷贝User的VO 50// dto.setList(BeanUtil.copyToList(records, UserVO.class)); 51// //4.返回 52// return dto; 53 } Docker 常见命令 文档: docs.docker.com\n1docker pull #从镜像仓库将镜像拉取到本地仓库,名字后面跟版本号, 不跟就是latest. 2docker puth #将本地仓库的镜像上传到镜像仓库/私服 3docker images #查看镜像 4docker rmi #删除镜像(remove image) 5docker build #构建镜像 6docker save #保存镜像到文件 7docker load #加载文件中的镜像 8docker run #根据镜像开启容器 9docker inspect #查看容器详情 10docker stop #停止容器 11docker start #启动容器 12docker ps #查看现存容器(process status) 13docker rm #删除容器 14docker logs #查看日志 15docker exec #进入容器环境执行命令 案例:\n1docker pull nginx #拉取nginx镜像 2docker images #查看镜像 3docker save -o nginx.tar nginx:latest 4docker rmi nginx:latest 5docker load -i nginx.tar 6docker run -d --name nginx -p 80:80 nginx #-d后台,-p端口映射前面是本机后面是容器,最后跟上镜像名 7docker stop nginx 8docker start nginx 9docker logs -f nginx #-f持续输出日志 10docker exec -it nginx bash #-it可交互终端  11exit 12docker exec -it mysql mysql -uroot -p 13docker rm nginx -f #-f强制删除,不然需要先stop再删除. 14 数据卷挂载 直接进入容器内修改是不可能的, 没有很多命令.于是产生了需求.\n数据卷(volume)是虚拟目录, 映射容器目录和主机目录. 创建数据卷, 那么docker会在/var/lib/docker/volumes下创建文件.这样容器内的文件通过数据卷和主机的文件绑定起来了, docker进行双向绑定.\n1docker volume create #创建数据卷 2docker volume ls #查看所有数据卷 3docker volume rm #删除指定数据卷 4docker volume inspect #查看某个数据卷详情 5docker volume prune #清除所有未使用的数据卷 案例1: 修改nginx的文件, 将静态资源部署到nginx的html目录\n 执行docker run命令时, 使用-v 数据卷:容器内目录 可以完成数据卷挂载\n 1docker run -d --name nginx -p 80:80 -v html:/usr/share/nginx/html nginx 2docker volume ls 3docker volume inspect html 4cd /var/lib/docker/volumes/html/_data 5ll 6#修改html文件,可以成功修改容器内文件. 7#上传静态文件, 容器内也有了这个文件 本地目录挂载 案例2: 查看mysql容器, 看看是否有数据卷挂载(是,匿名卷); 基于宿主机目录实现mysql数据目录,配置文件,初始化脚本的挂载\n 挂载/root/mysql/data 到容器内的/var/lib/mysql 挂载/root/mysql/init到容器内的/docker-entrypoint-initdb.d目录.携带课前准备的sql脚本 挂载/root/mysql/conf到容器内的/etc/mysql/conf.d目录,携带课前准备的配置文件.   执行docker run命令时, 使用 -v 本地目录:容器内目录 可以完成本地目录挂载\n本地目录必须以/ or ./开头. 这是为了区分数据卷\n 1docker run -d\\ 2 --name mysql \\ 3 -p 3306:3306 \\ 4 -e TZ=Asia/Shanghai \\ 5 -v /root/mysql/data:/var/lib/mysql 6 -v /root/mysql/init:/docker-entrypoint-initdb.d 7 -v /root/mysql/conf:/etc/mysql/conf.d 8 mysql 即便删掉了容器, 数据依然存在, 实现了数据的持久保存, 下次创建容器时只需要直接指定挂载便实现了数据迁移. 而默认的匿名卷模式目录太深, 容器删除后数据卷在那里, 但是重新创建后又会生成新的匿名卷, 迁移还需要手动转移.\n自定义镜像Dockerfile 参考资料\n网络 默认情况下, 所有容器都是以bridge方式连接到Docker的一个虚拟网桥上. 但是这样Ip地址可能会变动\n加入自定义网络才可以通过容器名互相访问, Docker的网络操作命令如下:\n   命令 说明     docker network create 创建一个网络   docker network ls 查看所有网络   docker network rm 删除指定网络   docker network prune 清除未使用的网络   docker network connect 使指定容器连接加入某网络   docker network disconnect 使指定容器连接离开某网络   docker network inspect 查看网络详细信息    1docker network create heima 2docker network connect heima mysql 3docker network connect heima dd 4docker run -d --name mysql -p 3306:3306 --network heima mysql #创建时加入网络 5docker exec -it dd bash 6ping mysql #可以直接用容器名ping 部署项目 部署Java应用 1docker build -t hmall . 2docker images 3docker run -d --name hm -p 80:80 --network heima hmall 4docker ps 5docker logs -f hm 部署前端 创建额nginx容器, 将提供的nginx.conf, html目录和容器挂载\n1docker run -d \\ 2\t--name nginx \\ 3\t-p 18080:18080 \\ 4\t-p 18081:18081 \\ 5\t-v /root/nginx/html:/usr/share/nginx/html \\ 6\t-v /root/nginx/nginx.conf:/etc/ngnix.conf \\ 7\t--network heima 8\tnginx DockerCompose Docker Compose通过一个单独的docker-compose.yml 模板文件（YAML 格式）来定义一组相关联的应用容器，帮助我们实现多个相互关联的Docker容器的快速部署。\n1version:\u0026#34;3.8\u0026#34;23services:4mysql:5image:mysql6container_name:mysql7ports:8- \u0026#34;3306:3306\u0026#34;9environment:10TZ:Asia/Shanghai11MYSQL_ROOT_PASSWORD:12312volumes:13- \u0026#34;./mysql/conf:/etc/mysql/conf.d\u0026#34;14- \u0026#34;./mysql/data:/var/lib/mysql\u0026#34;15- \u0026#34;./mysql/init:/docker-entrypoint-initdb.d\u0026#34;16networks:17- hm-net18hmall:19build:20context:.21dockerfile:Dockerfile22container_name:hmall23ports:24- \u0026#34;8080:8080\u0026#34;25networks:26- hm-net27depends_on:28- mysql29nginx:30image:nginx31container_name:nginx32ports:33- \u0026#34;18080:18080\u0026#34;34- \u0026#34;18081:18081\u0026#34;35volumes:36- \u0026#34;./nginx/nginx.conf:/etc/nginx/nginx.conf\u0026#34;37- \u0026#34;./nginx/html:/usr/share/nginx/html\u0026#34;38depends_on:39- hmall40networks:41- hm-net42networks:43hm-net:44name:hmall   参数 说明     -f 指定compose文件的路径和名称   -p 指定project名称   up 创建并启动所有service容器   down 停止并移除所有容器、网络   ps 列出所有启动的容器   logs 查看指定容器的日志   stop 停止容器   start 启动容器   restart 重启容器   top 查看运行的进程   exec 在指定的运行中容器中执行命令    1docker compose up -d #就在本目录, 则不需要-f指定文件 2docker compose down #全部都给移除了, 干干净净. 微服务 普通地服务调用 购物车业务中需要查询商品信息，但商品信息查询的逻辑全部迁移到了item-service服务，导致我们无法查询。想解决这个问题，我们就必须把原本本地方法调用，改造成跨微服务的远程调用（RPC，即Remote Produce Call）。\nRestTemplate Spring给我们提供了一个RestTemplate的API，可以方便的实现Http请求的发送。RestTemplate提供了常见的Get、Post、Put、Delete请求都支持，如果请求参数比较复杂，还可以使用exchange方法来构造请求。\n编写配置类, 将RestTemplate注册为一个Bean:\n1package com.hmall.cart.config; 2 3import org.springframework.context.annotation.Bean; 4import org.springframework.context.annotation.Configuration; 5import org.springframework.web.client.RestTemplate; 6 7@Configuration 8public class RemoteCallConfig { 9 10 @Bean 11 public RestTemplate restTemplate() { 12 return new RestTemplate(); 13 } 14} 远程调用 1private void handleCartItems(List\u0026lt;CartVO\u0026gt; vos) { 2 // TODO 1.获取商品id 3 Set\u0026lt;Long\u0026gt; itemIds = vos.stream().map(CartVO::getItemId).collect(Collectors.toSet()); 4 // 2.查询商品 5 // List\u0026lt;ItemDTO\u0026gt; items = itemService.queryItemByIds(itemIds); 6 // 2.1.利用RestTemplate发起http请求，得到http的响应 7 ResponseEntity\u0026lt;List\u0026lt;ItemDTO\u0026gt;\u0026gt; response = restTemplate.exchange( 8 \u0026#34;http://localhost:8081/items?ids={ids}\u0026#34;, 9 HttpMethod.GET, 10 null, 11 new ParameterizedTypeReference\u0026lt;List\u0026lt;ItemDTO\u0026gt;\u0026gt;() { 12 }, //利用反射获取字节码, List\u0026lt;ItemDTO\u0026gt;.class是不行的, 泛型会被擦除 13 Map.of(\u0026#34;ids\u0026#34;, CollUtil.join(itemIds, \u0026#34;,\u0026#34;)) //将集合转字符串, 通过逗号拼接, 满足输入参数要求 14 ); 15 // 2.2.解析响应 16 if(!response.getStatusCode().is2xxSuccessful()){ 17 // 查询失败，直接结束 18 return; 19 } 20 List\u0026lt;ItemDTO\u0026gt; items = response.getBody(); 21 if (CollUtils.isEmpty(items)) { 22 return; 23 } 24 // 3.转为 id 到 item的map 25 Map\u0026lt;Long, ItemDTO\u0026gt; itemMap = items.stream().collect(Collectors.toMap(ItemDTO::getId, Function.identity())); 26 // 4.写入vo 27 for (CartVO v : vos) { 28 ItemDTO item = itemMap.get(v.getItemId()); 29 if (item == null) { 30 continue; 31 } 32 v.setNewPrice(item.getPrice()); 33 v.setStatus(item.getStatus()); 34 v.setStock(item.getStock()); 35 } 36} 服务注册和发现(解决多个实例地址不一样如何调用的问题) 注册中心对服务提供者提供心跳检测, 注册服务. 向服务消费者推送变更, 调用者可以从注册中心订阅想要的服务，获取服务对应的实例列表.\nNacos注册中心 服务注册 微服务提供者需要将服务注册到注册中心, 步骤如下：\n  微服务中引入依赖\n1\u0026lt;!--nacos 服务注册发现--\u0026gt; 2\u0026lt;dependency\u0026gt; 3 \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; 4 \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-nacos-discovery\u0026lt;/artifactId\u0026gt; 5\u0026lt;/dependency\u0026gt;   配置Nacos地址\n1spring:2application:3name:item-service# 服务名称4cloud:5nacos:6server-addr:192.168.150.101:8848# nacos地址  重启程序\n  访问nacos控制台，可以发现服务注册成功.\n服务发现 服务的消费者要去nacos订阅服务，这个过程就是服务发现，步骤如下：\n  引入依赖\n服务发现除了要引入nacos依赖以外，由于还需要负载均衡，因此要引入SpringCloud提供的LoadBalancer依赖。\n1\u0026lt;!--nacos 服务注册发现--\u0026gt; 2\u0026lt;dependency\u0026gt; 3 \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; 4 \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-nacos-discovery\u0026lt;/artifactId\u0026gt; 5\u0026lt;/dependency\u0026gt; 这里Nacos的依赖于服务注册时一致，这个依赖中同时包含了服务注册和发现的功能。因为任何一个微服务可以是调用者，也可以是提供者。\n  配置Nacos地址\n1spring:2cloud:3nacos:4server-addr:192.168.150.101:8848  发现并调用服务\n微服务有多个实例, 服务调用者必须利用负载均衡的算法，从多个实例中挑选一个去访问。常见的负载均衡算法有：\n 随机 轮询 IP的hash 最近最少访问 \u0026hellip;  这里我们可以选择最简单的随机负载均衡。\n服务发现需要用到一个工具，DiscoveryClient，SpringCloud已经帮我们自动装配，我们可以直接注入使用.\n1 private void handleCartItems(List\u0026lt;CartVO\u0026gt; vos) { 2 //这边依赖ItemService, 通过网络远程请求来完成, 使用spring的restTemplate 3 // 1.获取商品id 4 Set\u0026lt;Long\u0026gt; itemIds = vos.stream().map(CartVO::getItemId).collect(Collectors.toSet()); 5 //2.查询商品 6 List\u0026lt;ItemDTO\u0026gt; items = itemService.queryItemByIds(itemIds); 7 //2.1根据服务名称获取服务的实例列表 8 List\u0026lt;ServiceInstance\u0026gt; instances = discoveryClient.getInstances(\u0026#34;item-service\u0026#34;); 9 if(CollUtil.isEmpty(instances)){ 10 return; 11 } 12 //2.2手写负载均衡, 从实例列表中挑选实例 13 ServiceInstance instance = instances.get(RandomUtil.randomInt(instances.size())); 14 //2.3利用RestTemplate发起http请求,得到http响应 15 ResponseEntity\u0026lt;List\u0026lt;ItemDTO\u0026gt;\u0026gt; response = restTemplate.exchange( 16 instance.getUri()+\u0026#34;/items?ids={ids}\u0026#34;, 17// \u0026#34;http://localhost:8081/items?ids={ids}\u0026#34;, 18 HttpMethod.GET, 19 null, 20 new ParameterizedTypeReference\u0026lt;List\u0026lt;ItemDTO\u0026gt;\u0026gt;() { 21 }, //利用反射获取字节码, List\u0026lt;ItemDTO\u0026gt;.class是不行的, 泛型会被擦除 22 Map.of(\u0026#34;ids\u0026#34;, CollUtil.join(itemIds, \u0026#34;,\u0026#34;)) //将集合转字符串, 通过逗号拼接, 满足输入参数要求 23 ); 24 //2.4解析结果 25 if(!response.getStatusCode().is2xxSuccessful()){ 26 //查询失败 27 return; 28 } 29 List\u0026lt;ItemDTO\u0026gt; items = response.getBody(); 30 if (CollUtils.isEmpty(items)) { 31 return; 32 } 33 // 3.转为 id 到 item的map 34 Map\u0026lt;Long, ItemDTO\u0026gt; itemMap = items.stream().collect(Collectors.toMap(ItemDTO::getId, Function.identity())); 35 // 4.写入vo 36 for (CartVO v : vos) { 37 ItemDTO item = itemMap.get(v.getItemId()); 38 if (item == null) { 39 continue; 40 } 41 v.setNewPrice(item.getPrice()); 42 v.setStatus(item.getStatus()); 43 v.setStock(item.getStock()); 44 } 45 }   OpenFeign(实现更简单) 利用RestTemplate实现的远程调用的代码太复杂了, 想让远程调用像本地方法调用一样简单这就要用到OpenFeign组件了.\n快速入门(通过client构造请求, feign完成负载均衡和请求) 1.服务调用者引入依赖:\n1 \u0026lt;!--openFeign--\u0026gt; 2 \u0026lt;dependency\u0026gt; 3 \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; 4 \u0026lt;artifactId\u0026gt;spring-cloud-starter-openfeign\u0026lt;/artifactId\u0026gt; 5 \u0026lt;/dependency\u0026gt; 6 \u0026lt;!--负载均衡器--\u0026gt; 7 \u0026lt;dependency\u0026gt; 8 \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; 9 \u0026lt;artifactId\u0026gt;spring-cloud-starter-loadbalancer\u0026lt;/artifactId\u0026gt; 10 \u0026lt;/dependency\u0026gt; 2.启用OpenFeign. 在微服务调用者cart-service的启动类CartApplication上添加注解@EnableFeignClients，启动OpenFeign功能：\n1@EnableFeignClients 2@MapperScan(\u0026#34;com.hmall.cart.mapper\u0026#34;) 3@SpringBootApplication 4public class CartApplication { 5 public static void main(String[] args) { 6 SpringApplication.run(CartApplication.class, args); 7 } 8} 3.编写OpenFeign客户端. 在微服务调用者中, 新定义接口, 编写Feign客户端:\n1package com.hmall.cart.client; 2 3import com.hmall.cart.domain.dto.ItemDTO; 4import org.springframework.cloud.openfeign.FeignClient; 5import org.springframework.web.bind.annotation.GetMapping; 6import org.springframework.web.bind.annotation.RequestParam; 7 8import java.util.List; 9 10@FeignClient(\u0026#34;item-service\u0026#34;) 11public interface ItemClient { 12 13 @GetMapping(\u0026#34;/items\u0026#34;) 14 List\u0026lt;ItemDTO\u0026gt; queryItemByIds(@RequestParam(\u0026#34;ids\u0026#34;) Collection\u0026lt;Long\u0026gt; ids); 15} 这里只需要声明接口，无需实现方法。接口中的几个关键信息：\n @FeignClient(\u0026quot;item-service\u0026quot;) ：声明服务名称 @GetMapping ：声明请求方式 @GetMapping(\u0026quot;/items\u0026quot;) ：声明请求路径 @RequestParam(\u0026quot;ids\u0026quot;) Collection\u0026lt;Long\u0026gt; ids ：声明请求参数 List\u0026lt;ItemDTO\u0026gt; ：返回值类型  有了上述信息，OpenFeign就可以利用动态代理帮我们实现这个方法，并且向http://item-service/items发送一个GET请求，携带ids为请求参数，并自动将返回值处理为List\u0026lt;ItemDTO\u0026gt;。\n我们只需要直接调用这个方法，即可实现远程调用了。\n4.使用FeignClient\nfeign替我们完成了服务拉取、负载均衡、发送http请求的所有工作, 我们不再需要RestTemplate了，还省去了RestTemplate的注册.\n1private void handleCartItems(List\u0026lt;CartVO\u0026gt; vos) { 2 //这边依赖ItemService, 通过网络远程请求来完成, 使用spring的restTemplate 3 // 1.获取商品id 4 Set\u0026lt;Long\u0026gt; itemIds = vos.stream().map(CartVO::getItemId).collect(Collectors.toSet()); 5 // 2.查询商品 6// List\u0026lt;ItemDTO\u0026gt; items = itemService.queryItemByIds(itemIds); 7// //2.1根据服务名称获取服务的实例列表 8// List\u0026lt;ServiceInstance\u0026gt; instances = discoveryClient.getInstances(\u0026#34;item-service\u0026#34;); 9// if(CollUtil.isEmpty(instances)){ 10// return; 11// } 12// //2.2手写负载均衡, 从实例列表中挑选实例 13// ServiceInstance instance = instances.get(RandomUtil.randomInt(instances.size())); 14// //2.3利用RestTemplate发起http请求,得到http响应 15// ResponseEntity\u0026lt;List\u0026lt;ItemDTO\u0026gt;\u0026gt; response = restTemplate.exchange( 16// instance.getUri()+\u0026#34;/items?ids={ids}\u0026#34;, 17//// \u0026#34;http://localhost:8081/items?ids={ids}\u0026#34;, 18// HttpMethod.GET, 19// null, 20// new ParameterizedTypeReference\u0026lt;List\u0026lt;ItemDTO\u0026gt;\u0026gt;() { 21// }, //利用反射获取字节码, List\u0026lt;ItemDTO\u0026gt;.class是不行的, 泛型会被擦除 22// Map.of(\u0026#34;ids\u0026#34;, CollUtil.join(itemIds, \u0026#34;,\u0026#34;)) //将集合转字符串, 通过逗号拼接, 满足输入参数要求 23// ); 24 //2.4解析结果 25// if(!response.getStatusCode().is2xxSuccessful()){ 26// //查询失败 27// return; 28// } 29// List\u0026lt;ItemDTO\u0026gt; items = response.getBody(); 30// if (CollUtils.isEmpty(items)) { 31// return; 32// } 33 //使用了Open Feign上面的就不需要了, 别人帮做了 34 //itemClient注入得到 35 List\u0026lt;ItemDTO\u0026gt; items = itemClient.queryItemByIds(itemIds); 36 // 3.转为 id 到 item的map 37 Map\u0026lt;Long, ItemDTO\u0026gt; itemMap = items.stream().collect(Collectors.toMap(ItemDTO::getId, Function.identity())); 38 // 4.写入vo 39 for (CartVO v : vos) { 40 ItemDTO item = itemMap.get(v.getItemId()); 41 if (item == null) { 42 continue; 43 } 44 v.setNewPrice(item.getPrice()); 45 v.setStatus(item.getStatus()); 46 v.setStock(item.getStock()); 47 } 48 } 连接池 Feign底层发起http请求，依赖于其它的框架。其底层支持的http客户端实现包括：\n HttpURLConnection：默认实现，不支持连接池 Apache HttpClient ：支持连接池 OKHttp：支持连接池  因此我们通常会使用带有连接池的客户端来代替默认的HttpURLConnection。比如，我们使用OK Http.\n1.微服务中引入依赖\n1\u0026lt;!--OK http 的依赖 --\u0026gt; 2\u0026lt;dependency\u0026gt; 3 \u0026lt;groupId\u0026gt;io.github.openfeign\u0026lt;/groupId\u0026gt; 4 \u0026lt;artifactId\u0026gt;feign-okhttp\u0026lt;/artifactId\u0026gt; 5\u0026lt;/dependency\u0026gt; 2.微服务中开启连接池\n1feign:2okhttp:3enabled:true# 开启OKHttp功能重启服务，连接池就生效了。\n最佳实践 需要在每个微服务调用者中再次定义微服务提供者的Client接口，这不是重复编码吗？ 有什么办法能加避免重复编码呢？避免重复编码的办法就是抽取. 这里有两种抽取思路：\n 思路1：抽取到微服务之外的公共module 思路2：每个微服务自己抽取一个module(每个微服务都有个api模块)  方案1抽取更加简单，工程结构也比较清晰，但缺点是整个项目耦合度偏高。\n方案2抽取相对麻烦，工程结构相对更复杂，但服务之间耦合度降低。\n由于item-service已经创建好，无法继续拆分，因此这里我们采用方案1.\n抽取Feign客户端 在hmall下定义一个新的module，命名为hm-api, 将client和需要的类复制过来. 现在，任何微服务要调用item-service中的接口，只需要引入hm-api模块依赖即可，无需自己编写Feign客户端了。\n引入 在微服务调用者的pom.xml中引入hm-api模块：\n1 \u0026lt;!--feign模块--\u0026gt; 2 \u0026lt;dependency\u0026gt; 3 \u0026lt;groupId\u0026gt;com.heima\u0026lt;/groupId\u0026gt; 4 \u0026lt;artifactId\u0026gt;hm-api\u0026lt;/artifactId\u0026gt; 5 \u0026lt;version\u0026gt;1.0.0\u0026lt;/version\u0026gt; 6 \u0026lt;/dependency\u0026gt; 删除调用者与api模块已经重复的类之后报错了, 因为ItemClient现在定义到了com.hmall.api.client包下，而cart-service的启动类定义在com.hmall.cart包下，扫描不到ItemClient(pom引入的api包)，所以报错了。\n解决办法很简单，在cart-service的启动类上添加声明即可，两种方式：\n  方式1：声明扫描包：\n1//basePackages指定远程包的位置, 这样才能被SpringBootApplication扫描到, 才能用这些FeignClient. 2@EnableFeignClients(basePackages = \u0026#34;com.hmall.api.client\u0026#34;) 3@MapperScan(\u0026#34;com.hmall.cart.mapper\u0026#34;) 4@SpringBootApplication 5public class CartApplication { 6 public static void main(String[] args) { 7 SpringApplication.run(CartApplication.class, args); 8 } 9}   方式2：声明要用的FeignClient\n1@EnableFeignClients(client = {ItemClient.class}) 2@MapperScan(\u0026#34;com.hmall.cart.mapper\u0026#34;) 3@SpringBootApplication 4public class CartApplication { 5 public static void main(String[] args) { 6 SpringApplication.run(CartApplication.class, args); 7 } 8}   日志配置 OpenFeign只会在FeignClient所在包的日志级别为DEBUG时，才会输出日志。而且其日志级别有4级：\n NONE：不记录任何日志信息，这是默认值。 BASIC：仅记录请求的方法，URL以及响应状态码和执行时间 HEADERS：在BASIC的基础上，额外记录了请求和响应的头信息 FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据。  1.定义日志级别\n在hm-api模块下新建一个配置类，定义Feign的日志级别：\n1package com.hmall.api.config; 2 3import feign.Logger; 4import org.springframework.context.annotation.Bean; 5 6public class DefaultFeignConfig { 7 @Bean 8 public Logger.Level feignLogLevel(){ 9 return Logger.Level.FULL; 10 } 11} 2.配置\n接下来，要让日志级别生效，还需要配置这个类。有两种方式：\n  局部生效：在某个FeignClient中配置，只对当前FeignClient生效\n1@FeignClient(value = \u0026#34;item-service\u0026#34;, configuration = DefaultFeignConfig.class)   全局生效：在@EnableFeignClients中配置，针对所有FeignClient生效。\n1@EnableFeignClients(defaultConfiguration = DefaultFeignConfig.class)   网关路由 网关就是网络的关口。数据在网络间传输，从一个网络传输到另一网络时就需要经过网关来做数据的路由和转发以及数据安全的校验。\n前端请求不能直接访问微服务，而是要请求网关：\n 网关可以做安全控制，也就是登录身份校验，校验通过才放行 通过认证后，网关再根据请求判断应该访问哪个微服务，将请求转发过去  快速入门 创建项目hm-gateway并引入依赖:\n1\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; 2\u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; 3 xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; 4 xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; 5 \u0026lt;parent\u0026gt; 6 \u0026lt;artifactId\u0026gt;hmall\u0026lt;/artifactId\u0026gt; 7 \u0026lt;groupId\u0026gt;com.heima\u0026lt;/groupId\u0026gt; 8 \u0026lt;version\u0026gt;1.0.0\u0026lt;/version\u0026gt; 9 \u0026lt;/parent\u0026gt; 10 \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; 11 12 \u0026lt;artifactId\u0026gt;hm-gateway\u0026lt;/artifactId\u0026gt; 13 14 \u0026lt;properties\u0026gt; 15 \u0026lt;maven.compiler.source\u0026gt;11\u0026lt;/maven.compiler.source\u0026gt; 16 \u0026lt;maven.compiler.target\u0026gt;11\u0026lt;/maven.compiler.target\u0026gt; 17 \u0026lt;/properties\u0026gt; 18 \u0026lt;dependencies\u0026gt; 19 \u0026lt;!--common--\u0026gt; 20 \u0026lt;dependency\u0026gt; 21 \u0026lt;groupId\u0026gt;com.heima\u0026lt;/groupId\u0026gt; 22 \u0026lt;artifactId\u0026gt;hm-common\u0026lt;/artifactId\u0026gt; 23 \u0026lt;version\u0026gt;1.0.0\u0026lt;/version\u0026gt; 24 \u0026lt;/dependency\u0026gt; 25 \u0026lt;!--网关--\u0026gt; 26 \u0026lt;dependency\u0026gt; 27 \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; 28 \u0026lt;artifactId\u0026gt;spring-cloud-starter-gateway\u0026lt;/artifactId\u0026gt; 29 \u0026lt;/dependency\u0026gt; 30 \u0026lt;!--nacos discovery--\u0026gt; 31 \u0026lt;dependency\u0026gt; 32 \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; 33 \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-nacos-discovery\u0026lt;/artifactId\u0026gt; 34 \u0026lt;/dependency\u0026gt; 35 \u0026lt;!--负载均衡--\u0026gt; 36 \u0026lt;dependency\u0026gt; 37 \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; 38 \u0026lt;artifactId\u0026gt;spring-cloud-starter-loadbalancer\u0026lt;/artifactId\u0026gt; 39 \u0026lt;/dependency\u0026gt; 40 \u0026lt;/dependencies\u0026gt; 41 \u0026lt;build\u0026gt; 42 \u0026lt;finalName\u0026gt;${project.artifactId}\u0026lt;/finalName\u0026gt; 43 \u0026lt;plugins\u0026gt; 44 \u0026lt;plugin\u0026gt; 45 \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; 46 \u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt; 47 \u0026lt;/plugin\u0026gt; 48 \u0026lt;/plugins\u0026gt; 49 \u0026lt;/build\u0026gt; 50\u0026lt;/project\u0026gt; 创建启动类:\n1package com.hmall.gateway; 2 3import org.springframework.boot.SpringApplication; 4import org.springframework.boot.autoconfigure.SpringBootApplication; 5 6@SpringBootApplication 7public class GatewayApplication { 8 public static void main(String[] args) { 9 SpringApplication.run(GatewayApplication.class, args); 10 } 11} 配置路由 在hm-gateway模块的resources目录新建一个application.yaml文件，内容如下：\n1server:2port:80803spring:4application:5name:gateway6cloud:7nacos:8server-addr:192.168.170.128:88489gateway:10routes:11- id:item-service# 路由规则id，自定义，唯一12uri:lb://item-service# 路由的目标服务，lb代表负载均衡，会从注册中心拉取服务列表13predicates:# 路由断言，判断当前请求是否符合当前规则，符合则路由到目标服务14- Path=/items/** # 这里是以请求路径作为判断规则15- Path=/search/**16filters:17- AddRequestHeader=Truth, anyone workhard will be rich#添加请求头的过滤器18- id:user-service19uri:lb://user-service20predicates:21- Path=/users/**,/addresses/**22- id:pay-service23uri:lb://pay-service24predicates:25- Path=/pay-orders/**26- id:trade-service27uri:lb://trade-service28predicates:29- Path=/orders/**30- id:cart-service31uri:lb://cart-service32predicates:33- Path=/carts/**uri中需要是微服务名称, predicates中填入路径, 这样对应路径的请求就会被转发至响应的微服务.\n访问http://localhost:8080/items/page?pageNo=1\u0026amp;pageSize=1, 实际上被转发到item-service微服务中.\n路由过滤 路由规则的定义语法如下：\n1spring:2cloud:3gateway:4routes:5- id:item6uri:lb://item-service7predicates:8- Path=/items/**,/search/**其中routes对应的类型是GatewayProperties类,\n1@ConfigurationProperties(\u0026#34;spring.cloud.gateway\u0026#34;) 2@Validated 3public class GatewayProperties { 4 public static final String PREFIX = \u0026#34;spring.cloud.gateway\u0026#34;; 5 private final Log logger = LogFactory.getLog(this.getClass()); 6 @NotNull 7 @Valid 8 private List\u0026lt;RouteDefinition\u0026gt; routes = new ArrayList(); 是一个集合，也就是说可以定义很多路由规则。集合中的RouteDefinition就是具体的路由规则定义，其中常见的属性如下：\n1@Validated 2public class RouteDefinition { 3 private String id; 4 @NotEmpty 5 @Valid 6 private List\u0026lt;PredicateDefinition\u0026gt; predicates = new ArrayList(); 7 @Valid 8 private List\u0026lt;FilterDefinition\u0026gt; filters = new ArrayList(); 9 @NotNull 10 private URI uri; 四个属性含义如下：\n id：路由的唯一标示 predicates：路由断言，其实就是匹配条件 filters：路由过滤条件，后面讲 uri：路由目标地址，lb://代表负载均衡，从注册中心获取目标微服务的实例列表，并且负载均衡选择一个访问。  predicates，也就是路由断言。SpringCloudGateway中支持的断言类型有很多：\n   名称 说明 示例     After 是某个时间点后的请求 - After=2037-01-20T17:42:47.789-07:00[America/Denver]   Before 是某个时间点之前的请求 - Before=2031-04-13T15:14:47.433+08:00[Asia/Shanghai]   Between 是某两个时间点之前的请求 - Between=2037-01-20T17:42:47.789-07:00[America/Denver], 2037-01-21T17:42:47.789-07:00[America/Denver]   Cookie 请求必须包含某些cookie - Cookie=chocolate, ch.p   Header 请求必须包含某些header - Header=X-Request-Id, \\d+   Host 请求必须是访问某个host（域名） - Host=.somehost.org,.anotherhost.org   Method 请求方式必须是指定方式 - Method=GET,POST   Path 请求路径必须符合指定规则 - Path=/red/{segment},/blue/**   Query 请求参数必须包含指定参数 - Query=name, Jack或者- Query=name   RemoteAddr 请求者的ip必须是指定范围 - RemoteAddr=192.168.1.1/24   weight 权重处理     网关登录校验 我们的登录是基于JWT来实现的，校验JWT的算法复杂，而且需要用到秘钥。如果每个微服务都去做登录校验，这就存在着两大问题：\n 每个微服务都需要知道JWT的秘钥，不安全 每个微服务重复编写登录校验代码、权限校验代码，麻烦  既然网关是所有微服务的入口，一切请求都需要先经过网关。我们：\n 只需要在网关和用户服务保存秘钥 只需要在网关开发登录校验功能  网关过滤器 想在请求转发之前做登录校验，就必须了解Gateway内部工作的基本原理。\n 客户端请求进入网关后由HandlerMapping对请求做判断，找到与当前请求匹配的路由规则（Route），然后将请求交给WebHandler去处理。 WebHandler则会加载当前路由下需要执行的过滤器链（Filter chain），然后按照顺序逐一执行过滤器（后面称为**Filter**）。 Filter分为两部分，是因为Filter内部的逻辑分为pre和post两部分，分别会在请求路由到微服务之前和之后被执行。 只有所有Filter的pre逻辑都依次顺序执行通过后，请求才会被路由到微服务。 微服务返回结果后，再倒序执行Filter的post逻辑。 最终把响应结果返回。  最终请求转发是有一个名为NettyRoutingFilter的过滤器来执行的，而且这个过滤器是整个过滤器链中顺序最靠后的一个。如果我们能够定义一个过滤器，在其中实现登录校验逻辑，并且将过滤器执行顺序定义到NettyRoutingFilter之前，这就符合我们的需求了\n那么，该如何实现一个网关过滤器呢？\n网关过滤器链中的过滤器有两种：\n GatewayFilter：路由过滤器，作用范围比较灵活，可以是任意指定的路由Route. GlobalFilter：全局过滤器，作用范围是所有路由，不可配置。  GatewayFilter和GlobalFilter这两种过滤器的方法签名完全一致：\n1/** 2* 处理请求并将其传递给下一个过滤器 3* @param exchange 当前请求的上下文，其中包含request、response等各种数据 4* @param chain 过滤器链，基于它向下传递请求 5* @return 根据返回值标记当前请求是否被完成或拦截，chain.filter(exchange)就放行了。 6*/ 7Mono\u0026lt;Void\u0026gt; filter(ServerWebExchange exchange, GatewayFilterChain chain); Gateway内置的GatewayFilter过滤器使用起来非常简单，无需编码，只要在yaml文件中简单配置即可。而且其作用范围也很灵活，配置在哪个Route下，就作用于哪个Route.\n例如，有一个过滤器叫做AddRequestHeaderGatewayFilterFacotry，顾明思议，就是添加请求头的过滤器，可以给请求添加一个请求头并传递到下游微服务。\n使用的使用只需要在application.yaml中这样配置：\n1spring:2cloud:3gateway:4routes:5- id:test_route6uri:lb://test-service7predicates:8-Path=/test/**9filters:10- AddRequestHeader=key, value# 逗号之前是请求头的key，逗号之后是value如果想要让过滤器作用于所有的路由，则可以这样配置：\n1spring:2cloud:3gateway:4default-filters:# default-filters下的过滤器可以作用于所有路由5- AddRequestHeader=key, value6routes:7- id:test_route8uri:lb://test-service9predicates:10-Path=/test/**自定义过滤器 无论是GatewayFilter还是GlobalFilter都支持自定义，只不过编码方式、使用方式略有差别。\n自定义过滤器过滤器还可以支持动态配置参数，不过实现起来比较复杂，示例：\n1 2@Component 3public class PrintAnyGatewayFilterFactory // 父类泛型是内部类的Config类型 4 extends AbstractGatewayFilterFactory\u0026lt;PrintAnyGatewayFilterFactory.Config\u0026gt; { 5 6 @Override 7 public GatewayFilter apply(Config config) { 8 // OrderedGatewayFilter是GatewayFilter的子类，包含两个参数： 9 // - GatewayFilter：过滤器 10 // - int order值：值越小，过滤器执行优先级越高 11 return new OrderedGatewayFilter(new GatewayFilter() { 12 @Override 13 public Mono\u0026lt;Void\u0026gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) { 14 // 获取config值 15 String a = config.getA(); 16 String b = config.getB(); 17 String c = config.getC(); 18 // 编写过滤器逻辑 19 System.out.println(\u0026#34;a = \u0026#34; + a); 20 System.out.println(\u0026#34;b = \u0026#34; + b); 21 System.out.println(\u0026#34;c = \u0026#34; + c); 22 // 放行 23 return chain.filter(exchange); 24 } 25 }, 100); 26 } 27 28 // 自定义配置属性，成员变量名称很重要，下面会用到 29 @Data 30 static class Config{ 31 private String a; 32 private String b; 33 private String c; 34 } 35 // 将变量名称依次返回，顺序很重要，将来读取参数时需要按顺序获取 36 @Override 37 public List\u0026lt;String\u0026gt; shortcutFieldOrder() { 38 return List.of(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;); 39 } 40 // 返回当前配置类的类型，也就是内部的Config 41 @Override 42 public Class\u0026lt;Config\u0026gt; getConfigClass() { 43 return Config.class; 44 } 45 46} 然后在yaml文件中使用：\n1spring:2cloud:3gateway:4default-filters:5- PrintAny=1,2,3# 注意，这里多个参数以\u0026#34;,\u0026#34;隔开，将来会按照shortcutFieldOrder()方法返回的参数顺序依次复制上面这种配置方式参数必须严格按照shortcutFieldOrder()方法的返回参数名顺序来赋值。\n还有一种用法，无需按照这个顺序，就是手动指定参数名：\n1spring:2cloud:3gateway:4default-filters:5- name:PrintAny6args:# 手动指定参数名，无需按照参数顺序7a:18b:29c:3自定义GlobalFilter 自定义GlobalFilter则简单很多，直接实现GlobalFilter即可，而且也无法设置动态参数：\n1@Component 2public class PrintAnyGlobalFilter implements GlobalFilter, Ordered { 3 @Override 4 public Mono\u0026lt;Void\u0026gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) { 5 // 编写过滤器逻辑 6 System.out.println(\u0026#34;未登录，无法访问\u0026#34;); 7 // 放行 8 // return chain.filter(exchange); 9 10 // 拦截 11 ServerHttpResponse response = exchange.getResponse(); 12 response.setRawStatusCode(401); 13 return response.setComplete(); 14 } 15 16 @Override 17 public int getOrder() { 18 // 过滤器执行顺序，值越小，优先级越高 19 return 0; 20 } 21} 登录校验 服务保护和分布式事务 微服务保护 微服务保护的方案有很多，比如：\n 请求限流: 限制或控制接口访问的并发流量，避免服务因流量激增而出现故障。 线程隔离: 当一个业务接口响应时间长，而且并发高时，就可能耗尽服务器的线程资源，导致服务内的其它接口受到影响。所以我们必须把这种影响降低，或者缩减影响的范围 服务熔断: 线程隔离虽然避免了雪崩问题，但故障服务依然会拖慢购物车服务的接口响应速度。我们需编写服务降级逻辑, 统计服务提供方的异常比例，当比例过高表明该接口会影响到其它服务，应该拒绝调用该接口，而是直接走降级逻辑。  微服务保护的技术有很多，但在目前国内使用较多的还是Sentinel\n分布式事务 出现以下情况之一就可能产生分布式事务问题：\n 业务跨多个服务实现 业务跨多个数据源实现  Seata 解决分布式事务的思想非常简单：\n就是找一个统一的事务协调者，与多个分支事务通信，检测每个分支事务的执行状态，保证全局事务下的每一个分支事务同时成功或失败即可。大多数的分布式事务框架都是基于这个理论来实现的。\nSeata也不例外，在Seata的事务管理中有三个重要的角色：\n TC **(Transaction Coordinator) - 事务协调者：**维护全局和分支事务的状态，协调全局事务提交或回滚。 TM (Transaction Manager) - **事务管理器：**定义全局事务的范围、开始全局事务、提交或回滚全局事务。 RM (Resource Manager) - **资源管理器：**管理分支事务，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。  XA模式 原始模式 一阶段：\n 事务协调者通知每个事务参与者执行本地事务 本地事务执行完成后报告事务执行状态给事务协调者，此时事务不提交，继续持有数据库锁  二阶段：\n 事务协调者基于一阶段的报告来判断下一步操作 如果一阶段都成功，则通知所有事务参与者，提交事务 如果一阶段任意一个参与者失败，则通知所有事务参与者回滚事务  Seata的XA模型 RM一阶段的工作：\n 注册分支事务到TC 执行分支业务sql但不提交 报告执行状态到TC  TC二阶段的工作：\n TC检测各分支事务执行状态 如果都成功，通知所有RM提交事务 如果有失败，通知所有RM回滚事务  RM二阶段的工作：\n 接收TC指令，提交或回滚事务  优缺点 XA模式的优点是什么？\n 事务的强一致性，满足ACID原则 常用数据库都支持，实现简单，并且没有代码侵入  XA模式的缺点是什么？\n 因为一阶段需要锁定数据库资源，等待二阶段结束才释放，性能较差 依赖关系型数据库实现事务  AT模式 AT模式同样是分阶段提交的事务模型，不过缺弥补了XA模型中资源锁定周期过长的缺陷。\nSeata的AT模型 阶段一RM的工作：\n 注册分支事务 记录undo-log（数据快照） 执行业务sql并提交 报告事务状态  阶段二提交时RM的工作：\n 删除undo-log即可  阶段二回滚时RM的工作：\n 根据undo-log恢复数据到更新前  AT模式下，当前分支事务执行流程如下：\n一阶段：\n TM发起并注册全局事务到TC TM调用分支事务 分支事务准备执行业务SQL RM拦截业务SQL，根据where条件查询原始数据，形成快照。 RM执行业务SQL，提交本地事务，释放数据库锁。此时 money = 90 RM报告本地事务状态给TC  二阶段：\n TM通知TC事务结束 TC检查分支事务状态  如果都成功，则立即删除快照 如果有分支事务失败，需要回滚。读取快照数据（{\u0026ldquo;id\u0026rdquo;: 1, \u0026ldquo;money\u0026rdquo;: 100}），将快照恢复到数据库。此时数据库再次恢复为100    AT与XA的区别 简述AT模式与XA模式最大的区别是什么？\n XA模式一阶段不提交事务，锁定资源；AT模式一阶段直接提交，不锁定资源。 XA模式依赖数据库机制实现回滚；AT模式利用数据快照实现数据回滚。 XA模式强一致；AT模式最终一致  可见，AT模式使用起来更加简单，无业务侵入，性能更好。因此企业90%的分布式事务都可以用AT模式来解决。\nMQ 微服务一旦拆分，必然涉及到服务之间的相互调用，目前我们服务之间调用采用的都是基于OpenFeign的调用。这种调用中，调用者发起请求后需要等待服务提供者执行业务返回结果后，才能继续执行后面的业务。也就是说调用者在调用过程中处于阻塞状态，因此我们称这种调用方式为同步调用，也可以叫同步通讯。如果我们的业务需要实时得到服务提供方的响应，则应该选择同步通讯（同步调用）。而如果我们追求更高的效率，并且不需要实时响应，则应该选择异步通讯（异步调用）。\n异步调用的优势包括：\n 耦合度更低 性能更好 业务拓展性强 故障隔离，避免级联失败  几种常见MQ的对比：\n追求可用性：Kafka、 RocketMQ 、RabbitMQ\n追求可靠性：RabbitMQ、RocketMQ\n追求吞吐能力：RocketMQ、Kafka\n追求消息低延迟：RabbitMQ、Kafka\nRabbitMQ  publisher：生产者，也就是发送消息的一方 consumer：消费者，也就是消费消息的一方 queue：队列，存储消息。生产者投递的消息会暂存在消息队列中，等待消费者处理 exchange：交换机，负责消息路由。生产者发送的消息由交换机决定投递到哪个队列。 virtual host：虚拟主机，起到数据隔离的作用。每个虚拟主机相互独立，有各自的exchange、queue  \rSpringAMQP 由于RabbitMQ采用了AMQP协议，因此它具备跨语言的特性。任何语言只要遵循AMQP协议收发消息，都可以与RabbitMQ交互。Spring的官方刚好基于RabbitMQ提供了这样一套消息收发的模板工具：SpringAMQP。并且还基于SpringBoot对其实现了自动装配，使用起来非常方便。\nSpringAMQP提供了三个功能：\n 自动声明队列、交换机及其绑定关系 基于注解的监听器模式，异步接收消息 封装了RabbitTemplate工具，用于发送消息  消息发送 rabbitTemplate.convertAndSend(queueName, message);\n1package com.itheima.publisher.amqp; 2 3import org.junit.jupiter.api.Test; 4import org.springframework.amqp.rabbit.core.RabbitTemplate; 5import org.springframework.beans.factory.annotation.Autowired; 6import org.springframework.boot.test.context.SpringBootTest; 7 8@SpringBootTest 9public class SpringAmqpTest { 10 11 @Autowired 12 private RabbitTemplate rabbitTemplate; 13 14 @Test 15 public void testSimpleQueue() { 16 // 队列名称 17 String queueName = \u0026#34;simple.queue\u0026#34;; 18 // 消息 19 String message = \u0026#34;hello, spring amqp!\u0026#34;; 20 // 发送消息 21 rabbitTemplate.convertAndSend(queueName, message); 22 } 23} 消息接收 @RabbitListener\n1package com.itheima.consumer.listener; 2 3import org.springframework.amqp.rabbit.annotation.RabbitListener; 4import org.springframework.stereotype.Component; 5 6@Component 7public class SpringRabbitListener { 8 // 利用RabbitListener来声明要监听的队列信息 9 // 将来一旦监听的队列中有了消息，就会推送给当前服务，调用当前方法，处理消息。 10 // 可以看到方法体中接收的就是消息体的内容 11 @RabbitListener(queues = \u0026#34;simple.queue\u0026#34;) 12 public void listenSimpleQueueMessage(String msg) throws InterruptedException { 13 System.out.println(\u0026#34;spring 消费者接收到消息：【\u0026#34; + msg + \u0026#34;】\u0026#34;); 14 } 15} WorkQueues模型 简单来说就是让多个消费者绑定到一个队列，共同消费队列中的消息。\n当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。\n此时就可以使用work 模型，多个消费者共同处理消息处理，消息处理的速度就能大大提高了。\n1@RabbitListener(queues = \u0026#34;work.queue\u0026#34;) 2public void listenWorkQueue1(String msg) throws InterruptedException { 3 System.out.println(\u0026#34;消费者1接收到消息：【\u0026#34; + msg + \u0026#34;】\u0026#34; + LocalTime.now()); 4 Thread.sleep(20); 5} 6 7@RabbitListener(queues = \u0026#34;work.queue\u0026#34;) 8public void listenWorkQueue2(String msg) throws InterruptedException { 9 System.err.println(\u0026#34;消费者2........接收到消息：【\u0026#34; + msg + \u0026#34;】\u0026#34; + LocalTime.now()); 10 Thread.sleep(200); 11} 消息是平均分配给每个消费者，并没有考虑到消费者的处理能力。导致1个消费者空闲，另一个消费者忙的不可开交。\n能者多劳 在spring中有一个简单的配置，可以解决这个问题。我们修改consumer服务的application.yml文件，添加配置：\n1spring:2rabbitmq:3listener:4simple:5prefetch:1# 每次只能获取一条消息，处理完成才能获取下一个消息可以发现，由于消费者1处理速度较快，所以处理了更多的消息；消费者2处理速度较慢，只处理了6条消息。而最终总的执行耗时也在1秒左右，大大提升。\n交换机类型 在订阅模型中，多了一个exchange角色，而且过程略有变化：\n Publisher：生产者，不再发送消息到队列中，而是发给交换机 Exchange：交换机，一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。 Queue：消息队列也与以前一样，接收消息、缓存消息。不过队列一定要与交换机绑定。 Consumer：消费者，与以前一样，订阅队列，没有变化  Exchange（交换机）只负责转发消息，不具备存储消息的能力，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！\n交换机的类型有四种：\n Fanout：广播，将消息交给所有绑定到交换机的队列。我们最早在控制台使用的正是Fanout交换机 Direct：订阅，基于RoutingKey（路由key）发送给订阅了消息的队列 Topic：通配符订阅，与Direct类似，只不过RoutingKey可以使用通配符 Headers：头匹配，基于MQ的消息头匹配，用的较少。  Fanout交换机 Fanout，英文翻译是扇出，我觉得在MQ中叫广播更合适。\n 1） 可以有多个队列 2） 每个队列都要绑定到Exchange（交换机） 3） 生产者发送的消息，只能发送到交换机 4） 交换机把消息发送给绑定过的所有队列 5） 订阅队列的消费者都能拿到消息  Direct交换机 在Fanout模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。\n在Direct模型下：\n 队列与交换机的绑定，不能是任意绑定了，而是要指定一个RoutingKey（路由key） 消息的发送方在 向 Exchange发送消息时，也必须指定消息的 RoutingKey。 Exchange不再把消息交给每一个绑定的队列，而是根据消息的Routing Key进行判断，只有队列的Routingkey与消息的 Routing key完全一致，才会接收到消息  Topic交换机 Topic类型的Exchange与Direct相比，都是可以根据RoutingKey把消息路由到不同的队列。\n只不过Topic类型Exchange可以让队列在绑定BindingKey 的时候使用通配符！\nBindingKey一般都是有一个或多个单词组成，多个单词之间以.分割，例如： item.insert\n通配符规则：\n #：匹配一个或多个词 *：匹配不多不少恰好1个词  举例：\n item.#：能够匹配item.spu.insert 或者 item.spu item.*：只能匹配item.spu  声明队列和交换机 发送者的可靠性 生产者重试机制 生产者发送消息时，出现了网络故障，导致与MQ的连接中断。为了解决这个问题，SpringAMQP提供的消息发送时的重试机制。即：当RabbitTemplate与MQ连接超时后，多次重试。\n修改publisher模块的application.yaml文件，添加下面的内容：\n1spring:2rabbitmq:3connection-timeout:1s# 设置MQ的连接超时时间4template:5retry:6enabled:true# 开启超时重试机制7initial-interval:1000ms# 失败后的初始等待时间8multiplier:1# 失败后下次的等待时长倍数，下次等待时长 = initial-interval * multiplier9max-attempts:3# 最大重试次数10SpringAMQP提供的重试机制是阻塞式的重试，也就是说多次重试等待的过程中，当前线程是被阻塞的。\n如果对于业务性能有要求，建议禁用重试机制。如果一定要使用，请合理配置等待时长和重试次数，当然也可以考虑使用异步线程来执行发送消息的代码。\n生产者确认机制 一般情况下，只要生产者与MQ之间的网路连接顺畅，基本不会出现发送消息丢失的情况，因此大多数情况下我们无需考虑这种问题。\n不过，在少数情况下，也会出现消息发送到MQ之后丢失的现象，比如：\n MQ内部处理消息的进程发生了异常 生产者发送消息到达MQ后未找到Exchange 生产者发送消息到达MQ的Exchange后，未找到合适的Queue，因此无法路由  针对上述情况，RabbitMQ提供了生产者消息确认机制，包括Publisher Confirm和Publisher Return两种。在开启确认机制的情况下，当生产者发送消息给MQ后，MQ会根据消息处理的情况返回不同的回执。\n 当消息投递到MQ，但是路由失败时，通过Publisher Return返回异常信息，同时返回ack的确认信息，代表投递成功 临时消息投递到了MQ，并且入队成功，返回ACK，告知投递成功 持久消息投递到了MQ，并且入队完成持久化，返回ACK ，告知投递成功 其它情况都会返回NACK，告知投递失败  MQ的可靠性 数据持久化 为了提升性能，默认情况下MQ的数据都是在内存存储的临时数据，重启后就会消失。为了保证数据的可靠性，必须配置数据持久化，包括：\n 交换机持久化 队列持久化 消息持久化  LazyQueue 在默认情况下，RabbitMQ会将接收到的信息保存在内存中以降低消息收发的延迟。一旦出现消息堆积问题，RabbitMQ的内存占用就会越来越高，直到触发内存预警上限。此时RabbitMQ会将内存消息刷到磁盘上，这个行为成为PageOut. PageOut会耗费一段时间，并且会阻塞队列进程。因此在这个过程中RabbitMQ不会再处理新的消息，生产者的所有请求都会被阻塞。\n为了解决这个问题，从RabbitMQ的3.6.0版本开始，就增加了Lazy Queues的模式，也就是惰性队列。惰性队列的特征如下：\n 接收到消息后直接存入磁盘而非内存 消费者要消费消息时才会从磁盘中读取并加载到内存（也就是懒加载） 支持数百万条的消息存储  消费者的可靠性 当RabbitMQ向消费者投递消息以后，需要知道消费者的处理状态如何。因为消息投递给消费者并不代表就一定被正确消费了，可能出现的故障有很多，比如：\n 消息投递的过程中出现了网络故障 消费者接收到消息后突然宕机 消费者接收到消息后，因处理不当导致异常 \u0026hellip;  一旦发生上述情况，消息也会丢失。因此，RabbitMQ必须知道消费者的处理状态，一旦消息处理失败才能重新投递消息。\n消费者确认机制 为了确认消费者是否成功处理消息，RabbitMQ提供了消费者确认机制（Consumer Acknowledgement）。即：当消费者处理消息结束后，应该向RabbitMQ发送一个回执，告知RabbitMQ自己消息处理状态。回执有三种可选值：\n ack：成功处理消息，RabbitMQ从队列中删除该消息 nack：消息处理失败，RabbitMQ需要再次投递消息 reject：消息处理失败并拒绝该消息，RabbitMQ从队列中删除该消息  一般reject方式用的较少。因此大多数情况下我们需要将消息处理的代码通过try catch机制捕获，消息处理成功时返回ack，处理失败时返回nack.\n由于消息回执的处理代码比较统一，因此SpringAMQP帮我们实现了消息确认。并允许我们通过配置文件设置ACK处理方式，有三种模式：\n none：不处理。即消息投递给消费者后立刻ack，消息会立刻从MQ删除。非常不安全，不建议使用 manual：手动模式。需要自己在业务代码中调用api，发送ack或reject，存在业务入侵，但更灵活 auto：自动模式。SpringAMQP利用AOP对我们的消息处理逻辑做了环绕增强，当业务正常执行时则自动返回ack. 当业务出现异常时，根据异常判断返回不同结果：  如果是业务异常，会自动返回nack； 如果是消息处理或校验异常，自动返回reject;    1spring:2rabbitmq:3listener:4simple:5acknowledge-mode:none# 不做处理失败重试机制 当消费者出现异常后，消息会不断requeue（重入队）到队列，再重新发送给消费者。如果消费者再次执行依然出错，消息会再次requeue到队列，再次投递，直到消息处理成功为止。\n极端情况就是消费者一直无法执行成功，那么消息requeue就会无限循环，导致mq的消息处理飙升，带来不必要的压力\n为了应对上述情况Spring又提供了消费者失败重试机制：在消费者出现异常时利用本地重试，而不是无限制的requeue到mq队列。\n修改consumer服务的application.yml文件，添加内容：\n1spring:2rabbitmq:3listener:4simple:5retry:6enabled:true# 开启消费者失败重试7initial-interval:1000ms# 初识的失败等待时长为1秒8multiplier:1# 失败的等待时长倍数，下次等待时长 = multiplier * last-interval9max-attempts:3# 最大重试次数10stateless:true# true无状态；false有状态。如果业务中包含事务，这里改为false 开启本地重试时，消息处理过程中抛出异常，不会requeue到队列，而是在消费者本地重试 重试达到最大次数后，抛出了AmqpRejectAndDontRequeueException异常, Spring会返回reject，消息会被丢弃  失败处理策略 在之前的测试中，本地测试达到最大重试次数后，消息会被丢弃。这在某些对于消息可靠性要求较高的业务场景下，显然不太合适了。\n因此Spring允许我们自定义重试次数耗尽后的消息处理策略，这个策略是由MessageRecovery接口来定义的，它有3个不同实现：\n RejectAndDontRequeueRecoverer：重试耗尽后，直接reject，丢弃消息。默认就是这种方式 ImmediateRequeueMessageRecoverer：重试耗尽后，返回nack，消息重新入队 RepublishMessageRecoverer：重试耗尽后，将失败消息投递到指定的交换机  比较优雅的一种处理方案是RepublishMessageRecoverer，失败后将消息投递到一个指定的，专门存放异常消息的队列，后续由人工集中处理。\n1@Bean 2public MessageRecoverer republishMessageRecoverer(RabbitTemplate rabbitTemplate){ 3 return new RepublishMessageRecoverer(rabbitTemplate, \u0026#34;error.direct\u0026#34;, \u0026#34;error\u0026#34;); 4} 业务幂等性 在程序开发中，则是指同一个业务，执行一次或多次对业务状态的影响是一致的。例如：\n 根据id删除数据 查询数据 新增数据  数据的更新往往不是幂等的，如果重复执行可能造成不一样的后果。比如：\n 取消订单，恢复库存的业务。如果多次恢复就会出现库存重复增加的情况 退款业务。重复退款对商家而言会有经济损失。  所以，我们要尽可能避免业务被重复执行。\n因此，我们必须想办法保证消息处理的幂等性。这里给出两种方案：\n 唯一消息ID 业务状态判断  唯一消息ID:\n这个思路非常简单：\n 每一条消息都生成一个唯一的id，与消息一起投递给消费者。 消费者接收到消息后处理自己的业务，业务处理成功后将消息ID保存到数据库 如果下次又收到相同消息，去数据库查询判断是否存在，存在则为重复消息放弃处理。  我们该如何给消息添加唯一ID呢？\n其实很简单，SpringAMQP的MessageConverter自带了MessageID的功能，我们只要开启这个功能即可。\n以Jackson的消息转换器为例：\n1@Bean 2public MessageConverter messageConverter(){ 3 // 1.定义消息转换器 4 Jackson2JsonMessageConverter jjmc = new Jackson2JsonMessageConverter(); 5 // 2.配置自动创建消息id，用于识别不同消息，也可以在业务中基于ID判断是否是重复消息 6 jjmc.setCreateMessageIds(true); 7 return jjmc; 8} 业务判断:\n业务判断就是基于业务本身的逻辑或状态来判断是否是重复的请求或消息，不同的业务场景判断的思路也不一样。\n在极小概率下可能存在线程安全问题。\n兜底方案","date":"2024-05-25","permalink":"/posts/tech/java-3-spring-cloud/","series":["Java"],"tags":["","",""],"title":"SpringCloud学习笔记"},{"categories":["计算机"],"content":"黑马Java进阶教程，全面剖析Java多线程编程，含抢红包、抽奖实战案例 ,现对学习到的内容做一个总结.\n一.多线程的三种方式 1.继承Thread类 继承Thread类,重写run方法.这里重写构造方法是为了方便在初始化的时候快速地设置线程的名称,当然也可以在创建线程后使用setName方法.\n1package mythread1; 2 3public class MyThread extends Thread{ 4 public MyThread(String name) { 5 super(name); 6 } 7 8 public MyThread() { 9 super(); 10 } 11 12 @Override 13 public void run() { 14 //写线程执行的代码 15 for (int i = 0; i \u0026lt; 100; i++) { 16 System.out.println(getName() + \u0026#34;: Hello World\u0026#34;); 17 } 18 } 19} 20 使用线程的start方法启动线程.\n1package mythread1; 2 3public class Main { 4 public static void main(String[] args) throws InterruptedException { 5 /* 6多线程第一种启动方式 71.定义类继承Thread类 82.重写run方法 93.创建子类对象，并启动线程 10*/ 11 //利用构造方法设置名字 12 MyThread t1 = new MyThread(\u0026#34;one\u0026#34;); 13 MyThread t2 = new MyThread(\u0026#34;two\u0026#34;); 14 //通过setName显式设置名字 15 //不显示地设置名字，它自己也有名字。 16// t1.setName(\u0026#34;Thread 1\u0026#34;); 17// t2.setName(\u0026#34;Thread 2\u0026#34;); 18 //开启线程 19 t1.start(); 20 //本线程,就是执行这个方法的线程,也就是main 21// Thread.sleep(5000); 22// Thread main = Thread.currentThread(); 23 t2.start(); 24 25 } 26} 2.实现Runnable接口 自定义类实现Runnable接口,重写run方法\n1package mythread2; 2 3public class MyThread implements Runnable { 4 @Override 5 public void run() { 6 for (int i = 0; i \u0026lt; 100; i++) { 7 //当前线程的对象 8// Thread t = Thread.currentThread(); 9// System.out.println(Thread.currentThread().getName() + \u0026#34; :Hello World\u0026#34;); 10 System.out.println(Thread.currentThread().getName() + i); 11 } 12 } 13} 14 创建好自定义类后,放入Thread类构造线程\nsetPriority是设置线程优先级,数目越高优先级越高\n1package mythread2; 2 3public class Main { 4 public static void main(String[] args) { 5 /* 6多线程第二种启动方式： 71.自己定义类实现runable接口 82.重写run方法 93.创建自己的类对象 104.创建Thread类对象，开启线程 11*/ 12 13 //自己的类对象，其实就是多线程的任务 14 MyThread myThread = new MyThread(); 15 //Thread 16 Thread t1 = new Thread(myThread,\u0026#34;线程1\u0026#34;); 17 Thread t2 = new Thread(myThread,\u0026#34;线程2\u0026#34;); 18 //设置名字以区分，这是Thread类的方法 19// t1.setName(\u0026#34;Thread 1\u0026#34;); 20// t2.setName(\u0026#34;Thread 2\u0026#34;); 21 System.out.println(t1.getPriority()); 22 System.out.println(t2.getPriority()); 23 //设置优先级,越高越能抢到cpu,这只是概率. 24 t1.setPriority(1); 25 t2.setPriority(10); 26 27 //开启 28 t1.start(); 29 t2.start(); 30 } 31} 32 3.实现Callable接口 自定义类实现Callable接口,重写Call方法.这个Call方法是有返回值的.\n1package mythread3; 2 3import java.util.concurrent.Callable; 4 5public class MyCallable implements Callable\u0026lt;Integer\u0026gt; { 6 @Override 7 public Integer call() throws Exception { 8 int sum = 0; 9 for (int i = 0; i \u0026lt;= 100; i++) { 10 sum += i; 11 } 12 return sum; 13 } 14} 15 下面注释已经写得很清楚了,实例化实现Callable接口的类,然后放入FutureTask对象进行管理,再将FutureTask放入Thread进行初始化.\n这种方式可以获取线程执行的返回值.\n1package mythread3; 2 3import java.util.concurrent.ExecutionException; 4import java.util.concurrent.FutureTask; 5 6public class Main { 7 public static void main(String[] args) throws ExecutionException, InterruptedException { 8 /* 9多线程第三种实现方式： 10特点：可以获取到多线程运行的结果 111.创建类实现Callable接口 122.重写call，可以获取结果 133.创建实现接口的对象 144.创建FutureTask接口对象，管理多线程运行的结果 155.创建Thread对象 16*/ 17 MyCallable mc = new MyCallable(); 18 FutureTask\u0026lt;Integer\u0026gt; ft = new FutureTask\u0026lt;\u0026gt;(mc); 19 Thread t1 = new Thread(ft); 20 t1.start(); 21 22 //获取结果 23 System.out.println(ft.get()); 24 25 } 26} 27 二.守护线程,出让线程,插入线程 不太重要\n1package mythread4; 2 3 4public class Main { 5 public static void main(String[] args) throws InterruptedException { 6// MyThread1 myThread1 = new MyThread1(); 7// MyThread2 myThread2 = new MyThread2(); 8// myThread1.setName(\u0026#34;hime\u0026#34;); 9// myThread2.setName(\u0026#34;prince\u0026#34;); 10// 11// //设置守护线程,当其他非守护线程结束后,守护线程陆续结束 12// //就是它自己不会运行完,慢慢地结束了. 13// myThread2.setDaemon(true); 14// myThread1.start(); 15// myThread2.start(); 16 17// MyThread1 t1 = new MyThread1(); 18// MyThread1 t2 = new MyThread1(); 19// t1.setName(\u0026#34;线程1\u0026#34;); 20// t2.setName(\u0026#34;线程2\u0026#34;); 21// t1.start(); 22// t2.start(); 23 24 MyThread1 t1 = new MyThread1(); 25 t1.setName(\u0026#34;另一个线程\u0026#34;); 26 t1.start(); 27 //插入线程 28 //把t线程,插入到当前线程(main线程)之前 29 //t1全都执行完,才该main执行 30 t1.join(); 31 32 for (int i = 0; i \u0026lt; 10; i++) { 33 System.out.println(\u0026#34;main线程\u0026#34; + \u0026#34;@\u0026#34; + i); 34 } 35 36 } 37} 38 1package mythread4; 2 3public class MyThread1 extends Thread{ 4 @Override 5 public void run() { 6 for (int i = 0; i \u0026lt; 100; i++) { 7 System.out.println(getName() + \u0026#34;@\u0026#34; + i); 8 //出让线程 9 //出让cpu执行权,就是不会一直抢着,重写和其他线程继续抢夺,这样执行结果可能会均匀一点. 10// Thread.yield(); 11 } 12 } 13} 14 三.线程安全(线程同步) 同步代码块 同步代码块用synchronized包裹,再括号之后需要放入一个唯一的锁对象,可以使用static修饰,也可以放入当前类的字节码文件\n1package threadsafe; 2 3public class MyThread extends Thread{ 4 static int ticket = 0; 5 6 //锁对象,一定是唯一的 7// static Object object = new Object(); 8 9 public MyThread() { 10 super(); 11 } 12 13 public MyThread(String name) { 14 super(name); 15 } 16 17 @Override 18 public void run() { 19 while (true){ 20 //同步代码块 21 synchronized (MyThread.class){ 22 if (ticket \u0026lt;= 100){ 23 try { 24 Thread.sleep(100); 25 } catch (InterruptedException e) { 26 throw new RuntimeException(e); 27 } 28 ticket++; 29 System.out.println(getName() + \u0026#34;selling ticket \u0026#34; + ticket); 30 }else { 31 break; 32 } 33 } 34 } 35 } 36 37 38 39} 40 同步方法 也可以把同步代码块抽取出来形成一个方法,称为同步方法,其实就是用synchronized修饰的方法\n同步方法:非静态的时候锁对象是this;静态的时候锁对象是当前类字节码文件\n1package threadsafe; 2 3public class MyRunnable implements Runnable{ 4 //这里不需要设置静态变量,因为只有一个实例. 5 int ticket = 0; 6 7 @Override 8 public void run() { 9 while (true){ 10 if (method()) break; 11 } 12 } 13 14 //同步方法. 非静态的时候锁对象是this;静态的时候锁对象是当前类字节码文件 15 private synchronized boolean method() { 16 if (ticket \u0026lt; 100){ 17 try { 18 Thread.sleep(100); 19 } catch (InterruptedException e) { 20 throw new RuntimeException(e); 21 } 22 ticket++; 23 System.out.println(Thread.currentThread().getName() + \u0026#34; selling ticket \u0026#34; + ticket); 24 }else { 25 return true; 26 } 27 return false; 28 } 29} 30 lock锁 创建一把静态锁, 然后在需要同步的代码块上使用lock方法, 在代码块结束时使用unlock方法.\n1package threadsafe; 2 3import java.util.concurrent.locks.Lock; 4import java.util.concurrent.locks.ReentrantLock; 5 6public class MyLock extends Thread{ 7 static int ticket = 0; 8 9 //多个对象共享同一把锁,加static 10 static Lock lock = new ReentrantLock(); 11 12 //锁对象,一定是唯一的 13// static Object object = new Object(); 14 15 public MyLock() { 16 super(); 17 } 18 19 public MyLock(String name) { 20 super(name); 21 } 22 23 @Override 24 public void run() { 25 while (true){ 26 //同步代码块 27 //synchronized (MyLock.class){ 28 lock.lock(); 29 try { 30 if (ticket \u0026lt;= 100){ 31 Thread.sleep(100); 32 ticket++; 33 System.out.println(getName() + \u0026#34;selling ticket \u0026#34; + ticket); 34 }else { 35 break; 36 } 37 } catch (InterruptedException e) { 38 throw new RuntimeException(e); 39 } finally { 40 //锁一定会被释放 41 lock.unlock(); 42 } 43 //} 44 } 45 } 46} 四. 生产者-消费者机制 生产者消费者模式是一个经典的多线程协作模式.\n等待唤醒机制 桌子Desk.class(控制生产者消费者的执行):\n1package waitandnotify1; 2 3public class Desk { 4 /* 5控制生产者和消费者状态 6*/ 7 8 //桌子上是否有面条,0表示没有,1表示有 9 public static int foodFlag = 0; 10 11 //总个数 12 public static int count = 10; 13 14 //锁 15 public static Object lock = new Object(); 16} 17 消费者Foodie.class:\n1package waitandnotify1; 2 3public class Foodie extends Thread{ 4 @Override 5 public void run() { 6 /* 71.循环 82.同步代码块 93.判断共享数据是否到了末尾,到了末尾 104.没有到末尾,执行核心逻辑 11*/ 12 while (true){ 13 synchronized (Desk.lock){ 14 if (Desk.count == 0){ 15 break; 16 }else { 17 /* 18判断是否有面条 19没有则等待 20有,吃,然后唤醒厨师,吃的数目减一,修改桌子状态 21*/ 22 if(Desk.foodFlag == 0){ 23 try { 24 Desk.lock.wait(); //当前线程和锁绑定,方便唤醒 25 } catch (InterruptedException e) { 26 throw new RuntimeException(e); 27 } 28 }else { 29 Desk.count--; 30 System.out.println(\u0026#34;eating, left \u0026#34; + Desk.count + \u0026#34; bowl to eat\u0026#34;); 31 Desk.lock.notifyAll(); 32 Desk.foodFlag = 0; 33 } 34 } 35 } 36 } 37 } 38} 生产者Cook.class:\n1package waitandnotify1; 2 3public class Cook extends Thread{ 4 @Override 5 public void run() { 6 while (true){ 7 synchronized (Desk.lock){ 8 if (Desk.count == 0){ 9 break; 10 }else{ 11 if (Desk.foodFlag == 1){ 12 try { 13 Desk.lock.wait(); 14 } catch (InterruptedException e) { 15 throw new RuntimeException(e); 16 } 17 }else { 18 System.out.println(\u0026#34;Cooking, left \u0026#34; + Desk.count + \u0026#34; to cook\u0026#34;); 19 Desk.lock.notifyAll(); 20 Desk.foodFlag = 1; 21 } 22 } 23 } 24 } 25 } 26} 27 测试代码:\n1package waitandnotify1; 2 3public class ThreadDemo { 4 public static void main(String[] args) { 5 //等待唤醒机制完成生产者-消费者 6 Cook c = new Cook(); 7 Foodie f = new Foodie(); 8 c.setName(\u0026#34;Cooker\u0026#34;); 9 f.setName(\u0026#34;Foodie\u0026#34;); 10 c.start(); 11 f.start(); 12 } 13} 14 阻塞队列实现等待唤醒机制 生产者:\n1package waitandnotify2; 2 3import java.util.concurrent.ArrayBlockingQueue; 4 5public class Cook extends Thread{ 6 7 //成员变量 8 ArrayBlockingQueue\u0026lt;String\u0026gt; queue; 9 10 //构造方法 11 public Cook(ArrayBlockingQueue\u0026lt;String\u0026gt; queue) { 12 this.queue = queue; 13 } 14 15 @Override 16 public void run() { 17 while(true){ 18 try { 19 //自带锁,里面会判断当前队列是否是满的 20 queue.put(\u0026#34;noodle\u0026#34;); 21 System.out.println(\u0026#34;put noodle in queue\u0026#34;); 22 } catch (InterruptedException e) { 23 throw new RuntimeException(e); 24 } 25 26 } 27 28 } 29} 30 消费者:\n1package waitandnotify2; 2 3import java.util.concurrent.ArrayBlockingQueue; 4 5public class Foodie extends Thread{ 6 7 ArrayBlockingQueue\u0026lt;String\u0026gt; queue; 8 9 public Foodie(ArrayBlockingQueue\u0026lt;String\u0026gt; queue) { 10 this.queue = queue; 11 } 12 13 @Override 14 public void run() { 15 while(true){ 16 try { 17 String food = queue.take(); 18 System.out.println(\u0026#34;eating a bowl of noodle\u0026#34;); 19 } catch (InterruptedException e) { 20 throw new RuntimeException(e); 21 } 22 } 23 } 24} 25 测试(提供一个阻塞队列):\n1package waitandnotify2; 2 3import java.util.concurrent.ArrayBlockingQueue; 4 5 6 7public class ThreadDemo { 8 public static void main(String[] args) { 9 //阻塞队列完成生产者-消费者 10 11 //创建阻塞队列 12 ArrayBlockingQueue\u0026lt;String\u0026gt; queue = new ArrayBlockingQueue\u0026lt;\u0026gt;(1); 13 //创建线程对象,将阻塞队列传入 14 Cook cook = new Cook(queue); 15 Foodie foodie = new Foodie(queue); 16 //开启线程 17 cook.start(); 18 foodie.start(); 19 } 20} 21 五.线程的六种状态 \r线程状态:\n 新建new,创建线程对象 就绪runnable,start方法 阻塞blocked,无法获得锁对象 等待waiting,wait方法 计时等待timed_waiting,sleep方法 结束terminated,全部代码执行完毕.  作业代码就不贴了, 以后需要复习时重新写.\n","date":"2024-05-09","permalink":"/posts/tech/java-1-thread/","series":["Java"],"tags":["","",""],"title":"Java多线程"},{"categories":["计算机"],"content":"本篇对面试的作用微乎其微\n面试总结：问了我半个小时，一半多的重要的东西都答不上来，特别重要的是多线程，还有数据库。算是一场经历吧。\n本篇对面试的作用微乎其微, 这里面有很大部分不会被问到.\n面试需要的准备：\n 视频看两遍，第二遍总结 复习之前做过的Java项目 复习之前看过的spring视频和代码。  一、Java基础 1.JDK、JRE、JVM三者区别和联系 jdk是java开发工具，jre是java运行时环境，jvm是java虚拟机。\njdk包含jre，jre中的bin就是jvm，lib就是类库。\njavac编译成class文件，class文件是字节码文件，由jvm解释为对应系统的机器码。\n2.==和equals ==对比栈的值，基本类型是变量值，引用类型是堆中内存对象的地址。equals默认是采用==比较。String中已经重写了equals方法，不然由于String是不可变的原因会不一样。\n3.final final修饰变量，变量初始化后不可变；修饰类，类不可被继承；修饰方法，方法不能被子类覆盖，但是可以被重载。修饰引用类型，初始化后不能让其指向另一个对象，但引用值可以改变。\n局部内部类和匿名内部类只能访问局部final变量。这是因为外部类方法结束变量就会销毁，但是内部类对象可能还存在，所以复制一份局部变量供内部类使用，为了保证这两个变量一致，所以用final修饰。\n4.String、StringBuffer、StringBuilder String 是final修饰的，不可变，每次操作会产生新对象。\nStringBuffer和StringBuilder都是在原对象上操作。\nStringBuffer是线程安全的，StringBuilder是线程不安全的。但是StringBuilder性能要高些。\n经常需要改变字符串就使用后面两个。\n优先使用StringBuilder，多线程使用共享变量使用StringBuffer\n5.重载和重写 重载：在同一个类中，方法名相同，参数类型不同，个数不同，顺序不同，方法返回值，修饰符可以不同。发生在编译。\n重写：发生在父子类，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符大于等于父类；如果父类方法修饰符为private则子类不能重写该方法。\n6.接口和抽象类 抽象类可以存在普通成员函数，而接口只能存在public abstract方法。\n抽象类的成员变量可以是各种类型的，而接口中的成员变量只能说public static final类型的。\n抽象类只能继承一个，接口可以实现多个。\n接口是对类的行为进行约束，约束了行为的有无，不对如何实现进行限制。对行为的抽象。is a的关系\n抽象类是为了代码复用，不同的类有相同的行为，都可以派生一‘个抽象类。是对类本质的抽象。like a的关系\n7.List和Set List：有序，可以重复，按对象进入的顺序保存，允许多个null元素对象，使用迭代器遍历，还可以get（int index）\nSet：无序，不可重复，最多允许有一个null对象，取元素只能用迭代器。\n8.hashCode与equals hashCode获取散列码，是int型整数，用于确定对象在hash表的索引位置。HashSet检查重复元素，就是比较hashCode看对应位置是否有值，没有就假设对象没有重复出现；有值才会调用equals方法检查两个对象是否真的相同（相同的对象hash值可能不同），相同就不会让其加入成功，不同重新散列到其他为止，这大大减少了equals次数。\n 两个对象相等，hashcode相同，equals返回true 两个对象hashcode相同，他们不一定相等  9.ArrayList和LinkedList ArrayList：基于动态数组，连续内存存储，适合下标访问，扩容就是新建一个然后把原来的复制，插入数据会涉及到元素的移动。使用尾插法可以极大提高性能，比linkedlist快（创建node节点）。\nLinkedList：基于链表，存储在分散的内存，适合插入和删除不适合查询。遍历使用迭代器，get(i)需要对list遍历，indexof也是会遍历整个list。\n10.HashMap和HashTable 1.HashMap线程不安全，HashTable线程安全\n2.HashMap允许key value为空，HashTable不允许\nHashMap是数组+链表实现的。jdk8开始，数组长度超过64，链表高度超过8，链表转化为红黑树，元素以内部类Node节点存在。\n 计算key的hash值，再二次hash得到一个数，这个数对数组长度取模，于是得到一个数组下标。 如果没有产生hash冲突（对应下标位置没有元素），则直接创建Node存入数组 产生hash冲突，先equals比较，相同就取代，不同判断链表高度插入链表，链表高度达到8，并且数组长度到64就转红黑树，长度低于6转回链表。 key为null存在下标为0的位置  11.ConcurrentHashMap原理 线程安全版本的HashMap。\njdk7：ReentrantLock+Segment+HashEntry。一个segment是一个HashEntry数组，每一个HashEntry是链表。\n查询：第一次hash定位到segment，第二次hash定位到元素所在链表的头部\n锁：Segment分段锁，Segment继承了ReentrantLock，锁定操作的segment，其余的Segment不受影响。并发度为segment个数，数组扩容不会影响其他segment。\njdk8：\n12.如何实现IOC容器  配置文件，配置包扫描路径 定义注解，表示控制层，服务层，数据持久层，依赖注入层，配置文件注解 递归包路径获取class文件，将这些文件添加到set集合存储 遍历set，获取在类上有指定注解的类，定义一个安全map存储这些对象，反射，确定需要交给IOC管理的类 对需要注入的类进行依赖注入  13.字节码 在机器和编译程序中加入了一层抽象的虚拟的机器。这台虚拟的机器在任何平台上都提供给编译程序一个共同的接口。于是编译程序只需要面向虚拟机，生成虚拟机理解的代码，再由虚拟机的解释器将字节码转换为特定系统的机器码执行。\njava源代码-\u0026gt;编译器-\u0026gt;jvm可执行的字节码-\u0026gt;jvm-\u0026gt;jvm的解释器-\u0026gt;机器可执行的二进制机器码-\u0026gt;程序运行\n好处：一定程度上解决了传统解释型语言执行效率低的问题；保留了解释型语言可移植的特点。java文件无需重新编译便可在多种平台运行。\n14.Java类加载器 JDK自带三个类加载器：bootstrap classloader，ExtClassLoader，AppClassLoader\nbootstrap classloader是ExtClassLoader父类加载器（不是直接继承），默认加载java_home/lib下的jar包和class文件。\nExtClassLoader是AppClassLoader的父类加载器，负责加载java_home/lib/ext下的jar包和class文件\nAppClassLoader是自定义类加载器的父类，加载classpath的类文件。\n继承ClassLoader实现自定义加载器。\n15.双亲委派（委托）模型 AppClassLoader中如果没有缓存，就往上委派，都是查找缓存，缓存没有就继续委派。到了最顶层缓存还是没有，查找加载路径，没有向下查找，继续查找加载路径。到发起加载的加载器为止。\n好处：为了安全性，避免用户自己编写的类动态替换Java的一些核心类。同时避免了类重复加载，相同的class文件被不同的加载器加载就是不同的两个类。\n16.Java异常体系 所有异常来自顶级父类Throwable，Throwable有两个子类：exception和error。\nerror是程序无法处理的错误，一旦出现，程序被迫终止\nexception不会导致程序停止，又分为runtimeEception运行时异常（发生在程序运行过程中，导致程序当前线程执行失败）和checkedException检查异常（常常发生在程序编译过程中，导致程序编译不通过）。\n二、Spring 1.单例Bean是单例模式吗？ 但单例模式是指在一个JVM中，一个类只能构造出来一个对象\n单例Bean也是以一种单例模式，但是范围很小，只是一个beanName的范围，一个beanName对应一个Bean对象，不同的beanName对应不同的Bean对象（可以同一个类）。\n2.Bean的实例化和初始化有什么区别？ Spring创建Bean时，先创建一个对象，然后通过反射执行类构造方法得到一个Java对象，这个过程就是Bean的实例化。\n得到对象后进行依赖注入，之后就可以初始化了。Bean的初始化就是调用前面创建出来的Java对象中特定的方法，比如Java对象实现了InitializingBean接口，那么初始化就会执行Java对象的afterPropertiesSet()方法。\n3.Spring AOP如何实现？和AspectJ有什么区别？ AOP是利用的动态代理机制，如果Bean实现了接口，那么就会采用JDK动态代理来生成该接口的代理对象，如果一个Bean没有实现接口，就会采用CGLIB生成当前对象的代理对象。代理对象会代理原来的Bean对象，执行某个方法时会在原来的基础上增加一些切面逻辑，使得我们可以利用AOP来实现一些登录校验，权限控制等统一功能。\nAOP和AspectJ没有特别强的关系，AOP是面向切面编程，一种编程思想。AspectJ可以实现这种思想，它在编译器对类进行增强。而Spring AOP通过动态代理实现AOP，但底层实现和AspectJ不一样，只是注解的名字是相同的（before around after）\n4.Spring事务如何实现？  底层是基于数据库事务和AOP机制。 使用了@Transactional注解的Bean，会创建一个代理对象。调用代理对象的方法时，会先判断该方法是否加了@Transactional注解 加了的话，会利用事务管理器创建一个数据库连接，修改数据库连接的AutoCommit属性为false，禁止自动提交。 然后执行方法，执行方法中的sql 执行完后没有异常就提交 出现了异常，根据异常的类型是不是rollbackfor指定的，再选择是否回滚  Spring事务的隔离级别对应的就是数据库的隔离级别\n5.你是如何理解Spring事务的传播机制的？底层是如何实现的？ Spring事务的传播机制是Spring事务自己实现的（propagation）。这个传播机制是基于数据库连接的，新开一个事务就是新建一个数据库连接。\n6.那些情况会导致Spring事务失效？对应原因？   方法内自调用：因为事务是基于AOP的，使用代理对象调用方法时事务才能生效。而在一个方法中调用this.xx()这个this不是代理对象，事务就会失效。\n解决办法：a 把调用的方法拆到另一个bean中\n​\tb 自己注入自己\n​\tc\n  方法是private的：Spring事务会基于CGLIB进行AOP，而CGLIB会基于父子类生效。如果父类中的某个方法是private，子类就没有办法重写，也就没办法而外为其增加逻辑。\n  方法是final的，和上者原理一样，子类不能重写父类的final方法\n  单独的线程调用方法：如果不是同一个线程，就从ThreadLocal中拿不到数据库连接对象，这样自己只能新建一个，这个新建的的AutoCommit是true。\n  没加@Configuration注解：springboot基本没有这个问题。如果是spring的话，没有加注解会导致map中存的DataSource和Mybatis和JdbcTemplate中的DataSource不相等。又会自己去创建连接。\n  异常被吃掉：事务没有捕获到异常就不会回滚了\n  类没有被Spring管理\n  数据库不支持事务\n  7.Spring中Bean创建的生命周期  推断构造方法 实例化 依赖注入（填充属性） 处理Aware回调 初始化前，处理@PostConstruct 初始化，处理initializingBean接口 初始化后，进行AOP  8.Spring中Bean是线程安全的吗 这取决于Bean本身，Bean本身是无状态，就是线程安全；本身有状态，就是线程不安全。\n9.ApplicationContext和BeanFactory有什么区别 BeanFactory可以生成Bean，维护Bean。ApplicationContext继承自BeanFactory，有BeanFactory的特点，由于继承了其他接口，还有其他功能，如获取系统环境变量，国际化，事件发布等功能。\n10.Spring容器的启动流程是怎样的  扫描，得到所有的BeanDefinition对象，存在Map中。 筛选单例BeanDefinition创建Bean，对于多例Bean会在每次获取Bean时利用BeanDefinition去创建。 利用BeanDefinition创建Bean就是Bean的创建生命周期，包括推断构造，实例化，依赖注入，初始化前，初始化，初始化后（AOP） 单例Bean创建完了，Spring发布一个容器启动事件。 Spring启动结束  11.Spring为什么要用三级缓存来解决循环依赖 三、SpringBoot 1.@SpringBootApplication注解有什么用？ 它是一个复合注解，是@SpringBootConfiguration，@EnableAutoConfiguration，@ComponentScan三个注解的整合。\n@SpringBootConfiguration：相当于@Configuration，表示这是一个配置类\n@EnableAutoConfiguration：负责自动配置类的导入，将项目的自动配置类导入到Spring容器\n@ComponentScan：Spring容器会进行扫描，扫描路径为当前这个类所在的包路径\n2.spring.factories有什么作用？ spring.factories是SpringBoot SPI（扩展）机制实现的核心。\n在SpringBoot启动过程中，会找出项目中所有的spring.factories，从而向Spring容器添加各个spring.factories中指定的ApplicationListener，ApplicationContextInitializer，配置类。使得对SpringBoot做扩展非常容易。\n3.如何理解SpringBoot自动配置？ 在Spring中，通常需要配置很多的Bean，比如Mybatis的SqlSessionFactory；AOP的@EnableAspectJAutoProxy注解等\n在SpringBoot中，内置了很多配置类，叫做自动配置类。在依赖了spring-boot-starer-web后会间接依赖到spring-boot-autoconfigure这个jar，里面就有很多自动配置类。\n4.SpringBoot启动时做了哪些事？  判断当前应用的类型，如是不是web应用，是servlet还是webflux应用，不同类型后续会创建不同的Spring容器。 根据类型创建Spring容器 解析启动类，进行扫描，导入自动配置类并解析。 启动tomcat或者jetty 调用ApplicationRunner或CommandLineRunner  四、SpringMVC 1.SpringMVC的处理流程是什么？  启动Tomcat中，创建DispatcherServlet对象，执行初始化逻辑 DispatcherServlet初始化创建Spring容器，初始化中还要初始化HandlerMapping，HandlerAdapter等。 SpringMVC提供了好几个HandlerMapping，其中有一个为RequestMappingHandlerMapping，它去寻找Spring容器中哪些加了@RequestMapping的方法。 找到这些方法后，解析注解上指定的path，把path作为key，method作为value存到一个map中。 DispatcherServlet接收到请求后，RequestMappingHandlerMapping就会根据请求路径找到对应method。 解析各个参数，从请求中拿到对应值，执行method。 执行完得到方法返回值，SpringMVC进一步解析，如果加了@ResponseBody就直接返回值给浏览器，没有的话根据返回值找页面。 ","date":"2024-04-29","permalink":"/posts/tech/java-0-audition/","series":["Java"],"tags":[""],"title":"Java面试准备1"},{"categories":["二次元"],"content":" 好听，所以想唱出来。\n1.歌词  作词 : 秋田ひろむ\n作曲 : 秋田ひろむ\n编曲 : 出羽良彰\n僕が死のうと思ったのは ウミネコが桟橋[さんばし]で鳴[な]いたから\n曾经我也想过一了百了 因为有黑尾鸥在码头悲鸣\n波[なみ]の随意（まにま）に浮（う）かんで消える[きえる] 過去[かこ]も啄[つい]ばんで飛[と]んでいけ\n随着浪花起伏消没 叼啄着往昔飞离不见\n僕が死のうと思ったのは 誕生日に杏[あんず]の花が咲[さ]いたから\n曾经我也想过一了百了 因为生日那天杏花开放\nその木漏れ日[こもれび]でうたた寝したら 虫[むし]の死骸[しがい]と土[つち]になれるかな\n若是在那洒下的阳光里打盹 能否与虫之死骸一同化为尘土呢\n薄荷[はっか]飴[あめ] 漁港[ぎょこう]の灯台[とうだい] 錆[さ]びたアーチ橋（きょう） 捨（す）てた自転車（じてんしゃ）\n薄荷糖 渔港的灯塔 生锈的拱桥 丢弃的自行车\n木造（もくぞう）の駅（えき）のストーブの前（まえ）で どこにも旅立たびだ）てない心\n木造车站的暖炉前 无处可去的心灵\n今日はまるで昨日みたいだ 明日（あす）を変えるなら今日を変えなきゃ\n今天与昨天如此相像 想改变明天 必须改变今天\n分かってる 分かってる けれど\n我知道 我知道 但是\u0026hellip;\n僕が死のうと思ったのは 心が空っぽになったから\n曾经我也想过一了百了 因为心中已空无一物\n満（み）たされないと泣（な）いているのは きっと満たされたいと願（ねが）うから\n感到空虚而哭泣 一定是渴望得到充实\n僕が死のうと思ったのは 靴紐（くつひも）が解（ほど）けたから\n曾经我也想过一了百了 因为鞋带松开了\n結（むす）びなおすのは苦手（にがて）なんだよ 人との繋（つな）がりもまた然（しか）り\n不擅长重新系起 与人的牵绊亦是如此\n僕が死のうと思ったのは 少年（しょうねん）が僕を見（み）つめていたから\n曾经我也想过一了百了 因为少年深情凝视着我\nベッドの上で土下座（どげざ）してるよ あの日の僕にごめんなさいと\n抱膝跪在床上 向那天的我说抱歉\nパソコンの薄明（うすあ）かり 上階（じょうかい）の部屋（へや）の生活音（せいかつおん）\n屏幕的微光 楼上的噪音\nインターフォンのチャイムの音（おと） 耳（みみ）を塞（ふさ）ぐ鳥かごの少年\n电话的铃声 紧塞住双耳 那笼中的少年\n見えない敵（てき）と戦（たたか）ってる 六畳（ろくじょう）一間（ひとま）のドンキホーテ\n与看不见的敌人战斗着 六畳一间的堂吉诃德\nゴールはどうせ醜（みにく）いものさ\n反正目的也是一样丑陋\n僕が死のうと思ったのは 冷（つめ）たい人と言（い）われたから\n曾经我也想过一了百了 因为被说是个冷漠的人\n愛されたいと泣いているのは 人の温（ぬく）もりを知（し）ってしまったから\n想要被爱而哭泣 是因为尝到了人的温暖\n僕が死のうと思ったのは あなたが綺麗（きれい）に笑（わら）うから\n曾经我也想过一了百了 因为你灿烂的笑容\n死ぬことばかり考（かんが）えてしまうのは きっと生きる事（こと）に真面目（まじめ）すぎるから\n净考虑着死的事 一定是因为太过认真地活\n僕が死のうと思ったのは まだあなたに出会（であ）ってなかったから\n曾经我也想过一了百了 因为还未与你相遇\nあなたのような人が生（う）まれた 世界を少し好きになったよ\n因为有像你这样的人出现 我对世界稍微有了好感\nあなたのような人が生きてる 世界に少し期待するよ\n因为有像你这样的人活在这个世上 我对世界稍微有了期待\n 引用 僕（ぼく）が死（し）のうと思（おも）ったのは\nウミネコが桟桥（さんばし）で鸣（な）いたから 波（なみ）の随意（まにま）に浮（う）かんで消（き）える\n过去（かこ）も啄（つい）ばんで飞（と）んでいけ\n僕（ぼく）が死（し）のうと思（おも）ったのは\n诞生日（たんじょうび）に杏（あんず）の花（はな）が咲（さ）いたから その木漏（こも）れ日（び）でうたた寝（ね）したら\n虫（むし）の死骸（しがい）と土（つち）になれるかな\n薄荷饴（はっかあめ）\n渔港（ぎょこう）の灯台（とうだい）\n锖（さ）びたアーチ桥（きょう）\n舍（す）てた自転车（じてんしゃ） 木造（もくぞう）の駅（えき）のストーブの前（まえ）で\nどこにも旅立（たびだ）てない心（こころ） 今日（きょう）はまるで昨日（きのう）みたいだ\n明日（あす）を変（か）えるなら今日（きょう）を変（か）えなきゃ 分（わ）かってる　分（わ）かってる　けれど\n僕（ぼく）が死（し）のうと思（おも）ったのは\n心（こころ）が空（から）っぽになったから 満（み）たされないと泣（な）いているのは\nきっと満（み）たされたいと愿（ねが）うから\n僕（ぼく）が死（し）のうと思（おも）ったのは\n靴纽（くつひも）が解（ほど）けたから 结（むす）びなおすのは苦手（にがて）なんだよ\n人（ひと）との繋（つな）がりもまた然（しか）り\n僕（ぼく）が死（し）のうと思（おも）ったのは\n少年（しょうねん）が僕（ぼく）を见（み）つめていたから ベッドの上（うえ）で土下座（どげざ）してるよ\nあの日（ひ）の僕（ぼく）にごめんなさいと\nパソコンの薄明（うすあ）かり\n上阶（じょうかい）の部屋（へや）の生活音（せいかつおん） インターフォンのチャイムの音（おと）\n耳（みみ）を塞（ふさ）ぐ鸟（とり）かごの少年（しょうねん） 见（み）えない敌（てき）と戦（たたか）ってる\n六畳（ろくじょう）一间（ひとま）のドンキホーテ ゴールはどうせ丑（みにく）いものさ\n僕（ぼく）が死（し）のうと思（おも）ったのは\n冷（つめ）たい人（ひと）と言（い）われたから 爱（あい）されたいと泣（な）いているのは\n人（ひと）の温（ぬく）もりを知（し）ってしまったから\n僕（ぼく）が死（し）のうと思（おも）ったのは\nあなたが绮丽（きれい）に笑（わら）うから 死（し）ぬことばかり考（かんが）えてしまうのは\nきっと生（い）きる事（こと）に真面目（まじめ）すぎるから\n僕（ぼく）が死（し）のうと思（おも）ったのは\nまだあなたに出会（であ）ってなかったから あなたのような人（ひと）が生（う）まれた\n世界（せかい）を少（すこ）し好（す）きになったよ\nあなたのような人（ひと）が生（い）きてる\n世界（せかい）に少（すこ）し期待（きたい）するよ\n作者：残天大魔王 https://www.bilibili.com/read/cv10662266/ 出处：bilibili\n","date":"2023-10-16","permalink":"/posts/anime/bokugashinouto/","series":["动漫歌曲",""],"tags":["",""],"title":"僕が死のうと思ったのは"},{"categories":["计算机"],"content":"0x01 第一种方式：使用bash 新版Kali默认的shell是zsh，而常见添加环境变量的方式是通过/etc/profile中，最好再在~/.bashrc中source一下生效。为了使用bash，需要修改/etc/passwd文件中对应用户的默认shell，比如root用户将\n1root❌0:0:root:/root:/usr/bin/zsh 变为\n1root❌0:0:root:/root:/bin/bash 修改之后再用普通bash添加环境变量的方式就可以了。\n0x01 第二种方式：使用zsh 还是想用漂亮的zsh怎么办？那就在zsh中添加环境变量！\n只需要在~/.zshrc中末尾添加环境变量，这是不需要再source了：\n1N=\u0026#34;/usr/local/go/bin\u0026#34; 2export PATH=$PATH:$N 这是如果再在后面加上source ./zshrc的话，会循环使用这个文件。\n这里还有个问题，当使用sudo执行命令时，sudo命令为了安全考虑将PATH环境变量进行了重置，我们可以使用sudo visudo或者vim /etc/sudoers进行修改。具体关于su和sudo的区别可以参考下面这篇文章：\nhttps://blog.csdn.net/weixin_39490665/article/details/123130500\n0x03 引用 不得不说网络上东西错误有点多，搞了估计有3小时才解决。\n https://blog.csdn.net/qq_30895747/article/details/126872781 https://blog.csdn.net/weixin_51368459/article/details/127682963 https://blog.csdn.net/weixin_51368459/article/details/127682963 https://blog.csdn.net/xiaopang_love_study/article/details/127753262 ","date":"2023-04-07","permalink":"/posts/tech/env-var/","series":[],"tags":[""],"title":"Kali添加环境变量"},{"categories":["二次元"],"content":"寂寥的世界，空っぽの姿。\n 这首歌真的太寂寞了……故事最终空寂的结局。献给亲爱的世界。记11日雨。\n1.歌词  Silent Night\n寂静的夜\n降（ふ）り続（つづ）ける\n一直飘落着\n悲（かな）しみふりはらい\n抖落悲伤\nどんな\n无论\n言葉（ことば）でなら\n怎样的言语\n寄（よ）り添（そ）えるの\n能靠近的\n暁（あかつき）に流（なが）れ落（お）ちる星（ほし）\n拂晓时刻滑落的流星\n世界（せかい）が目覚（めざ）める\n世界从睡意中醒来\nあなたが歩（あゆ）む大地（だいち）に\n在你曾走过的大地上\n祈（いの）りを\nSilent heart\n静默的心\n触（ふ）れられない\n触碰不到的爱\n愛（あい）を嘆（なげ）かないで\n不必叹息\n願（ねが）い\n期望啊\n託（たく）す光\n托付这光辉\n星座（せいざ）になる\n化作星宿\n暁に染（そ）まる空（そら）の果（は）て\n破晓染红的苍穹尽头\nわたしを感（かん）じて\n冥冥中感到\nあなたと同（おな）じ景色（けしき）を\n看到了与你同样景色\n見（み）ている\n看见\nはじまりの\n初始的\n白（しろ）い夜明（よあ）けを\n黎明白光的熹微\nあなたと出会（であ）った\n与你相遇\n愛（いと）し世界（せかい）で\n在这令人倾慕的世界里\n信（しん）じる強（つよ）さ知（し）った\n更加坚信\n「I stay with your heart,\n我与你的心相依相偎\nso sweet.tight\n如此亲昵甜蜜\ndreaming in your heart,\n怀梦与你的心中\nhey yey haaaa\u0026hellip;」\n嘿嘿 哈哈哈啊\n暁（あかつき）に流（なが）れ落（お）ちる星（ほし）\n拂晓时刻滑落的流星\n世界（せかい）が目覚（めざ）める\n世界从睡意中醒来\nあなたが歩（あゆ）む大地（だいち）に\n在你曾走过的大地上\n祈（いの）りを\n祈求着\n捧（ささ）げ…\n献出（我的爱）\n","date":"2023-03-11","permalink":"/posts/anime/shinainaru/","series":["动漫歌曲","Galgame"],"tags":["",""],"title":" 親愛なる世界へ"},{"categories":["二次元"],"content":"suki！\n 歌词  作词 : 中島みゆき\n作曲 : 中島みゆき\n编曲 : 衣笠道雄\nマリコの部屋（へや）へ 電話をかけて\n拨出了麻里子家里的电话\n男と遊んでる芝居（しばい） 続（ずず）けてきたけれど\n虽然还假装自己正与男人愉快交往\nあの娘（むすめ）もわりと 忙しいようで\n但是她好像也是十分匆忙\nそうそうつきあわせても いられない\n草草挂断电话 甚至不肯听我多说几句\n土曜（どよう）でなけりゃ 映画（えいが）も早（はや）い\n今天并不是周六 电影院也早早散场\nホテルのロビーも\n一直呆在酒店的大厅\nいつまで居（い）られるわけもない\n恐怕也不是什么好主意\n帰れるあての あなたの部屋も\n本应该可以回到你的房间才对\n受話器（じゅわき）をはずしたままね 話し中（ちゅう）\n可是你的电话却一直占线 打不进去\n悪女になるなら 月夜（つきよ）はおよしよ\n如果一定要变成坏女人的话 请不要像明月之夜那样\n素直（すなお）になりすぎる\n一切都能够看得清清楚楚 我害怕变得这般率真\n隠（かく）しておいた言葉が ほろり\n埋藏在心中的话语也会一不小心\nこぼれてしまう 「行かないで」\n脱口而出 「求求你不要离开我」\n悪女になるなら\n如果一定要变成坏女人的话\n裸足（はだし）で 夜明（よあ）けの電車で泣（ない）いてから\n要先体会一下光脚站在清晨的首班车上\n涙（なみだ）ぽろぽろ ぽろぽろ\n眼泪哗啦哗啦 哗啦哗啦\n流（なが）れて 涸（か）れてから\n流个不停 最后干涸在脸颊的滋味\n女のつけぬ コロンを買（か）って\n买了一瓶男人才会用的古龙水\n深夜（しんや）のサ店（みせ）の鏡（かがみ）で うなじにつけたなら\n在深夜咖啡馆的镜子前涂抹在脖子上\n夜明（よあ）けを待って 一番電車\n无助地等待着天明的首班车\n凍（こご）えて帰れば わざと捨（す）てゼリフ\n倘若能拖着冻僵的身体回到家 我定会甩下一句愤怒的道别\n涙も捨（す）てて 情（せい）も捨てて\n丢掉眼泪 再丢掉温存\nあなたが早く私に 愛想（あいそ）を尽（つかす）かすまで\n最好能让你立刻变得讨厌着我\nあなたの隠（かく）す あの娘のもとへ\n这样我就能够尽快把你从我的心中\nあなたを早く 渡（わた）してしまうまで\n送到那个你一直瞒着我的女孩子身边了\n悪女になるなら 月夜（つきよ）はおよしよ\n如果一定要变成坏女人的话 请不要像明月之夜那样\n素直（すなお）になりすぎる\n一切都能够看得清清楚楚 我害怕变得这般率真\n隠（かく）しておいた言葉が ほろり\n埋藏在心中的话语也会一不小心\nこぼれてしまう 「行かないで」\n脱口而出 「求求你不要离开我」\n悪女になるなら\n如果一定要变成坏女人的话\n裸足（はだし）で 夜明（よあ）けの電車で泣いてから\n要先体会一下光脚站在清晨的首班车上\n涙ぽろぽろ ぽろぽろ\n眼泪哗啦哗啦 哗啦哗啦\n流（なが）れて 涸（か）れてから\n流个不停 最后干涸在脸颊的滋味\n 翻译","date":"2023-02-21","permalink":"/posts/anime/akujo/","series":["动漫歌曲","Galgame"],"tags":[""],"title":"悪女"},{"categories":["二次元"],"content":"不得不说雪莱唱歌真的太好听了，很喜欢，这都是2020年3月的记忆，现在整理。\n 歌词  小木曽雪菜 - 深愛\n作曲∶上松範康 (Elements Garden)\nTVアニメ『WHITE ALBUM2』挿入歌\n雪が舞（ま）い散（ち）る夜空（よぞら）\n雪花飞舞的夜空\n二人寄（よ）り添（そ）い見上（みあ）げた\n我们两人并肩仰望\n繋（つ）がる手と手の温（ぬく）もりは\n紧系著的手和手的温暖\nとても優しかった\n非常的和善\n淡（あわ）いオールドブルーの\n在淡薄蔚蓝的\n雲間（くもま）に消えて行（ゆ）くでしょう\n云彩间隙裏消逝了的吧\n永遠へと続（つず）くはずの あの約束（やくそく）\n本应该永远持续的 那个约定\nあなたの傍（そば）にいるだけで\n只要守候在你的身边\nただそれだけで良（よ）かった\n仅仅如此就心满意足了\nいつの間（ま）にか膨（ふく）らむ\n不知何时已膨胀起\n現実(いま)以上（いじょう）の夢に気付（きず）かずに\n穿越现实的梦而我却没有察觉\nどんな時（とき）もどこにいる時でも\n无论身处何时人在何方\n強く強く抱（だ）き締（し）めていて\n我们都能紧紧的互相拥抱\n情熱（じょうねつ）が日常（にちじょう）に染（そ）まるとしても\n尽管这份热情将生命映的火红\nあなたへのこの想いはすべて\n对於你的这个感情就是一切\n終わりなどないと信じている\n并坚信著不会有终结的一天\nあなただけずっと見つめているの\n仅仅只有你是我一直想要注视的\n交（か）わす言葉と時間\n交错的言词与时间\n姿（すがた）も変（か）えていくでしょう\n都会变换身姿的吧\n白い頬（ほほ）に解（と）けた それは月（つき）の涙（なみだ）\n从苍白的脸颊间满溢出的 那就是明月的泪水\n「行かないで、もう少しだけ」\n「请不要离开、在稍微留在我身边」\n何度も言（い）いかけては\n却多次欲言又止\n「また会えるよね？きっと 」\n「我们一定会再次相见的吧？」\n何度も自分に問（と）いかける\n已多次喃喃自语\n突然（とつぜん）走（は）り出（だ）した\n突然开始奔跑\n行（ゆ）く先（さき）の違（ちが）う二人 もう止（と）まらない\n目的地却不同的两人 已经不能再度止步了\n沈黙（ちんもく）が想像（そうぞう）を超（こ）え引（ひ）き裂（さ）いて\n沉默已将想像穿越撕裂\n一つだけ許（ゆる）される願（ねが）いがあるなら\n如果只有一个允许实现的愿望的话\n「ごめんね」と伝（つた）えたいよ\n只想将「抱歉」这句话传达给你而已哟\nいくら思っていても届かない\n不管怎样思考都传达不到\n声にしなきゃ 動（うご）き出（だ）さなきゃ\n难道必须要发出声音 必须要付出行动吗\n隠（かく）したままの二人の秘密\n隐藏了只属於两人的秘密\nこのまま忘れられてしまうの？\n这样下去就会被遗忘的吧？\nだから．．．ねぇ、早く今ココに来て．．．\n因此…呢、快点来到我的身边吧。。。\nあなたの傍にいるだけで\n只要守候在你的身边\nただそれだけで良かった\n仅仅如此就心满意足了\n今度（こんこ）めぐり会えたら\n下次再度与你相见的时候\nもっともっと笑い合（あ）えるかな．．．\n会有更多更多的互视而笑吗…\nどんな时もどこにいる时でも\n无论身处何时人在何方\n强く强く抱き缔めていて\n我们都能紧紧的互相拥抱\n情热（じょうねつ）よりアツイ体温（ねつ）で溶（と）かして\n尽管将比这份热情还要灼热的体温溶化了\nあなたへのこの想いはすべて\n对於你的这个感情就是一切\n终わりなどないと信じている\n并坚信著不会有终结的一天\nあなただけずっと见つめているの\n仅仅只有你是我一直想要注视的\n 翻译","date":"2023-02-21","permalink":"/posts/anime/shinai/","series":["动漫歌曲","Galgame"],"tags":[""],"title":"深愛"},{"categories":["二次元"],"content":"听到这首歌只有感动。\n 感動。\n1.歌词  作词 : 梶浦 由記\n作曲 : 梶浦 由記\nあたたかな風(かぜ)の中(なか)で\n在和煦的暖风中\n誰(だれ)かが呼(よ)んでる\n有谁在呼唤着\n暗闇(くらやみ)を惜(お)しむように\n惋惜这黑闇似的\n夜明(よあ)けが始(はじ)まる\n天色开始亮了\n明日(あした)はきっと\n明天一定\n綺麗(きれい)な空(そら)に\n绮丽的青空中\n銀色(ぎんいろ)の虹(にじ)がかかるでしょう\n也会映照着银色的彩虹吧\nこんなに哀(かな)しい景色(けしき)を\n如此哀伤的景色\n君(きみ)が光(ひかり)に変(か)えて行(い)く\n你将化作光芒\n小(ちい)さな涙(なみだ)の粒(つぶ)さえ\n小小的泪珠\n宝石(ほうせき)のように落(お)ちてく\n宛如宝石般落下\n未来(みらい)の中(なか)へ\n置于未来之中\n心(こころ)には秘密(ひみつ)がある\n心中仍有秘密\nそれでも触(ふ)れたくて\n就算如此也想触碰\n触(ふ)れ合(あ)えば壊(こわ)れて行(い)く\n明知一旦触碰便会崩坏\n躊躇(ためら)いは螺旋(らせん)の中(なか)へ\n踌躇中渐渐靠向螺旋\n橋(はし)を渡(わた)った河(がわ)の向(む)こうまで\n直到横月河川的桥樑\n明日(あした)はきっと……\n明天一定\n真昼(まひる)の中(なか)で\n在正午之时\n春(はる)は甘(あま)く深(ふか)く香(かお)るのでしょう\n春天发出甜又香的气味\n夢(ゆめ)から醒(さ)めて\n从梦中醒来\n人(ひと)は何(なに)を探(さが)すの\n人们在寻找着什麽呢\nこんなに明(あか)るい世界(せかい)へ\n如此明亮的世界\n君(きみ)が私(わたし)を連(つ)れて行(い)く\n你带着我一起前往\n眩(まぶ)しさにまだ立(た)ち竦(すく)む\n在耀眼而害怕中伫立\n背中(せなか)をそっと抱(だ)きしめる\n你悄悄紧抱我的背\n信(しん)じることの儚(はかな)さを\n深信没有结果的未来\n君(きみ)が光(ひかり)に変(か)えて行(い)く\n你将化成光芒\n目覚(めざ)めた朝(あさ)には涙(なみだ)が\n早晨清醒时流下了泪\n宝石(ほうせき)のように落(お)ちてく\n宛如宝石般落下\n未来(みらい)の中(なか)へ\n在未来之中\n 2.翻译 暖か [あたたか]【形容动词/ナ形容词】 1.暖和，不冷不热。 2.有钱，富足。 3.暖色。\n惜しむ [おしむ]【他动词・五段/一类】 1.珍惜；惋惜；吝惜。\n夜明け [よあけ]【名词】 1.天亮的时候，拂晓，天明。 2.（新时代的）黎明。\n触れ合え[ふれあう]【自动词・五段/一类】 1.互相接触，互相挨着。\n連れて連れて【接续词】 1.伴随着，随着，跟着。类似接续助词。\n立ち竦む[たちすくむ]【自动词・五段/一类】 1.惊呆，呆立不动。\n儚さ[はかなさ]【名词】 1.短暂、虚幻、无常。形容词「儚い」的体言化。\n3.乐谱","date":"2023-02-19","permalink":"/posts/anime/kimigahikarini/","series":["动漫歌曲"],"tags":["",""],"title":"君が光に変えて行く"},{"categories":["二次元"],"content":"经常会不自觉地哼起来的歌\n 歌词  \u0026hellip;\n\u0026hellip;\u0026hellip;\nすれ違う（ちがう）毎日が 増え（ふえ）てゆくけれど\n擦肩而过的每一天 虽然渐渐变得更多\nお互い（たがい）の気持ちはいつも 側にいるよ\n彼此之间的情意 总是一直相伴左右\n二人会え（あえ）なくても 平気（へいき）だなんて\n纵然你我无法相见 却也不曾觉得寂寞\n強がり言う（いう）けど 溜（た）め息（き）まじりね\n虽然可以强颜欢笑 其中却夹杂着叹息\n過ぎ（すぎ）てゆく季節に 置（お）いてきた宝物（たからもの）\n在逝去的季节中 遗失的宝藏\n大切なピースの欠（か）けた パズルだね\n是缺失一角的 珍贵拼图\n白い雪が街（まち）に 優しく積（つ）もるように\n就像白雪在街道上 温柔地堆积的样子\nアルバムの空白（くうはく）を全部（ぜんぶ） 埋（う）めてしまおう\n也将回忆相簿的空白 全部填满吧\n\u0026hellip;\n\u0026hellip;\u0026hellip;\n降り積（つ）もる寂しさに 負（ま）けてしまいそうで\n只盼可以不负于 心底堆积的寂寞\nただ独（ひと）り 不安な日々を過（す）ごしてても\n独自一人 送走不安的日子\n大丈夫だよって 肩（かた）をたたいて\n总会觉得没有问题 轻轻敲敲你的肩膀\nあなたは笑顔で 元気をくれるね\n因为还有你的笑容 便能给我无穷欢乐\nたとえ離（はな）れていても その言葉があるから\n纵然你我相隔万里 只要还有那句誓言\n心から幸せと言える 不思議（ふしぎ）だね\n心底就会感到无比幸福 这就是所谓的不可思议\n淡（あわ）い雪が私の ひそかな想い込（こ）めて\n淡淡白雪悄悄潜入 我无比纷乱的思绪\n純白（じゅんぱく）のアルバムの ページ染（そ）めてくれる\n那纯白的白色相簿 亦被染成雪的颜色\n\u0026hellip;\n\u0026hellip;\u0026hellip;\n過（す）ぎてゆく季節に 置（お）いてきた宝物\n在逝去的季节中 遗失的宝藏\n大切なピースの欠（か）けた パズルだね\n是缺失一角的 珍贵拼图\n白い雪が街に 優しく積（つ）もるように\n就像白雪在街道上 温柔地堆积的样子\nアルバムの空白（くうはく）を全部 埋（う）めてしまおう\n也将回忆相簿的空白 全部填满吧\n\u0026hellip;\nEND\n 翻译","date":"2023-02-18","permalink":"/posts/anime/white-album/","series":["动漫歌曲","Galgame"],"tags":[""],"title":"WHITE ALBUM"},{"categories":["二次元"],"content":" 这个寒假的记忆，喜欢りそな。歌词有着浓浓的gal味……但是这部作品让我喜欢上了这首歌。\n歌词  あなたの側に いつでも寄りそうから Happy!\n陪伴在你身边 不管什么时候都能这样 太开心了！\nワクワクするの 初恋の時みたい!!\n就好像初恋的时候 令人兴奋不已！！\n月夜の下で 見つめ誓い合うキミ キラリ…と!\n月夜之下 注视着许下誓言的你 一瞬间…呀！\nドキドキしよう 出会った あの日みたい!!\n就好像与你 邂逅的那一天 内心砰砰直跳！！\nHeartの行方\n我心所在\n未来に繋げて\n紧连未来\n過去は捨てるの\n抛弃过去\nさぁ…飛び込もう…!\n快…飞向未来！\nCutie キミだけの smileを見せて!\n对面的女孩看过来 让我欣赏你的笑容！\nAngel 僕だけに 煌めいた 笑顔!\n天使般的你 献给了我 灿烂的 笑容！\n思い出を 重ねて どこまでも 行きたい\n让我沉浸其中 不管在哪里 但愿与你同在\nわたしの側に 寄りそい支えるから いつでも!\n你在我的身旁 不管什么时候 都鼓励着我！\nキラキラしてる 瞳の奥の光…\n眨巴眨巴的双眼 炯炯有神…\n桜の下で 出会い別れあう時 またね…と!\n樱树之下 重逢之时却又分手 再见了…呀！\n悲しくいよう いつかの会える日まで…\n在没有你的日子里 我的内心饱受煎熬…\n涙の雫\n泪飘零\nポロリ…と溢れて\n一颗颗…满溢而出\n笑顔になろう\n笑一笑好不好\nねぇ…扉開けよう!\n乖啦…打开心扉吧！\nSmiley わたしにも 出来るかな? 笑顔…\n笑起来 我的话 也能够做到吗？笑容…\nHappy! はにかんで 輝きの 天使\n好开心！ 那羞答答的 耀眼的 天使\n空を見て 目を閉じ…\n面朝蓝天 闭上双眼…\nSweetie またいつか 会える日が来るよ\n亲爱的 总有一天 我们还会再次相遇\nCatch me その日まで 離さずにいてね!\n跟上我 那天来临之前 不要离开我身边！\nCutie キミだけの smileを見せて!\n对面的女孩看过来 让我欣赏你的笑容！\nAngel 僕だけに 煌めいた 笑顔!\n天使般的你 献给了我 灿烂的 笑容！\n思い出を 重ねて どこまでも 行きたい\n让我沉浸其中 不管在哪里 但愿与你同在\n 翻译","date":"2023-02-12","permalink":"/posts/anime/sweet-heart-cherry/","series":["动漫歌曲"],"tags":[""],"title":"Sweet Heart Cherry"},{"categories":["二次元"],"content":" 最近喜欢听的一首歌\n歌词  花は散りゆく季節はめぐる\n花朵凋零飘落 季节流转变迁\n涙ひとしずくこぼれ落ちる\n一滴眼泪夺眶而出\nいつか思い出に出来るかな\n何时才能让这变成回忆呢\n好きすぎるからもうサヨナラ\n因为太过喜欢 所以选择说出再见\nサヨナラ\n再见\nmiwa\n想いの果ては空の彼方へ\n思念的尽头去向无际的天空\n海の底よりも深いなんて\n比海底还要更深\nほんの少しの未来見えたって\n其实可以窥见到些许的未来\n淡い期待だけさせないで\n请不要让我有这样小小的期待\n想いの果ては空の彼方へ\n思念的尽头去向无际的天空\n悲しみに悲しみ重ねないで\n不要让悲伤继续重叠\nいつかきらいになるその前にもう\n在我变得讨厌你之前\nサヨナラ\n说出再见\n名前呼ぶ声がやさしいよね\n你呼唤我名字的声音是那么的温柔\nずっと続いてく気がしてた\n曾以为可以一直这样下去\nぬくもりは近くにあるのに\n温暖明明还在身旁\n私はどこかさみしかったの\n我却不由得寂寞起来\n花は散りゆく季節はめぐる\n花朵凋零飘落 季节流转变迁\n涙ひとしずくこぼれ落ちる\n一滴眼泪夺眶而出\n始まらない二人だから\n我们二人无法开始\nこんなに好きだけどサヨナラ\n即使如此喜欢 还是要说出再见\nサヨナラ　サヨナラ　サヨナラ　サヨナラ\n再见 再见 再见\nI don\u0026rsquo;t wanna say\n我并不想说啊\n過ぎ去りし日々は流れる雲\n逝去的时日仿佛流动的云朵\n形を変えて空に溶けても\n就算形状变幻 消逝于天空\n埋まらない心の隙間はなぜ\n无法填补的内心空隙\n二人を遠ざけてしまうの\n为何将我们二人疏远\n過ぎ去りし日々は流れる雲\n逝去的时日仿佛流动的云朵\nわかり合っていると信じてたの\n曾相信着我们能够互相理解\nいつか消えてしまうその前にもう\n在那信任消失之前\nサヨナラ\n说出再见\nなんていやだよ\n果然还是做不到\n抱き締める腕はあたたかくて\n紧抱着我的双臂是那么的温暖\nいつも幸せを感じてた\n总能让我沉浸于幸福之中\n信じるたびに強くなれた\n每当这样相信便能更加坚强\n求めてばかりで脆(もろ)くなった\n可一味渴求只能让这更加脆弱\n花は散りゆく想いはめぐる\n花朵凋零飘落 思念巡回流转\n涙ひとしずくこぼれ落ちる\n一滴眼泪夺眶而出\nこれ以上そばにいれないの\n我已不能再伴你身旁\n届かない背中にサヨナラ\n望着无法触及的背影 说出再见\nサヨナラ　サヨナラ　サヨナラ　サヨナラ\n再见 再见 再见\nI don\u0026rsquo;t wanna say\n我并不想说啊\n巡り逢えたこと　間違いじゃないよね\n我们的相遇 绝不是个错误\nだけどもう伝えられない\n但是思念已无法传达\nこんなにも好きなのに\n虽然明明如此喜欢\n花は散りゆく季節はめぐる\n花朵凋零飘落 季节流转变迁\n涙ひとしずくこぼれ落ちる\n一滴眼泪夺眶而出\nいつか思い出に出来るかな\n何时才能让这变成回忆呢\n好きすぎるからもうサヨナラ\n因为太过喜欢 所以说出再见\n名前呼ぶ声も　抱きしめる腕も\n呼唤我名字的声音 紧抱我的双臂\n二人の未来も　昨日までの思い出も\n你我二人的未来 到昨日为止的回忆\nI don\u0026rsquo;t wanna say\n我不想说再见\n想いの果ては空の彼方へ\n思念的尽头去向无际的天空\n想いの果ては空の彼方へ\n思念的尽头去向无际的天空\n 翻译","date":"2023-02-12","permalink":"/posts/anime/sayorana/","series":["动漫歌曲"],"tags":[""],"title":"サヨナラ"},{"categories":["二次元"],"content":" 同样是耳熟能详的歌曲，很好听，所以决定记录发音在这里。Lisa唱歌真好听啊。\n歌词  さよなら　ありがとう　声の限り\n声嘶力竭喊出道别与感谢\n悲しみよりもっと大事なこと\n这是比悲伤更加重要的事\n去りゆく背中に伝えたくて\n多想传递给你远去的背影\nぬくもりと痛みに間に合うように\n希望还能够体会你的冷暖\nこのまま続くと思っていた\n原以为会就这样延续下去\n僕らの明日を描いていた\n与你一起描绘美好的未来\n呼び合っていた光がまだ\n照亮我们彼此的那束光芒\n胸の奥に熱いのに\n令我的心一直炽热地跳动\n僕たちは燃え盛る旅の途中で出会い\n在焰火绽放的旅途中相遇\n手を取りそして離した　未来のために\n紧握的手最终被命运分开\n夢が一つ叶うたび　僕は君を想うだろう\n每实现一个梦想 我都会想起来你\n強くなりたいと願い　泣いた　決意を餞に\n痛哭着说要变强 以决意为你饯别\n懐かしい思いに囚われたり\n沉湎于对你的回忆和思念\n残酷な世界に泣き叫んで\n恸哭于这世界竟如此残酷\n大人になるほど増えて行く\n越长大我想获得的就越多\nもう何一つだって失いたくない\n可却不愿再忍受任何失去\n悲しみに飲まれ落ちてしまえば\n若让自己被悲伤吞噬殆尽\n痛みを感じなくなるけれど\n君の言葉　君の願い\n虽然会陷入麻木不再疼痛\nは守りぬくと誓ったんだ\n但你曾说过的话语和愿望\n音を立てて崩れ落ちて行く\n是我倾尽一生守护的誓言\n一つだけの\n发出巨大轰鸣逐渐崩塌的\nかけがえのない世界\n这个无法被替代的世界\n手を伸ばし抱き止めた激しい光の束\n伸手去抱住那道灼目的光\n輝いて消えてった　未来のために\n你闪耀光芒消失在了未来\n託された幸せと　約束を超えて行く\n超越托付于我的幸福约定\n振り返らずに進むから\n我将头也不回地继续前进\n前だけ向いて叫ぶから\n我会一往无前地发出呐喊\n心に炎を灯して\n燃烧我的心灵\n遠い未来まで……\n奔赴遥远未来\n 翻译","date":"2023-01-25","permalink":"/posts/anime/homura/","series":["动漫歌曲"],"tags":[""],"title":"炎"},{"categories":["二次元"],"content":"丸户史明真神。最平衡的三角关系，友情与爱情。\n 虽然是快四年前看过的作品，三年前也通过视频的方式通过了cc部分，但其中蕴含的感情始终忘不了，一接触到相关的东西（冬马の顔）便会涌上心头。白色相簿2的音乐，剧本，立绘，声优都很记忆深刻。丸户史明真神。作为白2代表之一的届恋，自然是集白2种种心绪为一体的，一听便会联想到很多很多，所以这样的歌曲，不会唱不行啊！ 歌词  孤独（こどく）なふりをしてるの？\n莫非你是在故作孤独？\nなぜだろう 気（き）になっていた\n为何心如此为你牵动\n気（き）づけば いつのまにか\n回过神来 不知不觉\n谁（だれ）より 惹（ひ）かれていた\n我已被你深深吸引\nどうすれば この心（こころ）は\n要怎样才能将我的心\n镜（かがみ）に映（うつ）るの？\n映在镜中让你看清？\n届（とど）かない恋（こい）をしていても\n即使是场终成奢望的爱恋\n映（うつ）しだす日（ひ）がくるかな\n是否也有映在镜中的一天\nぼやけた答（こた）えが 見（み）え始（はじ）めるまでは\n在能够看见隐约的曙光之前\n今（いま）もこの恋（こい）は 動（うご）き出（だ）せない\n这场爱恋如今依然寸步难行\n初（はじ）めて声（こえ）をかけたら\n当我第一次出声相唤\n振（ふ）り向（む）いてくれたあの日（ひ）\n当你第一次回首之时\nあなたは 眩（まぶ）しすぎて\n你的身影是那么耀眼\nまっすぐ見（み）れなかった\n让我不禁移开目光\nどうすれば その心（こころ）に\n要怎样才能将我的名\n私（わたし）を写（うつ）すの\n深深映在你的心中？\n叶（かな）わない恋（こい）をしていても\n即使是场没有结果的爱恋\n写（うつ）しだす日（ひ）がくるかな\n是否也有映在你心的一天\nぼやけた答（こた）えが 少（すこ）しでも見（み）えたら\n哪怕能看见一丝隐约的曙光\nきっとこの恋（こい）は 動（うご）き始（はじ）める\n这份爱恋一定能够开始转动\nどうすれば この心（こころ）は\n要怎样才能将我的心\n镜（かがみ）に映（うつ）るの？\n映在镜中让你看清？\n届（とど）かない恋（こい）をしていても\n即使是场终成奢望的爱恋\n映（うつ）しだす日（ひ）がくるかな\n是否也有映在镜中的一天\nぼやけた答（こた）えが 見（み）え始（はじ）めるまでは\n在能够看见隐约的曙光之前\n今（いま）もこの恋（こい）は 動（うご）き出（だ）せない\n这场爱恋如今依然寸步难行\n 翻译 ふり【名词】：假装，装出\n気づく[きづく]【自动词・五段/一类】：注意到，察觉，意识到，认识到。\nより【副词】：更\n惹かれる[ひかれる] 【自动词・一段/二类】：心被吸引了\n映る [うつる]【自动词・五段/一类】：反射。\n動き [うごき]【名词】：动，活动，移动。\n出せ[だす]【他动词・五段/一类】：出，发，使出发。\n振り向く[ふりむく]自动词・五段/一类】：回头。\n眩しい[まぶしい]【形容词/イ形容词】：晃眼，耀眼。\nまっすぐ 【副词・形容动词/ナ形容词】：正直；坦率；耿直。\n叶う [かなう]【自动词・五段/一类】：能实现，能如愿以偿。\n写し [うつし]【名词】：抄本，本，摹本，誊本。\nぼやけた：模糊的；不清楚的；污脏的；毛茸茸的；淡漠；眼花；茫昧；灰败；昏茫\nたら：要是，如果，……的话。\n","date":"2023-01-24","permalink":"/posts/anime/todokanaikoi/","series":["动漫歌曲","Galgame"],"tags":[""],"title":"届かない恋"},{"categories":["二次元"],"content":"温柔美好的未来。\n 素晴日中我最喜欢的音乐，不是夜の向日葵（よるのひまわり），夏の大三角（なつのだいさんかく），而是这首言葉と旋律（せんりつ）。我认为这首歌代表了游戏中所有人尤其是柘榴和间宫（三人）所向往的那个温柔美好的未来。音乐本身听起来很华丽，有种让人翩翩起舞的感觉，中途稍有起伏，让我确信这就是本应该的未来，柘榴间宫应该在那样的世界，或者他们的脑海中已经存在的世界。\n ［间宫］「西哈诺的话……有种让人情不自禁的感觉……」\n［柘榴］「嗯」\n［间宫］「精神正派的人都会从他的ｐａｎａｃｈｅ中得到勇气呢」\n［柘榴］「ｐａｎａｃｈｅ？」\n［间宫］「嗯，对，西哈诺在被亡魂带走的最后一幕中，喊过“勇气”吧」\n［柘榴］「嗯……“你们要抢走我的一切”」\n［间宫］「“……来，抢吧，尽管抢吧！但有一样东西，你们只能任凭我带进天堂！”」\n［柘榴］「“我一行礼就把蔚蓝的入口清扫得纤尘不染，这东西没有一丝皱褶，没有一个污点，你们只能任凭我把它带走”」\n［柘榴］「“那就是我的……勇气！”」\n［间宫］「记得很清楚嘛」\n［柘榴］「只是……多看了几次之后就……」\n［间宫］「顺便说一下，他最后想要带走的东西。Ｍｏｎ ｐａｎａｃｈｅ……就是羽饰」\n［柘榴］「羽饰？」\n［间宫］「是的，他帽子上的羽饰」\n［柘榴］「是么？」\n［间宫］「那好像可以引申为“男子汉的勇气”呢」\n［间宫］「所以，其他的译本在羽毛上面注解为“勇气”呢」\n［柘榴］「是这样啊」\n［间宫］「在夺走一切的死神面前，西哈诺最后留下的话语很精彩啊」\n［间宫］「特别是死时对着天空吼出Ｍｏｎ ｐａｎａｃｈｅ！……真让人陶醉」\n［间宫］「对这种勇气无动于衷的人……对这种行为莫名惊诧的人……」\n［间宫］「如果那种家伙是正常的话，那我觉得我还是奇怪点好」\n 我……想再次变回蝼蚁么？\n在镜中世界微微蠕动的……蝼蚁……\n不是我……是某个遥远的地方的蝼蚁……\n但又不是……\n镜中的蝼蚁……是我。\n不对，没有什么镜中世界……镜子只是映出我的样子而已……\n那是我。\n「所以……」\n映在镜中的……是我。\n蝼蚁的做法……\n我是蝼蚁……\n蝼蚁……\n但是……\n我是……剑士……我是诗人……我是哲学家……我是……我是……我是……\n我才不是什么蝼蚁……\n……\n我要改变……\n柘榴正如镜中的昆虫（looking-glass insects），一直观察着自己的所作所为，但却无法控制，就像没有自我意识一样（联想某些里番也有类似的降智人物），她软弱，随波逐流。如果再早一点遇见西哈诺？再多给一点时间成长？毕竟是极端的艺术形象（不否定现实这种事情也很多）。優しい世界でありますように。\n","date":"2023-01-24","permalink":"/posts/anime/kotoba/","series":["",""],"tags":[""],"title":"言葉と旋律"},{"categories":["二次元"],"content":"看空之境界中印象很深的一首歌。\n 今年的11月和12月，是TypeMoon的季节，看了空之境界玩了旧版月姬，再准备玩魔法使之夜。空之境界真的太好看了，十足的艺术品！翻译等考研结束再补充，先挖坑。\n1.歌词  子供[こども]の頃[ごろ]に置[お]いてきた\n独自一人默默忆起了\n夢を思い出[だ]した\n孩提时代早已尘封的梦想\n若[わか]草色[くさいろ]の哀しみを\n轻声细语、甜美地吟唱着\n細[ほそ]く甘く[あまく] 歌う my fairytale\n浸淫在浅绿中的悲伤\n何も終わることのない\n早已明白所谓\u0026quot;永远\u0026quot;\n永遠を知っていた\n只是个美丽的传说\nもう誰も語[かた]らない\n再也不会有人提起\n二人の物語[ものがたり]\n只属于你我的故事\nキスを一つ残[のこ]して\n留下淡淡吻痕\n君は何処[どこ]へ行く\n你将去向何方\n灯火[ともしび]一つ抱[だ]いて\n手握一盏明灯\n森[もり]に消えて行く\n逝于森林尽头\nずっと遠くへ歩いて[あるいて]\n一直向着远方行走\n懷かしい面影[おもかげ]\n那令人怀念的容貌\nずっと遠くが君の家\n远在他方的你的家\n辿り[たどり]着[つ]けはしない\n也许永远无法到达\n夢に見た永遠は閉[と]ざされたままで\n梦境中的永远（仍被紧紧封锁）\n過ち[あやまち]は深く[ふかく]隠[かく]されたままで\n往日里的过错（依旧深深匿藏）\n消えていく帰り道\n归途逐渐消逝\n君がもう見えない\n你亦踪迹难寻 ……再见了吧\n霧[きり]の森を抜け[ぬけ] て\n逃离迷雾之森\n君は何処へ行く[ゆく]\n你将去向何方\n一つだけ手を振[ふ] って\n挥手诀别昨日\n明日[あす] へ去[さ]って行く[ゆく]\n独自去往明天\n君を好きになって\n只因爱上了你\n永遠は終わる\n永远亦会终结\n生きて行く喜びと\n生存的喜悦与悲痛\n痛みが始まる in the light\n一切都已拉开序幕\n 2.翻译 頃 [ごろ]1.……时分，……前后，……左右。2.正好的时候，正合适的时候〔程度〕。\n置く[おく]【他动词・五段/一类】1.放；配置；设立；留下；丢下；掌握；间隔；保持；计算；作抵押；定；留在心里；下露水或霜；保持下去；表示预先做好某种事；暂时。\n若 [わか]【形容词/イ形容词】1.年轻的。2.少年。3.主要用于身份地位高的人家的男孩。\n草色 [くさいろ] 【名词】1.草绿色。\n細 [ほそ]1.与名词或形容词组成复合词。细的。窄的。弱的。2.以“ぼそ”的形式接在名词之后组成复合词。细的东西。\n甘く [あまく] 【形容词/イ形容词】1.（形容词甘い的连用形）甜。淡。姑息。\n語る[かたる]【他动词・五段/一类】1.谈，讲，讲述。2.说唱。\n残す [のこす]【他动词・五段/一类】1.留下；剩下；遗留；（相扑中顶住对方的攻击）站稳。\n抱く [だく]【他动词・五段/一类】1.抱；搂抱；怀抱。2.孵（卵）。3.男人和女人发生两性关系。\n面影 [おもかげ]【名词】1.心中浮现的面貌。2.令人想起旧时的痕迹。\n辿り [たどり]【名词】1.追溯，查找。2.探求事物本质及其能力。\n着く[つく]【自动词・五段/一类】1.达到；运到；到达，抵达。\n閉ざす [とざす]【他动词・五段/一类】1.关闭。2.封，封闭，封锁。3.封上，封住。4.憋在心里。5.同：鎖す\n過ち [あやまち]【名词】1.过错，过失，罪过。2.错误，错儿，失败。\n隠す[かくす]【他动词・五段/一类】1.隐藏，躲藏，遮掩，遮蔽。2.隐瞒，掩盖，掩饰。\n抜ける [ぬける]【自动词・一段/二类】1.脱落；掉落。2.漏掉。3.穿过，通过狭窄的地方到对面。4.偷偷溜走；逃走；退出。5.迟钝；（智力）低下。6.透彻；清澄。7.（布料因不结实）变薄。\n3.乐谱","date":"2022-12-10","permalink":"/posts/anime/fairytale/","series":["动漫歌曲"],"tags":["",""],"title":"Fairytale"},{"categories":["二次元"],"content":"1.歌词  静(しず)けさから歩(ある)き出(だ)す\n我从寂静中迈步而出\nまだ见(み)ぬ爱(あい)の景色(けしき)へ\n走向未曾见过的爱情\nこの痛(いた)みを信(しん)じたいの\n为确认伤痛的真切\n夜(よる)を越(こ)えて\n我要穿越这片黑夜\n贵方(あなた)が触(ふ)れた胸(むね)に优(やさ)しい伤(きず)が一(ひと)つ\n你的手抚过我的胸口 留下一道浅浅的伤痕\n隠(かく)していた涙(なみだ)が红(くれない)に零(こぼ)れ落(お)ちて\n让我隐藏已久的泪水 化作鲜红的血珠滴落\n冷(つめ)たい肌(はだ)の上(うえ)にやっと灯(とも)した花(ばな)びら\n在我冰冷的肌肤之上 终于点亮了一朵鲜花\n私(わたし)がここにいる さいわいを歌(うた)うよ\n而此时此刻我在这里 为这份幸福而高歌\nもう梦(ゆめ)も终(お)わる\n当漫长梦境已然终结\n星(ほし)くずが消(き)える顷(ころ)\n繁星也将消失的时候\nねえ、生(い)きていると分(わ)かるほど抱(だ)きしめて\n为了感受生命的存在 请你将我紧拥在怀中\n静(しず)けさから生(う)まれて\n我从寂静中诞生于世\nまだぬくもりも知(し)らず\n未曾知晓温暖的感觉\nただいのちに届(とど)きたいの\n只为寻找到生命所在\n夜(よる)を越(こ)えて\n我要穿越这片黑夜\nなつかしいなつのあめ\n令人怀念的夏日细雨\n私(わたし)を见送(みおく)ってね\n仿佛在默默为我送行\n信(しん)じ合(あ)う始(はじ)まりへ\n愿我能带着泪水走向\n泣(な)きながら行(い)けるように\n尝试彼此信赖的开端\nよろこびもかなしみも\n无论是欣喜还是悲伤\n刻(きざ)みつけたい深(ふか)く\n都愿深深铭刻于心中\n贵方(あなた)とここにいる\n作为曾与你在此相伴\nさいわいの名残(なごり)に\n所留下的幸福痕迹\n星(ほし)くずが消(き)える顷(ころ)\n在繁星即将消失的时候\n初(はじ)めて见(み)る光(ひかり)の中(なか)で\n在初次见到的曙光之中\nその瞳(ひとみ)で くちづけで\n请用目光给我一个吻\n恋(こい)した迹(あと)を下(くだ)さい\n为我留下爱过的痕迹\n生(い)きることに贯(つらぬ)かれて泣(な)いてみたい\n让生命贯穿我的躯体 我愿试着去哭泣\n静(しず)けさから歩(ある)き出(だ)す\n我从寂静中迈步而出\nまだ见(み)ぬ远(とお)い夜明(よあ)けへ\n走向未知的遥远黎明\nただ愿(ねが)いを叶(かな)えたいの\n只为实现心中的愿望\n夜(よる)を越(こ)えて\n我要穿越这片黑夜\n 2.翻译 以后再补。\n3.乐谱","date":"2022-12-10","permalink":"/posts/anime/kizuato/","series":["动漫歌曲"],"tags":["",""],"title":"傷跡"},{"categories":[""],"content":"原句，部分词翻译（网络搜索，和整句翻译（来源于汉化组等）\n1.说明 片段选取标准源于我游戏时的体验，因人而异。游戏中有很多短的有趣的对话我就不放在这里了。我个人对剧情中的暴力场景无感（难受和厌恶），虽然它只是加强作用，但游戏展现的暴力并不比现实强多少。对于电波话语，有美的，也有恶心难受的，不求理解意思，只是各个词语组成的直观感受（将单个词语的几种意思，和所有词语综合起来的感受）。正因有了各种场景展现对比，游戏中关于哲学，戏剧等思考和交流才更加地耀眼和迷人，当然，音乐也是一绝。幸福地活下去吧！\n之后预期会做个人人物的语句摘录，和卓司控制人的技巧，心理学一些东西。当然都需要很长时间，不知道什么时候能做完。\n2.摘录片段 Down the rabbit Hole Down the rabbit Hole Ⅱ It\u0026rsquo;s my own Invention Looking-glass Insects Jabberwocky Which Dreamed It JabberwockyⅡ","date":"2022-11-13","permalink":"/bin/subarashikihibi-1/","series":[""],"tags":["",""],"title":"素晴日剧本片段"},{"categories":["计算机"],"content":"0. 前情 从9月开始，我的gal时间就是素晴日了，最近一口气在几天时间内完成了游戏的90%内容，三个结局，希实香线，HE线都全部通关了。我特别喜欢素晴日，而我表达喜欢的方式就是收集它相关的所以资源，各种cg立绘音乐cd特典什么的全都想要。而我去寻找cg时，发现那篇帖子的资源链接已经被百度封了，于是只得自己动手开干，这就是背景。\n1. 游戏解包\u0026amp;CG提取 从帖子中得知了解包用的软件是GARbro（这个名字我不忍吐槽，我还以为是我误看了pro），之后一切都非常顺利，成功从游戏中提取了图片，视频和音频。毕竟是10年前的游戏，就算是10周年特别版也没有修改底层系统，所以轻松提取了，全程傻瓜式操作。我发现这个系统和脏翅膀的系统是同一个。提取图片时我选择了转换格式为png，为的是最大的清晰度，当然文件体积也涨了好几倍。\n 2. 剧本提取 这一部是耗时最多的一步，原因在于剧本文件的编码。\n在游戏目录中arc的1开头的文件，正是游戏脚本文件，利用GARbro可以轻松提取出来，我尝试了很多编码，但无论用什么编码打开文本，浮现的始终是乱码。\n 这里推测可能性有两种，一是编码不对，二是编码大体是对的，但更重要的在于BGI系统自定义了许多的编码，或者是打乱了正常的编码。于是乎想要解决这个问题，我要么自己去核对推测编码自己破解，要么去找现成的轮子，别人已做的工作。我肯定选择后者，于是我开始了搜索，在汉化吧里面搜索“BGI”时我发现了线索，这将我引到了github，然后一下子找到了decoder。  这个是C#编写的，不过也不需要我理解除非我要看看它是怎么处理字符的。我用vscode编译了之后得到了docoder，就已经可以用了，但我还是瞥了眼代码。多么详细的注释啊！加上C#代码不是难理解和我编写小工具的经验，我觉得如果我想研究的话，我肯定看得懂！谢谢你，xupefei超人！！！你拯救了我的爱！\n 好了，现在问题来到了最后一步。游戏脚本文件是很多的，我总不可能一下一下每个文件去运行吧？于是我想到了bat批处理脚本。在我快速回顾遍历bat脚本后，我惊讶地发现我需要的bat脚本只需一行代码：for %%i in (.\\other\\*) do ( ScriptDecoder.exe %%i) ，当然还可以在后面加个重定向，更加舒服。问题就此解决了~我成功得到了游戏脚本。在我后续对脏翅膀提取剧本时，又出现日语编码问题了，待续未完。\n 3. 结尾 不可全部否定功利主义是我的结论，所以我将成果发到了贴吧上祈求别人表扬~但功利主义始终不是我的结果，我想要幸福地活下去！无论是艺术形而上也好，还是悲剧人生（目前我喜欢的哲学家可不是叔本华和尼采，而是康德。我之前一直觉得数学是唯一真神，超脱宇宙，而当我在阅读纯理性批判时，感受到了康德也是位非常像数学家的哲学家，先天分析判断是数学似的）。\n“我喜欢的人是……诗人……也是剑客……哲学家……还是空气力学的先驱者……” 我会写很多东西来纪念，表达我对素晴日的爱。最后附上我解包出来的图片吧。\n 谁不想要一个可爱的妹妹呢？ ","date":"2022-11-06","permalink":"/posts/tech/gal-extract/","series":["Galgame"],"tags":["",""],"title":"记第一次从gal中解包提取素材和剧本"},{"categories":[""],"content":"10月快见底了，想写写什么东西，但最近都在疯玩让自己好好休息，所以书没怎么读（没兴趣），歌曲也没有特别感触深的，于是决定随便聊聊来给10月划上句号。标题这两个话题算是我近期感触比较大的。\n阿西莫夫的小说 在9月读完《球状闪电》后，我继续读更多的科幻小说，这期间接触了两本阿西莫夫的小说《银河帝国》系列《神们自己》。但这两本我都读不懂，我总觉得废话太多了不对我口味，个人的心理活动太重了。我立马想到了唯物史观和唯心史观的区别，不知道是不是这种层面的差异导致我不喜欢这小说。\n虽然中间漫长的过程我不喜欢，但是这两本书的有些概念我是特别喜欢感兴趣的，比如“心理史学”“钨186”等，感兴趣的可以自己去看书。至于没看完的两部小说，等到我以后实在无聊了可能会重新拾起吧。\n简奥斯汀所处的时代 《傲慢与偏见》是我很早就看过的，最近想重新看一遍，就下载了一本电子版，这本电子版的导读非常精彩，译者对这本书的差评进行了种种说明和否定。让我感受到了时代对个人的引力是多么大，我们自己也始终是在历史中，同时个人的个性和主观批评又多么不重要trivial。我会这部分复制到文章末尾，有兴趣的可以读一读。\n","date":"2022-10-28","permalink":"/bin/free-talk/","series":[""],"tags":["",""],"title":"杂谈——阿西莫夫的小说\u0026简奥斯汀所处的时代\u00261984"},{"categories":["文字类"],"content":"有剧透，没看过原书建议不要点开。\n1.读后感 花了差不多两周断断续续将这本书读完了。我最喜欢这本书的地方在于刘慈欣将“电子，原子，量子效应 “夸张放大了，使我们能够在宏观现实中感受到这些粒子的物理效应，让我们能够看得见摸得着的电子，原子，与量子状态的物体和人，让我们能看到宏观尺度的量子现象而不是双缝实验的光！这些概念本身就很浪漫（如观察者），就像是意志能够真真切切地实际直接对现实影响，真正的“世界是我的表象和意志”！“我的心中永远有它的一席之地”。同时也让我回忆起在20世纪初，人们关于量子与上帝，宿命论和自由意识论的争论。和《三体》中的“永远一直走入黑洞奇点的数学家”一样的感觉~ 同时有些地方和《星际穿越》的黑洞中信息传递有点既视。整体这部作品我很喜欢。\n看这本书的时候没有用好软件的书签功能，下次写读后感，摘录书籍的时候就会全面些了。对于比较长的书籍，我会分几篇来摘录或者精简篇幅。下面是我喜欢的一部分片段。故事是一个整体，更多的好东西只有去读完才能知道。\n2.摘录片段 宏电子的解释  “我们之所以能看到空泡，是因为这一处弯曲的空间使经过它的光线弯曲，这形成了它可见的边缘。”丁仪继续解释道。\n“那你为什么认为它是电子，而不是质子或中子呢？”许大校问。\n“问得好，其实答案也很简单：空泡被闪电激发成球状闪电再恢复成空泡的过程，实际就是电子由低能级被激发成高能级，再跌回低能级的过程。在三种粒子中，只有电子能够被这样激发。”\n“也正因为它是电子，才能够沿着超导线传输，并在超导电池中像循环电流一样永不停息地运行。”林云恍然大悟地说。\n“可很奇怪的，它的直径与那节电池差不多。”\n“对于宏电子来说，波粒二象性中波的形态占很大比重，所以它的大小的意义与我们常识中的完全不同。它还有很多令人难以置信的特性，我们以后会慢慢看到的，我相信这会改变大家对世界的看法。不过现在，我们要先给这些大电子取一个名字，它们是宏观尺度的电子，就叫宏电子吧。”\n 量子态的物体  丁仪将电脑翻过来让我看，我看到在主板上，CPU和内存条的插槽全是空的。\n“当我观察的那一瞬间，量子波函数坍缩了。”丁仪将电脑轻轻放到桌子上，它的屏幕仍是黑的。\n“你是说，被烧毁的CPU和内存条也像宏电子那样处于量子态？”\n“是的，换句话说，在与宏电子发生物质波共振后，每一块芯片也转化成了宏量子，它们处于不确定状态，也就是同时处于两种状态：被烧毁和未被烧毁。刚才，在电脑启动的时候，它们处于后一状态，在那个时候，CPU和内存条完好无损地插在主板上的插槽中，而我的观察使它们的量子态又坍缩到被烧毁的状态了。其实，从本质上说，球状闪电的能量释放，就是它与目标的两团概率云的重叠或部分重叠。”\n“那么，在没有观察者的时候，那些芯片何时是处于完好状态的呢？”\n“这不确定，只是一个概率事件，你可以认为，这台电脑笼罩在那些芯片的概率云之中。”\n“那些被烧掉的试验动物，它们也处于量子态吗？”我紧张地问，预感到自己正在接近一个令人难以置信的真相。\n丁仪点点头。\n我实在没有勇气问出下一个问题，丁仪平静地看着我，显然早已知道我在想什么。\n“是的，还有人，所有死于球状闪电的人，都处于量子态，严格地说他们并没有真正死去，他们都是薛定谔的猫，在不确定中同时处于生和死两种状态。”丁仪站起身来踱到窗前，看着外面浓重的夜色，“对于他们，生存还是死亡，确实是个问题。”\n“我们能见到他们吗？”\n丁仪对着窗挥了一下手，像是要坚决赶走我脑子中的这个念头，“不可能，我们永远不可能见到他们，因为他们的坍缩态是死亡，他们只能在量子态中的某个概率上以生存状态存在，当我们作为观察者出现时，他们立刻坍缩到毁灭态，坍缩到他们的骨灰盒或坟墓中。”\n“你是说，他们活在另一个平行世界？”\n“不不，你理解有误，他们就活在我们的世界，他们的概率云可能覆盖着相当大的范围，也许，他们现在就站在这个房间中，站在你背后。”\n我的脊背一阵发冷。\n丁仪转过身来指着我的身后，“但当你回头看时，他们立刻坍缩到毁灭态。相信我，你或其他任何人永远不可能见到他们，包括摄像机在内的任何观察者也永远不可能探测到他们的存在。”\n“他们能在现实世界留下非量子态的痕迹吗？”\n“能，我想你已经见过这类痕迹了。”\n“那他们为什么不给我写信！”我失态地叫了起来，这时我说的他们只包括两个人了。\n“相对于芯片这类物体，有意识的量子态生物，特别是人类的行为要复杂得多，他们是如何与我们的非量子态现实世界互动的，仍是一个难以理解的谜，这中间有许多逻辑上甚至哲学上的陷阱。比如：他们也许写信了，但这些信有多大概率成为非量子态而被你觉察到呢？另外，现实世界在他们眼中是否也是量子态的？要是那样，他们在你的概率云中找到现在这个状态的你是很困难的，对于他们，回家的路一定漫长而渺茫……好了好了，这是些短时间内不可能想明白的事，牛角尖钻下去会把你弄垮的，以后再慢慢想吧。”\n我没说话，怎么可能不想呢？\n 一首诗  金黄色的树林里分出两条路，\n可惜我们不能同时去涉足，\n但我们却选择了，\n人迹罕至的那一条，\n这从此决定了\n我们的一生。\n林云喃喃地吟起了弗罗斯特的那首诗，声音像林间的清泉。\n 跨越空间的信息  丁仪没有再说什么，走到墓碑前，把自己带来的鲜花放到碑座上。放下花后，他好像被墓碑上的什么东西吸引了，迟迟没有直起腰来，后来索性蹲下来，仔细地察看着，脸几乎与碑面贴在一起。\n“天啊，这碑文是谁起草的？”他惊呼道。\n林云感到很奇怪，因为墓碑上除了张彬的名字和他的生卒日期外，没有别的什么，这也是张彬的遗愿，他觉得自己这一生没有什么值得总结的。林云走过去察看，立刻惊得目瞪口呆：除了那几个大字外，墓碑上还密密麻麻刻满了小字，这些小字甚至覆盖了碑顶和碑的背面，那些小字全是方程和计算公式。仿佛是这块墓碑被放到由方程和公式组成的液体中浸过一样。\n“啊，它们在变淡，在消失！”林云惊叫道。\n丁仪猛地推了一把林云，“转过身去！少一个观察者，它的坍缩就慢些！”\n林云转过身去，紧张地搓着双手，丁仪则伏在墓碑上，开始逐行读那些细密的碑文。\n“是什么？你看出什么来了吗？”\n“别说话！”丁仪大声说，同时目不转睛地读着。\n林云摸摸衣袋，“要不要到车上去找纸笔来？”\n“来不及了，别再打扰我！”丁仪说着，以惊人的速度读着碑文，他的双眼狠狠地盯着碑面，像要用目光将它刺穿似的。\n这时，西方的最后一线天光给墓碑群涂上了一层诡异的蓝色，周围的林地隐没于一片昏暗之中，刚刚出现的几颗晶莹的稀星一眨不眨地悬在苍穹上，时而有未落的树叶在微风中极轻的沙沙声，但旋即消失，仿佛被某种力量嘘着制止一样，寂静笼罩着一切，仿佛整个世界都在同丁仪一起全神贯注地读着那量子化的碑文。\n十分钟后，丁仪读完了正面，迅速扫视完碑顶和侧面，然后开始读背面。天已完全黑下来，他摸出打火机打着，借着火苗的微光疾读着。\n“我去拿手电！”林云说完，穿过排排墓碑间的小道向停车的地方跑去。当她拿着手电跑回来时，看到打火机的火苗已经消失了，她用手电照去，看到丁仪背靠着墓碑坐着，两腿平伸在地上，仰头看着星空。\n墓碑上，碑文已经消失得无影无踪，大理石光洁的平面像镜子似的反射着手电光。\n手电光也使丁仪如梦初醒般回过神来，他伸手拉住林云，拉着她转到墓碑后面，指着碑的根部说：“看这儿，留下了一行，非量子态的，也是碑文中唯一的一行汉字。”林云蹲下去，看到了墓碑根部那一行娟秀的刻字：\n彬，引起F的速度只有426.831米/秒，我好怕。\n“我认识这字体！”林云盯着那行字说，她曾不止一次看过张彬留下的那本被球状闪电隔页烧毁的笔记。\n“是的，是她。”\n“她都刻了些什么？”\n“一个数学模型，全面描述宏原子的数学模型。”\n 宏聚变  宏聚变是无声的，甚至照大多数目击者的说法，宏聚变时比平时都要安静，似乎大自然中的其他声音都被屏蔽了，整个过程都在不可思议的宁静中进行。按照一位目击者简洁的总结，整个宏聚变过程看上去就是一轮蓝太阳的升起和落下。首先是大篷中发出蓝光，很快人们就看到了那个还很小的蓝色光球，因为这时大篷正在变成透明的，仿佛是一张悬在光球上方的大玻璃纸，它很快像熔化似的坍塌了，奇怪的是，坍塌时大篷的各个部分都向着聚变中心收拢，整座大篷就像被吸入一个旋涡似的被吸进了光球之中，在周围没有留下任何残余和痕迹。大篷消失后，光球继续扩大，很快便以一个蓝太阳的形象出现在戈壁滩上，当它停止膨胀时，半径达到二百米，这正好是丁仪预言的距离，只有在这个距离之外，宏聚变的能量才呈现选择性，而在这距离之内，由于极大的能量密度，一切都将被毁灭。\n蓝太阳在最大的状态维持了约半分钟，这期间它很稳定，加上此时笼罩一切的诡异的宁静，它居然在这短暂的时间给人一种永恒感，仿佛自世界诞生之日起就在那里似的。蓝太阳使西边已落下去一半的夕阳黯然失色，整个戈壁都淹没在它的蓝光中，使这个世界变得陌生而怪异。这是一个冷太阳，人们即使在近处也感觉不到它的任何热量。\n这时，最不可思议的奇观出现了：在蓝太阳那幽深的内部，有许多璀璨的小星星放射状地飞了出来，那些星星一飞出光球的边界，立刻变成一个个物体，大小不一，当人们看出那些飞散的物体是什么时极为震惊：那是一个个的大篷！这些从蓝太阳中飞出的大篷看上去很有质感，绝不是幻影。它们大小不一，最大的比毁灭前的原物还大，成为天空中飘浮的一个巨大的黑影；小的则像一块碎片，细看去还是完整的大篷，仿佛是它的一个精致的模型。这些处于量子叠加态的大篷，在观察者的目光中迅速坍缩为毁灭态，纷纷拖着一个由自己映像叠成的尾迹消失在空中，但量子态的大篷仍不断地从光球中心飞出，这是一个大篷的概率云，它在向空中弥漫，蓝太阳也笼罩于概率云中，只有观察者才能抑制云的膨胀。\n终于有声音打破了宁静，这轻微的噼啪声从桌上的电脑里发出，从人们身上的手机中发出——是电子芯片被毁灭的声音。与此同时，人们看到有许多小碎片穿过电脑完好无损的外壳四下飞散，细看发现，那些碎片竟是一个个完整的CPU、内存条和其他芯片，每一个量子叠加态的芯片都同时出现于很多个位置，所以飞散的芯片数量巨大，一时间办公楼笼罩在芯片的稠密的概率云之中，但人们的目光像一把把无形的扫帚，将芯片扫回毁灭态，它们纷纷拖着尾迹消失，坍缩为机箱中的灰烬，空气中很快变得空无一物了。\n更大的声音出现了，它是空中传来的一声巨响，人们看到天空中出现了一团大火球，那是来袭的导弹。当它内部的所有芯片都被烧毁时，先是打着旋下坠，然后临空爆炸了。\n之后，宁静又恢复了，蓝太阳开始急剧缩小，最后在地表附近缩为一点消失了，一分钟前，就是在那一点，从“桥”上飞出的两个宏原子核以五百米每秒的相对速度相撞，两根由奇点构成的弦瞬间缠绕在一起，从此，在大得无法想象的宏宇宙中，两个氢原子消失了，一个新的原子诞生了，这个事件不可能被宏世界的任何观察者觉察。与我们的世界一样，只有当一亿亿对弦同时缠绕在一起时，才能产生一起能够被他们称之为事件的事件。\n 量子玫瑰  她与一群孩子在一起。\n她站在孩子们中间，仍穿着整洁的少校军装，脸上浮现着灿烂的笑容，从未有过的美丽动人。再看她周围的孩子们，我立刻认出是核电厂事件中与恐怖分子一起被球状闪电毁灭的那群孩子，他们同样笑得很甜，显然都处于快乐之中。我特别注意到林云一手紧紧搂着的一个小女孩儿，那是一个漂亮可爱的孩子，笑得双眼眯成了一条缝，但吸引我注意力的是那个孩子的左手。\n她没有左手。\n林云和孩子们是在一片修剪得很好的绿草坪上，上面有几只白色的小动物。在她们的后面，我看到了那幢熟悉的建筑，就是那间由大库房改建的宏电子激发实验室，我们就是在那里听到过量子态的羊叫声。但在照片上，库房宽大的外墙上画着色彩鲜艳的卡通动物，还有气球鲜花什么的，在这绚丽的色彩中，整座建筑像一个巨大的玩具。\n林云从照片中动人地微笑着看我，从她那清澈的目光中，我读出了许多她生前没有的东西：一种幸福的归宿感，一种来自心灵深处的宁静，让我想到了一个遥远的被遗忘的幽静港湾中，停泊着一片小小的孤帆。\n 我靠在椅子上闭起双眼，就这么什么也不想地坐着。每天的深夜我都这么坐一会，这是一天中最宁静的时刻，整个世界上仿佛只有我一个人还醒着。\n我闻到了一阵清香。\n这是一种去除了所有甜分的香，有一种令人舒适的微苦，令我联想到暴雨后初晴阳光中的青草地，想到了万里晴空中的最后一抹淡云，想到了幽深空谷中转瞬即逝的铃声……只是这时它更加缥缈，当我注意到它的存在时它就消失了，但当我将注意力从嗅觉上转移开来时它又出现了。\n喜欢这香水吗？\n啊……哦，部队上不是不让用香水吗？\n有时也可以。\n“是你吗？”我轻声问，没有睁开眼睛。\n没有回音。\n“我知道是你。”我又说，还是闭着眼睛，\n仍然没有回音，万籁俱静。\n我猛地睁开双眼，就在书桌上的紫水晶花瓶上，出现了一朵蓝色的玫瑰，但玫瑰在我看到它的瞬间就消失了，只剩空花瓶静静地立在那里。但那朵玫瑰的每一个细节都印在我的脑海中，它充满了生机，透出一种冰雪的灵气。\n我闭上眼睛又睁开，玫瑰没有再出现，但我知道它就在那里，就插在紫水晶花瓶上。\n “我知道你没骗我，那里真的有一朵玫瑰嘛，蓝色的玫瑰。”我说。\n以后，妻子再也没有提起过这事，任那个花瓶放在那里，有时，她还会小心地擦擦它，擦的时候一直竖着，像是怕里面的玫瑰掉下来，她还几次为瓶里添上蒸发掉的水。\n我以后再也没有看到蓝色玫瑰，但知道它在那里就够了。有时夜深人静，我就将水晶花瓶移到窗前，然后背对着它站着，这时我往往能闻到缥缈的花香，就知道它肯定已经在那里了，心灵的眼睛能看清它的每一个细节。我用心来抚摸着它的每一个花瓣，看它在来自窗外的夜风中微微摇曳……它是一朵我只能用心来看的花。\n不过，我还是希望在此生再用自己的眼睛看到一次蓝色玫瑰，据丁仪说，从量子力学的角度来讲，人的死亡过程就是由一个强观察者变为弱观察者再变为非观察者的过程，当我变成弱观察者时，玫瑰的概率云向毁灭态的坍缩速度就会慢一些，我就有希望看到它。\n当我走到人生的尽头，当我在弥留之际最后一次睁开眼睛，那时我所有的知性和记忆都消失在过去的深渊中，又回到童年纯真的感觉和梦幻之中，那就是量子玫瑰向我微笑的时候。\n 刘慈溪后语——浪漫又有趣的球状闪电解释  创造一个在所有细节上都栩栩如生的想象世界是十分困难的，需要深刻的思想，需要在宏观和微观上都强劲有力、游刃有余的想象力，需要从虚无中创世纪的造物主的气魄，而后面两项，恰恰是我们的文化所缺乏的。但如果我们一时还无力创造整个世界，是否能退而求其次，先创造其中的一个东西呢？这就是我写这部小说的目的。\n球状闪电至今还是一个科学之谜，但现在已经能在实验室中产生它（虽然平均七千次实验才能产生一个），而彻底揭开这个谜也指日可待，到那时有一点可以肯定：你会发现球状闪电完全不是小说中描述的那种东西。搞清球状闪电真的是什么，不是科幻的事，也不是科幻能做到的，我们所能做到的，只是描述自己的想象，创造一个科幻形象，与主流文学不同，这个形象不是人。\n自从目击球状闪电之后，近二十年来，我不由自主地对它产生了多种想象，这部小说描述了这些想象中的一种，不是我觉得最接近真实的那一种，而是最有趣最浪漫的那一种。它只是一个想象的造物：一个充盈着能量的弯曲的空间，一个似有似无的空泡，一个足球大小的电子。小说中的世界是灰色的现实世界，是我们熟悉的灰色的天空和云，灰色的山水和大海，灰色的人和生活，但就在这灰色的现实世界之中，不为人注意地飘浮着这么一个超现实的小东西，仿佛梦之乡溢出的一粒灰尘，暗示着宇宙的博大和神秘，暗示着这宇宙中可能存在的与我们的现实完全不同的其他世界……\n","date":"2022-09-16","permalink":"/posts/literature/lighting-ball/","series":[],"tags":["",""],"title":"《球状闪电》"},{"categories":["二次元"],"content":"我比较喜欢这种感觉的歌。\n1.歌词 来源于网易云歌词，歌曲在这里 。\n歌手：中恵光城 所属专辑：ASTRO=FILMS  夜[よる]はここにある\n夜于此处\n輝きを増す[ます]ほどに\n光芒愈盛\n影[かげ]は広[ひろ]がって\n暗影愈广\n身[み]も焼き[やき]焦がす[こがす]シリウス\n浑身烧灼的西利乌斯\n何よりも輝いて\n其光明灼耀绝伦\n気[け]高く強く\n其威压极盛难敌\n答え[こたえ]求[もと]められて 何時しか\n我问道 是何时起呢\n誰にも触れ[ふれ]られない\n绝对无人能触其肉身\n孤独[こどく]となった\n那和陷入孤独的我\n私と同じ傷痕\n一般的伤痕[きずあと]\n隣[となり]に居[い]てあげる\n我来待在你的身边\n痛いなら 撫で[なで]てあげる\n如果疼痛 就由我来抚慰\nだけど気づかない\n但还是没有人注意到我\n誰か私を見て\n谁来看着我\n空を揺蕩[たゆた]えば\n如果摇荡起整个苍穹\n数え[かぞえ]きれないほどの\n那不可胜数的\n星物語[ものがたり]が\n群星的故事\n生まれ[うまれ]ていくのが見える\n就会浮现于眼前\n何一つ触[さわ]らずに\n触碰不到任何一个\nシリウスのように\n如同西利乌斯一般\nいつか燃え尽き[もえつき]てしまうなら\n若终有一日燃尽成尘\n最後に一つだけ\n请让我许下\n願いがある\n最后一个愿望\n私を見つけて欲しい\n希望有人能找到我\n空っぽ[からっぽ]の器[うつわ]が\n这副空虚的躯壳\nそれだけを求め[もとめ]ている\n不过追求这一点\nだからここに来[き]て\n所以请来到这里\n誰か声を聞[き]いて\n谁来听听我的声音\n誰か私に\n谁来告诉我\n心を教えて\n心的含义\n見つけて\n请找到我\n 2.翻译 焦がす [こがす]【他动词・五段/一类】1.烧糊。2.使心情焦急。\n気 [け]【名词】1.迹象，苗头，先兆；本体散发的气；气氛。\n求める [もとめる]【他动词・一段/二类】1.要求，征求。2.招，惹，招致。（恶果等）。3.买，购买。4.渴望，希望，盼望。5.寻求，找。\n触れる [ふれる]【他动词・一段/二类】1.碰，触；宣扬。【自动词・一段/二类】1.触碰；（耳、目等）感觉；言及；遇到；冒犯；体验。\n隣[となり] 【名词】1.邻居，邻家，邻人；旁边，隔壁，邻室；邻邦，邻国；\n居る[いる]【自动词・一段/二类】1.有，在；在，居住，呆，逗留；始终停留（在……），保持……；表示动作、作用正在进行之中；表示动作结果继续存在；表示目前的状态；表示曾做过某事。经历过某事；表示某个动作习惯性的反复出现；现在的。\n撫でる[なでる]【他动词・一段/二类】1.抚摸。2.拂，抚摸。比喻柔软的物体或风轻轻掠过身体。3.梳拢。用梳子整理头发。\n揺蕩う [たゆたう]【自动词・五段/一类】1.摇动，晃荡，漂浮。2.犹豫不决。\n数える [かぞえる]【他动词・一段/二类】1.数数，算账。2.列举，枚举。3.算数。4.确认范围内的数量。\n生まれる [うまれる]【自动词・一段/二类】1.生。分娩。2.诞生，产生。3.产生某种想法。\n触る[さわる]【自动词・五段/一类】1.触摸；接触。2.有关联，有关系。3.触怒，伤害情绪。\n燃え尽きる[もえつきる]【自动词・五段/一类】1.烧完，烧尽。\n空っぽ [からっぽ]【名・形容动词/ナ形容词】1.没人；空的。\n器 [うつわ]【名词】1.容器，器皿；器具。2.才干，人才。\n3.乐谱 暂无待补（可能很长时间不会补）\n\n \n想做《命运石之门》的歌，但主题歌曲我都不太感冒，以后也不会做了；而《素晴らしき日々》的有词的歌也不太感冒，纯音乐倒是很好，于是选来选去做这首。关于《素晴らしき日々》，我以后一定会做一些东西的，因为我很喜欢这部作品！它让我对文学有了冲动兴趣。而且是很与众不同的作品！\n——2022.09.11中秋节。\n","date":"2022-09-11","permalink":"/posts/anime/shiriusunoyuuenn/","series":["","动漫歌曲"],"tags":[""],"title":"シリウスの遊園 -Hacka-"},{"categories":["二次元"],"content":"歌的链接：空種 -そらたね-  1.歌词  まっすぐに羽を伸ばし 傷痕[きずあと] 愈し[いやし]続け[つづ]るたび\n我的双翼会一直张开 每当持续治疗之时\n私はそれでもいい 誰かの為に\n即便如此我也愿意 因为这是为了人们\n飛び[とび]立て[たて]ることに もう少し 喜び感じ[かんじ]でいたいから\n也因为我希望能稍微飞翔起来而感觉到高兴\nあなたとここで出会[であ]えたこと 奇跡[きせき]と 呼[よ]ばせてください\n请你把我们的相遇称呼为奇迹\nOverthesky 遠くを見つめてる\n飞越天空 遥望远方\nその目に 光が指す[さす]ように\n双眼如同指向光芒一样\nOpenthemind 世界を\n敞开心怀 世界必定能改变\nきっと変え[かえ]てゆく そして 空へ\n然后再次飞向天空\n時々[ときどき]不安[ふあん]になる 私に何ができるのだろう\n有时候我会感觉到担心 我究竟能够做什么？\n時間は無限[むげん]じゃない そんな中で\n时间并非无限 而我正在此间\n生きできた時間の中には 忘れたいこともあるけど\n在我所生活过的时光里有我很想忘却掉的痛苦经历\n誰かとは立ち[たち‐]会えるのなら 記憶は 輝き始める\n但如果能和谁一起分享我的经历 这份记忆将会开始闪闪发光\nOverthesky 全てが終わる時\n飞越天空 当一切结束后\nその手で 強く抱きしめて[だきしめて]\n请用那双手紧紧拥抱着我\nOpenthemind 真実\n敞开心怀\n分かる日が来ても ずっと\n即使明白了真相 也要追寻永恒\n突然[とつぜん] 見つけた希望\n突然找到的希望\n偶然[ぐうぜん] 舞い[まい]降りできた夢\n偶然降落在了我们身上\nOverthesky 遠くを見つめてる\n飞越天空 遥望远方\nその目は 光が満ち[みち]でいる\n双眼充满了希望之光\nOpenthemind 世界をきっと変えてゆく そして\n敞开心怀 世界必定能改变 然后…\nOverthesky 遥か[はるか]な物語[ものがたり]\n飞越天空 追寻遥远的故事\nまだ見ぬ景色[けしき]が呼んでる\n那里还有更多未知的景色呼唤着我们\nOpenthemind 世界に光が差す[さす]とき\n敞开心怀 当世界充满光芒的时候\n笑ってどこかで 見ているから\n我一定会微笑着在某处注视着你\n 2.翻译 続く[つづく]【自动词・五段/一类】1.持续，连绵；（同样的事情一个接一个地）发生；紧连着；坚持，维持住。\n立て [たて]【接头/接尾】1.刚。（…したばかり。〕2.连败。〔連敗。〕3.最高级，首席，头目。（第一。）\n出会う[であう]【自动词・五段/一类】1.偶然相遇，遇见，碰见。2.意外地遭受到，遇到，遭到。\n呼ぶ [よぶ]【他动词・五段/一类】1.喊，叫；叫来；请来；邀请；掀起，引起；叫做。\n時々 [ときどき]【名词】1.每个季节；一时一时。【副词】1.时常，时时， 有时。\n立ち [たち‐]【接头/接尾】1.加强语气。\n抱きしめる [だきしめる]【他动词・一段/二类】1.死守；紧抱。2.相拥；拥抱。\n物語 [ものがたり]【名词】1.故事。2.传说。\n差す [さす]【自他・五段/一类】1.上涨，浸润。2.照射。3.透露，泛出，呈现。4.发生，起。5.打，撑，举。\n","date":"2022-07-31","permalink":"/posts/anime/soratane/","series":["动漫歌曲","Galgame"],"tags":["",""],"title":" 空種 -そらたね-"},{"categories":["二次元"],"content":"今年二月的坑填了。\n歌的链接：Asphodelus  1.歌词 来源于网易云歌词。   囚(とら）われた絶望[ぜつぼう]の淵(ふち）で\n身陷绝望的牢狱深渊\nわたしを抱きしめて[だきしめて]ください\n多么希望你能将我紧紧拥抱\n静寂[せいじゃく]に埋(う）め尽[づ]くされ\n这份渴求却无人回应\nひとりで凍(こご）えてる\n在冷寂中独自一人宛若冰雕\n崩れ[くずれ]墮(お）ちてゆく楽園[らくえん]の果て[はて]で\n在崩毁堕落的乐园边境\n忘れられた祈りが響[ひびき]いてる\n远远回响着那已被忘却的祷词\n支配[しはい]する闇[やみ]の中でも涸(か）れない\n祈求那份黑暗中也未曾枯涸的爱\n愛よ目覚め[めざめ]よ永遠(とわ）に\n在此觉醒 永不止息\n無限に降る孤独[こどく]を\n请伸出指尖\nその指[ゆび]で染め[そめ] てください\n沾染我深邃莫及的孤独吧\n叫ぶ[さけぶ]この心が\n这颗喧骚的心灵\n悲しみを愛せるように\n若能够包容那份悲伤\nまだ見ぬあの光の景色[けしき] へ\n无论多么渺茫的光明景致 我也愿前往\n亂(みだ）れ咲く花より深く[ふかく]\n此生既已绽放胜似芳华灿烂\n優しく口づけ[くちづけ]てください\n何不赐我以深情一吻\n躊躇(ためら）いの吐息(といき）さえも\n即便是你唇边踌躇着的气息\n命(いのち）を燈(とも）してく\n也足以点亮我的生命\n滲(にじ）む幻[まぼろし]に祝宴(しゅくえん）の鍾[かね]を\n沉溺于幻梦的喜宴之钟\nその温もり[ぬくもり] 素肌(すはだ）に伝う[つたう]まで\n如阵阵暖流游曳在每一寸肌肤\n迸(ほとばし）る岚[あらし]の中も\n祈求那份在骤雨狂风中飘摇的爱\n止まない[やまない]愛よ目覚めよ\n在此觉醒 永不止息\n抗[あらが]えぬ願いを\n请睁开双眼\nその瞳(め）で迎え[むかえ]てください\n接受我难以抗拒的心愿吧\n出逢[であ]えた喜びに\n这颗赤诚的心灵\n震え[ふるえ]てる裸(はだか）の心で\n若能体味相逢的喜悦\nもとめるあの殘酷[ざんこく]の彼方[かなた]へ\n无论多么残酷的一方土地 我也愿前往\n零れ[こぼれ]散る[ちる]涙[なみだ]が\n当凋零泪花\nきらきらと風に舞う[まう]頃[ごろ]\n随风的舞步画出闪烁光晕\n絆[きずな]を痛みをください永遠に消え[きえ]ないように\n请将羁绊与痛楚托付于我 让它们永存\n無限に降る孤独を\n请敞开心胸\nわたしに預(あず）けてください\n将你深邃的孤独送给我吧\n喚び[よび]合[あ]えた心が\n若两人心声共鸣\n扉[とびら]を放ち[はなち]羽ばたく\n一定能敲开那扇门扉\n近づく[ちかづく]あのはじまりの天空へ\n向着那片万物初始的天空 执着地飞翔\n 2.翻译 果て [はて]【名词】1.［境界的］边，边际；尽头。2.最后，末了，结局；下场。\n響 [ひびき]响。音响。余音。\n支配 [しはい]【名・他动词・サ变/三类】1.指使，支配，左右。2.控制，管理；统治，管辖。\n闇 [やみ]【名词】1.黑暗。暗夜。2.黑市；黑市交易；黑货。3.（心中）糊涂。迷惑。\n目覚め [めざめ]【名词】1.睡醒。2.萌动。3.觉醒。\n叫ぶ [さけぶ] 【自动词・五段/一类】1.大声叫。2.向社会呼吁。\n口づけ [くちづけ]【自动词・サ变/三类】1.接吻。亲嘴。2.口头禅。\n伝う [つたう]【自动词・五段/一类】1.沿着某物移动。2.一点点地移动。\n嵐 [あらし]【名词】1.暴风雨，风暴，风雨。\n迎え [むかえ]【名词】1.迎，迎接；迎接的人。〔迎えること。迎えの人。〕2.死期，大限。〔死期。〕3.接，请。〔請う。〕\n震え [ふるえ]【名词】1.颤抖，哆嗦，发抖。\n零れ [こぼれ] 【名词】1.洒落的东西，溢出。\n散る [ちる]【自动词・五段/一类】1.凋谢；分散；不专一；（热度和肿块等）消退；牺牲；（墨汁、墨水等）扩散而渗；（云、雾等被）吹散消失。\n頃 [ごろ]1.……时分，……前后，……左右。（…ごろ。）2.正好的时候，正合适的时候〔程度〕。（ちょうどよい。）\n近づく [ちかづく]【自动词・五段/一类】1.（地点、时期等）临近，靠近。2.亲近，接近，交往，来往。\n3.乐谱 暂无待补\n","date":"2022-07-31","permalink":"/posts/anime/asphodelus/","series":["Galgame","动漫歌曲"],"tags":[""],"title":"Asphodelus"},{"categories":["二次元"],"content":"kalafina的歌都好好听，现场的演出堪称完美，这首歌是我目前最喜欢的。\n  1.歌词  静かに瞬く[またたく]\n静寂天空\n星たちの散り[ちり]逝く[ゆく]空\n群星闪烁消散而去\n届[とど]かぬ祈り[いのり]が\n无法传达的祈愿\n天[てん]と地[ち]を満[み]たしてた\n满溢在这天地之间\n细い[ほそい]枝[えだ]に光るのは\n未曾绽放的未来\n咲き忘れた未来\n在细枝上闪着微光\nまた名残[なごり]惜[お]しそうに蕾[つぼみ]を落[お]とした\n将尚存依恋的花蕾落下\nほら、もう时は満[み]ちて\n看啊，时光满溢之时\n実る[みのる]黄金[きん]の果実[かじつ]\n结出金黄的果实\nその手で摘み[つみ]取る[とる]だけで\n只需伸手去摘的话\n世界は终わるから\n世界便会迎来终结\n戯[たわ]れぬものとして降る雪の白さは\n无暇飘落的洁白雪花\n温[ぬく]もりを知れば消[き]えてしまうの\n触碰到温暖的瞬间便会消融而去\n綺麗な梦だけが贵方を切[き] り裂[さ]いた\n仅是绮丽的梦境就将你切裂开来\n冷たい瞳[ひとみ]の优しさと真実[しんじつ]\n冰冷的眼眸仅存些许温柔与真实\n激しく[はげしく]瞬く星たちは天に背[せ]いて\n激烈闪烁的星辰背驰天地\n仇[あだ]なす祈りが\n偕同仇恨的祈愿\nこの空を坠とす[おとす] まで\n向着撕落苍穹而去\n私を吊う[とむらう]为の\n无需任何\n花束[はなたば]はいらない\n为我吊唁的花束\n心が溃え[ついえ]ぬうちに愿い[ねがい]を叶え[かなえ]て\n只要心灵尚未溃败 愿望便可达成\n见届け[みとどけ]てみたい\n还想去见证\n人の望み[のぞみ]が\n人们的希望\n灿々[さんさん]と光に満ちる[みちる]时を\n满溢着璀璨光芒之时\n翼[つばさ]を欲しがって谁もが泣い[ない]ていた\n幻想双翼的人们眼含泪水\n命[いのち]が奏でる[かなでる]\n以满天的合唱\n満天のコーラス\n奏响生命的乐章\n焼け焦げ[やけこげ]た愿いが\n当烧焦的愿望\n空を抉じ开ける[こじあける]顷[ごろ]に\n撕裂苍穹的那刻\n懐かしい故郷[ふるさと]は\n怀念的故乡\nきっと花の盛り[さかり]でしょう\n也一定会开满鲜花吧\n激しく瞬く星たちの梦の迹[あと]\n激烈闪烁的星辰 划出梦想的轨迹\n安らぎ[やすらぎ]のあると人の言う[いう]\n直到人们常说的\n最果て[さいはて]まで\n安乐和平存在的尽头\n月影[つきかげ]优しく\n还请温柔的月影\n行く路[みち]を教ぇ[おしえ]てよ\n指明前行的道路吧\n静かに瞬く星たちの\n星辰静寂闪烁的\n祈りの空\n祈愿的天空\n贵方の叫び[さけび]で\n以你的呼喊\nこの梦が终わるまで\n直抵这梦的终焉\n 2.翻译 瞬く[またたく]【自动词・五段/一类】1.眨眼。2.闪烁，明灭。\n散り[ちり]1.四散；离散，分散。\n逝く [ゆく]【自动词・五段/一类】1.逝世，死去。（死ぬ。）2.一去不复返。（行って帰らない。）\n届く[とどく]【自动词・五段/一类】1.送达，收到，发出的物件到达对方处。2.达到，够上，够到。3.周到，注意到，顾到。4.达到愿望，心情与想法传至对方，并被接受。\n祈り [いのり]【名词】1.祈祷，祷告。（祈ること。祈祷。）2.同：祷り\n満たす [みたす]【他动词・五段/一类】1.满足。2.充满；填满；装满。\n細い [ほそい]【形容词/イ形容词】1.细，纤细。2.狭窄，窄。3.微细，低小。\n名残 [なごり]【名词】1.惜别，依恋。2.余音，余韵。\n蕾 [つぼみ]【名词】1.未成年（的人）。2.花骨朵，花蕾，蓓蕾。\n落とす [おとす]【他动词・五段/一类】1.（从高处）扔下。使落下。使降落。2.遗漏。漏掉。丢失。失落。\n満ちる [みちる]【自动词・一段/二类】1.充满。2.涨潮。3.期满。4.完整。\n実る [みのる]【自动词・五段/一类】1.有成果，有成绩，结果实。2.结实；成熟。\n果実 [かじつ]【名词】1.果实，果子。2.水果。3.〈法〉果实；收益；收获。\n戯れる [たわむれる]【自动词・一段/二类】1.游戏，玩耍。2.说说笑笑，耍笑，闹着玩儿。3.调戏；挑逗。\n切り裂く [きりさく]【他动词・五段/一类】1.切开；劈开。\n瞳 [ひとみ]【名词】1.瞳孔，瞳仁儿；眼珠子，眼睛。\n激しく [はげしく]【副词】1.激烈地；猛烈地。\n仇 [あだ]【名词】1.仇人，仇敌。（かたき。）2.仇恨；复仇。（うらみ、怨恨）3.危害；报复；毁灭。（害悪、害をなすもの。）\n坠とす（落とす）[おとす]1.（从高处）扔下。使落下。使降落。\n吊う[とむらう]【他动词・五段/一类】1.吊丧，吊唁，吊慰。2.祭奠，祭祀，为死者祈冥福。\n花束 [はなたば]【名词】1.花束，花把。\n潰え [ついえ]【名词】1.衰败;溃败(同つかれくるしむ;よわる)\n叶う[かなう]【自动词・五段/一类】1.能实现，能如愿以偿。\n見届ける [みとどける]【他动词・一段/二类】1.看到，看准，看清；一直看到最后，结束，用眼看，确认。\n望み [のぞみ]【名词】1.希望，愿望，期望；要求。 奏でる [かなでる]他动词・一段/二类】1.奏，演奏，特指演奏弦乐器。\n抉じ開ける [こじあける]【他动词・一段/二类】1.撬开。\n頃 [ごろ]1.……时分，……前后，……左右。（…ごろ。）2.正好的时候，正合适的时候〔程度〕。（ちょうどよい。）\n盛り [さかり]【名词】1.全盛时期。2.壮年。3.动物发情。4.表示最\u0026hellip;的时候。\n安らぎ [やすらぎ]【名词】1.安乐，平静，安稳。\n言う [いう]【自他・五段/一类】称为，叫做。\n最果て [さいはて]【名词】1.最终，最边远，尽头。\n3.乐谱","date":"2022-07-09","permalink":"/posts/anime/the-whole-sky/","series":["动漫歌曲"],"tags":["",""],"title":"満天"},{"categories":["二次元"],"content":"这首歌有种“希望”和“时间流逝”的感觉。\n 1.歌词 来源于网易云歌词，但是错误很多，通过对比百度的改了一下。\n歌曲链接：Continued Story 注意下面的视频可能含有剧透！！   God bless our king,\n天佑吾王，\nit is a bright light day\n光明之日即将到来，\nLet us worship in your triumph\n让吾等沐浴您荣光凯旋。\nAnd this story is mine,\n这是因我而生的故事，\nand this moment is mine.\n这是尽归于我的时刻。\nCan I steal your pain\n能让我带走你的伤痛\nand shadows away?\n并将之消弭吗？\nTo have made this way,\n为了避免这些苦难，\nto have found this name.\n为了追寻这些真名，\nCan you show me the name of your way?\n我能替你分担这些痛苦吗？\nAnd this story is mine,\n这是因我而生的故事，\nand this moment is mine.\n这是尽归于我的时刻。\nCan I steal your pain\n能让我带走你的伤痛\nand shadows away?\n并将之消弭吗？\nTo have made this way,\n为了避免这些苦难，\nto have found this name.\n为了追寻这些真名，\nCan you show me\n我能替你分担这些痛苦吗？\nthe name of your way?\n\nLalalalalalalalala\nLalalalalalalalala\nDrive your day in my year\n只属于我的时代即将到来，\nLalalalalalalalala\nLalalalalalalalala\nDrive your day in my year\n我梦想中的国度终将建成。\nTowards the light,\n行向光明，\nand this story is mine.\n此乃因我而生的故事。\nCan I steal your pain\n能让我带走你的伤痛，\nand shadows away?\n并将之消弭吗？\nTowards the light,\n行向光明，\nand this story is mine.\n此乃尽归于我的时刻。\nCan I steal your pain\n能让我带走你的伤痛，\nand shadows away?\n并将之消弭吗？\nI miss her\n这是我的过错。\nその一粒（ひとつぶ）のしずくでさえも\n或许只要一滴露水，\n花を守る（まもる）かもしれない\n便可以守住花儿的娇颜。\nその笑い颜ただそれだけで\n或许只要一张笑脸，\n差し（さし）伸べる（のべる）手にもなれる\n便可以给他人带去帮助。\nその震え（ふるえ）てる声集め（あつめ）れば\n若是可以集起微弱的呼唤，\n风を起こす（おこす）かもしれない\n或许也可以唤来呼啸的狂风。\nその命（いのち）というはかなき明かり（あかり）\n若是可以点燃生命的灯火，\n灯し（ともし）て足を进めよう\n或许也可以照亮前进的道路。\nラララララララララン\nLalalalalalalalala\nいつかまた会（あ）おう\n愿我们下次再见。\nラララララララララン\nLalalalalalalalala\n生きてる限り（かぎり）\n只要还未到生命的大限。\n时を超え（こえ）捕らえ（とらえ）られてる\n超越时间来到我心间，\nあふれるこの想いは何?\n这满溢的思念又为何人？\n優しさが目尻（めじり）に似合う（にあう）\n犹记那满目温柔的面容，\nあの人たちは今どこに居る（いる）の?\n那样的人如今又在何处？\nGod bless our king,\n天佑吾王，\nit is a bright light day\n光明之日即将到来，\nLet us worship in your triumph\n让吾等沐浴您荣光凯旋。\n隣り（となり）には新しい席（せき）\n邻座又来了一位新同学，\n未来のためにまた出会う（であう）\n为了迎接未来大家又在此汇聚。\n飾（かざ）らないまま出来る（できる）だけ\n不再掩饰彼此的真心，\n生きてみよう今日という日（ひ）\n只为走好今后的人生。\n悲しくて人は切ない（せつない）\n尽管悲伤依旧难忘，\nそれでもどこまでも道はつづく\n人生之路依然延续。\nラララララララララン\nLalalalalalalalala\nいつかまた会おう\n愿我们下次再见。\nラララララララララン\nLalalalalalalalala\n生きてる限り\n只要还未到生命的大限。\nラララララララララン\nLalalalalalalalala\n風が運ぶ（はこぶ）もの\n那场风所带来的礼物，\nラララララララララン\nLalalalalalalalala\n明日（あす）をくメロディ\n正是开启明日的旋律。\nラララララララララン\nLalalalalalalalala\nいつかまた会おう\n愿我们下次再见。\nラララララララララン\nLalalalalalalalala\n生きてる限り\n只要还未到生命的大限。\nラララララララララン\nLalalalalalalalala\n風が運ぶもの\n那场风所带来的礼物，\nラララララララララン\nLalalalalalalalala\n明日をくメロディ\n正是开启明日的旋律。\n 2.翻译 守る[まもる]：【他动词・五段/一类】守卫，保卫，防守，保护。\n差し伸べる[さしのべる]：【他动词・一段/二类】伸出。\n震え [ふるえ]：【名词】颤抖，哆嗦，发抖。\n集める[あつめる]：【他动词・一段/二类】集合，收集，集中。\n起こす[おこす]：【他动词・五段/一类】立起，扶起；唤醒。\n明かり [あかり] ：【名词】光，光亮。灯，灯光。\n灯す[ともす]：【他动词・五段/一类】点，点亮，点燃。\n限り[かぎり]：【名词】在……的范围内，除非……就……。限，限度，极限，止境。\n超える [こえる]：【自动词・一段/二类】超出，超过。超过，多于。\n捕らえる[とらえる]：捉住，逮住；逮捕。陷入。\n目尻 [めじり]：【名词】外眼角，眼梢。眼睛靠近耳朵的一端。\n似合う [にあう]：【自动词・五段/一类】适称，合适，配合，般配。\n隣り[となり]：【名词】邻居，隔壁，旁边，邻近，附近。\n出会う [であう]：【自动词・五段/一类】偶然相遇，遇见，碰见。意外地遭受到，遇到，遭到。\n飾る[かざる]：【他动词・五段/一类】装饰。装点。粉饰。只装饰表面。\n出来るだけ[できるだけ]：【副词】尽量地；尽可能地。\n切ない [せつない] ：【形容词/イ形容词】难受的，苦闷的，（因悲伤而感到）憋得慌的，难过的。身体感觉）难受的，痛苦的。\n運ぶ [はこぶ] ：【他动词・五段/一类】搬运，运送。开展，进行，推进。运用（工具）。\n3.乐谱 虫虫钢琴有哈，我不搬了，感兴趣自取。\n","date":"2022-06-19","permalink":"/posts/anime/continued-story/","series":["动漫歌曲"],"tags":[""],"title":"Continued Story"},{"categories":["普通类"],"content":"一、Stolz定理[1] 1.$\\frac{0}{0}$型Stolz定理 设{$a_n$}和{$b_n$}都是无穷小量，其中{$a_n$}还是严格单调减少数列，又存在 $$ \\lim_{n\\rightarrow \\infty }\\frac{b_{n+1}-b_{n}}{a_{n+1}-a{n}}=l $$ （其中$l$为有限或$\\pm \\infty$），则有 $$ \\lim_{n\\rightarrow \\infty } \\frac{b_{n}}{a_{n}}=l $$\n 证：只对有限的$l$作证明.根据条件对$\\varepsilon \u0026gt; 0$存在$N$，使得当$n\u0026gt;N$时成立 $$ \\left | \\frac{b_{n}-b_{n+1}}{a_{n}-a_{n+1}}-l \\right | \u0026lt;\\varepsilon $$ 由于对每个$n$都有$a_{n}\u0026gt;a_{n+1}$，这样就有 $$ (l-\\varepsilon)(a_{n}-a_{n+1})\u0026lt;b_{n}-b_{n+1}\u0026lt;(l+\\varepsilon)(a_{n}-a_{n+1}) $$ 任取$m\u0026gt;n$，并且将上述不等式中的$n$换成$n+1$，$n+2$，$\\cdots $，直到$m-1$，然后将左右这些不等式相加，就得到 $$ (l-\\varepsilon)(a_{n}-a_{m})\u0026lt;b_{n}-b_{m}\u0026lt;(l+\\varepsilon)(a_{n}-a_{n+1}) $$ 即 $$ \\left| \\frac{b_{n}-b_{m}}{a_{n}-a_{m}}-l \\right|\u0026lt;\\varepsilon $$ 令$m\\rightarrow \\infty$，并利用条件$\\lim \\limits_{n \\rightarrow \\infty } a_{m}=\\lim \\limits_{n \\rightarrow \\infty } b_{m}=0$，就知道当$n\u0026gt;N$时成立 $$ \\left| \\frac{b_n}{a_n}-l\\right| \\leq \\varepsilon $$\n2.$\\frac{*}{\\infty}$型Stolz定理 设数列{$a_n$}是严格单调增加的无穷大量，又存在 $$ \\lim_{n\\rightarrow \\infty }\\frac{b_{n+1}-b_{n}}{a_{n+1}-a{n}}=l $$ （其中$l$为有限或$\\pm \\infty$），则有 $$ \\lim_{n\\rightarrow \\infty } \\frac{b_{n}}{a_{n}}=l $$\n 证：只对$l$为有限的情况写出证明。对$\\varepsilon\u0026gt;0$存在$N$，使得当$n\u0026gt;N$时成立 $$ \\left | \\frac{b_{n+1}-b_{n}}{a_{n+1}-a_{n}}-l \\right | \u0026lt;\\varepsilon $$ 由于对每个$n$有$a_{n+1}\u0026gt;a_{n}$，这样就有 $$ (l-\\varepsilon)(a_{n+1}-a_{n})\u0026lt;b_{n+1}-b_{n}\u0026lt;(l+\\varepsilon)(a_{n+1}-a_{n}) $$ 取定$N$，并且将上述不等式中的$n$换成$N$,$N+1$,$\\cdots$,直到$n-1$，然后将所有这些不等式相加，就得到 $$ (l-\\varepsilon)(a_{n}-a_{N})\u0026lt;b_{n}-b_{N}\u0026lt;(l+\\varepsilon)(a_{n}-a_{N}) $$ 即 $$ \\left| \\frac{b_{n}-b_{N}}{a_{n}-a_{N}}-l \\right|\u0026lt;\\varepsilon $$ 为了进一步得到关于$\\left| \\frac{b_n}{a_n}-l \\right|$的估计，可以利用恒等式 $$ \\frac{b_n}{a_n}-l=(1-\\frac{a_N}{a_n})\\cdot(\\frac{b_n-b_N}{a_n-a_N}-l)+\\frac{b_N-la_N}{a_n} $$ 由于$\\lim \\limits_{n \\rightarrow \\infty } a_{n}=+\\infty$，存在$N_1$，使得当$n\u0026gt;N_1$时成立 $$ 0\u0026lt;1-\\frac{a_N}{a_n}\u0026lt;2\\quad和\\quad\\left|\\frac{b_N-la_N}{a_n} \\right|\u0026lt;\\varepsilon $$ 则在$n \u0026gt; max \\left \\{N,N_1\\right \\}$时就得到 $$ \\left|\\frac{b_n}{a_n}-l \\right|\u0026lt;3\\varepsilon $$ **两类Stolz定理对$l$为有限或者$\\pm \\infty$的情况成立，但是对不带符号的无穷大量$\\infty$不成立。且定理的逆命题不成立。**\n\n二、一道例题 设已知$\\lim \\limits_{n \\rightarrow \\infty } a_{n}=a$，证明：$\\lim \\limits_{n \\rightarrow \\infty } \\frac{1}{2^n} \\sum \\limits_{k=0}^{n} \\binom{n}{k}a_k=a$ 证明方法直接利用极限定义分步法即可。\n ①证明过程中注意 $$ \\frac{1}{2^n} \\sum \\limits_{k=0}^{N} \\binom{n}{k}\\left| a_k-a \\right|\u0026lt;\\frac{M(1+n+\\cdots+n^N)}{2^n}\u0026lt;\\varepsilon $$ 中利用了$\\binom{n}{k}\u0026lt;n^k$。可以这样观察这个式子： $$ \\begin{aligned}\\binom{n}{k} = \\frac{n!}{k!(n-k)!}\u0026amp;=\\frac{(n-k+1)(n-k+2)\\cdots(n)}{k!}\\ \u0026amp;=\\frac{(n+1-k)(n+1-k-1)\\cdots n}{k\\cdot(k-1)\\cdots1}\u0026lt;n^k\\end{aligned} $$ 对于每个单项可以发现$n\u0026gt;\\frac{n+1-k-i}{k-i}$。\n②关于组合数有以下公式参考：\n $2^n=(1+1)^n=\\binom{n}{0}+\\binom{n}{1}+\\cdots+\\binom{n}{n}=\\sum \\limits_{k=0}^{n}\\binom{n}{k}$ $0=(1-1)^n=\\binom{n}{0}-\\binom{n}{1}+\\binom{n}{2}-\\binom{n}{3}+\\cdots$ $\\frac{1}{2}\\cdot2^n = 1+\\binom{n}{2}+\\binom{n}{4}+\\cdots$ $cosm\\alpha = 2^{m-1}cos^m\\alpha -(\\binom{m}{2}+2\\binom{m}{4}+\\cdots)cos^{m-2}\\alpha +\\cdots$  第4条公式[2]是通过$cosm\\alpha+isinm\\alpha = (cos\\alpha+isin\\alpha)^m$计算后分虚实部得来的，利用这个公式可以导出常用的二倍角三倍角公式，在高中我们通常是用三角恒等式变换得到这些公式的。\n这个部分其余的证明方法想不出来，反正必须要$ \\sum \\limits_{k=0}^{N}\\binom{n}{k}$部分放缩到是$2^n$的无穷小量即可，当然我们知道这是肯定的。\n 1.尝试Stolz 注意到 $$ \\begin{aligned}\\frac{1}{2^n} \\sum \\limits_{k=0}^{n} \\binom{n}{k}a_k \u0026amp;= \\frac{\\sum \\limits_{k=0}^{n}\\binom{n}{k}a_k}{\\sum \\limits_{k=0}^{n}\\binom{n}{k}} \\\\ \u0026amp;=\\frac{\\binom{n}{0}a_0+\\binom{n}{1}+a_1+\\cdots+\\binom{n}{n}a_n}{\\binom{n}{0}+\\binom{n}{1}+\\cdots+\\binom{n}{n}}=\\frac{p_n}{q_n} \\end{aligned} $$ 但这是如果应用Stolz定理会发现不能简化问题： $$ \\frac{p_{n+1}-p_{n}}{q_{n+1}-q_{n}}=\\frac{a_1+\\binom{n}{1}a_2+\\binom{n}{2}a_3+\\cdots+\\binom{n}{n-2}a_{n-1}+\\binom{n}{n-1}a_n+a_{n+1}}{\\binom{n}{0}+\\binom{n}{1}+\\cdots+\\binom{n}{n}}\\qquad \\left[\\binom{n+1}{i}=\\binom{n}{i-1}+\\binom{n}{i}\\right] $$ 2.一些联想 根据这个例题可以立刻联想到一种简单形式：\n设{$x_n$}收敛于$l$，如果$a_n\\in R$，则有： $$ \\lim_{n\\rightarrow \\infty }\\frac{a_1x_1+a_2x_2+\\cdots+a_nx_n}{a_1+a_2+\\cdots+a_n}=l $$ 可以通过极限定义证明是成立的。\n那能不能有一个更一般的定理解决上面的例题呢？比如： 设{$x_n$}收敛于$l$，如果$a_k=f(n,k)$，则有： $$ \\lim_{n\\rightarrow \\infty }\\frac{a_1x_1+a_2x_2+\\cdots+a_nx_n}{a_1+a_2+\\cdots+a_n}=l $$ 这个问题我思考不了，暂且留在这里，或者用一个更具体的$a_n$可能可以解决问题，这里的题目是组合数，比如： $$ \\lim_{n\\rightarrow \\infty }\\frac{\\sum\\binom{n}{k}A^{k}B^{n-k}a_k}{\\sum\\binom{n}{k}A^{k}B^{n-k}}=l $$ 但是这样就已经是正确的结论了。\n三、Cauchy命题和一些变形 利用Stolz定理可以推出Cauchy命题，当然极限定义也可以证明之：\n(Cauchy命题)设{$x_n$}收敛于$l$，则它的前$n$项的算术平均值所成的数列也收敛于$l$，既有 $$ \\lim_{n\\rightarrow \\infty }\\frac{x_1+x_2+\\cdots+x_n}{n}=l $$ 其他形式：\n 若$\\lim \\limits_{n\\rightarrow \\infty }(a_n-a_{n-1})=d$，则$\\lim \\limits_{n\\rightarrow \\infty }\\frac{a_n}{n}=d$ 设${a_n}$为正数列，且收敛于$A$，则$\\lim \\limits_{n\\rightarrow \\infty }(a_1a_2\\cdots a_n)^{\\frac{1}{n}}=A$ 设${a_n}$为正数列，且存在极限$\\lim \\limits_{n\\rightarrow \\infty }\\frac{a_{n+1}}{a_n}=l$，则$\\lim \\limits_{n\\rightarrow \\infty }\\sqrt[n]{a_n}=l$  第一个是等价命题，2和3是推论。后面如果发现有有价值相关联的Cauchy命题的东西的话会补充到这里。\n[1]谢惠民,恽自求. 数学分析习题课讲义. 北京: 高等教育出版社, 2018.\n[2]丘维声. 高等代数学习指导书.上册. 北京: 清华大学出版社, 2017.\n","date":"2022-06-17","permalink":"/posts/other/stolz/","series":[""],"tags":["",""],"title":"Stolz定理和一道例题"},{"categories":[""],"content":"（我已经厌烦了这种重复抄写笔记的方式，所以没有笔记2了——2022.11.13）\n第一单元 语法    中文 日语     ~是~ [名] は [名] です   ~不是~ [名]は[名]では（じゃ）　ありません   ~是~吗？ [名] は[名]ですか   回答 はい、そうです・いいえ、ちがいます・分（わ）かりません   ~的~ [名表从属] の[名]   这个/那个是~ これ/それ/あれは[名]です   ~是~？ それは何ですか / あの人は**誰（だれ）**ですか（礼：どなた）   这个~是~ この/その/あの [名] は [名] です   （三个以上）~是哪一个/哪一个[名]？ ～はどれ/どの机ですか。   这里/那里是~ ここ/そこ/あそこ は [名] です（礼：こちらそちらあちら）   ~东西存在于~地方 ～は　[名表场所] です   ~东西在哪里？ ～はどこですか（礼：どちら）   ~也是~ [名]も　[名]です   （询问多种可能答案）~是~，还是~ [名]は　[名]ですか、 [名]ですか   ~多少钱？ [名]は　いくらですか   ~地方有~东西 [场所]に [物人]が あります/います（不具有意志）   ~东西在~地方 [物人]は [场所]に あります/います   ~东西在哪里？ [物人]は どこに ありますか/いますか   ~和~ [名]と[名]   谁都不在，什么都没有（全面否定） 誰もいません　何もありません（疑问词+も+动否定）    注意\n ～です是谓语部分，有时表示“是”，有时表示“在”；～は提示主语 日语中问句不使用“？” これそれあれ・このそこあの・ここそこあそこ使用相同。两人面对面时ko对应说话人近，so对应听话人近，a对应都比较远；两人同一地方时ko是较近，so是较远，a是更远。  表达和词语  わたし・あなた・あの人对应第一第二第三人称。あなた只在不知道姓名有需要称呼时用，不礼貌。 姓+さん，不分男女，不用于自己；名字+ちゃん用于对小孩的称呼；君（くん）用于与自己年龄相当或比自己年轻的男性。 请多关照：どうぞよろしくお願いします，省略：どうぞよろしく/よろしくお願いします。，更加礼貌：おねがいいたします，回答：こちらこそ 会社員（かいしゃいん）：强调在公司工作的人，不关注什么公司。社員（しゃいん）：强调具体属于某一个公司的人。 方（かた）：用于长辈，上司或者初次见面见面不多的人。あの方は田中さんです。 询问年龄：何歳（なんさい）ですか。礼貌（什么年龄都可以）：おいくつですか。对小孩：いくつ ええ表示对提问的肯定。是はい比较随便的说法。 非常感谢：どうもありがとうございました，普通感谢：ありがとうございます。，略表谢意：どうも 询问来自那个国家：お国（くに）はどちらですか，询问公司地址或者那个公司：会社はどちらです。意思需要自己判断 パソコン个人电脑是パーソナルコンピューター的缩写。   上（うえ）　下（した）　：上表示范围比中文小，只表示垂直上方。墙上是壁に而不是壁の上（墙上方的天花板） 前（まえ）　後ろ（うしろ）　 中（なか）　外（そと）　：里面外面 隣（となり）：旁边   ご家族　ご兄弟　ご両親指别人的，去掉ご才是指自己的。 兄弟（きょうだい）可以指兄妹姐弟姐妹兄弟。 离开家人一个人生活：一人暮らし（ひとりぐらし） おじいさん　おばあさん指祖母祖父　おじさん　おばさん指伯伯伯母叔叔婶婶舅舅姑姑等。   0-10：れい/ゼロ　いち　に　さん　し/よん　ご　ろく　しち/なな　はち　く/きゅう　じゅう 14、17、19两种写法都可以；40、70、90是よんじゅう　ななじゅう　きゅうじゅう 100：ひゃく；300、600、800的读音有变化：さんびゃく　ろっぴゃく　はっぴゃく。400、700、900继承407090。 1000：せん；千中只有3000读音有变化さんぜん，60008000不变。400070009000同样继承407090。 一万：いちまん 。十万：じゅうまん 。一百万：ひゃくまん 。一千万：いっせんまん。一亿：いちおく。 注意一百一千十万百万前面是没有“いち”的，一万一千万一亿都有“いち” 0.1：れいてんいち 。2/3：さんぶんのに。    第二单元 语法 动词ます形    ~ます ~ません ~ました ~ませんでした     肯定地叙述现在的习惯性动作、状态以及未来的动作状态 是ます的否定形式 肯定地叙述过去的动作，这是ます变为ました 是ました的否定形式   休みます 休みません 休みました 休みませんでした   起きます 起きません 起きました 起きませんでした   寝ます 寝ません 寝ました 寝ませんでした       中文 日语     现在是~点~分钟 今（いま）～時（じ）～分（ふん）です   ~时间发生了什么事情 名[时间]　に　动   从~到~期间发生了什么事情 名[时间]から名[时间]まで 动（kara和made可以单独使用）   什么时候干什么 いつ/何時（なんじ）/何曜日（なんようび）/何日（なんにち）动ますか   什么时候开始干什么/什么时候结束什么 いつから始まりますか？　何曜日まで休みますか？   去什么地方，回什么地方 名[场所]へ 动 （へ表示移动行为的目的地）   从什么地方来 名[场所]から 动（北京からきました）   和什么人一起做什么事 名[人] と动（私は友達と帰りました）   通过什么交通工具去哪里 名[交通工具] で名[地点]へ动（歩いでアパートへ帰りました）   从什么地方开始到什么地方终点 名[场所] から 名[场所] まで 动（駅からアパートまで歩いて帰りました：从车站走回公寓）   动+名（吃东西，看电视等等） 名 を 动（コーヒーを飲みます　何を食べますか）   什么地方干什么 名[场所] で 动（図書館で勉強します）   什么或者什么 名 か 名（パンかお粥を食べます：吃面包或者稀饭）   用什么手段/材料做了什么 名[工具] で 动（日本語で手紙を書きます：用日语写信）   什么人给什么人什么东西 人1 は 人2に 物3を あげます（私は小野さんに：我给小野，小野さんは森さんに。物品以“第一人称-\u0026gt;第二人称-\u0026gt;第三人称”或者“第三人称-\u0026gt;第三人称\u0026quot;转移）   什么人从什么人那里得到了什么东西 人1は 人2に 物3を もらいます（私はおのさんに：我从小野那里得到了。物品按照三二一或者三三移动）   见到了什么人 名[人]に会（あ）います（森さんに会いました）    注意：\n 表达现在的时间时，30分钟（三十分さんじゅっぷん）可以用半（はん）来代替。 表达具体时间的词前面还可以加上午前（ごぜん）午後（ごご）。今午前七時半です（现在是上午7点半） 表达动作发生的时间（时间に动）时，今（いま）、昨日（きのう）、明日（あした）、毎日（まいにち）、去年（きょねん）、来年（らいねん）等词后面不能加に：私は明日休みます（我明天休息） 什么东西在什么地方（[物人]は [场所]に あります/います）和什么地方干什么（名[场所] で 动）中文都是“在”，但在日语一个是に，一个是で。 什么人从什么人那里得到了什么东西（人1は 人2に 物3を もらいます）中，赠送者如果是人，后面可用に/から，多用に；如果是组织或者团体，用から：父は会社から記念品（きねんひん）をもらいました。 给东西直接说あげます会给人单方面强加于人的印象，可以用どうぞ/どうですか:李さん、これ、どうぞ（小李，吃吃点心）  表达和词语  两个名词都表示时间，且前面的名词包含毎（まい）时，两个名词之间不加の；当前面的名词不包括毎まい时，可以加也可以不加の。毎朝何時に起きますか？　来週（の）日曜日に働きます。 表示时间的大概，左右：ごろ。如一時ごろ、三十分ごろ。而ごろ后面一般不加に：十二時半ごろ寝ました（12点半左右睡觉） 家有两种表达：家（いえ）うち。家意指建筑物，着重家人时一般用うち。うち本身有“我的家”的意思，家表达我的家时需要”私の家”。 まっすぐ帰りました：直接回家。まっすぐ表示笔直的意思。 お先（さき）に失礼します。（我先走了）お疲れ様でした。（辛苦了） 何的读法有两种：なに、なん。基本读法是なに，在助词の和量词前读なん；在で前两种读法都可以。（何の本です？何時にきますか？何で会社へいきますか？何を食べますか？何がありますか？nan nan nan/nani nani nani） 离现在很近的过去：さっき、たった、今。离现在非常近用たった今，稍前用さっき。 ","date":"2022-05-31","permalink":"/bin/japanese-study-1/","series":[""],"tags":["",""],"title":"日语笔记1"},{"categories":["计算机"],"content":"0x00 前情 在4月中旬的时候，我看我一个op5二手机一直没人用，想送给别人，最终决定送给一个刚刚高中上完的亲戚使用。本着传教的目的，想着给手机root了再送出去，于是就了这么个简短的救砖的经历。我玩机的时间也不是太多，很多知识不懂，这次救砖也是我第一次经历。\n0x01 变成砖 在昨年5月份，我人生的第一次root是通过别人提供的工具箱一键root的，虽然在这之前通过magisk的官方教程尝试过root，但是因为手机是vivo，bl锁解不了，所以没有root成功，这也是二手机的由来。\n于是这次，我为了图方便还是使用了那个工具箱，全然忘机了我为什么丢掉了root（直接升级了系统到安卓10），而工具箱root只支持安卓8和9，结果就是手机就变成了砖，具体表现是手机开机后进入不了系统，黑屏状态，但是可以进入fastboot。recovery也是进入不了。\n0x02 救砖 由于已经过了半个月了记忆模糊了，我只是把整个流程叙述一遍，至于过程，反反复复搞了4个多小时吧，都是一步一步边搜索边操作的。\nrecovery方面，我分别尝试了官方rec和twrp。官方rec每次利用usb修复的时候中途都会失败，原因不明，因而使用了twrp。twrp刷入时使用了\u0026rsquo;fastboot flash recovery'，但是每次重启时却又没安装成功，于是只能使用低版本的twrp，recovery到这里就解决了，可以顺利进入twrp。\n接下来就是使用sideload线刷第三方rom了，这一部分比较顺利，但是sideload总会出错，查了一下发现是好像传的东西超过2gb的话就会有问题，于是只能委曲求全找比较小的第三方rom，最终成功刷入miui。\n0x03 官方方法root 成功救砖后我就安装官方教程进行root了，这一部分我之前做过，所以很顺利。安装magisk，去除rom的boot.img用magisk修补，利用adb pull这个img取到电脑上，fastboot flash boot。顺利的话很快的。root成功后就进行一些常用软件的安装，先弄zygisk，然后shamiko，lsposed，scene安上，再弄点什么模块什么的给他玩玩……其余的就等他自己探索，如果他有兴趣的话……没兴趣也无所谓，反正手机已经给他了……\n0x04 尾 回看其实发现过程不怎么难，但我觉得还是有点意思。希望后面会越来越好玩~\n","date":"2022-05-01","permalink":"/posts/tech/phone-root/","series":[],"tags":[""],"title":"记一次简单的救砖经历"},{"categories":["文字类"],"content":" 1.盎格鲁–萨克逊王国与维京人入侵  维京人摧毁了大部分撒克逊王国的实力后，剩下的英格兰国王、伯爵、大乡绅都奋起反击，大家联手对付维京人。在北方，皮克特人和达尔里亚塔（Dal Riata）本来互不相让，现在出现了前所未有的局面：貌似结成联盟来抗衡一个共同敌人。在北方20年的争斗后，皮克特国王君士坦丁一世刻意给自己起了第一个罗马基督教皇帝的名字，打败了达尔里亚塔，在811年，在北方建立了一个联合王国。\n同样，在剩下的非维京人占领的英格兰地区，统治者们面临无法改变的共同灾难时，摒弃前嫌，团结到单一的全英格兰国王旗下。要拢得住这种史无前例的忠诚，这人必定非同凡响，而阿尔弗雷德正是合适人选。都铎家族认为他非常具有号召力，愿意把不同于所有前辈的“大帝”称号封给他以示敬意，这称号直接将他和查理曼大帝相提并论。而且在所有关于阿尔弗雷德的神话中，也不能说它们错了。盎格鲁–撒克逊叫他英格兰的牧羊人，英格兰的宝贝。\n维京人摧毁了大部分撒克逊王国的实力后，剩下的英格兰国王、伯爵、大乡绅都奋起反击，大家联手对付维京人。在北方，皮克特人和达尔里亚塔（Dal Riata）本来互不相让，现在出现了前所未有的局面：貌似结成联盟来抗衡一个共同敌人。在北方20年的争斗后，皮克特国王君士坦丁一世刻意给自己起了第一个罗马基督教皇帝的名字，打败了达尔里亚塔，在811年，在北方建立了一个联合王国。\n同样，在剩下的非维京人占领的英格兰地区，统治者们面临无法改变的共同灾难时，摒弃前嫌，团结到单一的全英格兰国王旗下。要拢得住这种史无前例的忠诚，这人必定非同凡响，而阿尔弗雷德正是合适人选。都铎家族认为他非常具有号召力，愿意把不同于所有前辈的“大帝”称号封给他以示敬意，这称号直接将他和查理曼大帝相提并论。而且在所有关于阿尔弗雷德的神话中，也不能说它们错了。盎格鲁–撒克逊叫他英格兰的牧羊人，英格兰的宝贝。\n阿尔弗雷德于849年生于万蒂奇（Wantage），是威塞克斯国王埃塞尔沃夫（Aethelwulf）的小儿子，埃格伯特（Egbert）的孙子。塞克斯王国通过常见的战争和联姻结合的方法，取代了中央地带的麦西亚（Mercia）王国，成为最重要的撒克逊王国。马背上的强盗维京人那时还只是被大家当作一时的困扰，他们从圣陵和繁忙的撒克逊市场城镇比如哈姆威克［Hamwic，现代南安普顿（Southampton）的前身］大肆偷盗，然后假慈悲地离去享用赃物。但是后来船队的规模越来越大——每次30—35条船——而且维京人停留的时间越来越长，危害加大。到850年，他们整个冬天都待在肯特的萨内特和谢佩（Sheppey）。据《盎格鲁–撒克逊编年史》记载，850年，一支船队，整整350条船，袭击掠夺坎特伯雷和伦敦，废黜了麦西亚人国王伯赫特沃夫（Berhrtwulf）。白银也不再能保证维京人不杀到跟前，864年，肯特贵族已经依约支付钱财，但维京人仍然不顾一切，决定在这里大开杀戒。接着在865—866年的这一年间，伟大的基督教王国诺森伯兰被毁，这是不列颠到当时为止见过的规模最大的维京船队所为，867年约克沦陷。到876年，诺森伯兰的土地被维京人主要头领们瓜分。869年，这次轮到东盎格利亚国王埃德蒙，往常他都是花钱消灾，这次他却厌倦了，转而奋起反抗，却遭到斩首，身体被刺穿。很明显，对威塞克斯国王埃塞雷德（Aethelred）和他仅存的弟弟阿尔弗雷德来说，用不了多久，他们也将不可避免地直接面对维京人。\n今天我们知道的大部分关于阿尔弗雷德的故事都来自威尔士僧侣阿塞（Asser）所写的传记，阿塞应邀来到威塞克斯宫廷，毫无疑问热情地大唱赞歌。理想化地去看，阿塞所作的记述还是有一部分真实内容，阿尔弗雷德还是个孩子的时候就很好学，最有名的神童故事就是母亲给阿尔弗雷德一本绘图本盎格鲁–撒克逊诗集，这孩子就无师自通地全读懂了。不消说，阿尔弗雷德记住了诗歌，还大声地背给妈妈听，一个自大的小书呆子。\n可是，那年头容不得书生气。868年，维京人在麦西亚人诺丁汉过冬。阿尔弗雷德已经结婚，那明显是战略联姻，他娶了埃勒斯维斯（Eahlswith），岳母是麦西亚王室一员。到870年，丹麦人驻扎在雷丁（Reading），直接威胁到了威塞克斯王国。871年，埃塞雷德与阿尔弗雷德哥俩打了好多仗，高潮是阿什当（Ashdown）大捷。但还没来得及初尝胜利的喜悦，埃塞雷德就死了，留下阿尔弗雷德独自支撑威塞克斯王国。消息传来，第二支庞大的维京队伍已来到雷丁，可不让人省心，威塞克斯沦陷指日可待，整个盎格鲁–撒克逊英格兰看来要重蹈罗马–不列颠的覆辙。\n但就在这时，一些小的奇迹起了干扰作用。维京人的杀戮机器本来令人印象深刻，但其失败之处在于他们庆祝胜利的方式是自我分裂；他们分头去打劫不如征服之后分裂来得多。这都是因为维京人过于自信，以为没人能抵抗他们，在865年和871年，强大的维京人异教徒队伍都分头各自行动。在874年，865年来过的同一批上层维京人返回挪威，剩余的在诺森伯兰长住下来。871年来的一批，在维京人中属于低级阶层，领头的叫古德龙（Guthrum），安营在剑桥，而威塞克斯位于剑桥南边和西边，自然古德龙这帮人对威塞克斯构成两面威胁，维京人已视为威塞克斯囊中之物。当古德龙继续向格洛切斯特开拔时，眼看他的如意算盘就要成真了。\n一时之间，阿尔弗雷德只得暂且避其锋芒，撤退并且和古德龙交换人质，想使维京人离开威塞克斯进入麦西亚。尽管要和古德龙这样的异教徒盟誓，这种策略看起来短时间里能奏效，但阿尔弗雷德心里肯定是悲观的。果然，878年1月的寒冬，在第十二夜，阿尔弗雷德这样的基督徒庆祝显圣节（Epiphany），维京人知道对手的注意力肯定会分散，就对威塞克斯皇城奇彭纳姆（Chippenham）发动突然袭击，他们的计划当然包括俘虏国王，这差一点点就得手了。在当时实际上无力防守的情况下，阿尔弗雷德只能走为上计。\n接下来发生的事就是阿尔弗雷德传奇的重心，阿泰尔尼（Athelney）沼泽地里的莎草没过人头，这个逃亡者利用泥沼容易陷入作为有利条件，开始扭转大势抗敌。阿塞给我们描绘了一个游击队战士原型：“在萨默赛特的树林和沼泽里，过着极其失落的生活，没有生活资料，除了能靠突然袭击中找到的东西。”阿尔弗雷德被迫屈尊向农民乞讨施舍，包括养猪人的妻子，他烤焦了她的蛋糕时，对方使他非常难堪。无论在当时还是后来，这些故事都带着一种经文的调子（或者最起码有短文的影子）：尊贵的国王不幸沦落潦倒却仍然坚忍谦恭（特别是面对愤怒的妇人斥责时）；接着，时运不济，但得到神灵感应，阿尔弗雷德把握住了自己和王国的命运。后来，很多关于四处逃亡的国王故事中，有一种说法是圣卡斯伯特（除了他，还有谁？）现身，要求分享食物，阿尔弗雷德听从了他给他食物；来人随即消失，一会儿又穿上圣者的全副行头出现，应许他最终胜利。并且圣卡斯伯特和吉迪恩一样，敦促阿尔弗雷德相信上帝，吹响战斗号角，召集朋友们。\n到878年春天，阿尔弗雷德成功地召集起临时的抵抗联盟，依靠国王埃格伯特之石，在威尔特郡和萨默赛特（Somerset）边界，领导一支部队，两天后，他们在埃丁顿（Edington）打败了古德龙的维京人，一路追赶到奇彭纳姆，围困两周后，维京头领投降，阿尔弗雷德大获全胜，这可不是一般意义上的投降。古德龙被阿尔弗雷德的战神力量深深打动，他决定立即和他的30名武士加入基督徒战士之列。他在萨默赛特的阿莱（Aller）教堂受洗。阿尔弗雷德作为他的教父，将他从洗礼盆里托起。从前凶猛的异教徒维京贵族不再是穿戴盔甲，而是从头到脚裹着柔软的改宗白布。庄重的仪式结束后，他们受洗时的穿着送去威德莫尔（Wedmore）的阿尔弗雷德皇宫领地，因此这是战场和精神的双重胜利。阿尔弗雷德使古德龙相信了自己，还接纳他加入英格兰教会团体。这样，现在有可能签订神圣的有约束力的条约了（至少阿尔弗雷德是这么想的）。古德龙同意满足于在自己的东盎格利亚称王，再也不袭击威塞克斯、麦西亚或埃塞克斯和肯特的地面，后二者也完全属于威塞克斯统治。后来的事情大抵也就如此了，古德龙退到萨塞克斯的哈德利（Hadleigh），也许在那里过着田园牧歌式的隐居生活，悠游自在，不再像维京人那样给谁带来伤害。\n阿尔弗雷德很聪明，并没有被胜利冲昏头脑。这只是打败了一个强盗和他的队伍，可不是全英格兰的维京人武力。到9世纪末，诺斯人作为殖民者很明显要在不列颠岛长期盘踞，不再做打家劫舍的海盗。阿尔弗雷德的最大愿望就是控制局面，与皈依基督教从而相对温和的维京人邻国妥协。尽管埃丁顿一役不太算得上历史传奇，但它的确使维京人国王暂停了在不列颠岛上的扫荡，给了阿尔弗雷德宝贵的14年喘息时间。在这期间，他修建了30座坚固城堡，组成环状防御带，称作“伯赫”[10]，长期驻防守军，他的战略工事建筑在历代先祖的军事智慧积累之上：利用了铁器时代的山丘堡垒、罗马帝国的大道、撒克逊的低石墙和沟渠。他的民兵（fyrd）非职业军队，由高级领主属下的大乡绅筹建，配上马匹，实行轮值制。这样，不管维京人在何时何地出现，都要面对顽强的抵抗。正如阿尔弗雷德所预计的，在9世纪90年代，维京人真的卷土重来了，但不再像9世纪中叶维京人劫掠的全盛时期那样能够恣意妄为。阿尔弗雷德的措施迫使维京人不得不在小半个国家范围内活动，在丹麦人和撒克逊人的英格兰之间，从东盎格利亚，麦西亚东部到诺森伯兰划定了一道强大的边境防线。\n而这充其量是一种隔离状态。在886年，阿尔弗雷德进入伦敦时［他在罗马旧址上恢复了伦敦，而不是麦西亚–撒克逊人的伦敦（Lundenwic），那个更靠近今天的奥德维奇（Aldwych）和斯特兰德街区（the Strand）］，发生了一些具有重大意义的事件。阿塞写道，他被称为“不臣属于丹麦人的全体英格兰人”的君主。也是从此开始，他被叫作“盎格鲁–撒克逊的国王”。有的故事说得更进一步，称呼他“英吉利之王”（Rex Anglorum），927年，他的孙子倒确实是以这个头衔加冕。因此，毫无疑问在阿尔弗雷德生前，一个联合的英格兰王国已成形，甚至也已有预期。在阿泰尔尼（Athelney）不远处出土的精美“阿尔弗雷德珠宝”（Alfred Jewel），它非凡的祖母绿头面，和富勒（Fuller）胸针有点儿像，圆睁的双眼象征远见和智慧，它的品质完全适合用来赞美一个博学的君主。阿尔弗雷德珠宝侧面刻着传奇的“阿尔弗雷德让我制作”。也可以说是他复活了英格兰君主制。\n 2.阿尔弗雷德与英格兰中的罗马统治典范  的确，盎格鲁–撒克逊的英格兰王国尚在缓慢形成中，同时在苏格兰肯尼斯一世（Kenneth I）统治下的麦克·埃尔平（Mac Ailpin）王国也是这样。但是，当阿尔弗雷德故去的时候，他已经缔造了国王的头衔，以前它只是一个武士头领，颁赏指环者（阿尔弗雷德也被认为是其中最伟大的武士），到这时候已经是制度的建立者和天授王权之人。作为赞美诗翻译者的国王肯定想过自喻为新大卫王或所罗门（Solomon）。和大卫王一样，他是基督教会的左臂右膀——在阿宾顿（Abingdon）出土的一柄剑说明他如何郑重其事地看待自己的职责。和所罗门一样，阿尔弗雷德认为王权的基础应该是正义，而不是武力调停。因此他把众多法律条文和惩罚条例合并，整理出成为单一明晰的完整法律，让人编写、翻译成文，他是第一个这么做的国王。那么他的子民（至少那一半自由的臣民，我们得记住撒克逊英格兰是个奴隶社会）能把得到皇家的裁决视为当然，还有，阿尔弗雷德提供的司法裁决明确限定在现实主义范围内。阿尔弗雷德深知宣布世家仇杀违法的实际作用不大，所以他只坚持国王应该控制这种行为，给予一定的宽限期，例如，让受袭击一方在受攻击前能妥协。维京人烧毁修道院图书馆的痛苦令人记忆犹新，阿尔弗雷德还自认国王要成为教育者。在翻译波伊提乌（Boethius）《哲学的安慰》（De consolatione philosophiae）一书时，他给予智慧最高的赞美，而阿尔弗雷德关于教育的承诺从实际出发。他不仅为自家和宫廷，同时也为全体贵族开办学校，这么做的目的是告诉那些想称王的人，首先要成为识文断字受过教育的人，而不是靠武力和掠夺。\n阿尔弗雷德最热忱最坚定的信念是，动用武力的先决条件是拥有知识。这是远见卓识，不列颠地面上的统治者里还有多少人能如此？\n撒克逊国王经历了长久的转变，才从杀人不见血的异教徒、挥舞斧子的冒险家变成了图书馆的建造者！自然这幅和平好学的盎格鲁–撒克逊威塞克斯图景，更像是一种高贵理想而不是眼前的现实。大半个国家处在维京人的严重威胁下，到10世纪，以威塞克斯国王统治为基础的英格兰已经把国境扩展到特威德河；这片依靠维京人统领的“丹麦法”（Danelaw）统领的地区能享有充分自治。到10世纪末，第二波凶猛的维京人强盗，再一次试图深入盎格鲁–撒克逊英格兰腹地侵略。11世纪初，丹麦的一个国王克努特（Cnut）统治了整个哈德良长城以南的国土，但他的统治更多是受益于阿尔弗雷德及其继任者们奠基的盎格鲁–撒克逊政府。\n经过历年磨难，威塞克斯王家的朝廷后来被摧毁、血洗，甚至常常到了被彻底清洗的边缘。但英格兰国王的范式在阿尔弗雷德的坚持下，像水晶一样纯化了，在最里层植入了撒克逊文化的中心即罗马帝国的统治典范；而通常认为是撒克逊人埋葬了这一古典传统；这是早期不列颠历史上最具讽刺性的事实之一。在特威德河以北，这种情况同样存在。阿尔巴（Alba，900年后他们这么称呼旧的皮克特人国土）国王们轮流用盖尔语和拉丁文名字给他们的儿子们取名，一个叫安格斯（Oengus）王子，他的兄弟叫康斯坦丁王子。从许多方面来看，阿尔弗雷德是撒克逊人中最罗马化的。853年，还在他孩提的时候，他的父亲埃塞尔沃夫送他去罗马执行一项特殊使命，在那里，教皇利奥九世（Pope Leo IV）给小家伙穿上罗马执政官的皇家紫袍，给他腰里围上罗马基督教武士的剑带。公元854—855年，阿尔弗雷德和父亲一起在罗马待了一整年，甚至去了帕拉丁山（Palatine）的废墟，这对于一个盎格鲁–撒克逊人来说，绝对是没齿难忘的经历。成年后阿尔弗雷德学习拉丁语，翻译教皇格列高利的《神职关怀》（Pastoral Care）一书，使他热切的基督教罗马化过程画上圆满的句号。教皇马克西姆斯二世（Maximus II）在任期间，阿尔弗雷德的一个做法后来成了传统，每年给英格兰四分之一的城市免税，返还税款作为国王的救济金，送英格兰人民去罗马游学，这个传统直到亨利八世（Henry VIII）改革才终止。\n当然，阿尔弗雷德忠于的这个罗马，早已不是克劳狄和哈德良派遣军团上岛进而缔造了不列坦尼亚的那个异教徒帝国，而是新的罗马基督教帝国。假如说阿尔弗雷德心中有他自己关于王权的崇高目标，那一定是查理曼大帝。阿尔弗雷德让有学识的宗教人士进入宫廷的政策，看上去就是直接仿效法兰克皇帝。同样，973年，当他的曾孙埃德加（Edgar）先后加冕两次时，邓斯坦（Dunstan）为他设计典礼如下：坎特伯雷大主教（必定懂得古迹的人）——直到今天仍然是英格兰加冕的仪式核心——涂抹圣油、拿起王冠上带十字架的小球和节杖、欢呼“国王万岁！天佑吾王！”——这些来自罗马也来自法兰克传统。那么那两次加冕又是在什么地方举行的呢？就是英格兰这两个罗马和古不列颠融合最彻底的地方：巴斯和切斯特（Chester）。\n不管他还懂得什么其他的，埃德加已经足够聪明，他知道如果要存活下来，英格兰国王决不能心胸狭隘。\n ","date":"2022-04-28","permalink":"/posts/literature/british-history-2/","series":[],"tags":["",""],"title":"威塞克斯与维京人"},{"categories":["文字类"],"content":"第一段：\n 罗马帝国东部前线灾难连连，野蛮人的军队侵入帝国腹地。与之相比，不列颠至少表面上来看稳如磐石。卡劳修斯完善了哈德良长城防线，他加筑了九座“撒克逊海岸要塞”，从诺福克的布兰卡斯特（Brancaster）到汉普郡的博奇斯特（Portchester），战略性地排列在东南沿岸，但由于人力匮乏，帝国军队大批抽调回防，因为欧洲大陆战事吃紧。罗马的敌人对这样的损耗当然不会不知情，公元367年，毫无先兆地发生了三股不同的入侵者合力侵入。盎格鲁–撒克逊（Anglo-Saxon）人从北海来，突破了撒克逊海岸要塞，杀死了守将。向来屈服在罗马统治下的武士，即苏格兰中北部的皮克特人和来自爱尔兰的达尔里亚塔盖尔人（Gaelic Dal Riata，更常见的也更混淆视听的说法是“斯科蒂人”[6]），在陆地上攻破一直认为固若金汤的其他要塞，别墅被洗劫一空然后放火焚毁，城镇被包围，没有给养补充或援军。编年史学家阿米亚努斯（Ammianus）写到伦敦被围困时，记载了匪徒们沿路驱赶劫掠的群众和牲畜。\n这只是不列颠暂时的情形。两年后，令人震惊的野蛮人入侵过后，罗马的法制和秩序恢复了，守卫加强了。但无可否认，危机到4世纪末出现了。具有讽刺意味的是，这个国家在面对外部袭击时在有些方面束手无策，是因为它太适应罗马政府了。足够的守备是保证位于罗马帝国这个系统中心的城市生活延续不断的先决条件。但是，由职业军人和外国雇佣军加本地人辅助担当的防卫力量这时候不再可靠（不管帝国做什么许诺都没用）。失去了这种保护后，最罗马化的不列颠省一时间无法想象临时组织自卫，更别提做点别的什么了。在不列颠那些城市化程度较低的外围地区——威尔士、德文和康沃尔，在较远的北方，例如，那些旧的不列颠准罗马武士阶层较少融入罗马当局的地区——反倒能组织起一些由本地强人领头的自卫，山区丘陵地形对他们也有利，有一个地方甚至收复了哈德良长城上废弃的博得斯瓦德（Birdoswald）罗马要塞作为军事总部。军事劣势导致了经济危机。在罗马–不列颠的中心地带，农民因为给城市里的市场提供农作物，世世代代因此生活富足。但这时野蛮人袭击市场，城乡之间的重要纽带被切断，很多乡下人只好重新变成游牧民。留下的居民也看不到有什么理由要特别忠于罗马–不列颠当局，他们已经没人保护，怎么还能在乎谁在统治着不列颠？对没有自由的村民来说，痛苦的只是不断变换一拨拨主人。公元410年，接到不列颠请求援助的信时，霍诺里乌斯（Honorius）给不列颠领头的市民回信说，从此以后，他们得设法自卫，指望罗马帝国的庇护已经不再可能。\n 第二段：\n 吉尔达斯认为公元5、6世纪的灾难——饥荒、小规模暴政、“一头野蛮人中的‘雌狮’率领一批‘幼崽’带来的蹂躏”——是因为倔强傲慢的罗马–不列颠人甚至基督徒不遵守神的意旨，招致神的惩罚；基督徒“本来应该是全体人民的模范榜样，但事实上他们大部分喝得烂醉如泥”。为了使不列颠历史事件听起来更像《旧约》（Old Testament）经文里的灾难，也为了带着点所谓诗意——“破碎的尸体表面是一层鲜血凝结成的紫色外壳，可怕得好像一些葡萄压碎了混在其中。”——吉尔达斯夸大了崩坍的范围和速度。野蛮人武士即使在最“高潮”也不过是分散的小股势力，稀稀落落地驻足（如果他们也算驻扎的话）在不列颠的东部和南部。当然，他们蛮横无理而极具威胁，但在公元6世纪，罗马–不列颠人在总人口上占压倒性多数，野蛮人可以说势单力薄。这种数量上的不均衡使得某些抵抗行动即刻远近闻名，比如在圣奥尔本斯（St Albans）即维鲁拉米亚姆（Verulamium）临时发动的行动，圣日耳玛纽斯（Saint Germannus）最有力的战争武器就是高喊“哈里路亚（Hallelujah）”而取胜；或者在不列颠北部或苏格兰南部的战斗，在诗人阿贝林（Aneirin）创作的威尔士史诗《葛德丁》（The Gododdin）里，不列颠三王坎里克（Cynri）、塞农（Cynon）与辛瑞恩（Cynrhain）及其300武士，“戴着金环”，骑在300匹威猛的公马上，迎战撒克逊人。其中最著名的是可能发生在公元516年的巴东山（Mount Badon）之战，这个地方有时被认为是在巴斯周围某座小山上。后来，公元8世纪的僧侣历史学家南尼厄斯（Nennius），想象巴东山之战的胜利者不是别人，正是亚瑟，最后一个罗马–基督教武士，挺身而出反抗黑暗蛮族；但是凯尔特智者给予卡米洛（Camelot）一种圣地氛围和神授王命，这一抹诗意，照亮了这个在编年史中几乎无从寻觅，也难以准确纪年的时代。但更有可能的情况是，巴东山之战的英雄是吉尔达斯描述的某个罗马贵族，或许是前执政官安布罗修斯·奥里利厄斯（Ambrosius Aurelianus），他的名字第二部分就有金环的含义。\n尽管这些传奇带着史诗的光辉，但事实上公元5—6世纪不列颠岛一蹶不振时，并非就只有光明与黑暗激烈交战。随着罗马–不列颠土崩瓦解，紧接着盎格鲁–撒克逊的英格兰骤变转型，不列颠历史上割据浪潮风起云涌，但它们和不列颠绝大部分居民的个人经历没有关系，当然，罗马行省的统治机构确实瓦解了，可是在前几批撒克逊雇佣军和海盗上岸后很长一段时间里，罗马–不列颠的社会活动、文化乃至古不列颠的语言大部分都保留了下来。很可能罗马–不列颠人和北海武士们不是死敌，倒是世代比邻而居。因为撒克逊人、朱特人（Jutes）和盎格鲁人需要成熟的有人耕种的土地（因为他们自己根本不想屈尊种地），同时，无自由的村民唯一的兴趣是算计哪个领主能提供更多的安全保护。这样，新旧势力之间很容易达成合作。\n","date":"2022-04-20","permalink":"/posts/literature/british-history-1/","series":[],"tags":["",""],"title":"罗马-不列颠到盎格鲁-撒克逊"},{"categories":[""],"content":"24/4/8 或许我想，英语老师才是那个剑冢，才是条狼，非常恶毒，深深怀疑。\n另外我需要去另一个地方找工作。需要的准备有衣服，房子。目前的存款应该没问题的，然后找工作方面还需要完善简历，打印成绩单等。\n24/3/23 经历了许多，我依旧还是老样子，我在工作上好像也有点失败。但现在我想法不一样了，我想在这里面发泄我的情绪，我真的很想骂人，这工作真的费力不讨好，我真的太讨厌教书了，教一群智障，教的这么费力，教两门科目，有门科目资料也是少得可怜，还需要我自己去弄，工资也是少的可怜，又累又不讨好，你妈卖批学生还不会感谢你，只知道“啊这里我又没教到，啊我讲太快了，啊我成绩提不上去就是你的错”，真的是日了狗了，老子tm一辈子再也不做这种事了。教这个b科目，教这群垃圾。\n23/9/27 事情按照我预想地发展，我确实越来越好了，我现在更坚信自己能够变得很厉害，给老婆和周围人一个美好的人生\n23/9/8 女朋友的几个关键词：可爱，纯真，饱受痛苦。我要一直守护她。\n23/9/1 我的人生在8月发生了翻天覆地的变化。遇到了喜欢的人……希望能够长久下去；然后我的病希望能够稳步恢复。\n23/7/30 估计租门面这个事情，大概率会亏，我估计会亏32-5*2=22万。大概是两年的工资了。我得加吧劲！\n补充：这件事可能促进爸妈离婚，不过我是崇尚虚无主义的，只要人活着什么都没关系。但是这样的话没有稳定的经济来源，那我目前就要准备去学习工作技能找工作了。\n补充2：没买。但是因此事最近多了很多麻烦的事，很难受。本来数据结构复习就够头疼了……姑且休息一下，调整呼吸。\n23/7/24 从今天开始挑战五个月除了吃住只花200元！\n23/7/3 我发觉阅读网安文章更看文献差不多，看文献不可能将所有每一篇文章全部总结一下吧？留个印象即可。所以我感觉目前这样还是算了，重新整理一下网站。\n23/6/10 有时会有那种“目前正在经历的事好像以前做梦梦到过”的感觉，每往前走一步都是一种验证重复。不知道是不是梦的理念和现实重合了。\n23/6/01 我是那种人，在外人不熟悉我的时候拼命表现自己的好想讨好别人，但当亲近之后却又恐惧地将人拒之门外。我真是矛盾啊。\n23/5/26 最终我还是不准备走正规路线。其实做出决定的最大原因在于自身的不安全感，因为是个不正常的人，世上大部分高学历的路线都必须要进入公司等机构工作，而是我所恐惧的，我恐惧我离开了组织机构我会失去一切。为了能随时离开，我决定学习黑客技术。至于其他的，有经济基础有兴趣去学吧。\n23/5/21 突然好想做人工智能的工作……怎么办。我看看我这想法会持续多久吧，如果持续了一个月，那我可能真的要考虑考虑了。\n23/5/12 答辩顺利过关，没想到离上次写的过了这么多天，我也马上准备离开雅安了。我觉得以理想的思考铲除理性就如试图提着自己拉开地面一样困难（不可能），非理性的探索任重道远。\n23/5/02 被自己菜晕。我觉得我应该找好自己的定位……我不过是虫子中稍微突出的虫子罢了，我梦想的光景大概有点形象了，追求安稳，我设想我在普通的维修点普通地过日子，追求技术。我说这些只是提醒自己不要做天命以外的事，我依旧可以努力，但我总会遇到一个永远也达不到的地方，所以不要给自己太大压力了。我是从辣条，游戏厅，烟雾缭绕的网吧中来的，我始终是个喜欢到处玩耍的野小孩。\n23/4/28 想成立开锁王\u0026amp;保安俱乐部……\n23/4/20 其实除了工作挣钱和休息时间，人生所剩的自由时间已经没有多少了。珍惜时间学习阅读自己想要的吧。当然可以浪费时间，但是所浪费的时间都是从学习，接触了解美好有趣的事物的时间中扣除了，时间本身是矛盾的，做了这件事做不了那件事。损失的是遇见美好事物的可能，我很痛心。什么美好事物呢？听一听魔法使之夜的音乐，独自品品茶便知道了。\n我还想学习和接触更多的事物，但我不知道我还能活多久。但对于这种艺术类的品赏还是得看时机，很多时候是静不下心来感受的，可遇不可求的存在。\n23/4/18 为了入侵系统而学的知识瞬间魅力大增，有很多东西等待着学也是种幸福。\n23/4/17 难于启齿，我最近一直梦到拉shit的场景……回想起我小时候到初中时期经常憋着，我觉得我人的问题可能很大程度和这个有关。我开始看梦的解析了，希望能从潜意识角度入手这个问题，多看看弗洛伊德等相关作品。听说黑格尔哲学也比较玄乎意识流，我也准备看看。\n23/4/15 我的家人们根本不关心我的实际情况，我只能欺骗他们了。我最清楚我的情况，但我对我的病一无所知。\n23/4/14 一遍说“钱不好挣啊，得省钱”，一遍又疯狂地买几百的游戏账号……我都懒得吐槽我自己了。\n我现在将这个页面隐藏了，我估计能看到这个页面的不超过两位数。Fastjson漏洞真难学啊……我觉得还需要更多时间，这东西看一会不想看了。\n关于情绪，我觉得失落悲伤的情绪好过浮躁焦虑的情绪，第二种情绪真的非常难受，什么都做不了。伤心低气压嘛至少可以看看剧，漫画。\n2023-04-05 经过一番思考，我不想读研了，但这几天还是先准备准备复试，暂时把拟录取拿到再说。我对数学不再充满热爱了，目前只是将数学当做工具，并且只想思考实际的事。按照最坏的情况来说，应用数学出来后貌似只有当老师比较合适一点，与其打工还不如现在开始。（好了，这下复试都不用准备了，可以摆了，只能说考研失败的经历还是很痛苦的，学坏了身体，却得不到什么东西。）\n2023-04-02 あしゅみ这名字我太喜欢了，又是お趣味又是あすみ的。卡哇伊！\n2023-03-30 老是想一步登天不可用哟，dame。\n2023-03-27 我时而感到自己一无所有，时而感到什么都能有；时而要求低到网络搬砖工，时而又想自己能很厉害；时而想做应用，时而想做理论。感觉现实很割裂呢，不太清楚很多事，什么事情都是忽高忽低的，矛盾体的集合，，此消彼长，此起彼伏，半升半降，繰り返す。\n嘛，普通事情就是看个熟悉，又不是叫你研究什么大成果。一遍看不懂看第二遍，又看不懂看第三遍，直到熟悉为止。一次不成功就又来。自己熟悉时就会觉得自己又行了。至于自己能想达到什么程度，能达到什么程度，想怎么幻想怎么幻想。\n2023-03-25 最近在听重金属，感觉挺适合我的，还以为很伤耳朵，结果没啥感觉，每天早上下午听几小时。为什么突然听重金属了，主要还是因为最近的飘忽不定，加上看了2019万圣节滑板的视频。有种将所有事物都摧毁的想法，抱着这种摆子想法听歌。\n2023-03-24 何が悪いの？意义是自己赋予的。\n2023-03-22 高情商：我觉得决定一个人的不是学校而是能力。\n低情商：你考上的是垃圾学校，但仍未来可期。\n2023-03-19 不得不说我这个博客已经全是歌词了……主要原因还是写其他东西太费精力了，还有最近也没有学啥新知识~\n2023-03-10 青空下的加缪……我决定下一个推的gal是这个！(来自未来的自己：玩了一段有点无聊，暂时算了)\n2023-02-28 最近在看《夏日重现》，我觉得他们那个方言真的好可爱啊，我都非常想去学了！但目前又不知道，或许查一查就知道了やん！\nhttps://www.bilibili.com/read/cv18879462\n2023-02-19 昨天晚上加了个评论系统，其中还可以统计文章访问次数，鉴于明知道流量很少的情况下，我还是不打开了…… 另外虽然我每首歌低下都写了个乐谱，但真是心有力而余不足，我这时期学不了那么多了，如果可能我活到40岁，那时候我觉得合适了。\n车子被偷真的大大地打乱了我的计划，现在回乡非常非常麻烦，但是我觉得应该走之前再回去一次。\n2023-02-17 我好喜欢布琉艾特……声音太好听了~ 然后我去查了一下，发现声优居然是前职业拳击手！！！另外我也需要提一下，代表她的音乐同样很喜欢，非常有活力轻盈，同SP中的空门苍一样！。\n另外我发现这个博客的目录系统不是很明显，我又想换一个博客了……但是不知道迁移得了不。\n2023-02-14 遭遇南宁周某（窃格拉瓦） 车被偷啦！好心疼。为什么选我的车！一晚上就不见了……然后就是第一次报警，第一次去派出所，警察还给我一支烟。反正这电车是大概率要不回来了。默哀……\n2023-02-01 这次又是我一个人在家里了。我要尽量在回学校前消耗完所有家里的东西！而不是什么生存模式。我得做很多关于大葱的菜才能将家里面的大葱消耗完。 做饭真的挺解压的~不过一定至少做出来能吃。做饭也是种生活态度，如果在心情不好时也愿意用心做菜煮饭的话，那一定很不错。 另外以后一些简短的分享就在这上面写了。自己有些时候确实有冲动想发点东西，但是感觉都不合适。所以最终还是决定在这写动态类分享了。唯一的问题就是没有和文章区分。\n2022-06-23 今天是艾伦图灵（Alan Mathison Turing，1912年6月23日—1954年6月7日）的生日，恰好是北回归线的日子。祝图灵110岁生日快乐！\n以下选自《图灵传》：\n 对艾伦来说，这个问题的意义是，它展示了怎样由有理数推出无理数。因此，用类似的方法，通过一条对角线的证明，可计算也可以推出不可计算。当艾伦想到这里时，他马上就知道了希尔伯特问题的答案——不。不可能存在一种“机械的过程”来解决所有数学问题，每一个不可计算数都是活生生的例子。\n  2022-04-13 最近读到的：\n In an image-centered and pleasure-driven world, there is no place for rational thinking, because you simply cannot think with images. It is text that enables us to \u0026ldquo;uncover lies, confusions and overgeneralizations, and to detect abuses of logic and common sense. It also means to weigh ideas, to compare and contrast assertions, to connect one generalization to another.\u0026rdquo;\n That\u0026rsquo;s Why I love TeXT. 回到固有的生动活泼的思考。\n 2022-03-31 1.日记代替 这学期开始考研了，我用日记代替了平常思考记录的电子笔记，所以很多东西都不会发在这了。以前的就作纪念吧（不过我偷偷删了你们也不会知道）。\n2.最近 3月份很忙碌，三级考试还有毕业设计。普通日子除了学习就是玩。不过我已经找到了最重要的东西了，我现在在慢慢理解并行动，这是我理解的“知行合一”，不知道原意是什么。\n一个人租房子真的太舒服了，所以我以后一定好好挣钱争取有自己的一席之地，自己单独的位置。\n最近看的番剧：进击的巨人，幸运星。进击的巨人看到第二季快结束了便不想再看了，我觉得这番编剧是个很肤浅的人，只知道愤怒和视觉冲击还有无脑的信念，整部番剧很没意思。幸运星非常好看，强推！\n最近玩的游戏：国际象棋和刺客信条。lichess里面的每日残局经常下，非常好玩~刺客信条也很好玩（这就是大作嘛？），另外“万物皆虚万物皆允”我也觉得很有意思，和我的目前的人生信条有点相似。\n 最后还是唱起那旋律：#432165454~ 未来加油~ 我永远喜欢Eustia和L.L.\nAdds:关闭上学期做的Java智能问答系统 这样就结束了。最后想说一句：学校的项目不配我用心做。我那天就像失恋被甩了一样很难受（这句话槽点慢慢草www）。\n","date":"2022-02-17","permalink":"/tweet/essay2/","series":[""],"tags":["",""],"title":"随记合集2022.3-"},{"categories":["二次元"],"content":"1.歌词 来源于网易云歌词。   交(か)わした約束(やくそく)忘れないよ\n交换过的约定我一直记得\n目(め)を閉(と)じ確(たし)かめる\n闭上眼仔细确认\n押(お)し寄(よ)せた闇(やみ)\n驱散压迫而来的黑暗\n振(ふ)り払(はら)って進(すす)むよ\n向前进发\nいつになったらなくした未来を\n我在这里是否还能看见\n私ここでまた見ることできるの\n那早已失落的未来\n溢(あふ)れ出(だ)した不安(ふあん)の影(かげ)を\n那溢出来的不安的影子\n何度(なんど)でも裂(さ)いて\n无数次撕裂\nこの世界歩(あゆ)んでこう\n在这世上仔细前进\nとめどなく刻(きざ)まれた\n不停刻画着的时光\n時(とき)は今始まり告(つ)げ\n如今正式宣告一切的开始\n変わらない思いをのせ\n我带着不变的信念\n閉(と)ざされた扉(とびら)開(あ)けよう\n打开尘封已久的门\n目覚(めざ)めた心は走(はし)り\n觉醒的心为了描绘未来\n出(だ)した未来を描(えが)くため\n开始奔走\n難(むずか)しい道\nで立(た)ち止(ど)まっても\n前路充满险阻\n空はきれいな青(あお)さでいつも\n但天空永远蔚蓝\n待っててくれる\n如永恒般 在那里等待着我\nだから怖くない\n所以我无所畏惧\nもうなにがあっても\n无论发生什么\n挫(くじ)けない\n也不会再感到受伤\n振り返れば仲間(なかま)がいて\n回头时也有朋友陪伴\n気がつけば優しく包(つつ)まれてた\n大家的温柔将我包裹\nなにもかもが歪(ゆが)んだ世界で\n在一切都被颠倒的世界里\n唯一(ゆいつ)信じれるここが\n我唯一确信的\n救(すく)いだった\n只有最初的救赎\n喜(よろこ)びも悲しみもわけあえば\n若将喜悦和悲伤一同分享\n強まる想い\n心灵就能变得坚强\nこの声が届くのなら\n这声音如果能够传达\nきっと奇跡はおこせるだろう\n奇迹就一定会发生\n交わした約束忘れないよ\n交换过的约定我一直记得\n目を閉(と)じ確かめる\n闭上眼仔细确认\n押(お)し寄(よ)せた闇(やみ)\n驱散压迫而来的黑暗\n振り払(はら)って進むよ\n向前进发\nどんなに大きな\n无论前路\n壁(かべ)があっても\n存在着多么大的阻碍\n越(こ)えてみせるからきっと\n也一定能跨越\n明日信じて祈(いの)って\n我相信着明天如此祈愿\n壊れた世界で\n在这崩溃的世界中\n彷徨(さまよ)ってわたしは\n彷徨着的我\n引(ひ)き寄(よ)せられるように\n如受到启示一般\n辿(たど)り着(つ)いた\n最后还是来到了这里\n目覚(めざ)めた心は走り出した\n觉醒的心为了描绘未来\n未来を描くため\n开始奔走\n難しい道で立(た)ち止(ど)まっても\n前路充满险阻\n空はきれいな青さでいつも\n但天空永远蔚蓝\n待っててくれる\n如永恒般 在那里等待着我\nだから怖くない\n所以我无所畏惧\nもうなにがあっても\n无论发生什么\n挫けない\n也不会再感到受伤\nずっと明日待って\n永远等待明天的到来\n 2.翻译 暂无待补\n3.乐谱 暂无待补\n","date":"2022-02-11","permalink":"/posts/anime/connect/","series":["动漫歌曲"],"tags":[""],"title":"コネクト(TV动画《魔法少女小圆》片头曲)"},{"categories":["二次元"],"content":"1.歌词 来源于网易云歌词。   「それじゃ またね」って手を振(ふ)って\n向你挥着手说“那就再见啦”\n無理に笑って さみしくなって\n勉强地笑着 变得空虚起来\n歩道橋(ほどうきょう) 自転車抱(かか)えて登(のぼ)る人\n过街天桥上 推着自行车攀登的人\nコンピニ 誰かのウワサ話(うわさばなし)\n便利店里 讨论着某人的流言\n交差点(こうさてん) 信号(しんごう)\n十字路口 红绿灯\n遠くのクラクション\n从远处传来的汽车鸣笛声\n知らない誰かの笑い合(あ)う声\n不知是谁和谁的欢声笑语\n今日は独りで歩(ある)く\n今天一个人漫步\n通(かよ)い慣(な)れた街(まち)\n即使在这熟悉的街道上\nでもいつもよりもなんだか\n不知怎么地比平时还觉得\n自分(じぶん)がちょっと 小(ちい)さく思えるよ\n自己更加渺小了\n「それじゃ またね」って手を振って\n向你挥着手说“那就再见啦”\n笑顔作(つく)って さみしくなって\n强作笑脸 变得空虚起来\nホントはまだ話(はな)し足(た)りないけど\n其实我明明还没有和你聊够\n「それじゃ またね」って言葉で\n“那就再见啦”这句话\nまた会(あ)えるって ウソをついて\n说着“还能再见”的谎言\nいつも通(とお)りの笑顔で言(い)うよ\n就像平时那样微笑着说吧\n「また あした」\n“那就再见啦”\n独りには慣(な)れてる フリをしてるけど\n虽然假装着自己已经习惯独自一人\nホントはそんなに強くないし\n但其实也并没有那么坚强\nいつもと同(おな)じ景色 いつもと同じ街(まじ)\n一如过往的风景 一如过往的街道\nなにも変わらないハズなのに\n明明周围什么也没有改变\n自分だけが小さく思えるよ\n只是觉得自己很渺小\n「それじゃ またね」じゃなくって\n不是说什么“那就再见啦”\n「あと少(すこ)し」って言えば良(よ)かった\n要是能说“再待一会儿”的话就好了\n気が付(つ)いて欲しくて期待(きたい)していたけど\n虽然这样期待着 想让你察觉到这份心情\n「それじゃ またね」って言葉で\n用“那就再见啦”这样的话\nまた自分に ウソをついて\n再次对自己撒谎\nいつも通りの笑顔で隠(かく)すこの気持ち\n如同以往 用微笑隐藏着这份心情吧\n「それじゃ またね」って手を振って\n向你挥着手说“那就再见啦”\n笑顔作って さみしくなって\n强作笑脸 变得空虚起来\nホントはまだ話し足(た)りないけど\n其实我明明还没有和你聊够\n「それじゃ またね」って声さえ\n连“那就再见啦”这句话\n届(とど)かないほど 近(ちか)くて遠い\n好像都无法传达 这么近又那么远\nいつも通りに あと１度(いちど)だけ言(い)わせて\n一如往常 一次就好 让我说出\n「また あした」\n“明天 再见”\n 2.翻译 暂无待补\n3.乐谱 暂无待补\n","date":"2022-02-09","permalink":"/posts/anime/mataashita/","series":["动漫歌曲"],"tags":[""],"title":"また あした"},{"categories":["二次元"],"content":"1.歌词 来源于网易云歌词。   いつか君が瞳(ひとみ)に灯(とも)す愛の光が\n曾在你眼中点亮的爱之光\n時(とき)を超(こ)えて\n超越了时空\n滅(ほろ)び急(いそ)ぐ世界(せかい)の夢(ゆめ)を\n急剧消逝着的世界的梦\n確(たし)かに一(ひと)つ壊(こわ)すだろう\n此刻确实面临着毁灭\n躊躇(ためら)いを飲(の)み干(ほ)して\n饮尽所有的踌躇之后\n君が望(のぞ)むモノは何?\n你要索求的到底是什么？\nこんな欲深(よくふか)い憧れの行方(ゆくえ)に\n在如此深切渴望着的应许之地中\n儚(はかな)い明日はあるの?\n存在的是否只是虚无缥缈的明天？\n子供(こども)の頃(ころ)夢に見てた\n用那如同儿时梦见的\n古(いにしえ)の魔法(まほう)のように\n能像远古魔法一般\n闇(やみ)さえ砕(くだ)く力(ちから)で\n粉碎黑暗的力量\n微笑(ほほえ)む君に会(あ)いたい\n去与微笑的你相逢\n怯(おび)えるこの手(て)の中には\n这颤栗的手中\n手折(たお)られた花の勇気(ゆうき)\n有着残花的勇气\n想いだけが頼(たよ)る全(すべ)て\n能够依赖的只有信念\n光を呼(よ)び覚(さ)ます\n这呼唤光明到来的\n願(ねが)い\n信念\nいつか君も誰かの為(ため)に\n你终有一天会为了谁\n強い力を望(のぞ)むのだろう\n去祈求强大的力量\n愛が胸(むね)を捉(とら)えた夜(よる)に\n心灵为爱所困的夜里\n未知(みち)の言葉(ことば)が生(う)まれて来(く)る\n你会脱口而出从未说过的话语\n迷(まよ)わずに行けるなら\n只要我能扫清疑虑\n心が砕(くだ)けてもいいわ\n心灵变得破碎也无妨\nいつも目(め)の前の哀(かな)しみに\n我衷心渴望着的\n立(た)ち向(む)かう為(ため)の\n是那句能与眼前的悲哀\n呪文(じゅもん)が欲しい\n作斗争的神秘咒语\n君はまだ夢見(ゆめみ)る記憶(きおく)\n你是残留梦中的记忆\n私は眠(ねむ)らない明日\n我是无法入眠的明天\n二人が出会(であ)う奇跡(きせき)を\n为争取能让我们相遇的奇迹\n勝(か)ち取(と)る為に進(すす)むわ\n向前进发\n怯(おび)えるこの手の中には\n这颤栗的手中\n手折(たお)られた花の刃(やいば)\n有着残花的刀刃\n想いだけが生きる全て\n最终幸存的只有信念\n心に振(ふ)りかざす\n这舞动于心中的\n願い\n信念\n囚(とら)われた太陽(たいよう)の輝く\n在被囚禁的太阳的光辉下\n不思議(ふしぎ)の国(くに)の本が好きだった頃(ころ)\n欣赏不可思议的国度的书本时\n願いはきっと叶(かな)うと\n愿望必定会实现\n教(おし)えるお伽噺(とぎばなし)を\n我相信着\n信じた\n被人如此教导的童话\n(光と影の中\u0026hellip;)\n（在这光影中\u0026hellip;）\n静(しず)かに咲(さ)き乱(みだ)れていた\n有声音告诉我 能用静谧的、\n古(いにしえ)の魔法優(やさ)しく\n纷乱绽放于世的远古魔法\n世界を変(か)える力が\n将世界轻轻改变的力量\nその手にあると囁(ささや)く\n就在这手中\n終わらない夢を見よう\n去看看这永无止境的梦境吧\n君と行く時の中で\n在与你同行的时光中\n想いだけが生きる全て\n最终幸存的只有信念\n命(いのち)を作(つく)るのは\n这创造了生命的\n願い\n信念\n 2.翻译 暂无待补\n3.乐谱 暂无（口琴吹这个可能不好听）\n","date":"2022-02-08","permalink":"/posts/anime/magia/","series":["动漫歌曲"],"tags":[""],"title":"Magia(TV动画《魔法少女小圆》片尾曲2)"},{"categories":["二次元"],"content":"1.歌词 转载来源：百度 作了一点排版修改。   锖付（さびつ）いた心（こころ)、音（おと）も无（な）い世界（せかい）\nSabitsuita kokoro, otomonai sekai,\n锈迹斑斑的心灵,寂静无比的世界,\n何（なに）を见（み）てるの\nnani o miteruno?\n你到底看见了什么？\nまたねを言（い）える颜（かお）を探（さが）すよ\nMatanewo ieru kao o sagasuyo\n寻找着能将再见说出口的表情,\nそれを缲（く）り返（かえ）すだけ\nsore o kurikaesu dake\n只是不断将此重复罢了\n気付（きつ）けばそこには，\nKizukeba soko niwa\n回神之时伫立于此,\n一人(ひとり)きりで泣（な）く后（うし）ろ姿（すがた）\nhitorikiri de naku ushiro sugata\n只剩下孤单哭泣的背影\n辛（つら）いような、寂（さび）しいような　场所（ばしょ）、\nTsurai youna, sabishii youna basho\n在这个好似艰辛,又好似寂寞的 地方,\n手（て）を繋（つな）いでいたいんだ\nte o tsunaide itainda\n我想与你一同牵手走下去\n何度（なんど）目（め）の気持（きも）ちだろう\nNandome no kimochi darou\n这到底是第几回的心情了呢,\nここにある温（ぬく）もりは\nkoko ni aru nukumori wa\n而存在于此的温暖\n间违（まちが）いでも构（かま）わない、傍（そば）にいること\nMachigai demo kamawanai, soba ni iru koto\n就算是误会也无妨 只要彼此相伴\n涙（なみだ）の音（おと） ため息（いき）の色（いろ）\nNamida no oto , tameiki no iro\n眼泪的音色 叹息的色彩\n今（いま）、确（たし）かめる现在地（げんざいち）\nima, tashikameru genzaichi\n现在 确认于此的现居地\n冗谈（じょうだん）みたいな毎日（まいにち）\nJoudan mitai na mainichi\n仿若玩笑般的每一天,\n见（み）たい 见（み）たい 未来（みらい）\nmitai, mitai, mirai\n好想要预见的 好想要预见 那未来\n强（つよ）がりの声（こえ）も掠（かす）れたな、\nTsuyogari no koe mo kasureta na,\n逞强的声音也终究声嘶力竭,\nと梦（ゆめ）に落（お）ちるの\nto yume ni ochiru no\n堕落于梦境之中\n抱（かか）えた膝（ひざ）、\nKakaeta hiza,\n一旦抱紧双膝\n目（め）を落（お）とすと\nme o otosu to\n闭上双眼,\nすぐに崩（くず）れてしまいそうで\nsugu ni kuzurete shimai soude\n仿佛立刻就要崩坏一般\nこのまま、このまま\nKonomama, konomama\n就像这样 就像这样,\n二人（ふたり）きり駆（か）け込（こ）む远（とお）い出口（でぐち）\nfutarikiri kakekomu tooi deguchi\n你我两人跑向遥远的出口\nまだ 期待（きたい）しているの。\nMada, kitai shiteiru no.\n还抱有着希望呢 ,\nさぁ 笑（わら）って见（み）つめ合（あ）うんだ\nSaa waratte mitsume aunda\n来吧 相视而笑吧\n単纯(たんじゅん）で无邪気（むじゃき）な颜（かお）\nTanjun de mujaki na kao\n单纯天真的脸庞,\nくしゃくしゃの思（おも）い抱（だ）いて\nkushakusha no omoi daite\n拥抱着混乱不堪的思念\n迷（まよ）い込（こ）んだ场所（ばしょ）さえ优（やさ）しすぎて\nMayoikonda basho sae yasashi sugite\n就连迷路的地点 都无比温柔\n何度（なんど）でも名前（なまえ）を呼（よ）ぶよ\nNando demo namae o yobu yo\n无论几次都会呼喊你的名字,\n不确（ふたし）かな未来（みらい）でも\nfutashika na mirai demo\n就算面对不可确定的未来\n离（はな）せないもの 思（おも）うだけ心（こころ）が痛（いた）いよ\nHanasenai mono, omou dake kokoro ga itai yo\n只要想起那些不愿放手的东西就会心痛\nここにいるよ\nKoko ni iru yo\n我就在这里哦\nここにいるよ\nKoko ni iru yo\n我就在这里哦\n帰（かえ）る场所（ばしょ）はここだよ\nkaeru basho wa koko da yo?\n你的归所不是就在这里哟?\nいつだって変（か）わらない\nItsudatte kawaranai\n无论何时都不会改变,\n思（おも）いを残（のこ）すの\nomoi o nokosu no\n留下永恒的思念.\n 自己也手抄了一份（书写在练了在练了，我的中文书写一样差）：\n 我不会好好写的！我也写不好~  2.部分词语翻译 錆付く：【自动・一类】金属类物品因生锈而与其他物品黏在一起，锈在一起。或者是指金属物品完全生锈了。（这里动词活用た型表过去）\n繰り返す：【他动词・五段/一类】反复；重复。\n気付く（気づけば）：【自动词・五段/一类】发觉，注意到。\nきり：【副词】只，仅，就，终于。\n後ろ：【名词】后，后面，后方。\n姿：【名词】1.姿态2.态度，举止；装束，打扮3.身影4.姿势,形象\nような ：【助动词】1.よう为样态助动词，在连接名词时＋な　2.像，类似。3.例如。4.某种样子。\nつなぐ（つないで） ：【他动词・五段/一类】1.接上，连上。2.系，栓。3.拘禁。4.维系。\n何度：【名词】多少次，几次。\n温もり：【名词】温和，温暖，暖和气儿，暖气儿。\n間違い：【名词】错误，有误，不正确。\n構わない ：【接续词】没关系，不要紧，不在乎。\nため息 ：【名词】叹；惋；惋叹\n確かめる ：【他动词・一段/二类】弄清，查明。\nみたい ：【助动词】像……那样，像……一样。\n強がり ：【名词】逞强，装硬汉。\n掠れる：【自动词・一段/二类】嘶哑。\n落ちる：【自动词・一段/二类】落下，降落，掉下来，坠落。\n抱え：【接头/接尾】抱，搂。表示两臂搂抱所及的大小。\n落とす ：【他动词・五段/一类】\n崩れる ：【自动词・一段/二类】崩溃，坍塌，倒塌。\nまま ：【接续助词】由于，因而。\nきり：\u0026lt;接续\u0026gt;　名词+きり\n駆け込む：【自动词・五段/一类】跑进，跑入里面\n見つめ合う：互相对视，相互凝视\nくしゃくしゃ：【形容动词/ナ形容词】杂乱无章『成』，乱七八糟『成』，蓬乱。心情纠结成一团的样子。\n込む：【自动词・五段/一类】彻底；深　某种状态的持续。复杂。精致。精巧。 [込む]是[込んだ]的原形形式\nさえ：【副助词】连。甚至。\n離す：【他动词・五段/一类】放，放开，放掉，撒开\n残す：【他动词・五段/一类】留下；剩下；遗留\n3.乐谱 暂时没有找。\n","date":"2022-01-24","permalink":"/posts/anime/andimhome/","series":["动漫歌曲"],"tags":[""],"title":"And I`m Home（杏子沙耶香合唱角色歌)"},{"categories":["普通类"],"content":"今年是Eustia的一年。\n有个博客，我也可以学别人写写年终总结了~因为博客显然比较正式，相比于社交媒体来说。\n一、音乐方面 其实我就是因为网易云音乐的年终总结才想起来可以写一个同主题博客的，所以第一个就贴里面总结的一些截图了。我非常惊讶的是我听初音的歌听了那么多次，居然打败了99%的人。年终歌曲空種そらたね是没有任何问题的，我直到现在还依然非常喜欢这首歌和Eustia，而且我是在2021年1月1日遇见这首歌的，所以，对于我来说，今年是Eustia和初音的一年。\n \u0026emsp; 二、2021年流水账 回忆一下这一年的大概内容。\n1月：复习，回家后在学计算机技术（网络安全，C++貌似），当时头发留得很长，我现在都还有照片，我觉得那时候我的样子很酷，但是头发很难打理（因为太长了）\n2月：过年，玩，剃掉头发，学英文版抽象代数。\n3月：回校，继续学英文数学，并且尝试用英文做数学题，发布到网上记录，还在学密码学。那个时候还在玩原神，并且疯狂地买原神账号。和同学一起报名数学建模。\n4月：继续学习网络安全和密码学。准备数学建模竞赛。重新看鬼灭之刃（有个很喜欢的小女孩，我贴个图）。结束了gal魔女的夜宴学姐线。初步尝试俄语字母学习。\n 5月：在劳动节假期初步创建了博客，购买Unzybaryl.xyz.com域名。对手机root进行了学习和尝试（最后发现vivo手机bl是解不了的，所以之后买了个二手机root）。继续数学建模，继续密码学和网络安全学习。玩Summer pockets。\n6月：日语继续学习（我的日语学习总是很断断续续）。开始准备期末考试。结束Summer pockets和脏翅膀游戏。 7月：考试，回家。一个人生活自己学习做菜做饭。学习网络安全，学习日语。追番寒蝉鸣泣之时。\n8月：和7月差不多，因为是暑假期间。学习口琴。\n9月：回校。学习网络安全和密码学。重新看了一些传记（乔布斯，图灵）。尝试解决病情（时机已成熟Time has come）。读了一些闲书（圣经，博弈，宗教史，禅，西方哲学，都没读完）。购买了一台Linux云服务器。追番赤瞳。特别的离散数学我非常喜欢。学校周边网吧上网。\n10月：国庆暗黑破坏神重置版。复习数分。准备java大作业。自由的概念（自由是自律的自由，自由不能以牺牲自由为代价）。看一些闲书（中医，克莱因）。\n11月：数学史，数学学习。尝试和各种游戏（崩坏3，音游，赛尔号）。Java大作业2天完成。网站换域Eustia.me。\n12月：Java“答辩”效果良好。学习数学，复习考试。\n三、总结 今年过得也是有点混乱，什么地方都学了一下，但是很多都没学完，就是缺少一个明确的计划和目标，但是我相信这个问题明年就会得到解决。大概掌握了Web的基本知识（处于即将挖洞的阶段），学了一点逆向的知识，数学学了一大半抽象代数，一大半密码学。生活方面有了一点点的进步，慢慢学会怎么休息，但是现在还没完全学会；我之前一直没有自我意识的，现在也在慢慢培养。主要的是这一年我终于理解了我的心理病的根源，我现在终于可以慢慢改正了。\n因为昨年没有写2021年的愿望，所以愿望实现部分就不写了，但是2022年的总结一定会有一部分的。\n四、明年愿望 目标越上面越重要，我不一定完成全部目标，完成一件就很满意了。\n抽象方面：\n 考研不留遗憾 极大程度地解决病情 学会休息 学会分配爱好和工作的时间（学会合理规划时间，安排事物） 学会如何生活  具体方面：\n 成功考试（准备过程和考试过程）并准备好面试 数学竞赛国奖 日语N2及以上 音乐可以达到任何曲子都可以练习的基础并可以吹出来（口琴） 英语持续学习  五、尾巴 新年快乐~祝看到这段文字的人愿望实现~\n","date":"2021-12-30","permalink":"/posts/other/2021/","series":[],"tags":[""],"title":"2021年的总结"},{"categories":[""],"content":"随便写写最近所看到的数学。\n最近在读数学史，终于发现了喜欢的东西了，就是无穷级数。之前一直对分析不是很感兴趣（但是也不讨厌），所以有了点兴趣让我也很开心。今天（其实结果写了几天）随便写一点无穷级数（就是写写书上的东西），就突出一个词：“随便”。毕竟我今后是想做数学事业的，所以我还是想多花点时间在数学上……\n背景在17，18世纪……人物挺多，最耀眼的当然是Euler。\n顺序就不谈了，我随便写写，没有什么提纲顺序的。生成的文章右边小栏上有目录可以看看。\n开始\u0026amp;一般 1360 Oresme $$ 级数:\\frac{1} {2} + \\frac{1}{2} + ( \\frac{1}{4} + \\frac{1}{4}) + ( \\frac{1}{8} + \\frac{1}{8} + \\frac{1}{8} + \\frac{1}{8} )+\\cdots 发散 $$ 于是比以上大的调和级数: $$ 1+\\frac{1}{2}+\\frac{1}{3}+\\frac{1}{4}+\\frac{1}{5}+\\cdots发散 $$ Mercator, Newton $$ log(1+x) = x - \\frac{1}{2}x^{2} + \\frac{1}{3}x^{3}+\\cdots $$ 在$x=2$时右边的级数为无穷，而它应该为$log(3)$。 $$ 2 +(-2+\\frac{8}{3}) + (-4 + \\frac{32}{5})+\\cdots $$ 1671 Collins $$ \\begin{aligned} \u0026amp;\\tan x = x+\\frac{x^3}{3}+\\frac{2}{15}x^{5}+\\frac{17}{315}x^7+\\cdots \\\\ \u0026amp;\\sec x = 1+\\frac{x^2}{2}+\\frac{5}{24}x^4 + \\frac{61}{720}x^6+\\cdots \\end{aligned} $$ 1675 Leibniz $$ \\frac{\\pi}{4} = 1-\\frac{1}{3}+\\frac{1}{5}-\\frac{1}{7}+\\cdots $$ 1668 James Gregory 收敛得较快的级数，在计算中更有用。 $$ \\frac{1}{2}log\\frac{(1+z)}{(1-z)} = z+\\frac{1}{3}z^3+\\frac{1}{5}z^5+\\cdots $$ 推理\u0026amp;计算 James Bernoulli\u0026amp;John Bernoulli ① 从级数 $$ N = \\frac{a}{c}+\\frac{a}{2c}+\\frac{a}{3c}+\\cdots $$ 得到（注意级数是发散的）。 $$ N - \\frac{a}{c}= +\\frac{a}{2c}+\\frac{a}{3c}+\\cdots $$ 将以上两式相减得： $$ \\frac{a}{c} = \\frac{a}{1\\cdot 2c}+\\frac{a}{2\\cdot 3c}+\\frac{a}{3\\cdot 4c}+\\cdots $$ James说这样的做法是有问题的，如果不慎重是不能用的（级数发散的原因）。\n②","date":"2021-12-11","permalink":"/bin/math_history_1/","series":[""],"tags":["",""],"title":"一些无穷级数"},{"categories":["二次元"],"content":"预告一下这个系列，回忆一下这部作品，里面的很多台词都引我深思。\n主要采取截取台词的形式吧，并且简单地写一下我的感受，重头游玩一下这部作品。\n","date":"2021-12-09","permalink":"/posts/anime/eustia_1/","series":["Galgame"],"tags":[""],"title":"【预告】穢翼のユースティア游戏回顾"},{"categories":[""],"content":"以前没写完的，写作日期为2021-05-07。\n  先说一下，以前没写完的，现在对这个也没什么兴趣了，主要还是因为自己能力不足吧，本意是想建模，公理化进行推理来构建的。发现写不出来，加上那时也快考试了，就无了。\n当时主要想解决网络争吵的事情，感觉非常地“空”，现在看来也确实如此。发出来只是记录下想法。\n  根据代数学，墙纸中的二维晶体限制种类(2D Crystallographic Restriction)只有17种（rotation，reflection，glide的组合），墙纸的样式无论再多，它也只能属于17种的一种。数学超越人的感官，能更深刻地认识事物。我一直在想如果能对一个事物构建出基本体系，创建公理，那么就可以推理出人类感官以外的结论。这种想法持续了很久，也一直没去继续想下去，只是个模模糊糊的东西，但是小站新开张，于是将一些思考写下来，记录下来，作为小站的礼物纪念。\n更新记录：\n 2021-05-07 11:14:56创建文件  说明 正如简介说的，这是我目前的对数学的粗浅的理解。一个公认规律是，学得越深，理解也越深，描述观察得越准确。只不过目前不想学太多数学了。关于世界理解，我的想法是这样的，打个比方：初中生对世界的理解就像单元函数，事物的原因只有一个主要的；高中生同样是单元函数，只不过扩充到了更复杂的如指数，对数变化，就像是从$N$变化为了$N\\log N$，更加细致，精密了；大学生认识到事物的原因有很多，变成了多元函数，对事物以群类分，环等；之后嘛就测度论，更加更加深刻的认识。\n并且我还想有些东西也许也炒菜一样，将各种东西看作调料，魔法般地调整比例，制作自己心爱的东西。\n其实有一些例子供我参考的，目前我所了解的比如信息论，欧几里得几何原本，皮诺亚公理的相容性，图灵的可计算数，抽象计算机，抽象代数的开始（Galois，Abel，群，环），大刘的关于黑暗森林的推理。我都没仔细了解，之后闲暇时间慢慢了解，补充到这里，顺便给我启示。\n❗这篇记叙可能不会太认真，而且也可能不会有结果，但是有新想法会更新，并且会随着自己理解增加不断地修改内容与细节。\n❗自身水平有限，客观上错误会有很多​，有心的话可以讨论讨论。\n❗纯粹写着玩的，颇有点民科的味道😰。。。。\n❗尽量避开社会学，哲学等模糊不清地方。我不太会用专业名词，只是作为一个观察者将观察到的现实描述下来。我感觉这些东西比数学还复制难懂。\n观察/Observe ❗ 这部分会根据真实情况不断修正，世界所有的活动就是样本，只要不满足任意一种现实情况，就是错误的\n网络社交空间分为网络与社交，所以先需要对现实社交进行观察。观察现象如下：\n普通社交  人们通过语言等信息载体交流，传递信息，而任何事物都可以作为信息，如石头，墙体，人的皮肤碎屑。这里我们只讨论以语言为载体，并且是实时或短间时的对称交流。（①短间时如传纸条，情书，email，qq，社交论坛，视频评论区，并且时间间隔小于一个量，如传纸条的最大时间间隔除特殊情况外不超过一节课的时间，而网络社区的时间间隔24h左右都行，这是一个相对量。②交流主体都是平等的，对称的；像老师对一群学生就是不对称的，而学生学生之间，或者单个老师与单个学生之间是对称的。） 表达是人类正常的生理需求，本能冲动，日常生活中主要通过社交完成。每个人从小时候就开始叽喳学语，本能地想表达传递信息；即使是十分沉默自闭的人，不通过语言，也会通过其他方式表达，如画画，跳舞，运动，唱歌等。 社交的目的是为了自己，在有些特殊情况有些不同。人类是群居动物，人类是自私的，本能下首先会考虑自己的利益，人与人的交往建立在共赢或者互损（互相伤害）的基础上，并且有时候会相互转化，而其他情况属于不稳定情况。在家族，爱人，知己等等情况会有所不同，毕竟我们见闻过牺牲自己求对方的事情等，那类非常真心真诚的事情。 自身面临的事件类型处在大大小小不同圈子的时候，社交行为会发生一定变化。如亲戚圈，同学圈，同事圈，老乡圈，同专业圈，同性别圈，同比赛阵营圈，同国家圈，同游戏圈，同爱好圈。共同特征是别人与自己具有一定的相似性，无论是内在还是外在的，一般来说，内在圈相比外在圈的行为变化幅度会更大。和排外性一样，人们不希望被anti自身的事物干扰打搅。 人类个体综合属性（表面身体，精神与性格等）是不同的，在相对封闭的环境下形成了奇妙的社交集合。同样的，如果自身综合属性改变，社交集合也会慢慢改变。人类的社交集合随着自身处于的环境的变动而改变，并且通常情况下随着时间流逝慢慢完成更新，变为稳定。当当前相对封闭环境中如果个体的社交集合有数量不够，比例失调等问题的话，会向外补足，寻找替代品。（异地恋容易失败也是这个原因） 每个人交往的对象数量是有限制的，交往越深，数量越少。这是个普遍规律，在很多事物中都有体现，如一个人的爱好，食物链，正态分布。 在社交过程中，信息存在着非常大的损耗和变化，这与对象之间的理解能力，表达能力的差值和对象属于的社交集合有关，很多时候都不在一个频道上。脑袋是自己的脑袋，所见之事是自己眼睛见到的，是自己在想自己的事情。如一位母亲见到了一名陌生的环卫工人，教导孩子以后好好学习。而那名环卫工人是家人呢？第一反应应该不是这样。 社交内容限制 社交博弈 ","date":"2021-12-01","permalink":"/bin/internet-social-space-1/","series":[""],"tags":["",""],"title":"【废案/想法】网络社交空间"},{"categories":["计算机"],"content":"(多图警告！）给一些需要的朋友，互联网本身也有很多教程，反正有疑问的地方可以通过网站给出的链接询问~\nPERFACE 1.教程方向 尽量简单易懂 有问题反馈后会进行补充。\n2.顺序结构 按照Hugo，GIthub Page和Git，域名的顺序来写。由Hugo的基本操作，选择Theme后生成博客；通过Git上传博客内容至Github仓库，在仓库中设置Github page，最后的域名购买可绑定是可选择的。最后还会介绍一些需要使用的东西，如Md文档样式，hugo theme文件格式。\n一、Hugo Hugo是由Go语言实现的静态网站生成器。可以快速生成静态网站。\n1.Hugo的下载和安装 Hugo下载地址：Hugo 0.89.2 下载了好后解压把文件放在一个位置，如我放在了D:\\目录下（www3不用管）：\n  接下来配置环境变量，win和R键一起按，调出运行窗口，在其中输入“systempropertiesadvanced”回车：\n  出现系统属性窗口，点击右下角的“环境变量”，双击系统变量中的“Path”：\n  点击右边的新建，将你下载解压的hugo地址填上去：\n  检查是否安装成功，win+R键打开运行窗口，输入“cmd”回车，在命令提示符中输入“hugo -help”查看是否有以下信息出现，出现则安装成功：\n  在命令行窗口中输入“hugo new site 路径/名字” 就可以建立一个站点，例如以我的环境，输入\u0026quot;hugo new site D:\\hugo_0.82.1_Windows-64bit\\www3\u0026quot;。我上面的www3文件夹也是这么来的，文件夹名字可以随便取，我取的就是“www3”啦。\n  2.Hugo Theme下载和安装 安装好了Hugo，还需要安装一个主题，主题就是你搭建博客的style样式。主题地址：https://themes.gohugo.io/ ：\n  这里有非常非常多的主题，你喜欢哪款就点击进去，点击左下角的“Download”按钮，跳转到对应的github仓库，在绿色的code按钮下，点击“Download zip”就可以下载啦：\n  之前我们用hugo new site命令创建了一个站点，现在将下载的Theme放入站点中的theme文件夹，我这里已经放了3个theme了：\n  接下来导入theme的配置文件，这里不同的theme表现有些不同，先去下载theme的examplesite找一下，我遇到的有两种可能：\n①存在一个config.toml，那么就把这个文件复制到站点根目录下去：\n  ②没有config.toml而是一整个config文件夹，那么把这个文件夹复制到站点根目录下：\n  反正不管怎么样，这个东西或者文件夹就是配置文件了。这里面的设置都挺重要的，并且还有一些theme作者提供的额外功能，一般来说theme里面有教程，我这里附上我以前的配置，里面包含了url，网站语言，HTML title，使用的主体文件夹名等等，这个就自己探索吧。里面的配置随着主题的不同有很大的不同，一般来说作者会给出教程的，在下载主题文件夹里面找找。\n  3.Hugo创建和写作文章 首先需要在之前生成site的那个文件夹内打开cmd窗口，先打开那个文件夹，然后在文件夹上方的那个地址栏中输入”cmd“即可实现：\n  之后我们就可以用命令来生成空文章了，在cmd中输入：\n1hugo new xxx.md 就在站点目录的content中生成了一个叫\u0026quot;xxx.md\u0026quot;的文件。有些站点的文章目录结构有些不同，像我的站点content里面还有文件夹，如我想在content\\posts\\文件夹里面生成空文章的话，可以输入：\n1hugo new posts\\new.md 其他的目录就依次类推了。\n  打开自动生成的空文章，最上面就是生成空文章的一些信息，title表示文章标题，date表示发布日期，draft代表是否是草稿，如果文章是操作，在之后的生成过程中这篇文章是不会被生成的。当然这里不同主题的表现可能也有些不同，下面是图，这个就自己探索了，如果有疑问可以通过站内给出的联系方式问我。\n  之后就可以用md文档写文章了，md文章还是有很多样式的，并且可以插入HTML代码，之后的附录里会给一些md文章写作技巧。\n4.调试站点和生成站点 写好文章以后，还是在站点根目录的cmd窗口中输入hugo server或者hugo server --buildDraft来调试站点。其中第二个指的是将draft设置为true的站点也生成。\n  默认地在浏览器中输入localhost:1313就可以看到你的站点啦~之后在网站的各个地方修改并且保存后，它会检测到改动，并且快速地重构站点，你可以立刻就看到改动后的样子。我现在写这篇文章就是这样做的哦！注意如果源代码出错了hugo server也是会构建不了的，需要重新再输入一次上面的指令。\n  站点调试完成后，觉得差不多了想要上传，还是在站点根目录的cmd的窗口中输入：\n1hugo 就会生成站点啦。站点生成在站点根目录的“public”文件夹下面：\n  二、Github Page 静态站点的源代码hugo已经帮我们弄好了，现在怎么才能变成可以访问到呢？Github Page给我们提供了个非常方便的服务，可以将网站源代码上传至github仓库，设置好Github Page以后我们网站可以由github提供的域名：“username.github.io”访问到了，并且还可以绑定上自己买的域名。\n1.Git 首先需要注册个github账号，之后嘛……给你个链接：GIt使用 配置好SSH key，把站点public文件上传到Github仓库就算成功啦。下面给出我站点仓库的截图，里面的东西和之前用hugo指令生成在public文件夹的东西是一模一样的，所以这部就是把public的东西搬过来。\n  每次写完文章，用hugo生成了之后，都需要上传至Github仓库，这里我把我上传的过程写一下：\n首先在网站public目录中打开Git，然后4条指令就搞定：\n1git add . 2git commit -m \u0026#34;注释\u0026#34; 3git pull 4git push origin master 2.Github Page 在网站仓库的“settings”中倒数第二个“Pages”中设置，启用了之后自动就给一个域名，可以直接访问。\n三、域名购买和绑定Github Page 续待未完。\n四、附录 1.Md文章写作 2.Hugo主题自定义","date":"2021-11-27","permalink":"/posts/tech/blog_instruct/","series":[],"tags":[""],"title":"我的Hugo+Github Page搭建博客教程"},{"categories":["二次元"],"content":"所谓既视感，就是既视感。\n这部番是一位友人推荐的，据说他被这部番伤得很深。。但是我看完还好。在前期看的过程中发现好多和尤斯蒂娅的一些类似的地方，无聊写一下。有些有图片，有些没图片，懒得截图了，后面看到了也许会补上。\n补：现在马上快的12点，我再慢慢补图……（补完了已经快一点了……）\n1.中世纪风格 服装，建筑等各种地方。其实我也不确定是不是中世纪，只是和之前看罗马纪录片那些人物服装的风格有些相似……特别是图二的艾莉丝的服饰非常有纪录片中康茂德妻子服饰的感觉。赤红之瞳NPC的服装也大概感觉是这样，但是主角们的服装就有些不一样的特点了。（嗯……都是用的冷兵器，差不多吧……）\n ユースティア 服饰1    ユースティア 服饰2    ユースティア 建筑1    赤红之瞳 服饰1  2.上层建筑 这两部作品都分有类似于「阶级」的概念，刚好对应上层的建筑挺类似的。通俗的讲就是“人上人”等富裕和统治阶级居住的地方。都有那种很高的很漂亮的天桥的建筑，也都是白色调子的，图一的天桥已经垮了……\n  ユースティア 上层1    ユースティア 上层2    赤红之瞳 上层1  3.一位女性角色 羽狩和使用生物性帝具的反派，她们两位都是出场开始属于上层阵营的，但是，越到后面差别越大，菲奥奈在和主角相处的过程中看到了真相，发觉到上层在欺骗底层民众；而塞琉一直维持着“变态”的正义感，直到她死亡。赤瞳表现反派人物真是有些夸张……有那种蜜汁立绘。另外说起来我还特别喜欢菲奥奈，她非常正直，单纯的感觉。\n  ユースティア 菲奥奈立绘    ユースティア 菲奥奈游戏截图    赤红之瞳 赛琉  4.革命 这里只放尤斯蒂亚游戏内的图片啦，关系大概也仅仅就革命而已，就是下层因为一些矛盾推翻上层统治的过程，尤斯蒂娅中是因为不断的“崩落”，下层民众的生存之地不断减少，整天活的提心吊胆；赤瞳中就很平常的是因为上层的腐败，对人们剥削严重。结局可能有些不同，比较尤斯蒂娅是gal，有多分支结局。\n  ユースティア 革命1  大概写完啦，没什么好总结的，尤斯蒂亚是今年6、7月份玩的，刚刚好开学后补完了赤红之瞳。我是非常喜欢尤斯蒂亚这部gal的，特别是和圣女的那一幕，引起了我很多思考，可以说是伴随着我的心理的转变，我之后也会好好记录这部gal的。对于赤红之瞳没有太大的感觉，可能是因为人物都死得太快了吧😂，对于艾斯德斯，黑瞳，和那位粉红色的化妆帝具的人物挺有印象，有些人物死得有些奇怪，只能说死于话多了……\n好了我回去了，悄悄说一下，现在的1:41我还在黑灯瞎火的教学楼，就在刚刚出现了不明来路的光线……我还是赶快寝室睡觉吧。真的有点恐怖。。。吓死我了，虽然我也没干什么不好的事情。（来自第二天的我）\n","date":"2021-11-25","permalink":"/posts/anime/akame/","series":[],"tags":[""],"title":"《斩！赤红之瞳》与《穢翼のユースティア》类似的地方"},{"categories":[""],"content":"随便写点什么。\n我真的就是随便写了，没啥时间排版，画图和构思。所以写下的内容可能没什么逻辑条理。还是想看就看吧，不想看就不看。\n之前暑假看番剧《寒蝉鸣泣之时》，里面的人物得了一种综合征，触发条件疯起来就会非常可怕地伤害人。其中一个条件就是“不信任，猜疑”。但是结合我自己的事例来说，我觉得即使没有得那种综合征，人因极度的猜疑和恐惧，确实是可以发生非常离谱的事件的，如杀人等。当然可能还需要一些条件，如我来说就是经历事物太少，见识不多，所以认识事物非常抽象，只停留在表面，追寻神秘主义。\n还有另一个相关的东西就是猜疑链，三体小说中出现的。我想猜疑本身就是一种刺激，当猜疑本身的事件出现便会给猜疑人出现巨大的冲击，使得猜疑的事物权重上升，眼中于是便只有猜疑，而且真的是越看越像，越觉得真实，事情本身虽然是不确定的，但是猜疑人心中越来越相信是真实的了。整个过程开始于猜疑，然后不断地由于猜疑本身而发生正反馈，所以越来越疯狂，在外人看起来就像是疯了一样，我自己本身也曾当面骂过老师，但我想事情的最终答案应该是这个，所以我好了之后还要找时间去和老师道个歉。。。极端的猜疑和恐惧导致的自我相信的现实是非常真实的（我现在也是，但我在勇敢地突破），但是事情的真相终究是不确定的，越到后来越会觉得离谱，最终达到平衡，猜疑人的世界分裂了，不知道那边是真实，一直犹豫仿徨，不过最终肯定会选择一边的，因为这是个相信的世界，很多东西是不确定的，所以决定因素是自己，自己相信，那就是那样的。\n综合看来猜疑成神经病这种结构，其实是很脆弱的，因为真相只有一个，真相永远不会变化，真相是什么就是什么，但是由于猜疑人强烈的猜疑和恐惧这种强大的动力才变成这样的。先猜疑，后恐惧；因为恐惧，所以猜疑；互相加强。真是魔鬼。。破坏这种结构可以破坏猜疑本身，这是个人因素，也可以破坏反馈——发现真相。可能还有其他的方法，隐藏在逻辑中。哪种方法都不容易，发现真相的过程中缺会因为恐惧而更加反馈也说不定，这一点在动画中也有体现。\n个人感觉很多事物都和这个有关，除了以上的《寒蝉》、猜疑链。如社交生活中，特别是网络社交生活中，在自己猜疑别人是怀着什么心态时可以注意一下，看自己是不是已经相信了某种自认定的事实，然后在过程中寻找蛛丝马迹。想起来还有一例就是看到新闻之前一个算卦觉得有一个人天性“克”他，于是过了一段时间他就把别人给杀了，也是很有意思的事情。\n所有这些事情的共性我觉得还有一个更深的层次，就是“痒”的感觉，这一点也在《寒蝉》中有体现。我之前也是脖子等各种地方痒。痒代表了很多东西，欲望，急躁等情绪，这一点就请后面的时间了。\n总之，克服这种东西需要拿出足够的勇气，长时间的坚持和乐观的发现真理的信念。Wir mussen Wissen. Wir serden Wissen.祝君加油。\n2021/11/28 基于以上的观点，我发现现实中很大部分的事物我们永远都认识不了真相。并且很多东西都有种“套娃”的结构：“我们在认识事物的时候本身就被影响着，不能脱离这种影响来认识事物（除了数学物理等科学）”，这种结构我目前没有找到解决办法，并且如果是这种结构，依据我浅薄的毕生所学的实验知识，它是永远不能满足“单一变量”的条件的，所以所有都是错误的。怎么说呢，活得开心就算成功，不要一直被瘴气缠绕，不要多想地做自己想做的事。\n下面附上之前读书读到的一段话，我就把原文打在这里，是关于笛卡尔的，就以这段话结尾吧：\n ​\t如果Descartes把周围的一切看做只是由运动的物质构成的，那么，他怎样解释味道、气味、颜色和声音的质量呢？这里他采用了古希腊关于第一性和第二性的学说，依照Democritus，这个学说主张“甜与苦、冷与热以及颜色等东西，只在意念中存在，在实际中不存在，真正存在的是不变的粒子，原子以及它们在空的空间中的运动.”第一性的东西，即物质与运动，存在于物理世界中；第二性的东西，仅仅是当外界原子冲击到人的感官时，第一性的东西产生这些感官上的效果.\n​\t因此，在Descartes看来，有两个世界：一个是巨大的协调地设计出来的数学机器，存在于空间和时间中，另一个是思维的世界，第一世界的元素作用在第二世界上的效果就产生出物质的非数学性质或次要的性质.此外，Descartes肯定了自然界定律的不变性，因为这些定律只是预先规定的数学图案的一部分，就是上帝，也不能改动这不变的自然界，在这里，Descartes否认了通行的信条：上帝不断地干预着宇宙的活动.\n","date":"2021-11-05","permalink":"/bin/suspect-discuss/","series":[],"tags":[""],"title":"聊聊猜疑"},{"categories":["文字类"],"content":"百年孤独中阿玛兰妲的全部片段。\nPreface 阿玛兰旭也是个非常奇怪的人，和丽贝卡一样，她所表现的行为可能就是孤独吧。另外我之前一直把阿玛兰妲认成阿玛兰旭了……\n我之前和阿玛兰妲的内核大概是一样的吧，这也就是说我现在慢慢不这样了。\n阿玛兰妲 阿玛兰妲出生 　一月里一个星期四的凌晨两点，阿玛兰妲出生了。在其他人进入房间之前，乌尔苏拉先把她浑身上下细细检查了一遍。她又轻又湿像条蜥蜴，不过身体所有部位都属于人类无疑。\n阿玛兰妲童年时期 　乌尔苏拉出去打听吉卜赛人是从哪里走的，按照别人的指引边走边问，相信还来得及追上。她离村子越来越远，等发觉时已经走出太远，便索性不再回头。何塞·阿尔卡蒂奥·布恩迪亚直到晚上八点听到小阿玛兰妲哭得声音沙哑，把材料留在粪床上加热，过去一看才发现妻子失踪了。几小时后他聚集起一支整装待发的队伍，把阿玛兰妲托付给一位自愿喂奶的妇女，随后上路四处追寻乌尔苏拉的踪迹。奥雷里亚诺也跟了去。黎明时分，几个操着陌生语言的土著渔夫打着手势告诉他们，不曾见到有人经过。徒劳寻索三天之后，他们回了村。\n　此后几个星期，何塞·阿尔卡蒂奥·布恩迪亚陷入沮丧当中。他担负起母亲的职责照料小阿玛兰妲，给她洗澡换衣服，一天四次送去哺乳，晚上甚至为她唱起乌尔苏拉从来不会唱的摇篮曲。\n（母亲乌尔苏拉去找何塞阿尔卡迪奥了）\n　时间使一切恢复了原样。何塞·阿尔卡蒂奥·布恩迪亚和儿子不知从何时起又回到了实验室，他们抖落尘埃，点起炉灶，拾起已经在粪床上沉睡了数月的材料，又一次耐心地操作起来。连躺在柳条小筐里的阿玛兰妲，也好奇地观看父兄在水银蒸气弥漫的小屋里入神地工作。架子上被遗忘多日的一个空瓶忽然重得挪不动。工作台上的一锅水未经加热便沸腾了半个小时，直到完全蒸发。何塞·阿尔卡蒂奥·布恩迪亚和儿子看着这一切又恐惧又欢喜，他们无法解释，只是将其视作新材料要诞生的预兆。一天阿玛兰妲的小筐自行移动起来，在房间里兜了个圈。奥雷里亚诺大吃一惊，连忙去拦下它。做父亲的却没有惊慌，他把小筐放回去，固定在桌腿上，坚信期待已久的事情即将发生。就在那时，奥雷里亚诺听见他说： “就算你不敬畏上帝，也该敬畏金属。”\n　…………\n　奥雷里亚诺却用钱买来盐酸配制王水，还把钥匙镀了层金。不过他的古怪之处与阿尔卡蒂奥和阿玛兰妲相比又算不得什么，那两个孩子早就开始换牙，却依然整天跟在印第安女人后面，顽固地不肯说卡斯蒂利亚语而只说瓜希拉土语。“你有什么可抱怨的，”乌尔苏拉对丈夫说，“有发疯的父母就有发疯的儿女。”正当她哀叹自己命不好，认定儿女们的怪癖与猪尾巴同样可怕时，奥雷里亚诺眼神定定地望着她，令她感到一阵茫然。\n　“有人要来了。”他说。\n（没错，丽贝卡来了，这里接丽贝卡那里了）\n　…………\n　乌尔苏拉知道后，在药物治疗之外又加上了皮带抽打。永远无从确知，究竟是大黄或毒打，还是二者一起最终发挥了效用，总之几个星期后丽贝卡显出康复的迹象。她加入到阿尔卡蒂奥和阿玛兰妲的游戏中，他们把她当姐姐看待。她胃口颇佳，刀叉也用得不错。不久家人又发现她的卡斯蒂利亚语说得和印第安土语一样流利，手头活计也干得出色，还会哼唱音乐钟奏出的华尔兹舞曲，配上滑稽的自编歌词。大家很快就接纳她为家庭新成员。她和乌尔苏拉最亲，连乌尔苏拉的亲生儿女都比不上。她管阿玛兰妲和阿尔卡蒂奥叫小妹妹小弟弟，称奥雷里亚诺为叔叔，呼何塞·阿尔卡蒂奥·布恩迪亚为爷爷。于是，她和其他家人一样名正言顺地用上了丽贝卡·布恩迪亚的姓名，那也是她一生用过的唯一姓名，直到去世从未玷污。（这里第一人称是丽贝卡） 阿玛兰妲与皮埃特罗·克雷斯皮 　在这个古怪的家里，乌尔苏拉尽力保持正常，她扩大了糖果小动物生意，整夜不歇地开着烤炉，产出一篮篮面包以及品种丰富的布丁、蛋白酥和小饼干，几个小时内就在通往大泽区的小路上全部售出。明明已到可以安享生活的岁数，她反倒越来越活跃。她一直忙于自己兴隆的事业，一天下午，当印第安女人帮她往面团里加糖，她无意中向院子望去，竟看见两位陌生的美丽少女在暮色中绣花。那是丽贝卡和阿玛兰妲。她们为外祖母严格守孝三年，那时刚刚脱去孝服，鲜艳的衣裳仿佛使她们在世上获得了新的地位。谁也不曾想到，丽贝卡会是两人中更漂亮的那个。她面容白皙明净，眼睛大而沉静，一双有魔力的手仿佛在将无形的丝线绣成花样。年龄小些的阿玛兰妲虽然魅力稍逊，但遗传了过世外祖母自然的气质和内心的高傲。\n　…………\n　（人多了，修了新家）\n雪白如鸽子的新家落成时，举办了一场庆祝舞会。乌尔苏拉是在那天下午发现丽贝卡和阿玛兰妲已出落成婷婷少女的一刻萌生这个想法的，甚至可以说，扩建计划的主要目的正是为了让姑娘们有一处体面的地方接待访客。为了完美无缺地实现这一愿望，她在扩建进程中像苦役犯一般劳作，在竣工前就已订购了昂贵的装饰品和生活用具，还添置了一样必将震惊全镇、引发年轻人欢呼的神奇发明——自动钢琴。钢琴分部件装箱运来，一同到货的还有维也纳的家具，波希米亚的玻璃器皿，西印度公司的餐具，荷兰的桌布，以及各式各样的灯具，烛台、花瓶、帷幔和壁毯。进口公司自费派来一名意大利技师皮埃特罗·克雷斯皮，负责安装和调试自动钢琴，指导顾客使用，并教授如何伴着印满六卷纸带①【注①自动钢琴上用于控制琴键的穿孔纸带。】的时兴乐曲跳舞。\n　皮埃特罗·克雷斯皮是个金发的年轻人，马孔多的居民还从未见过这样英俊又有教养的男子。他非常注重仪表，酷暑天气仍身着花缎紧身马甲和厚厚的深色呢料上装。他出于礼貌与主人保持适当距离，好几个星期关在客厅里汗流浃背地工作，心无旁骛的状态足可与金银器作坊里的奥雷里亚诺媲美。一天上午，他没有开门，也没有招呼任何人来见证奇迹，就在自动钢琴上装好第一卷纸带，于是烦人的捶打声和板条持续的轰鸣戛然而止，只有明净谐和的乐声开始荡漾。所有人都赶到了客厅。何塞·阿尔卡蒂奥·布恩迪亚大吃一惊，倒不是因为优美的旋律，而是因为自动钢琴琴键的自行弹奏。他立刻把梅尔基亚德斯的照相机架设在客厅里，期望能够拍到那看不见的演奏者。那天意大利人和他们共进午餐。这个天使般的男子未戴戒指的苍白手指使用起刀叉来如行云流水，令负责斟酒上菜的丽贝卡和阿玛兰妲惊诧不已，在客厅旁的起居室里，皮埃特罗·克雷斯皮教她们跳舞。他用节拍器打着拍子指导舞步，但不触及她们的身体。这一切都受到乌尔苏拉礼貌的监视，她在女儿们上课的过程中一刻不曾离开房间。皮埃特罗·克雷斯皮这些日子脚踏舞鞋，身穿富于弹性又极其贴身的舞蹈长裤。“你用不着这么担心，”何塞·阿尔卡蒂奥·布恩迪亚对妻子说，“这人是个娘娘腔。”但她不肯放松警惕，直到课程结束，意大利人离开马孔多才罢休。接着他们开始筹备舞会。乌尔苏拉开列出一张经过严格筛选的宾客名单，入选的都是村庄创建者的后代——除去庇拉尔·特尔内拉一家不算，那女人又生了两个父亲不明的孩子。实际上这是门第之选，只不过以友情作为选择标准。那些入选者早在背井离乡创建马孔多之前就是何塞·阿尔卡蒂奥·布恩迪亚家的常客，而且他们的儿孙也是跟奥雷里亚诺和阿尔卡蒂奥一起长大的伙伴，他们的女儿则是唯一可以来家里与丽贝卡和阿玛兰妲一同绣花的姐妹。\n　…………\n　皮埃特罗·克雷斯皮重新把自动钢琴组装起来。丽贝卡和阿玛兰妲帮他理顺琴弦，听到那颠倒的华尔兹乐曲时跟他一起连连大笑。见他那样可亲又可靠，乌尔苏拉便取消了监视。在他告别的前夜，家里用修复的自动钢琴临时举行了一场舞会，他和丽贝卡联袂表演了一场美妙的现代舞。阿尔卡蒂奥和阿玛兰妲的舞姿舞技也并不逊色。但表演被迫中断，挤在门口围观人群中的庇拉尔·特尔内拉和另外一个女人又撕又咬打了起来，只因后者胆敢妄言年轻的阿尔卡蒂奥长着女人的屁股。将近午夜时分，皮埃特罗·克雷斯皮满怀感情地发表了简短致辞，并许诺会很快回来。丽贝卡一直送他到门口，随即关闭家门，熄灭灯火，她回到自己房间里恸哭起来。那是一种难以安慰的哭泣，持续了好几天，连阿玛兰妲也不明白其中的缘由。她的守口如瓶并不奇怪。她虽然表面热情坦诚，实际秉性孤僻，从不敞开心扉。她已出落成一位亭亭玉立的少女，身材修长结实，但仍旧喜欢坐在那把和她一起到来的小木头摇椅上，那椅子加固过多次，扶手已经不见了。没人留意她到了这个年龄还是喜欢吸吮手指，她一有机会便把自己关在浴室里，并养成了面朝墙壁睡觉的习惯。雨天的下午，她和女友们待在秋海棠长廊里刺绣，每当看到潮湿的土层和蚯蚓在花园里堆起的小丘，她常常会从交谈中走神，怀念的泪水带着咸味涌上舌尖。她一开始哭泣，当年那些被橘汁和大黄压服的秘密嗜好顿时化为无法抑制的渴望爆发。她又开始吃土。第一次几乎是出于好奇，她确信那糟糕的味道将是摆脱诱惑的最佳药方。她果然无法忍受泥土在嘴里的感觉，但她没有放弃，而是受制于不断增强的渴望，渐渐恢复了旧日的胃口，恢复了对原生矿物的喜爱以及原始食物带来的满足。她将一把把泥土藏进口袋，一边传授女友们最繁难的针法，谈论其他不值得自己为之吃下石灰墙皮的男人，一边趁人不注意一点点吃掉，心中涌起既幸福又愤怒的迷乱感觉。这一把把泥土使那唯一值得她自卑自贱的男人不再遥远也更加真切，仿佛从他脚上精巧的漆皮靴在世界另一处所踏的土地传来矿物的味道，她从中品出了他鲜血的重量和温度，这感觉在她口中猛烈烧灼，在她心里留下安慰。一天下午，安帕萝·摩斯科特无缘无故请求参观新家。阿玛兰妲和丽贝卡对这突如其来的到访不明所以，礼貌而生硬地接待了她。她们向她展示扩建后的家宅，请她听自动钢琴的演奏，为她端上橘子水和小饼干。安帕萝给她们上了一课，诸如什么是端庄大方，什么是仪态可亲，什么是举止得体，给在场不过短短一会儿的乌尔苏拉留下了深刻印象。两小时后，谈话渐渐无味，安帕萝趁阿玛兰妲分神的瞬间将一封信塞给丽贝卡。她只来得及看见“可敬的丽贝卡·布恩迪亚小姐”字样，与自动钢琴说明书上的字体同样工整，以同样的绿色墨水写就，使用同样的绮丽措辞。她立刻用指尖将信折起藏进胸衣，望着安帕萝·摩斯科特的眼神中充满无尽感激，还有结下生死之盟的无声承诺。\n　…………\n　她做到了。只是时机不对，因为家里已经失去往日的平静。（她指庇拉尔，这里不重要，为了连贯加上）丽贝卡那般喊叫已经无法保守秘密，阿玛兰妲发现了她的痴恋后开始发烧。她也在为没有回应的爱情而饱受折磨。她把自己关在浴室里，写下一封封狂热的信，以摆脱没有希望的激情带来的折磨，然后把信深藏在衣箱内。乌尔苏拉同时照顾两个病人，几乎忙不过来。她费尽心机长时间询问，也没能问出阿玛兰妲委靡的缘由。最终，她又灵机一动，撬开衣箱，便发现了用玫瑰色丝带系好的信，信内塞满新鲜的百合花瓣，信上泪痕未干，封封都写给皮埃特罗·克雷斯皮，但从未寄出。乌尔苏拉眼含愤怒的泪水，诅咒自己动念购买自动钢琴的那个时刻，并取消了刺绣课程，下令进入没有死人的丧期，直到女儿们死心断念为止。何塞·阿尔卡蒂奥·布恩迪亚已经改变对皮埃特罗·克雷斯皮最初的看法，十分欣赏他对音乐器械的灵活掌握，于是试图干预，却无济于事。庇拉尔·特尔内拉告诉奥雷里亚诺，蕾梅黛丝已经作好结婚的准备，他意识到这个消息会给父母带来新的痛苦。但他还是选择面对现实。何塞·阿尔卡蒂奥·布恩迪亚和乌尔苏拉被郑重其事地请到客厅，漠然听着儿子的宣告。但听到那未婚妻的名字时，何塞·阿尔卡蒂奥·布恩迪亚气红了脸。“爱情是瘟疫！”他咆哮着，“有那么多漂亮又正派的女孩，你偏偏要娶敌人的女儿。”乌尔苏拉却赞成儿子的选择。她坦承自己对摩斯科特家七姐妹的好感，说她们漂亮、能干、端庄又有教养，称赞儿子有眼光。何塞·阿尔卡蒂奥·布恩迪亚面对妻子的热情让了步，但提出一个条件：作为交换，丽贝卡要嫁给皮埃特罗·克雷斯皮。乌尔苏拉等到能腾出时间时，会带阿玛兰妲去省城观光，让她多和外人接触以淡忘自己的失落。丽贝卡听到这个结果，立时恢复了健康，给未婚夫写了一封欢喜万分的信，经父母过目后亲自送到邮局投递。阿玛兰妲假意接受了这一决定，渐渐退了烧，但在心中暗暗发誓，丽贝卡想要结婚除非从她的尸体上跨过去。\n　…………\n　（梅尔基亚德斯死了）\n他们将他葬在为公墓预留的空地中央，筑起一座坟墓，墓碑上铭刻着他们对他的唯一所知：梅尔基亚德斯。他们为他守灵九个夜晚。大家聚在庭院里喝咖啡、讲笑话、玩纸牌，阿玛兰妲趁着这混乱找到一个机会向皮埃特罗·克雷斯皮表白自己的爱情，后者几个星期前刚与丽贝卡正式订下婚约，并且开办了一家乐器和发条玩具店，就在当年阿拉伯人常常流连并用廉价的小玩意儿交换金刚鹦鹉的地方，也就是人们口中的土耳其人大街。意大利人那一头闪亮的鬈发常引得女人们情不自禁地赞叹，他觉得阿玛兰妲不过是个任性的小姑娘，没有把她的话当真。\n　“我有个弟弟，”他对她说，“他很快会来店里给我帮忙。”\n　阿玛兰妲感到受了侮辱，带着刻骨的怨恨告诉皮埃特罗·克雷斯皮，她下定决心要阻止姐姐的婚礼，就算横尸门前也在所不惜。意大利人对如此骇人的威胁大感震惊，忍不住告诉了丽贝卡。于是，因乌尔苏拉的繁忙一再推迟的旅行，在不到一个星期内就安排妥当。\n　阿玛兰妲没有反对，但在与丽贝卡吻别的一刻，在她耳边轻轻说道：\n　“你别做梦了。就算把我赶到天边，我也能想办法让你结不成婚，哪怕要杀了你也不在乎。”\n　乌尔苏拉的离开，以及梅尔基亚德斯无形的存在——他继续悄无声息地在房间里游荡——使家里显得分外空旷。丽贝卡接管了日常家务，印第安女人负责照管面包房。每到傍晚，皮埃特罗·克雷斯皮就在一阵薰衣草的香风中到来，总带上一件玩具做礼物，他的未婚妻则在客厅里接待他，并敞开所有门窗以免引起风言风语。这种谨慎不免显得多余，因为意大利人已充分表明他的正派可靠，他甚至连姑娘的手都没有碰过，尽管她年内就将成为他的妻子。这样的来访很快使家里摆满了神奇的玩具。上了弦就能翩翩起舞的跳舞女郎，八音盒，奔跑的马儿，耍杂技的猴子，敲鼓的小丑，各种令人惊异的机械动物，皮埃特罗·克雷斯皮带来的这些玩具驱散了何塞·阿尔卡蒂奥·布恩迪亚心头悼念梅尔基亚德斯去世的悲痛，他又回到了过去那个钻研炼金术的时期。他生活在满是开膛破肚的动物、大卸八块的机件的天堂里，试图利用钟摆原理设计一套永动系统，使这些玩具趋于完善。\n　…………\n　只有丽贝卡受了阿玛兰妲的威胁一直闷闷不乐。她了解妹妹的性格，了解她的高傲，因她刻毒的怨恨而担惊受怕。她连续几个小时躲在浴室里吸吮手指，竭尽全力抗拒吃土的诱惑。为了摆脱心头的忧虑，她请庇拉尔·特尔内拉为自己推算未来。说了些模棱两可的套话之后，庇拉尔·特尔内拉给出了预言：\n　“只有等你父母入士为安，你才会幸福。”\n　丽贝卡一阵颤抖。她记起好像在梦里，看见还是小女孩的自己走进家门，带着衣箱、小木头摇椅和一个口袋，而她一直不知道口袋里面装的什么。她记起一位秃顶的先生，他身着亚麻衣裳，领口别着一粒金扣，但与金杯国王①【66页①“金杯”(copa)与后文中的“金元”(oro)、“宝剑”(espada)都是西班牙纸牌中的花色，“国王”、“骑士”、“仆侍”分别为每种花色中的第十二、第十一、第十张牌。】毫无相似之处。她记起一位非常年轻美貌的女士，双手温和芬芳，与金元仆侍那双似乎患了风湿病的手相去甚远，那女士曾在她发间簪上鲜花，下午带她在一个绿色街巷的城镇中散步。\n　“我不明白。”她说。\n　庇拉尔·特尔内拉同样困惑。\n　“我也不明白，但牌上就是这么说的。”\n　丽贝卡被这解不开的谜团搅得忧心忡忡，便告诉了何塞·阿尔卡蒂奥·布恩迪亚。他责怪她竟然相信纸牌的预言，自己却在暗中翻遍衣柜和衣箱，挪开家具，掀起床板和地板，四处寻找那个骨殖袋。他想起自从房子扩建以后就再没见过，便偷偷找来那些泥瓦匠，其中一个承认，当时嫌那袋子碍事就把它砌在了夹壁里。他们耳朵贴在墙上四处侦听，听了好几天终于听到了低沉的咯啦咯啦声，于是凿开墙壁，发现骨殖仍完好无损地保存在袋中。当天他们便把骨殖安葬在一个没有墓碑的坟茔里，就在梅尔基亚德斯的坟墓旁。何塞·阿尔卡蒂奥·布恩迪亚回到家，心里卸下了如同对普鲁邓希奥·阿基拉尔的回忆一样的良心重负。经过厨房的时候，他吻了一下丽贝卡的额头。\n　“别胡思乱想了，”他说，“你会幸福的。”\n　…………\n　（奥雷里亚诺和蕾梅黛丝结婚了）\n喧闹的庆典一直持续到星期一早上，其间唯一不幸的人是丽贝卡·布恩迪亚。这本该也是她的喜事。乌尔苏拉已同意在同一天为她举行婚礼，不料皮埃特罗·克雷斯皮星期五接到的一封信带来了他母亲病危的消息。婚礼推迟了。度埃特罗·克雷斯皮接到信后一个小时即起程前往省城，在路上错过了与母亲的相遇，他母亲星期六晚上准时抵达马孔多，并在奥雷里亚诺的婚礼上献唱了本是为自己儿子婚礼准备的悲伤咏叹调。皮埃特罗·克雷斯皮为了及时赶回自己的婚礼，一路跑瘫了五匹马，但当他星期天午夜时分赶到的时候，能做的只剩下打扫喜事的残烛余烬。从未查出究竟是谁写了那封信。在乌尔苏拉的拷问下，阿玛兰妲气得哭了起来，对着木匠们尚未拆除的祭坛赌咒发誓以证明自己的无辜。\n　…………\n　从那以后，神甫担心自己的信念会动摇，就不再去探望他，全心投入教堂的建造以加快进程。（他指何塞阿尔卡迪奥布恩迪亚，不重要）丽贝卡重新燃起了希望。她的未来全系于教堂的竣工，因为有个星期天尼卡诺尔神甫来家里吃午饭时，全家人都在席间谈论教堂建成后举行的宗教仪式将是何等庄重堂皇。“最幸运的人是丽贝卡。”阿玛兰妲说。丽贝卡没有听懂她的意思，于是她带着天真的笑容解释：\n　“因为你的婚礼将是教堂落成后举行的第一个仪式。”\n　丽贝卡试图抢先作出评论。以现在的施工速度来看，教堂竣工起码要等十年。但尼卡诺尔神甫看法不同：鉴于信徒们捐赠日益慷慨，完全可以作出更乐观的估计。尽管丽贝卡暗暗生气，连饭都没有吃完，乌尔苏拉还是赞同阿玛兰妲的主意，并捐出一笔可观的款项以加速施工。尼卡诺尔神甫认为再有一笔相同数额的捐赠，教堂就能在三年内竣工。从此，丽贝卡不再和阿玛兰妲说话，确信她的用心并不像表面那样单纯无辜。“我已经手下留情了，”在当晚的激烈争吵中阿玛兰妲回答道，“这三年我都用不着杀你了。”丽贝卡接受了挑战。\n　皮埃特罗·克雷斯皮得知婚礼再次推迟，失望之极，但丽贝卡向他证明了自己的忠贞不渝。“等你准备好，咱们就私奔。”她对他说。然而皮埃特罗·克雷斯皮并不是敢于冒险的人，他不像未婚妻那样性情冲动，视对承诺的尊重为不容挥霍的资本。于是丽贝卡采取了更大胆的举措。一阵神秘的风吹灭了客厅里的灯，乌尔苏拉随即发现这对情侣在黑暗中接吻。皮埃特罗·克雷斯皮窘迫地向她解释说这要归咎于新式煤油灯的质量问题，甚至帮她在客厅里安上了更可靠的照明设施。但又一次不知是灯油出了问题还是灯芯被阻断，乌尔苏拉发现丽贝卡坐在未婚夫的腿上。她不再接受任何借口。她把面包房托付给印第安女人比西塔西翁打理，亲自坐到摇椅上监视情侣的相会，免得那些在自己的青春年代就已过时的花招得逞。“可怜的妈妈，”丽贝卡看着乌尔苏拉在一旁打着哈欠昏昏欲睡的样子，又好气又好笑，“到死也要在这把摇椅上受罪。”皮埃特罗·克雷斯皮天天去察看施工，在过了三个月受监视的爱情生活后终于厌烦了缓慢的工程进度，决定自己出钱给尼卡诺尔神甫补足完工所需的资金。阿玛兰妲并没有慌张。她每天和女友们在长廊里绣花或做编织活计，一边聊天一边酝酿新的计策。她自以为最有效的一招，即取走丽贝卡将嫁衣收入卧室衣柜之前就放好的樟脑丸，却因为估算失误落了空。她是在离教堂完工不到两个月时采取的行动，但随着婚期临近丽贝卡迫不及待地要试穿嫁衣，比阿玛兰妲预计的时间提前了许多。丽贝卡打开衣柜，依次取下包装纸和护衬布，发现从锦缎礼服、织绣纱巾直到橘花头冠都被蛾子蛀成了粉末。她确信当初在包装里放过两把樟脑丸，但这一悲剧似乎纯粹出于偶然，她不敢责怪到阿玛兰妲身上。离婚礼已不到一个月，安帕萝·摩斯科特竟慨然答允在一个星期内为她做出一身新嫁衣。那个阴雨绵绵的中午，当安帕萝抱着一堆泡沫般的织物走进家门让丽贝卡最后一次试衣时，阿玛兰妲几乎要昏厥过去。她瞬间失声，一道冷汗沿脊背下流。漫长的数月里，她一直在恐惧的战栗中等待这一刻的到来。她深信，如果最终找不到阻挠丽贝卡婚礼的办法，到了一切手段用尽的最后时刻，她不会缺乏下毒的胆量。那天下午，安帕萝以无穷无尽的耐心在丽贝卡周身上下别了千万枚别针，丽贝卡则裹在那甲胄般的缎料里热得透不过气来，与此同时，阿玛兰妲多次乱了针脚，扎了手指，但仍以可怕的冷静作出决定：日期定在婚礼前最后一个星期五，方式是在咖啡中加一剂鸦片酊。\n　不料一个更大的障碍突然出现，并且无法挽救，迫使婚礼再次无限期延迟。婚期前一个星期，小蕾梅黛丝半夜醒来，内脏打嗝般撕裂，火热的汁液爆涌浸透全身。三天后她被自己的血毒死，一对双胞胎也横死腹中。阿玛兰妲受到良心的谴责。她曾切切祈求上帝，希望发生某种可怕的事情免得自己向丽贝卡下毒，因此对蕾梅黛丝的死怀有负罪感。那并不是她日夜祈祷所期盼的障碍。蕾梅黛丝为这个家带来了欢快气息。她和丈夫在作坊旁收拾出一间小屋，用刚刚告别的童年时代的娃娃和玩具装饰一新。她欢快的活力溢出房间四壁，像生机盎然的和风吹过秋海棠长廊。她从清晨便开始唱歌。她是唯一敢在丽贝卡与阿玛兰妲争吵时从中斡旋的人。\n　…………\n　乌尔苏拉吩咐关闭门窗守丧，如非绝对必要不许任何人出入。她还要求一年之内不得高声说话，并将一张蕾梅黛丝的银版照片摆在停放遗体守灵的地方，照片上斜系着一根黑色饰带，前面点起一盏长明灯。此后子孙们一直保持灯火不熄，他们面对着照片上这个身着百褶裙、脚踏白色小靴子、头系蝉翼纱蝴蝶结的小女孩却不免困惑，难以将其与曾祖母的标准像联系起来。阿玛兰妲担负起照顾奥雷里亚诺·何塞的职责。她当作儿子抚养的这个孩子，将会分担她的孤独，缓解她的内疚——由于她向上帝疯狂祈求，鸦片酊误落在蕾梅黛丝的咖啡里。皮埃特罗·克雷斯皮戴着系了黑纱的帽子轻手轻脚走进家门，与一袭黑衣长袖及手、心中仿佛暗暗淌血的丽贝卡默默相会。此时此刻连重议婚期的念头也会被视为大不敬，恋人关系就此永远停滞不前，沦为无人再去理会的倦怠爱情，仿佛昔日为了亲吻而熄灭灯火的情侣已被抛弃，屈从于死神的淫威。方向迷失，希望破灭，丽贝卡又开始吃土。\n　居丧多日后十字绣活动已经恢复，一天下午两点，酷热的死寂中突然有人推开大门。房柱震颤不已，长廊里刺绣的阿玛兰妲及其女友，卧室里吸吮手指的丽贝卡，厨房里的乌尔苏拉，作坊里的奥雷里亚诺，甚至栗树下孤零零的何塞·阿尔卡蒂奥·布恩迪亚，都感到房子在大地的震动中摇摇欲坠。来人是一个身材过人的大汉。他粗壮的胸背几乎挤不进门。他野牛似的脖子上挂着救难圣母像，双臂和胸前覆满神秘的刺青，右手腕上紧紧缠着“十字架婴孩”①【注①“十字架婴孩”(ni?os-en-cruz)，带有浓厚巫术色彩的护身符，未必与圣婴(el Ni?o)有关，据说贴身携带并以自身鲜血饲喂后能令主人力大无穷，刀枪不入。】护符铜手链。他的身体经风吹日晒变成棕褐色，短发竖起好像骡子的鬃毛，下颌坚毅，眼神悲伤。他的腰带比马肚带宽两倍，靴子带护腿和马刺，靴跟钉了铁掌，走到哪里都给人以地震般的战栗感。他拎着几个破旧的褡裢穿过客厅和起居室，像一阵风暴般出现在秋海棠长廊，惊得阿玛兰妲和女友们一动不动，绣花针停在空中。“嗨。”他用疲倦的声音说道，随手将褡裢往缝纫桌上一丢，径直走向家中深处。“嗨。”他向丽贝卡打了个招呼，她看着他从自己卧室门前经过，吓得呆了。\n(后面的事都知道了……在丽贝卡里面)\n　…………\n　三天后，他们在五点钟的弥撒上结为夫妇（丽贝卡与“前面回来的人”）。何塞·阿尔卡蒂奥前一天去了皮埃特罗·克雷斯皮的商店，看见他正在给学生上古弦琴课，但并没有把他叫到一边回避学生。“我要和丽贝卡结婚了。”他说。皮埃特罗·克雷斯皮顿时脸色煞白，把琴交给学生，宣布课程结束。等到堆满乐器和上弦玩具的厅里只剩下他们两人，皮埃特罗·克雷斯皮说：\n　“她是您的妹妹。”\n　“我无所谓。”何塞·阿尔卡蒂奥回答。\n　皮埃特罗·克雷斯皮用散发出薰衣草气味的手帕擦了擦额头。\n　“这违背天理，”他解释道，“另外，法律也不允许。”\n　何塞·阿尔卡蒂奥失去了耐性，倒不是皮埃特罗·克雷斯皮所讲的道理，而是他那副苍白的脸色更让人恼火。\n　“去他的天理，”他说，“我来是为了告诉你，不要再费心去问丽贝卡什么。”\n　但当看到皮埃特罗·克雷斯皮眼眶湿润，他粗暴的态度软了下来。\n　“好吧，”他换了一副腔调，“如果您真喜欢我们家，那还有阿玛兰妲呢。”\n　尼卡诺尔神甫在星期天的讲道中申明何塞·阿尔卡蒂奥和丽贝卡不是兄妹。乌尔苏拉视此事为不可想象的失礼，永远不肯原谅。当他们从教堂回来的时候，她禁止这对新人再迈进家门。对她来说，他们就等于死了一样。因此他们到公墓对面租了一间小屋，屋里唯一的家具是何塞·阿尔卡蒂奥的吊床。新婚之夜一只蝎子钻进拖鞋蜇了丽贝卡的脚，她的舌头为此都麻痹了，但这并不妨碍他们度过一个惊世骇俗的蜜月。邻居们因惊醒整个街区的叫声而恐慌——每夜八次，连午睡时段也有三次——祈祷那种肆无忌惮的激情不要侵扰死人的安眠。\n　奥雷里亚诺是唯一关心他们的人。他给他们买了一些家具，并送钱过去，直到何塞·阿尔卡蒂奥恢复常态，开始耕种与家中院子相邻的无主土地。阿玛兰妲却永远无法摆脱对丽贝卡的怨恨，尽管生活为她带来了超出梦想的满足：乌尔苏拉不知如何洗刷耻辱，她主动提出让皮埃特罗·克雷斯皮每个星期二仍来家中共进午餐，后者平和而不失尊严地战胜了挫折。出于对这一家人的尊敬，他在帽子上仍然系着黑纱，并很乐意亲近乌尔苏拉，为她带来异国礼物：葡萄牙沙丁鱼，土耳其玫瑰果酱，还有一次是一条精美的马尼拉大披巾。阿玛兰妲总是亲切殷勤地款待他。她揣测他的喜好，为他扯掉衬衫袖口的脱线，在他过生日时送上一打绣着他姓名缩写的手帕。每个星期二吃过午饭，她在长廊里绣花，他陪伴一旁，其乐融融。对皮埃特罗·克雷斯皮而言，这个他一向当小女孩对待的姑娘不啻全新的发现。她虽然外表缺乏魅力，却拥有罕见的感受力，能体会世间万物的美好，还蕴含一种不为人知的柔情。一个星期二，发生了众人意料中早晚会发生的事：皮埃特罗·克雷斯皮向她求婚。她没有停下手里的活计，等耳边火热的红潮退去才开口，镇静的声音显出老成持重。\n　“当然可以，克雷斯皮，”她回答，“但要等了解更深的时候。太着急总是不好。”\n　…………\n　阿玛兰妲和皮埃特罗·克雷斯皮得到了乌尔苏拉的信任，友情日深，这一回她认为没有必要再监视他们的见面。这是一段暮色恋情。意大利人每天傍晚登门，扣眼里别着一枝栀子花，把彼特拉克的十四行诗译给阿玛兰妲听。他们待在弥漫着牛至和玫瑰香气的长廊里，他朗读，而她编织袖口花边，对战争中的种种动乱和噩耗都毫不关心，直到不堪蚊子的烦扰才躲进客厅。阿玛兰妲的善解人意，以及不失分寸又包容一切的温柔，织起一幅无形的网罗把男友围在其中，他不得不用自己未戴戒指的苍白手指生生拨开，才能在八点时告辞离去。他们用皮埃特罗·克雷斯皮收到的意大利明信片做成一本精美的图册，里面的图画都是幽静园林中的恋人，配以中箭的红心和鸽子衔起的金色缎带。“我知道佛罗伦萨的这个公园，”皮埃特罗·克雷斯皮边浏览明信片边说，“你一伸手，鸽子就落下来吃食。”有时看着一幅威尼斯的水彩画，思乡之情使运河中污泥和腐败水产的气味升华成了花朵的幽香。阿玛兰妲一时叹息，一时欢笑，幻想着第二故乡，在那里容貌俊美的男男女女说着孩童的语言，古老的城市昔日荣光不再，只剩下出没于瓦砾间的猫儿。皮埃特罗·克雷斯皮曾经穿过大洋上下寻索，曾经在丽贝卡冲动的纠缠中错生激情，最终找到了真爱。爱情的幸福带来了生意的兴隆。他的商店那时几乎占据了整个街区，堪称幻想的温床，里面有能以钟琴报时的佛罗伦萨钟楼仿制品，有索伦托的八音盒，有一开盖便奏起五音曲的中国香粉盒，以及一切所能想象的乐器和一切所能构想的上弦装置。他的弟弟布鲁诺·克雷斯皮负责商店的业务，因为他自己单单照管音乐学校就忙不过来。多亏了他那五光十色的玩物博览，土耳其人大街变成了一方和谐的绿洲，令人淡忘了阿尔卡蒂奥的种种专横和遥远的战争梦魇。乌尔苏拉恢复星期天弥撒的时候，皮埃特罗·克雷斯皮捐赠给教堂一架德国簧风琴，组织了一个儿童唱诗班，教他们唱格列高利圣诗，为尼卡诺尔神甫沉郁的仪式平添了几许亮丽色彩。没有人怀疑阿玛兰妲会是一位幸福的妻子。他们不刻意推进恋情，任凭心中的感情自然发展，最后只差定下婚期。他们没遇到什么阻碍。乌尔苏拉为当初反复推迟丽贝卡的婚期这一失误暗中自责不已，不愿重蹈覆辙增添懊悔。战争的戕害，奥雷里亚诺的远走，阿尔卡蒂奥的暴行，以及何塞·阿尔卡蒂奥和丽贝卡的被逐，都令为蕾梅黛丝的服丧退居其次，不再那么严格。婚期在望，皮埃特罗·克雷斯皮暗示将收养奥雷里亚诺·何塞为长子，他一直待他以父亲般的亲切。一切都预示着阿玛兰妲将一帆风顺地走向幸福。然而与丽贝卡相反，她丝毫不显急切。一如染桌布、织绦带、绣孔雀那样，她耐心等待着皮埃特罗·克雷斯皮向内心的煎熬屈服。她盼望的时刻与十月不祥的阴雨一同到来。皮埃特罗·克雷斯皮拿过她膝上的绣筐，双手紧握她的手。“我不能再等了，”他对她说，“我们下个月就结婚。”阿玛兰妲触碰到他冰冷的双手时没有颤抖。她像只抓不住的小动物似的缩回手去，继续自己的活计。\n　“别天真了，克雷斯皮，”她微笑着，“我死也不会和你结婚的。”\n　皮埃特罗·克雷斯皮瞬时崩溃，他不顾羞耻地哭泣，绝望得几乎扭断手指，但无法令她改变主意。“别浪费时间了，”这便是阿玛兰妲的全部回应，“如果你真那么爱我，就请不要再进这个家。”乌尔苏拉觉得自己羞愧得要发疯。皮埃特罗·克雷斯皮百般哀求，卑躬屈膝到了令人难以置信的程度。他在乌尔苏拉的怀里哭了一个下午，而她恨不得出卖自己的灵魂换取对他的安慰。雨夜里常可见到他的身影，擎着一把绸伞在屋子附近游荡，期望看到阿玛兰妲卧室里的一点儿灯光。他的衣着打扮从未像那段时间那样考究。他那受难君王一般的庄严头颅，显出一种奇异的伟大风姿。他去哀求阿玛兰妲的女友，就是那些和她一同在长廊里刺绣的女郎，请她们从中说项。他抛下生意，整日待在店后写下狂热的短笺，连同花朵薄瓣与蝴蝶标本寄给阿玛兰妲，又都被她原封不动地退了回来。他关在屋里无休无止地弹古弦琴。一天晚上，他唱了起来。马孔多在睡梦中惊醒，心神俱醉，那琴声不似这个世界所有，那饱含爱意的歌声也不会再现人间。一时间皮埃特罗·克雷斯皮看见镇上所有的灯火都亮了，唯独阿玛兰妲的窗前依旧黑暗。十一月二日，亡灵节，他弟弟打开店门，发现所有的灯都亮着，所有的八音盒都在奏乐，所有的钟表都停在一个永恒的时刻。在这纷乱的合奏中，皮埃特罗·克雷斯皮伏在店后的写字台上，双腕用剃刀割破，双手浸没在一盆安息香水里。\n　乌尔苏拉决定在家中为他守灵。尼卡诺尔神甫反对举行宗教仪式，也不同意将他葬在公墓里。乌尔苏拉顶撞了他。“尽管您和我都理解不了，但这个男人是一位圣徒，”她说，“所以我要违背您的意思，把他安葬，就葬在梅尔基亚德斯的墓旁边。”她得到了整个镇子的支持，葬礼极其隆重。阿玛兰妲没有离开卧室，她在床上听见乌尔苏拉的哭声，涌进家中的人群的脚步声和低语声，然后是一片深沉的寂静，带有被践踏花朵的气味。很长一段时间，每到傍晚她依然会闻到皮埃特罗·克雷斯皮身上的薰衣草余香，但她还能克制住不至于陷入谵妄。乌尔苏拉抛弃了她。那天下午当阿玛兰妲走进厨房，把手伸到炉子的炭火中，她甚至没有抬头表示同情。阿玛兰妲在剧痛中失去了痛感，只闻到自己皮肉烧灼的焦味。这是治疗悔恨的一剂猛药。很多天来，她在家里的时候都把手浸在一个盛着蛋清的碗里。当烧伤痊愈时，那些蛋清似乎也使她心中的创伤愈合。这场悲剧为她留下的唯一外在痕迹便是裹在伤手上的黑纱，她到死也没摘下。\n阿玛兰妲与赫里内勒多·马尔克斯 　（补充：赫里内勒多·马尔克斯是跟随家族第二代奥雷里亚诺·布恩迪亚一起打仗的朋友） 赫里内勒多·马尔克斯上校不仅是奥雷里亚诺·布恩迪亚上校最信任的人，还被乌尔苏拉当作家中的一员。他体质虚弱，性格腼腆，生来文质彬彬，却更适合打仗，不适合从政，他的政治顾问们毫不费力就将他绕进了理论迷宫。不过他还是在马孔多实现了奥雷里亚诺上校梦寐以求的乡土平安，后者希望可以在此安心打造小金鱼以终老。他住在父母家里，但每星期总有两三次到乌尔苏拉这里吃午饭。他开始教奥雷里亚诺·何塞使用火器，对他提前进行军事训练，还在征得乌尔苏拉的同意后带他去军营生活了几个月，使他成长为男子汉。多年以前，赫里内勒多·马尔克斯几乎还是个孩子，就表白过对阿玛兰妲的爱意。她那时正沉浸在对皮埃特罗·克雷斯皮的单相思中，因而还嘲笑过他。赫里内勒多·马尔克斯在等待。有一回他从狱中给阿玛兰妲捎来一张小纸条，请她在一打细棉布手帕上绣上自己父亲的名字缩写，还捎去了工钱。一个星期后，阿玛兰妲去监狱给他送那一打绣好的手帕，钱也还了他，两人谈了几个小时的往事。“等我出去就和你结婚。”赫里内勒多·马尔克斯在告别时说道。阿玛兰妲笑了，但教孩子们读写的时候仍然想着他，希望为他寻回年轻时对皮埃特罗·克雷斯皮燃起的激情。每个星期六是探监的日子，她都去赫里内勒多·马尔克斯父母家，陪他们一同去监狱。其中一个星期六，乌尔苏拉看见她在厨房里等蛋糕出炉，要挑出最好的裹在专为此绣出的餐巾里。\n　“嫁给他吧，”乌尔苏拉对她说，“你很难再找到像他这样的男人。”\n　阿玛兰妲装出生气的样子。\n　“我不需要追着男人嫁，”她回答，“我给赫里内勒多带蛋糕，是觉得他可怜，迟早会被枪毙。’ 她本是随口一说，却赶上政府公开威胁，如果叛军不交出里奥阿查就要枪毙赫里内勒多·马尔克斯上校。探监被取消。阿玛兰妲关起门来痛哭，与当初蕾梅黛丝死时相仿的罪疚感折磨着她，仿佛是她出于无心的话语又一次引来死亡。母亲安慰她，让她相信奥雷里亚诺·布恩迪亚上校一定会有所举动制止枪决，并许诺一等战争结束就亲自把赫里内勒多·马尔克斯给她带来。结果她提前兑现了承诺。当赫里内勒多·马尔克斯以军政首领的显赫身份再次登门时，她像对待儿子一般接待他，百般恭维以取悦他，全心祈求以唤起他迎娶阿玛兰妲的初衷。她的祈求看来灵验了。每次吃过午饭，赫里内勒多·马尔克斯上校都会留下，在秋海棠长廊里和阿玛兰妲下跳棋。乌尔苏拉给他们送上牛奶咖啡和蛋糕，并照顾好孩子，免得他们被打扰。阿玛兰妲在奋力重燃心中已被遗忘的青春激情的余烬。她无法忍受心头的焦虑，期盼着共进午餐的日子，期盼着下跳棋的午后。有这位勇士的陪伴时间流逝得飞快，他的名字带有怀旧色彩，他的手指移动棋子时的轻微颤抖不易觉察。但那天赫里内勒多·马尔克斯上校再次提出结婚的请求时，她拒绝了。\n　“我谁也不嫁，”她告诉他，“尤其不嫁给你。你太爱奥雷里亚诺才想跟我结婚，因为你没法跟他结婚。”\n　赫里内勒多·马尔克斯上校是个有耐性的人。“我会再提出来，”他说，“我迟早要说服你。”他继续登门造访。阿玛兰妲关在卧室里强忍悲声，捂住耳朵，免得听见那位追求者向乌尔苏拉谈论最新战况的声音。尽管心里无比渴望，她仍能克制着不出去见面。\n　…………\n阿玛兰妲与奥雷里亚诺·何塞 　（奥雷里亚诺·何塞是家族第二代奥雷里亚诺和庇拉尔的儿子） 阿玛兰妲坐在藤摇椅上，将手中活计搁在膝头，看着奥雷里亚诺·何塞往下巴上涂满泡沫，在皮条上刮着剃刀，准备平生第一次刮胡子。他试着把上唇棕黄的茸毛理成髭须时不慎割破皮肤，粉刺流出血来，而到最后他也没理成个样子，但这番艰苦的努力却让阿玛兰妲觉得自己从这时起便开始老了。\n　“你和你这个年龄时的奥雷里亚诺一模一样，”她说，“你已经是大人了。”\n　其实他早就是了，这可以追溯到已然遥远的一天，阿玛兰妲仍把他当作孩子，在浴室里当着他的面脱下衣服。自从庇拉尔·特尔内拉把孩子托付给她抚养，她一向这样做，已经习惯了。他第一次看到的时候，唯一注意到的是乳房间的深沟。他天真地问这是怎么了，阿玛兰妲装作用指尖在胸前掏挖的样子回答：“挖呀挖呀挖呀就成这样了。”后来，当她从皮埃特罗·克雷斯皮的自杀事件中恢复，又和奥雷里亚诺·何塞一起洗澡，他已经不再注意那深沟，而注目于那紫色乳头和丰硕双峰，感到一阵奇怪的战栗。他继续观察，一点一点发现她隐秘处的神奇，窥看时感到皮肤上汗毛倒竖，就像她的皮肤碰到水时一样。很小的时候他就习惯天亮前离开自己的吊床睡到阿玛兰妲的床上，觉得和她在一起就不会惧怕黑暗。然而从意识到她的裸体那天起，驱使他钻进她蚊帐的不再是对黑暗的恐惧，而是对天明时感受她温暖呼吸的渴望。一天凌晨，就在阿玛兰妲拒绝赫里内勒多·马尔克斯上校的那段日子，奥雷里亚诺·何塞在几近窒息中惊醒，感觉她的手指像滚烫的虫子在焦灼地向他的腹部蠕动。他装作熟睡未醒，调整姿势为她除去一切障碍，随即感到那只未缠黑纱的手宛如失明的软体动物在他饥渴的水藻间潜游。两人都装作不知道双方心知肚明的事实，都装作不知道对方已知情，自那天晚上起被一种不容侵犯的默契紧紧联结在一处。奥雷里亚诺·何塞不听到客厅里时钟午夜报时的华尔兹就无法安眠，而那位容颜开始枯萎的盛年处女没等到梦游人钻进蚊帐也一刻不得安宁。她亲手将他抚养大，未曾想到他有朝一日会成为宽慰自己孤独的良药。他们不仅赤身露体睡在一起，彼此爱抚到精疲力竭，还在家中各个角落互相追逐，随时随刻关在卧室里，沉浸于持久的兴奋中。他们差点儿被乌尔苏拉发现，那天下午她走进谷仓，正撞见他们准备接吻。“你很爱你姑妈？”她毫不知情地问奥雷里亚诺·何塞。他回答说是。“你做得对。”乌尔苏拉评判道，称好做面包的面粉就回了厨房。这一幕让阿玛兰妲从狂热中惊醒。她意识到自己已经走得太远，不是在和孩子玩亲嘴游戏，而是在挑动人过中年危险无望的情火，便决然断绝了关系。奥雷里亚诺·何塞那时快要完成军训，最终接受了现实，搬到军营去睡。每个星期六他都和士兵们去卡塔利诺的店里。他突如其来的孤独，早熟的青春，都在散发着残花味道的女人们身上得到了慰藉。他在黑暗中展开幻想，竭力将她们想象成阿玛兰妲。\n　…………\n　奥雷里亚诺·何塞从尼加拉瓜联邦派军队里开了小差，跑到一艘德国船上当水手，最后出现在家中的厨房里。他壮实如马，肤色黝黑，头发浓密，像个印第安人。他怀着秘密的目的回来，一心要和阿玛兰妲结婚。\n　阿玛兰妲见他进来，没等他开口，便明白了他回来的原因。在饭桌上，他们不敢对视。但两个星期后，他当着乌尔苏拉的面盯着她的双眼说：“我一直在想你。”阿玛兰妲躲着他，竭力避免碰面的机会，尽量不与美人儿蕾梅黛丝分开。那天当侄子问她手上的黑纱要戴到什么时候，她脸红了，并因自己脸红而气恼，因为她觉得那问题在影射她的童贞。自从他回来后，她就闩上了卧室的门，但许多个夜晚过去，听着隔壁房间他那平稳的鼾声，她放松了警惕。在他归来两个月后的一天凌晨，她察觉到他进了卧室。那一刻，她并没有像预想的那样逃走或叫喊，心头反而涌上一阵如释重负的轻松。她感觉到他钻进蚊帐，就像他孩提时代常做的那样，就像他一直以来所做的那样。她意识到他寸丝不挂，不禁冷汗直流，牙齿咯咯打战。“你走，”她低声道，惊得喘不过气来，“不走我就喊了。”但奥雷里亚诺·何塞知道此刻该做些什么，他已经不再是怕黑的孩子，而是出自军营的猛兽。自那天晚上起，没有结果的无声战斗又开始了，每每持续到黎明。“我是你姑妈，”精疲力竭的阿玛兰妲低声道，“差不多就等于你母亲，这不光因为年纪，我还把你养大，就差没给你喂过奶。”奥雷里亚诺·何塞黎明时离开，第二天凌晨又回来，每次发现房门并未闩上就愈加兴奋。他没有一刻不想她。在那些被攻陷村镇的阴暗卧室里，特别是在那些最下贱的地方，找到她的影子；在伤员绷带上干涸血迹的味道中，觅见她的身形；在致命危险所激发的恐惧中，随时随地与她相遇。他曾经从她身边逃开，试图在记忆中将她抹去，为此不仅远走他方，还表现出被战友们归为莽撞的凶悍冒进。他越是在战争的粪坑里摔打她的形象，战争本身就越像阿玛兰妲。他就这样在流亡中忍受煎熬，寻求以自己的死亡来消灭她，直到听见有人讲起那个古老的故事。故事主人公和既是自己姑妈又是自己表姐的女人结婚，结果生出的儿子成了自己的祖父。\n　“一个人能娶自己的姑妈吗？”他惊异地问。\n　“不光可以娶姑妈，”一个士兵回答，“我们现在跟教士打这场仗，就是为了让人连亲娘都能娶。” 十五天后他开了小差。他发现阿玛兰妲比记忆中更憔悴，也更忧伤、更端庄；她岁月的航船正在绕过盛年的最后一个岬角，但在卧室的幽暗中她却显出从未有过的狂热，激烈的反抗也从未显得这样富于挑战。“你是头野兽。”受他追逼的阿玛兰妲说，“不能对一个可怜的姑妈干这种事，除非有教皇的特许。”奥雷里亚诺·何塞答应去罗马，答应膝行整个欧洲去亲吻教皇的鞋子，只要她肯放下悬着的吊桥。\n　“不光是这个，”阿玛兰妲反驳道，“会生出猪尾巴孩子的。”\n　奥雷里亚诺·何塞对一切道理都充耳不闻。\n　“就算生出犰狳也不要紧。”他恳求道。\n　一天凌晨，他再也无法压抑欲望和忍受痛苦，便去了卡塔利诺的店里。他找到一个乳房干瘪、亲切又廉价的女人，暂时平息了欲火。他试图对阿玛兰妲采取蔑视的态度，见到她在长廊里做缝纫活计，已经能将手摇式缝纫机应用自如时，一句话都不对她说。阿玛兰妲感觉卸去了重担，却不明白自己为什么又想起了赫里内勒多·马尔克斯上校，为什么怀念下跳棋的午后，甚至渴望他成为卧室中的情人。奥雷里亚诺·何塞还不知道自己已丧失多少领地，一天晚上他无法再忍受伪装的漠然，又回到阿玛兰妲的房间。她以无可动摇的决心拒绝了他，从此永远闩上了卧室的房门。\n　…………\n　“要出大事，”乌尔苏拉对奥雷里亚诺·何塞说，“下午六点以后不要上街。”这些劝告都归于徒然。奥雷里亚诺·何塞和当年的阿尔卡蒂奥一样，已经脱离她的怀抱。他回到家里，仿佛就可以不再为日常需要操心，这在他身上唤醒了伯父何塞·阿尔卡蒂奥那种放浪懒散的习性。他对阿玛兰妲的激情消逝得无影无踪。他四处游荡，打打台球，拈花惹草排解孤独，翻出各个角落里乌尔苏拉藏起又忘记的钱财。到后来他只为换衣服回家。“都一个样。”乌尔苏拉哀叹道，“一开始好好的，又听话又体面连只苍蝇都舍不得打，结果刚长出胡子就都变坏了。”\n阿玛兰妲与赫里内勒多·马尔克斯② 　赫里内勒多·马尔克斯上校第一个感觉到战争的虚无。身为马孔多的军政首领，他每星期两次与奥雷里亚诺·布恩迪亚上校互通电报。起初，这种通话决定着一场血肉战争的进程，那清晰的局势让他们任何时刻都能确认所处位置并预见未来走向。奥雷里亚诺·布恩迪亚上校虽然从未与人推心置腹，即使对最亲近的朋友也不例外，但那时尚保持着亲切的口吻，能让线路另一端的人辨认出来。很多次他都延长谈话超出预计，扯开话题拉起家常来。然而随着战事吃紧战火绵延，他的形象渐渐黯淡，消逝在一个虚幻的世界。代表他声音的点横越来越遥远模糊，汇聚组合而成的词语逐渐失去意义。赫里内勒多·马尔克斯上校只是倾听，心中却感惶惑，觉得仿佛在和另一个世界的陌生人通电。\n　“明白，奥雷里亚诺，”他总是按下发报键这样作结，“自由党万岁！”\n　他最终失去了与战争的一切关联。曾几何时一段真实的经历，一股青春年代不可抗拒的激情，如今对他而言已成为遥远的注脚：虚无而己。他在阿玛兰妲的缝纫间里找到了唯一的慰藉。他每天下午都去看她。他喜欢看着她的双手为细麻布上褶，美人儿蕾梅黛丝则在一旁摇着缝纫机的摇柄。他们就这样静静地度过几个小时，享受彼此的陪伴。但当阿玛兰妲因他衷情不改而暗自欣喜的时候，他却猜不透她那无法捉摸的秘密思绪。刚听到他归来的消息，阿玛兰妲心中就无比焦灼。但当看见他混在奥雷里亚诺·布恩迪亚上校的卫队中进门，看见他被严酷的流亡生活折磨得脱了形，因岁月流逝和遭人遗忘而愈显衰老，因汗水和尘土而污秽不堪，左臂悬着绷带模样丑陋，甚至还闻到他散发出牲畜的气味，她险些因幻灭而晕倒。“上帝啊，”她想，“这可不是我盼的那个人。”但第二天他再次登门时，已经剃须沐浴，髭髯散发出薰衣草的香气，臂上染血的绷带也不见了。他给她带来一本散发着珍珠光泽的精装祈祷书。\n　“男人真是奇怪，”她这样说，因为想不出别的话来，“反对教士打了一辈子仗，到头来还送人祈祷书。”\n　从那以后，即使是战事最激烈的时日，他仍然每天下午来看她。有很多次美人儿蕾梅黛丝不在，他就负责转动缝纫机的摇柄。阿玛兰妲面对这个男人表现出的恒心、忠诚和温顺不知所措——他虽然大权在握，但总是将所有武器留在客厅，寸铁不带地走进缝纫间。四年间他多次求爱，她总能找到办法拒绝却不伤害他，因为她虽然不再爱他，却也离不开他。美人儿蕾梅黛丝似乎对一切都无动于衷，且被认为智力发育迟缓，却为这痴情感动，自愿帮赫里内勒多·马尔克斯上校说项。阿玛兰妲突然间发现，自己一手抚养成人的小女孩刚刚步入花季，就已出落成马孔多有史以来最美丽的女子。她感到当年对丽贝卡的那种仇怨在心中苏醒，于是祈求上帝不要让自己走上极端盼望她死去，同时将她赶出了缝纫间。就在这个时期，赫里内勒多·马尔克斯上校开始厌倦战争。他对阿玛兰妲百般劝说，表露出深沉蕴藉的无限柔情，甚至不惜为她牺牲自己用锦绣年华换来的荣光，但却没能说服她。八月的一个下午，阿玛兰妲在彻底拒绝了这位坚毅的追求者后，再也无法忍受执拗性情的重压，锁在房间里为自己孤独到死的命运痛哭起来。\n　“你我都忘掉对方吧，”她对他说，“我们已经老得不适合谈这种事了。”\n　那天下午赫里内勒多·马尔克斯上校收到了奥雷里亚诺·布恩迪亚上校的电报。那是一次例行公事的谈话，没有为胶着的战局带来任何突破。谈话即将结束时，赫里内勒多·马尔克斯上校望着荒凉的街道、巴旦杏树上凝结的水珠，感觉自己在孤独中迷失了。\n　“奥雷里亚诺，”他悲伤地敲下发报键，“马孔多在下雨。”\n　线路上一阵长久的沉默。忽然，机器上跳出奥雷里亚诺·布恩迪亚上校冷漠的电码。\n　“别犯傻了，赫里内勒多，”电码如是说道，“八月下雨很正常。”\n　…………\n　开始的时候，赫里内勒多·马尔克斯上校每到傍晚都来拜访，两人坐在大门口追忆过往。但阿玛兰妲无法忍受这个疲累的男人勾起自己的回忆，他的秃顶正将他引向未老先衰的深渊。于是她无理地令他处处难堪，终于他只在特殊情况下才登门，最后因瘫痪而彻底消失。\n　…………\n　赫里内勒多·马尔克斯上校尽管瘫痪在摇椅上，但在一段时期内的确是唯一能够联络到起义军旧部的人物。自从尼兰迪亚停战协定签订以来，奥雷里亚诺·布恩迪亚上校寄身于打造小金鱼的作坊，他却与直到战败仍忠心耿耿的部下保持着联系。他和他们一起打着一场屈辱的日常战争，其中充满恳求与申请：“请您明天再来”，“就快了”，“我们正在认真研究您的问题”；打着一场彻底失败的战争，败给了那些“您忠实恭顺的仆人”，他们应该签发但从未签发养老抚恤金。另一场血腥的战争延续了二十年，却不曾像这场无限拖延、日日消磨的战争带给他们如此多伤害。赫里内勒多·马尔克斯上校曾躲过三次暗杀。五次受伤大难不死，身经百战安然无恙，却败给了无尽的等待，屈服于凄凉的晚景，在一间借来的光线昏暗的屋子里想着阿玛兰妲。最后一批他知晓下落的老兵出现在报纸上的照片里，卑顺地仰着面孔，身旁站着不知名的共和国总统。他赏赐他们铸有自己头像的金扣子别在衣领上，又归还给他们一面染着鲜血和硝烟污痕的战旗，以备日后覆在棺材上。另一些人更有骨气，在社会救济的荫庇下仍苦苦等待回音，他们或因饥饿而死，或怀着一腔怒火苟活，或在精致的荣誉粪堆中衰老腐烂。因此，当奥雷里亚诺·布恩迪亚上校邀请他发动一场殊死决战，彻底铲除外国入侵者扶植的腐败可耻的政府，赫里内勒多·马尔克斯上校不禁因同情而颤抖起来。\n　“噢，奥雷里亚诺，”他叹气道，“我知道你老了，可现在才明白你比看起来的样子还要老得多。”\n阿玛兰妲与丽贝卡 　数月过去，奥雷里亚诺·特里斯特已为人们所熟识和喜爱，开始四处寻找房屋准备把自己的母亲和妹妹——不是上校的女儿——接来。他看上了广场一角那座似已废弃的破败宅子，便打听主人是谁。有人告诉他那房子没有主人，过去曾经住过一位以泥土和墙皮为食的孤单寡妇，她晚年时别人在街上只见过她两次。她头戴缀有细小假花的女帽，脚穿古银色的鞋子，穿过广场到邮局寄信给主教。他们说陪伴她的只有一个残忍的女仆，那女人杀死猫狗及其他一切闯入家中的动物，并把尸体抛到街上，让市镇上的人都闻得到腐烂的恶臭味。自从最后一只动物的尸体在阳光下晒干后，又过了很久，所有人都确信那女主人和她的女仆早在战争结束前就已去世，房子迄今未倒不过是因为近年来没赶上严酷的冬季，也没遇上能使房倒屋塌的暴风。铰链因锈蚀而断裂，门板靠成团的蛛网勉强支撑，窗框受潮卡死，地面长满杂草野花，其间裂缝成为蜥蜴和各种爬虫的巢穴，一切似乎都证明这里至少有半个世纪没人居住过。对冲动的奥雷里亚诺·特里斯特而言，并不需要见到这些迹象才会采取行动。他用肩膀撞了下大门，蛀蚀的木板便寂然倒塌，灰尘四溢，白蚁巢碎屑飞扬。奥雷里亚诺·特里斯特伫立在门口不动，等到尘雾落定，立时看见了客厅中央那位瘦骨嶙峋的女人。她穿着上个世纪的衣服，光秃的头顶上稀疏几根黄发，一双大眼睛仍残存着昔日的美丽，只是最后的希望之光已在其间熄灭，脸上的皮肤因孤寂而干裂。奥雷里亚诺·特里斯特被眼前非人间所有的景象震慑，险些没有察觉到那女人正用一把老旧的军用手枪指着他。\n　“抱歉。”他含糊地低声道。\n　她在堆满破烂的客厅中央一动不动，一点点仔细打量这肩宽背厚、额头有灰烬刺青的大汉。她透过尘雾看到他站在往昔的薄雾中，背上斜挎着双铳猎枪，手里拎着一串兔子。\n　“慈悲的上帝啊，”她低声惊叹道，“这不公平，现在又让我想起这些！”\n　“我想租房。”奥雷里亚诺·特里斯特说。\n　那女人举起手枪，稳稳瞄准他额间的灰烬十字，毅然决然地扣紧扳机。\n　“请出去。”她下令道。\n　当天晚上吃饭时，奥雷里亚诺·特里斯特向家人讲起自己的遭遇，乌尔苏拉难过地哭了起来。“神圣的上帝啊，”她双手抱头喊道，“她还活着！”时光流逝，战事频仍，加上平日里无数的不幸，她都把丽贝卡给忘了。自始至终清楚地知道她还活着并在蛆虫窝里腐烂的人，只有日渐衰老却毫不心软的阿玛兰妲。当天亮时心中的寒意将她从孤枕上唤醒，她会想起她；当她用肥皂擦洗自己凋零的乳房和枯萎的腹部，当她穿上老年人雪白的细棉布裙和胸衣，当她更换手上缠裹赎罪伤痕的黑纱，都会想起她。无论何时，或睡或醒，从最庄重到最卑下的时刻，她都会想起丽贝卡，因为孤独已经为她筛选记忆，将生活在她心中累积的无数垃圾尽行焚毁，并净化、升华了其他记忆，即那些最苦涩的记忆，使其永远存留。从她那里美人儿蕾梅黛丝知道了丽贝卡的存在。每当她们路过那幢破败的房子，她都会讲起丽贝卡一桩负心的事件，一个出丑的故事，想借此让侄女分享自己日渐衰竭的怨尤，并使积怨在她死后延续。但她没能成功，因为蕾梅黛丝对一切激烈的情感都具有免疫力，遑论他人恩怨。乌尔苏拉经历了与阿玛兰妲截然相反的过程，她记忆中的丽贝卡已经被净化，那个和父母的骨殖袋一起被送来的小女孩令人怜惜的形象已经掩盖了大逆不道脱离家庭的那段过往。奥雷里亚诺第二决定接她回家好生照料，但他的好意遭到丽贝卡的断然拒绝。她辛苦多年忍受折磨好不容易赢得的孤独特权，绝不肯用来换取一个被虚假迷人的怜悯打扰的晚年。\n阿玛兰妲准备死亡 　阿玛兰妲在织她的寿衣。费尔南达不理解她为什么不时给梅梅写信，还寄去礼物，但对何塞·阿尔卡蒂奥却提都不愿提起。“你们到死也不会明白。”当她通过乌尔苏拉询问原因时，阿玛兰妲这样回答，而这一回答在她心中种下的疑问，永远也没有得到解答。身材高挑瘦削，神情高傲，总穿着宽松的泡泡纱裙，顽强地抗拒岁月流逝以及苦痛记忆的侵蚀，阿玛兰妲仿佛在前额上刻着代表贞洁的灰烬十字。其实真正的记号在她手上，在她睡觉时也不摘下并且总是亲手清洗熨平的黑纱上。时间在她织绣寿衣的指缝间流逝。在人们的印象中，她似乎白天织晚上拆，却不是为了借此击败孤独，恰恰相反，为的是持守孤独。\n　…………\n　如果不是阿玛兰妲不合时宜的死亡引发新的动荡，布恩迪亚家衰颓宅院中安静恬和的日子或许能持续很久。这一事件出乎所有人的意料。她虽然衰老又孤僻离群，但看起来依然结实挺拔，一如往常健康得好像磐石。自从那个下午她彻底拒绝赫里内勒多·马尔克斯上校并关在房中痛哭，再没有人能窥见她的内心。她在走出房门的那一刻，已经耗尽所有的眼泪。从此再没见她哭过，不管是在美人儿蕾梅黛丝升天的时候、奥雷里亚诺们遇害的时候，还是在奥雷里亚诺·布恩迪亚上校去世的时候。上校是她在这世上最爱的人，尽管直到他的尸体在栗树下被发现时她才表现出这一点。她去帮忙抬运尸体。她为他穿上军装，刮胡子，梳头发，给髭须上蜡，比他自己在光荣岁月中做得还好。没有人觉察到其中的爱意，因为他们都已见惯阿玛兰妲熟练地处理丧葬事宜。费尔南达惊诧于她对天主教与生活的关系一无所知，只懂得天主教与死亡的关联，仿佛那不是一种宗教，而只是一套丧葬习俗的手册。阿玛兰妲太过沉浸于自己的回忆，无法理解那些精微的教理。她人老了，心中的往事却依然鲜活。她听到皮埃特罗·克雷斯皮的华尔兹舞曲时，想哭的欲望一如年轻时涌上心来，仿佛流逝的时间和往日的教训都没留下痕迹。那些她借口受潮发霉而亲手扔进垃圾桶的乐谱纸带，依然在记忆中转动【第14章2420页】令琴槌敲击不停。她曾经试图在与侄子奥雷里亚诺·何塞窘迫的激情中将记忆淹没，试图在赫里内勒多·马尔克斯上校稳重阳刚的庇护下藏身，但都是枉然，连她老年时最绝望的举措也归于徒劳。还在小何塞·阿尔卡蒂奥被送去神学院之前三年，她为他洗澡时用的爱抚方式就不像是老祖母对待孙儿，更像是女人对待男人，如同传言中法国女郎们所做的那样，也如同十二岁和十四岁的她看见皮埃特罗·克雷斯皮穿着紧身舞蹈长裤随着节拍器的拍子舞动魔杖时想要对他做的那样。她有时为自己没能阻止这一悲惨的暗流而痛苦，有时愤怒得甚至用针扎手指，然而最令她痛苦最令她愤怒最令她心酸的却是爱情这棵芳香四溢却暗遭虫蛀的番石榴树正渐渐走向死亡。就像奥雷里亚诺·布恩迪亚上校总想起战争一样，她不可避免地想起丽贝卡。她兄长可以看淡记忆，她却只能让它越发灼烫。多年间她对上帝的唯一祈求，就是不要让自己遭受惩罚死在丽贝卡之前。每次路过丽贝卡的家，看着房子日渐破败，她便心满意足地以为上帝垂听了她的祈求。一天下午，她在长廊里缝纫，突然冒出一个念头，确信自己会坐在这里，以同样的姿势并在同一束阳光下听见丽贝卡的死讯传来。她坐下等待，仿佛在等一封信。一段时间里，她拆下扣子又缝上，让等待变得不那么漫长难耐。家里没人注意到阿玛兰妲在为丽贝卡缝制一件精美的寿衣。后来，当奥雷里亚诺·特里斯特说看见丽贝卡形如鬼魂，皮肤遍布裂纹，头顶黄发稀疏，阿玛兰妲丝毫不觉惊奇，因为他描述的鬼魂和她很久以来想象的一模一样。她已作好决定要为丽贝卡的尸身装殓整容，用石蜡掩盖脸上的裂纹，再用圣徒像的头发为她做一顶假发。她将装扮出一具美丽的尸体，让它身着亚麻寿衣，并为棺材套上带紫色花边的丝绒衬面，还要举行最体面的仪式下葬到蛆虫的所在。她满怀怨恨地制定了计划，但心中一个念头令她战惊：纵然出于爱意，她也无法做得比这更好。但她没受困惑搅扰，继续完善各种细节，最后超越了丧葬专家的水准，不啻精通死亡仪轨的大师。在这可怖的计划中唯一没有考虑到的就是，她尽管曾向上帝祈求，仍有可能死在丽贝卡之前。事实上，事情就这样发生了。然而在最后的时刻，阿玛兰妲毫无受挫感，相反感到摆脱一切苦痛获得了自由，因为死神格外开恩，提前几年预先给出了通知。那是在梅梅上学后不久，一个炎热的中午，她正在长廊里缝纫时看见了死神。她当下认了出来，没有丝毫恐惧，因为她面前是一位穿蓝衫的长发女人，外表有些老气，与昔日帮忙下厨的庇拉尔·特尔内拉有几分相似。费尔南达很多次也在场，却没有看见她，尽管她是那样真实，那样有血有肉，好几回还请阿玛兰妲帮忙穿针。死神并未说到她何时会死，也没告知她是否会死在丽贝卡之前，只是让她从四月六日起开始为自己缝制寿衣。死神应许她尽可以做得精美复杂，但要像为丽贝卡缝制时一样认真，还说她会死在完工的当天傍晚，死时没有痛苦、没有恐惧也没有烦恼。为了尽可能拖延时间，阿玛兰妲订购了优等麻纱，亲手织布。她织得极其仔细，光做这项活计就耗费了四年时间。然后她开始绣花。随着完工日期不可避免地临近，她意识到除非发生奇迹，才能将活计拖到丽贝卡死后，但干活时的专注令她得以保持必要的镇静来接受失败。也就在那时，她理解了奥雷里亚诺·布恩迪亚上校制成小金鱼随即又销毁的举动。世界不过是身外之物，她的内心不再为任何苦痛而波动。她深深遗憾没能在多年前获得这样的领悟，那时还来得及净化记忆，在崭新的光芒下重建世界，平静地唤回傍晚时皮埃特罗·克雷斯皮身上的薰衣草味道，并且将丽贝卡救出悲惨的境地，而这不是出于爱也不是出于恨，而是出于对孤独的深切理解。那天晚上梅梅言语中的怨恨令她惊讶，并非因为她在情感上受到触动，而是因为她感觉到自己的经历在另一个少女身上重演，她表面看来纯洁无瑕，实际上却已遭到怨恨的玷污。但那时她已完全接受命运，明知纠正的一切可能都不复存在，也并不觉得失落。做完寿衣成了她的唯一目标。她非但没像当初那样借助不必要的精工细作来拖延时间，反而加快了进度。一个星期前，她估计将在二月四日晚间缝上最后一针，便向梅梅提议将预定在次日举行的古钢琴音乐会提前。她没有说明原因，结果建议没被采纳。于是，阿玛兰妲开始设法拖延四十八个小时，后来她甚至觉得死神也在助她一臂之力，因为二月四日晚上风雨大作破坏了发电厂。但到第二天早上八点，她还是在任何女人都不曾完成过的精美作品上添上了最后一针，并以最平常的口气宣告自己将死于当晚。她不仅告诉了家人，还通知了整个市镇，因为她相信可以通过最后一次造福世人的举动来补救自己卑微的一生，而在她看来没有什么事比给逝者带信更好。\n　正午之前，阿玛兰妲·布恩迪亚将在傍晚起程捎带冥信的消息就在马孔多传开，到下午三点客厅里已经放了整整一箱信件。不愿写信的人托阿玛兰妲带个口信，她就在小本子上一一记下收信人的姓名和去世日期。“放心，”她安慰委托人，“我一到那边就去打听他的下落，把口信带给他。”一切仿佛一场闹剧。阿玛兰妲没显出丝毫慌乱，也没露出任何痛苦的迹象，甚至因为履行了义务而显得更加年轻。她身形挺拔修长一如平常。如果不是颧骨凸出和牙齿略有缺残，她看上去会比实际年龄年轻得多。她亲自吩咐将信件放进涂了柏油的箱子，并指定安放在坟墓中的位置，以尽量做到防潮。上午她请来一位木匠，站在客厅里让他量尺寸做棺材，就像是要做一件礼服。她在最后几小时迸发出无穷活力，费尔南达认为她是在拿所有人寻开心。乌尔苏拉知道布恩迪亚家的人都是无疾而终，并不怀疑阿玛兰妲的死亡预感，但仍害怕昏了头的寄信人希望信件早些送达而将她活着下葬。于是她拼命在家中清场，喊叫着与侵入者争吵，到下午四点时终于达到目的。这时，阿玛兰妲刚刚将自己的物品分发给穷人，只留下死后要穿的一套换洗内衣和一双普通的灯芯绒便鞋放在简陋的粗木棺材板上。她没有忽略这个细节，因为她还记得奥雷里亚诺·布恩迪亚上校死的时候只剩下在作坊里穿的拖鞋，自己不得不给他买一双新鞋。快五点的时候，奥雷里亚诺第二来接梅梅去参加音乐会，惊讶地发现家里正在筹备丧事。那时看上去生机勃勃的活人就只有阿玛兰妲，她甚至还好整以暇地修了鸡眼。奥雷里亚诺第二和梅梅开玩笑似的与她告别，还约好下个星期六举办复活宴席。听说阿玛兰妲·布恩迪亚将给死人带信，安东尼奥·伊莎贝尔神甫在五点钟赶来准备施行临终仪式，但等了一刻多钟才看到濒死的女士从浴室出来。一见她穿着马达普兰白细布睡衣、披散着头发出现，老迈的神甫便认定这是一个玩笑，随即遣走了祭童。但他认为可以利用这个机会，让阿玛兰妲作出一次延宕了二十年的忏悔。阿玛兰妲直截了当地回答说，她不需要任何宗教仪式的帮助，因为她的良心是清白的。费尔南达大惊失色，她不顾别人会听见，高声自问阿玛兰妲究竟犯下了怎样可怕的罪行，以至于宁可亵渎神明而死也不愿丢脸地忏悔。于是阿玛兰妲躺下，逼迫乌尔苏拉当众检查自己的贞洁。\n　“谁也不用乱猜，”她喊道，好让费尔南达听见，“阿玛兰妲·布恩迪亚怎样来到这世上就怎样离开。”\n　她没再站起来。她靠在厚垫子上仿佛真的病了，编起长辫子在耳边盘好，根据死神的教导她应该这样躺进棺材。然后，她向乌尔苏拉要来一面镜子，四十多年来第一次看见自己饱经岁月摧残与苦痛煎熬的面容，惊讶于所见竟然与想象中的形象分毫不差。乌尔苏拉从房间里的寂静知道天色已暗了下来。\n　“跟费尔南达告别吧，”她恳求道，“一分钟的和好抵得过一辈子的友谊。”\n　“已经没这个必要了。”阿玛兰妲回答。\n　当临时搭起的舞台上灯光亮起，演出的第二部分开始时，梅梅不禁想到了她。曲子弹奏到一半时，有人到她耳边告知了消息，演出当即中止。奥雷里亚诺第二赶到家中的时候，不得不推开人群挤进去，看到了那位老处女的尸体。她面容丑陋惨淡，手缠黑纱，身穿精美的寿衣。棺材安置在客厅里，旁边是一箱信件。\n　　","date":"2021-09-04","permalink":"/posts/literature/amaranta/","series":[],"tags":[""],"title":"阿玛兰妲——以前的孤独"},{"categories":["文字类"],"content":"百年孤独中关于梅尔基亚德斯（Melquíades）和科学相关的一部分片段。\nPerface 目前我最喜欢的片段~ 特别喜欢那种探索求知的感觉，希望我以后也能抱着这种态度求知学习。\n由于在书中，家族第一代何塞·阿尔卡蒂奥·布恩迪亚，和科学相关很大，所以他们的部分片段也被放到了这里；而且在书中，知识和孤独也有很大联系。\n后：做了一个晚上发现科学和知识与家族的大部分成员关系很大，如果把他们拿出来放到一起还不如完整地看完书呢……于是乎只做了一点点，但是也有快2万字了。所以如果对后续感兴趣的话，可以下载电子版或者买实体书去看。\n梅尔基亚德斯部落发现马孔多 | 家族第一代 （梅尔基亚德斯是在书本一开始就出场了的）\n多年以后，面对行刑队，奥雷里亚诺·布恩迪亚上校将会回想起父亲带他去见识冰块的那个遥远的下午。那时的马孔多是一个二十户人家的村落，泥巴和芦苇盖成的屋子沿河岸排开，湍急的河水清澈见底，河床里卵石洁白光滑宛如史前巨蛋。世界新生伊始，许多事物还没有名字，提到的时候尚需用手指指点点。每年三月前后，一家衣衫褴褛的吉卜赛人都会来到村边扎下帐篷，击鼓鸣笛，在喧闹欢腾中介绍新近的发明。最初他们带来了磁石。一个身形肥大的吉卜赛人，胡须蓬乱，手如雀爪，自称梅尔基亚德斯，当众进行了一场可惊可怖的展示，号称是出自马其顿诸位炼金大师之手的第八大奇迹。他拖着两块金属锭走家串户，引发的景象使所有人目瞪口呆：铁锅、铁盆、铁钳、小铁炉纷纷跌落，木板因钉子绝望挣扎、螺丝奋力挣脱而吱嘎作响，甚至连那些丢失多日的物件也在久寻不见的地方出现，一窝蜂似的追随在梅尔基亚德斯的魔铁后面。“万物皆有灵，”吉卜赛人用嘶哑的嗓音宣告，“只需唤起它们的灵性。”何塞·阿尔卡蒂奥·布恩迪亚天马行空的想象一向超出大自然的创造，甚至超越了奇迹和魔法，他想到可以利用这个无用的发明来挖掘地下黄金。梅尔基亚德斯是个诚实的人，当时就提醒他：“干不了这个。”然而那时的何塞·阿尔卡蒂奥·布恩迪亚对吉卜赛人的诚实尚缺乏信任，仍然拿一头骡子和一对山羊换了那两块磁铁。他的妻子乌尔苏拉·伊瓜兰本指望着靠这些牲口扩展微薄的家业，却没能拦住他。“很快我们的金子就会多到能铺地了。”她丈夫回答。此后的几个月他费尽心力想要证实自己的猜想。他拖着两块铁锭，口中念着梅尔基亚德斯的咒语，勘测那片地区的每一寸土地，连河床底也不曾放过。唯一的挖掘成果是一副十五世纪锈迹斑斑的盔甲，敲击之下发出空洞的回声，好像塞满石块的大葫芦。何塞·阿尔卡蒂奥·布恩迪亚和一起探险的四个男人将盔甲成功拆卸之后，发现里面有一具已经钙化的骷髅，骷髅的颈子上挂着铜质的圣物盒，盒里有一缕女人的头发。\n　三月里，吉卜赛人又来了。这次带来一架望远镜和一台足有鼓面大小的放大镜，展出时声称是阿姆斯特丹犹太人的最新发明。他们让一个吉卜赛女人坐在村子一头，将望远镜安在帐篷入口。花上五个里亚尔，人们就可以凑到望远镜后，看到那个吉卜赛女人在眼前出现，仿佛触手可及。“科学消除了距离，”梅尔基亚德斯说，“用不了多久，人们不出家门就能看到世界上任何地方发生的事情。”一个烈日炎炎的中午，他们用那台巨型放大镜作了一次惊人的演示：把一堆干草铺在街道中央，然后通过聚焦阳光点燃起来。尚未从磁铁实验的失利中平复的何塞·阿尔卡蒂奥·布恩迪亚，又萌生了将这一发明应用于战争的想法。梅尔基亚德斯再次试图让他打消念头，但最后还是接受了两块磁铁加三枚殖民地金币，将放大镜换给了他。乌尔苏拉难过地哭了。那些钱是从她父亲一辈子省吃俭用攒下的一匣金币中拿出来的，她本来一直埋在床下，想等待合适的机会做本钱。何塞·阿尔卡蒂奥·布恩迪亚无暇安慰她，以科学家的忘我精神全心投入战术实验，甚至不惜以身犯险。为了验证放大镜对敌军产生的效果，他亲自待到阳光的焦点下，结果身体被灼伤后溃烂，挨了很长时间才痊愈。妻子对如此危险的发明心生恐惧而提出抗议，但他全然不顾，险些把家里的房子点燃。他久久待在房间里，计算新武器的战略威力，写出了一本解说无比清晰、说服力无可抗拒的手册。他把该手册连同多种实验记录和多幅示意图一起寄给当局，承担这一使命的信使翻越山脉，迷路于无边的沼泽，蹚过湍急的河水，遭猛兽的袭击、绝望情绪和瘟疫的打击险些丧命，最后终于找到了邮政骡队途经的驿道。虽然当时远赴首都不太可能，何塞·阿尔卡蒂奥·布恩迪亚仍然表示，只要政府一声令下他立刻出发，为军方实地演示他的发明，并亲自传授阳光战的精密战术。他等待回复多年，最终厌倦了等待，到梅尔基亚德斯面前哀叹自己的挫折。于是那个吉卜赛人做出了足以显明其诚实的举动：收回放大镜，把那三枚多卜隆①【注①多卜隆( dob1ón)，西班牙古金币名。】还给他，还留下一些葡萄牙人的地图和多种航海仪器。梅尔基亚德斯亲笔写了一份赫尔曼修士②【注②赫尔曼修士(monje Hermann，1013 - 1054)，即Hermann von Reichenau，德国本笃会修士，著有多种星相学著作。】的研究成果提要给他，教他如何使用星盘、罗盘和六分仪。为了确保不受打扰地进行实验，何塞·阿尔卡蒂奥·布恩迪亚在宅院深处盖了一间小屋，整个漫长的雨季都把自己关在屋中。他把家庭职责完全抛在脑后，整夜待在院子里观测星体的运行，为了寻找精确测定正午的方法险些患上日晒病。掌握了那些仪器的用法并操作自如之后，他对空间的认知使他无须离开小屋就能遨游未知的海洋，寻访荒凉的地域，并与神奇的生灵交流。正是在那个时期他养成了自言自语的习惯，旁若无人地在家中踱步，与此同时乌尔苏拉和孩子们却在菜园里累得直不起腰来，照料香蕉、海芋、木薯、山药、南瓜和茄子。然而，没有任何征兆，他疯狂的活动猝然中断，整个人陷入一种心醉神迷的状态。他连续好几天像是着了魔，喃喃自语，说出一连串自己都无法相信的惊人设想。最终，在十二月一个星期二的午饭时分，他从所有的折磨中一下解脱了。孩子们终其一生都将记得父亲如何在桌首庄严入座，被长期熬夜和苦思冥想折磨得形销骨立，因激动而颤抖着，向他们透露自己的发现：\n　“地球是圆的，就像个橙子。”\n　乌尔苏拉再也无法忍耐。“如果你非发疯不可，就一个人疯好了，”她喊道，“别想用你那套吉卜赛人的胡话教坏孩子！”何塞·阿尔卡蒂奥·布恩迪亚无动于衷，妻子在狂怒之下把星盘扔到地上摔得粉碎，他也没有被吓着。他又造了一台，还召集村里的男人到自己的小屋，用无人能懂的理论向他们证明，一直向东航行就有可能回到出发点。全村人都确信何塞·阿尔卡蒂奥·布恩迪亚已经失去理智，这时梅尔基亚德斯来到澄清了真相。他当众赞许这个男人的聪明才智，说他仅凭天文观测就建立起的理论尽管在马孔多尚不为人所知，但已经被实践所证明。为了表示敬佩，他特别馈赠了一样将对村子的未来产生深远影响的礼物：一间炼金实验室。\n　那一时期，梅尔基亚德斯在以惊人的速度衰老。他头几回来访时看上去和何塞·阿尔卡蒂奥·布恩迪亚岁数相仿，但当后者仍然力气过人，揪住马耳朵就能将马掀翻的时候，吉卜赛人却好像已被某种顽疾击垮。实际上，那是他无数次周游世界时染上多种罕见疾病的结果。他在帮助何塞·阿尔卡蒂奥·布恩迪亚搭建实验室时亲口说过，死神一直追随他的脚步，嗅闻他的行踪，但尚未下定决心给他最后一击。他经历了危害人类的各种疾病和灾难幸存下来。他在波斯得过蜀黍红斑病，在马来群岛患上坏血病，在亚历山大生过麻风病，在日本染上脚气病，在马达加斯加患过腺鼠疫，在西西里碰上地震，在麦哲伦海峡遭遇重大海难，却都大难不死。这个天赋异禀，自称掌握了诺查丹玛斯①【注①诺查丹玛斯(Nostradamus，1503 - 1566)，法国预言家，所著《诸世纪》中载预言诗千首，据说在后世多有应验。】之钥的人是个阴沉的男子，裹在一团愁云惨雾里，目光斜曳像是能够看透一切。他总戴着一顶黑色大礼帽，活像乌鸦展开的翅膀，身穿一件天鹅绒坎肩，染着沧桑岁月的苔印。他智慧无边又神秘莫测，但还是有着凡人的一面，未能摆脱日常生活中琐碎问题的烦扰。他抱怨着衰老和病痛，为经济上微不足道的困窘而难过：他很久以前就不再展露笑容，因为坏血病夺去了他所有的牙齿。在一个闷热的正午，他吐露了心声，何塞·阿尔卡蒂奥·布恩迪亚确信那是一段伟大友情的开始。孩子们听着他的神奇故事，目瞪口呆。奥雷里亚诺那时只有五岁，他一生都将记得，那个下午吉卜赛人如何坐在窗前金属的反光中，用管风琴般深沉的声音揭示最幽暗的想象地域，热得从太阳穴流下油腻的汗水。他的哥哥何塞·阿尔卡蒂奥，将会把这奇妙的形象作为记忆遗产，传给所有后世子孙。乌尔苏拉却对这次来访印象恶劣，因为她走进房间的时候，正赶上梅尔基亚德斯一分神，打破了一个装有二氯化汞的小瓶。\n　“这是魔鬼的气味。”她说。\n　“绝不是。”梅尔基亚德斯纠正道，“魔鬼已被证明具有硫化物的属性，而这不过是一点儿氯化汞。”\n　一向诲人不倦的梅尔基亚德斯详细讲解了朱砂与魔鬼相关的效用，但乌尔苏拉却未加理睬，径自带孩子们出去祈祷。那种刺鼻的味道将与对梅尔基亚德斯的记忆一起，永远铭刻在她心里。\n　那间简陋的实验室，除了大量的小锅、漏斗、蒸馏瓶、滤器和滤网，还备有一座简陋的炼金炉，一个仿照“哲学之卵”制成的长颈烧瓶，以及一套由吉卜赛人按照犹太人玛利亚对三臂蒸馏器的现代描述制作的蒸馏过滤设备。梅尔基亚德斯还留下了对应七大行星的七种金属的若干样品，摩西和索希莫①【注①索希莫(Zósimo)，公元3世纪的希腊炼金术士。】的倍金配方，以及“超绝之精”②【注②“超绝之精”(Gran Magisterio)，炼制点金石的程序指南，象征着灵魂臻于至善的进程。】系列笔记和草图，如果参悟成功就能炼出点金石。何塞·阿尔卡蒂奥·布恩迪亚见倍金配方很简单便着了迷，接连几个星期都央求乌尔苏拉挖出她的殖民地金币，说水银能分割多少次，金子就能翻上多少倍。乌尔苏拉像往常一样，在丈夫无可动摇的决心前让了步。于是，何塞·阿尔卡蒂奥·布恩迪亚将三十枚多卜隆金币投入一口坩埚，与铜屑、雌黄、硫黄和铅一起熔化，然后倒入盛满蓖麻油的锅里用旺火煮沸，直到熬出一摊发出恶臭的浓浆，看起来更像是劣质的糖浆而非美妙的黄金。在令人忐忑和绝望的蒸馏过程中，经过与七种行星金属冶合，再放入玄妙的水银和塞浦路斯的硫酸盐中炮制，又用猪油替代萝卜油回锅熬炼，乌尔苏拉宝贵的遗产最后变成一坨碳化的油渣，死死粘在锅底。\n　当吉卜赛人再来的时候，乌尔苏拉已经发动全村的人加以抵制。但好奇心胜过了恐惧，因为这一次吉卜赛人走遍全村，利用各式乐器制造出震耳欲聋的响声，叫卖人还声称将要展出纳西安索人最神奇的发明。因此全村人都去了帐篷，付上一个生太伏就看到了青春焕发的梅尔基亚德斯：身体痊愈，皱纹平复，全新的牙齿闪闪发亮。凡是还记得他的牙龈如何毁于坏血病、脸颊如何松弛、嘴唇如何干瘪的人，面对这一无可置疑的明证，都不禁为吉卜赛人的魔力而惊栗。梅尔基亚德斯将镶在牙床上的牙齿完好无损地摘下并向观众展示——那一瞬间他变回了往昔的老朽模样——随后又戴上牙齿展露出重获青春的微笑，这时惊慌变成了恐惧。即便是何塞·阿尔卡蒂奥·布恩迪亚都觉得梅尔基亚德斯的知识已经达到令人无法容忍的程度，不过当后者私下里给他讲解了假牙的原理后，他随即感到一阵畅然。他觉得这一切如此简单而神奇，一夜之间又对炼金研究完全失去了兴趣，陷入新的情绪危机，无心饮食，整天在家中踱步。“世上正发生着不可思议的事情，”他对乌尔荪拉说，“就在那边，在河的另一边，各种魔法机器应有尽有，而我们却还像驴子一样生活。”从马孔多创建之初就认识他的人，都惊讶于他在梅尔基亚德斯影响下发生的变化。\n　当初何塞·阿尔卡蒂奥·布恩迪亚是那种年轻的族长式人物，他指导人们怎样播种，建议怎样教育孩子、饲养牲畜，为村社的繁荣与所有人通力合作，在体力劳动上也不例外。从一开始他家的房子就是村里最好的，成为他人仿效的对象。他家有一间敞亮的小厅，一间鲜花盛开、颜色喜人的露台餐厅，两间卧室，一座栽着一棵大栗树的庭院，一片精心打理的菜园，还有一个畜栏，山羊、母鸡和猪在其间和谐相处。在家里乃至整个村子，斗鸡是唯一禁养的动物。\n　………………\n　何塞·阿尔卡蒂奥·布恩迪亚当初建功立业的雄心，迅速在磁铁迷狂、天文演算、炼金幻梦以及见识世上奇观的热望中消磨殆尽，曾经勇于开拓、仪表整洁的他，变成一个外表懒散、不修边幅的男人。他那野蛮人一样的胡须，乌尔苏拉费尽力气才能勉强用菜刀收拾干净。甚至有人将他视为某种诡异巫术的牺牲品。然而当他将开荒的工具扛上肩头，倡议全体村民共同开辟一条将马孔多与新兴发明相连的捷径时，即使是那些深信他已发疯的人也丢下活计与家人而去跟随他。\n　………………\n　“见鬼！”他喊了起来，“马孔多周围全是水！”\n　很长时间内，马孔多处在一个半岛上成为根深蒂固的观念，这源于何塞·阿尔卡蒂奥·布恩迪亚远征归来后武断绘出的地图。他绘图时满怀怒气，故意夸大交通的艰难，以此来惩罚自己竟如此荒唐地选择了这样一个地方。“我们一辈子哪儿也去不了，”他向乌尔苏拉抱怨道，“我们注定要在这里活活烂掉，享受不到科学的好处。”他在实验室小屋里思来想去，脑海中全是这个念头，几个月后终于酝酿出一个方案，要将马孔多迁移到更合宜的地点。但这一次，乌尔苏拉抢在了他那狂热计划的前头。凭借一番百折不挠的努力，她暗中与村里所有女人联合起来，反对男人们的突发奇想——他们已经在准备搬家了。何塞·阿尔卡蒂奥·布恩迪亚不知道从何时起，又是怎样的力量从中作梗，他的计划陷入由种种借口、托辞和阻力形成的罗网，最终彻底沦为幻想。这天早上他在庭院尽头的小屋里一边念叨着搬家梦想，一边把实验器具装回原来的箱子，乌尔苏拉带着无辜的神情关注着这一切，甚至对他感到些许怜悯。她任凭他装完，任凭他钉好箱笼、用刷子漆上自己名字的缩写，没有责怪他一句，心里却知道他已经明白——因为听见他这么低声自言自语——村里的人不会随他上路。只是当他开始拆卸小屋的房门时，乌尔苏拉才鼓起勇气询问为什么要这样做，他不无苦涩地回答：“既然没人肯走，那我们自己走。”乌尔苏拉没有动摇。\n　“我们不走，”她说，“就留在这儿，因为我们已经在这儿生了一个孩子。”\n　“我们还没有死人，”他说，“只要没有死人埋在地下，你就不属于这个地方。”\n　乌尔苏拉反驳了他，温和而坚定：\n　“如果非要我死了才能留下，那我就去死。”\n　何塞·阿尔卡蒂奥·布恩迪亚无法相信妻子竟会如此意志坚决。\n　他试图用自己的幻梦诱惑她，许诺带她去一个神奇的世界，在那里只需往地里洒一点儿魔水就能让作物按照自己的愿望结实，在那里花一点点钱就能买到各式各样的止痛器械。但乌尔苏拉对他预言的景象毫不动心。\n　“忘了你那些疯狂的新鲜玩意儿，还是管管你的孩子吧。”她回答，“瞧瞧他们，自生自灭没人管，和驴子一样。”\n　何塞·阿尔卡蒂奥·布恩迪亚照妻子的话做了。他往窗外望去，只见两个孩子赤脚待在阳光暴晒的菜园里，他感觉从那一刻起他们才开始存在，从乌尔苏拉的咒语中诞生出来。随即他内心发生了某种变化，某种神秘而明晰的力量将他从当下拉扯出来，带往记忆中从未涉足的所在。乌尔苏拉继续打扫，此刻她已经确信有生之年再也不会离开这个家园，而他一直凝视着孩子们，直到双眼湿润。他用手背擦干眼睛，深深地叹息一声，接受了现实。\n　“好吧，”他说，“让他们帮我把东西从箱子里拿出来。\n　…………\n　然而自从那个下午叫孩子们帮忙取出实验器具，他便将自己最宝贵的时间留给了他们。在僻静的小屋里，墙壁上渐渐挂满荒唐的地图和奇异的图画。他教他们读写和算术，向他们讲起世界上的诸多奇迹，不光涉及自己已知的事物，还充分发挥想象力达到令人难以置信的极致。就这样，孩子们得知在非洲的最南端有平和而智慧的人民，他们唯一的消遣是坐下来沉思；得知爱琴海可以徒步穿越，只需从一个岛屿跳上另一个直到萨洛尼卡港。那些光怪陆离的课程深深铭刻在孩子们的记忆中，以至于多年以后，在政府军军官向行刑队下令开枪的前一刻，奥雷里亚诺·布恩迪亚上校又回想起三月里那个温暖的下午：父亲在物理课上倏然顿住，一脸着迷的神情，手停在半空中，眼神凝固，倾听着远远传来的高音笛，串铃和鼓的声音。吉卜赛人又来到了村里，推销孟菲斯城的智者们最新最惊人的发明。\n　那是一批新的吉卜赛人，男男女女都很年轻，只会说他们自己的语言，个个容貌俊美，皮肤油亮，双手灵巧。他们在街上载歌载舞引来喧声笑语，激起惊诧不断：染成各种颜色的鹦鹉吟唱着意大利浪漫曲，母鸡伴着手鼓的节奏下出一百个金蛋，训练有素的猴子能猜出人的所思所想，多功能机器既能缝扣子又能退烧，还有用来忘却不快回忆的仪器、用来浪费时间的药膏以及其他上千种异想天开、闻所未闻的发明，何塞·阿尔卡蒂奥·布恩迪亚都恨不得发明一台记忆机器来记录下这一切。村子瞬间变了样。马孔多的居民在自己村子的街道间迷失了方向，置身于喧嚷的集市中不知所措。\n　何塞·阿尔卡蒂奥·布恩迪亚一手拉住一个孩子，免得他们在混乱中走失。他从镀金牙的卖药人和六条胳膊的杂耍艺人身旁跌跌撞撞地走过，在人群散发出的粪便和檀香气味中艰难地呼吸，发疯似的四处寻找梅尔基亚德斯，想请他解开这场神奇梦魇中的无尽奥秘。\n　他问了好几个吉卜赛人，但他们都听不懂他的语言。最后他来到梅尔基亚德斯惯常扎帐篷的地方，遇见一个神情郁郁的亚美尼亚人在用卡斯蒂利亚语①【注①卡斯蒂利亚语( castellano)，即西班牙语，今日的西班牙语起源于卡斯蒂利亚地区。】介绍一种用来隐形的糖浆。那人喝下一整杯琥珀色的液体，正好此时何塞·阿尔卡蒂奥·布恩迪亚挤进入神观看的人群向他询问。吉卜赛人惊讶地回望了他一眼，随即变成一摊热气腾腾散发恶臭的柏油，而他的回答犹自在空中回荡：“梅尔基亚德斯死了。”听到这个消息，何塞·阿尔卡蒂奥·布恩迪亚惊呆了，他竭力抑制悲恸，而人群渐渐被别处的机巧吸引过去，那一摊亚美尼亚人的遗存物也彻底消失。后来，别的吉卜赛人向他证实梅尔基亚德斯的确在新加坡的沙洲上死于热病，被丢到了爪哇海的最深处。孩子们对这个消息不感兴趣，坚持要父亲带他们去见识孟菲斯智者们创造的最新奇观，据帐篷入口处招揽生意的吉卜赛人说，那曾经是所罗门王的宝藏。孩子们非去不可，何塞·阿尔卡蒂奥·布恩迪亚只好付了三十里亚尔，领他们走到帐篷中央，那里有一个遍体生毛的光头巨人，鼻上穿着铜环，脚踝间绕着沉重的铁链，正看守着一个海盗藏宝箱。巨人刚打开箱子，立刻冒出一股寒气。箱中只有一块巨大的透明物体，里面含有无数针芒，薄暮的光线在其间破碎，化作彩色的星辰。何塞·阿尔卡蒂奥·布恩迪亚茫然无措，但他知道孩子们在期待他马上给出解释，只好鼓起勇气咕哝了一句：\n　“这是世上最大的钻石。”\n　“不是。”吉卜赛人纠正道，“是冰块。”\n　何塞·阿尔卡蒂奥·布恩迪亚没能领会，伸出手去触摸，却被巨人拦在一旁。“再付五个里亚尔才能摸。”巨人说。何塞·阿尔卡蒂奥·布恩迪亚付了钱，把手放在冰块上，就这样停了好几分钟，心中充满了体验神秘的恐惧和喜悦。他无法用语言表达，又另付了十个里亚尔，让儿子们也体验一下这神奇的感觉。小何塞·阿尔卡蒂奥不肯摸，奥雷里亚诺却上前一步，把手放上去又立刻缩了回来。“它在烧。”他吓得叫了起来。但何塞·阿尔卡蒂奥·布恩迪亚没有理睬，他正为这无可置疑的奇迹而迷醉，那一刻忘却了自己荒唐事业的挫败，忘却了梅尔基亚德斯的尸体已成为乌贼的美餐。他又付了五个里亚尔，把手放在冰块上，仿佛凭圣书作证般庄严宣告：\n　“这是我们这个时代最伟大的发明。” 梅尔基亚德斯死去之后 | 家族第二代 　何塞·阿尔卡蒂奥·布恩迪亚没能解开镜屋之梦，直到见识冰块的那一刻。于是他相信自己理解了梦境的深意。他想到在不久的将来可以利用水这种寻常材料大规模生产冰块，并用它们建造村庄的新居。马孔多将不再是一个连合页和插销都因高温而变形的酷热之地，而会变成一个寒冬之城。他没有坚持建立制冰厂的尝试，只因那时他正热衷教育儿子们，特别是奥雷里亚诺，这孩子起初就显露出炼金方面的罕见天赋。实验室已经收拾干净。他们重新查阅梅尔基亚德斯的笔记，如今已心情平静，不再有因新奇而生的兴奋。他们长时间耐心实验，试图将乌尔苏拉的金子从粘在锅底的废料中分离出来。年轻的何塞·阿尔卡蒂奥几乎从不参与。当他父亲全身心摆弄炼金炉的时候，这位冲动任性、发育一向超出实际年龄的长子，已经长成一个体格魁伟的小伙子。他变了声，上唇布满初生的茸毛。\n　…………\n　（下面的他是家族第二代何塞·阿尔卡蒂奥）\n他完全沉浸在自己的世界里，以至于当他父亲和弟弟的好消息使全家沸腾时，他还不知道是他们终于熔开了那个金属块，分离出了乌尔苏拉的金子。\n　经过多日繁难而艰巨的工作，他们的确做到了。乌尔苏拉欣喜万分，甚至为炼金术的发明赞美上帝。实验室里挤满了村民，主人端出番石榴甜点加小饼干款待他们，来庆祝这一奇迹。与此同时，何塞·阿尔卡蒂奥·布恩迪亚隆重展示了坩埚中失而复得的黄金，仿佛那是他刚刚创造出来的。他让所有人一一看过，最后来到近来极少在实验室露面的长子跟前。他把发黄的干硬块摆到儿子眼前，问道：“你觉得怎么样？”何塞·阿尔卡蒂奥直率地回答：\n　“像狗屎。”\n　父亲反手给了他一巴掌，打得他直流出血和泪来。那天晚上庇拉尔·特尔内拉在黑暗中摸索着找到药瓶和棉布，用山金车酊给他敷肿，还让他尽情享受而不用费神，爱怜他而不弄疼他。他们如此心心相印，片刻之后不知不觉开始窃窃私语。\n　“我想和你单独在一起。”他说，“总有一天我要把这一切告诉所有人，用不着再躲躲藏藏。”\n　她不想扫他的兴。\n　“那太好了。”她说，“要是单独在一起，我们就可以点亮灯，互相能看见，而且我想怎么叫就怎么叫，不用管别人，你在我耳边想说什么就说什么。”\n　这一场谈话，伴以对父亲的切齿怨恨，对纵情相爱的迫切憧憬，在他身上激发出一种沉着的勇气。他事先未作任何铺垫，直接把一切都告诉了弟弟。\n　一开始小奥雷里亚诺只意识到风险，觉得哥哥的冒险极有可能引来祸端，却没能理解其中的魅力所在。后来哥哥的渴望渐渐感染了他。他听他讲述种种波折的细节，分享他的痛苦和喜悦，与他一起担惊受怕，一起体验幸福。他整夜不睡，一个人躺在床上好像睡在炭火席上，直等到天亮哥哥回来，然后两人毫无睡意地交谈到起床的时候。很快两人都变得委靡不振，都对父亲的炼金术和智慧失去了敬意，都躲藏到孤独之中。“这两个孩子呆呆的，”乌尔苏拉说，“一定是肚子里有虫子。”她用土荆芥研末熬制了一剂难喝的汤药，不料两人都以意想不到的坚忍喝了下去，并且一天之内同时坐到便盆上达十一次之多，排出了几条粉红色的寄生虫。他们兴高采烈地向所有人展示，为的是避免乌尔苏拉追究他们神不守舍和倦怠消沉的真实原因。那时奥雷里亚诺不仅能理解，还能对哥哥的经历感同身受，因为有一次当哥哥详尽无遗地向他描述情爱的奥妙，他插话问道：“那是什么感觉？”何塞·阿尔卡蒂奥当即回答：\n　“好像地震。”\n（奥雷里亚诺也失去了对炼金的兴趣，因为“庇拉尔“）\n　…………\n　乌尔苏拉安稳休息了四十天不到，吉卜赛人又来了，是带来过冰块的同一拨江湖艺人和杂耍演员。与梅尔基亚德斯的部落不同，他们在很短的时间内就证明了自己并非传播进步的使者，而是贩卖娱乐的商人。包括他们带来的冰块，也不是为了推广应用到生活中，而是纯粹当作马戏团的奇物。这次的奇巧物件中有一块飞毯，他们同样没有将其视为交通发展上的重大贡献，而仅仅当作用于消遣的玩物来介绍。毫不奇怪，人们挖出了自家埋藏的最后几枚金币，想换取一次从村里房顶飞过的短暂经历。借着纷乱人潮的掩护，何塞·阿尔卡蒂奥和庇拉尔享受了一段惬意的独处时光。他们成为人群中一对幸福的情侣，甚至开始怀疑，爱情或许可以是一种比夜晚幽会中疯狂而短暂的快乐更平和深沉的感觉。然而，庇拉尔打破了美梦。她受身边何塞·阿尔卡蒂奥的激情感染，选择了错误的方式和时机，一句话就使他的世界地覆天翻。“现在你是真正的男人了。”见他没听懂自己的意思，她又明明白白地解释了一遍：\n　“你就要有儿子了。”\n　连续几天何塞·阿尔卡蒂奥都不敢走出家门一步。一听到厨房里传来庇拉尔声震屋瓦的笑声，他就立刻逃到实验室。那里的炼金器械在乌尔苏拉的祝福下都已重获新生，何塞·阿尔卡蒂奥·布恩迪亚兴高采烈地接纳了迷途知返的儿子，并且带他入门，参与自己终于启动的点金石探寻工作。一天下午，飞毯载着吉卜赛驭手和几个村里的孩子从实验室窗前迅捷掠过，他们在飞毯上兴奋地挥手致意，两个儿子都被吸引过去，而何塞·阿尔卡蒂奥·布恩迪亚看都不看一眼。“让他们做梦去吧，”他说，“将来我们要用更科学的方式比他们靠一条可怜的床罩飞得更高。”尽管装出感兴趣的样子，何塞·阿尔卡蒂奥其实从未理解“哲学之卵”的魔力，在他看来那不过是一个做坏了的瓶子。他无法抛开自己的心事。他吃不下睡不着，脾气变坏，就像父亲工作受挫时一个样。何塞·阿尔卡蒂奥·布恩迪亚见他举止失常，以为他对炼金术太过投入，便免去他在实验室的工作。奥雷里亚诺当然知道哥哥所受的折磨与寻找点金石毫无关系，但也无法令他吐露真情。往日的推心置腹已经一去不返，同谋和交流变成敌意与缄默。他渴望孤独，对整个世界的怨恨咬噬着他的心。一天晚上他像往常一样下了床，不过不是去庇拉尔·特尔内拉家，而是混迹于集市的喧嚷人潮中。他走过各样花巧的玩意儿，没有一样能引起他的兴趣。最后他的注意力落在一样非展品上：一个非常年轻的吉卜赛女郎，几乎还是个孩子，被身上的玻璃珠链压弯了腰。这是何塞·阿尔卡蒂奥一生见过的最美的女人。她正在人群中观看一个人因为忤逆父母而变成蟒蛇的惨剧。\n（之后何塞·阿尔卡蒂奥跟着吉普赛人走了，他失踪了，母亲乌尔苏拉也去找他了）\n　…………\n　时间使一切恢复了原样。何塞·阿尔卡蒂奥·布恩迪亚和儿子不知从何时起又回到了实验室，他们抖落尘埃，点起炉灶，拾起已经在粪床上沉睡了数月的材料，又一次耐心地操作起来。连躺在柳条小筐里的阿玛兰妲，也好奇地观看父兄在水银蒸气弥漫的小屋里入神地工作。架子上被遗忘多日的一个空瓶忽然重得挪不动。工作台上的一锅水未经加热便沸腾了半个小时，直到完全蒸发。何塞·阿尔卡蒂奥·布恩迪亚和儿子看着这一切又恐惧又欢喜，他们无法解释，只是将其视作新材料要诞生的预兆。一天阿玛兰妲的小筐自行移动起来，在房间里兜了个圈。奥雷里亚诺大吃一惊，连忙去拦下它。做父亲的却没有惊慌，他把小筐放回去，固定在桌腿上，坚信期待已久的事情即将发生。就在那时，奥雷里亚诺听见他说：\n　“就算你不敬畏上帝，也该敬畏金属。”\n梅尔基亚德斯复活 |家族第二代 　（乌尔苏拉回来了，同时发现了和外界联系的道路，很多人来到了马孔多）\n马孔多变了样。跟着乌尔苏拉一起来的人四处宣扬它土地肥美、位置又比大泽区优越，于是昔日僻静的小村落很快变成繁华的城镇，有了手工作坊和店铺，还开通了一条永久商道。第一批穿尖头靴戴耳环的阿拉伯人就沿商道而来，用玻璃珠链交换金刚鹦鹉。何塞·阿尔卡蒂奥·布恩迪亚一刻也不能平静。他着迷于眼前的现实，认为这比自己广袤的幻想世界更为神奇，因而对炼金实验完全丧失了兴趣。他将漫长时日中饱受锤炼的材料搁置一旁，又变回了创业之初那个富于进取心的男子，那时他忙于设计街道规划新居，以保证人人享有平等权益。他在新落户的居民中赢得极大尊重，任何人铺设地基或修造围栏都要先咨询他的意见，大家还一致决定由他掌管土地的分配。走江湖的吉卜赛人又来了，这次把流动游艺会变成了大型赌场。人们兴高采烈地表示欢迎，相信何塞·阿尔卡蒂奥会一道归来。但他并没有出现，吉卜赛人也没有带蛇人来，在乌尔苏拉看来有关儿子的唯一线索也没了着落。镇上因此拒绝吉卜赛人扎营，并将他们视为贪欲与堕落的传播者，不许他们以后再踏上这片土地。但何塞·阿尔卡蒂奥·布恩迪亚也明确表示，梅尔基亚德斯以他悠远的智慧和神奇的发明对村子的发展壮大作出过不可磨灭的贡献，马孔多的大门将永远对他古老的部落敞开。然而据那些周游各地的旅人说，梅尔基亚德斯的部落由于逾越了人类知识的界限，已从大地上被抹去。\n　何塞·阿尔卡蒂奥·布恩迪亚至少暂时从幻想的种种煎熬中解脱出来，很快便营造出一种井然有序的实干氛围，其中只批准一项自由：释放从建村伊始就以歌声欢快报时的群鸟，代之以家家户户各备一台音乐钟。这些雕刻精美的木钟是用金刚鹦鹉从阿拉伯人那里换来的，由何塞·阿尔卡蒂奥·布恩迪亚统一校准。每隔半小时镇上便响起同一乐曲的欢快和弦，一到正午更是蔚为壮观，所有时钟分秒不差地同时奏响整曲华尔兹。那些年间，也是何塞·阿尔卡蒂奥·布恩迪亚决定在街上种植巴旦杏代替金合欢，并且发现了能使树木经久不衰的方法，但一直秘不示人。多年以后，马孔多已经遍布锌顶木屋，那些最古老的街道上却依然可见巴旦杏树蒙尘的断枝残干，然而已无人知晓出自谁人手植。当父亲忙于整治市镇，母亲一心扩展家业，每天两次用树枝穿着糖制的小鸡小鱼出门销售，奥雷里亚诺则从早到晚待在被遗弃的实验室里，完全凭自己的探索掌握了金银器工艺。他身量大长，哥哥留下的衣服很快都不合身了，便开始穿父亲的衣服，只是得让比西塔西翁收紧衬衣修剪裤子，因为奥雷里亚诺没有他们那样魁伟的身材。青春期的他失去了甜美的童音，变得沉默寡言孤独入骨，但却恢复了呱呱坠地时流露出的执著眼神。他全神贯注于金银艺实验，甚至到了废寝忘食的地步。何塞·阿尔卡蒂奥·布恩迪亚担心他过于专注，认为他或许需要一个女人，便给了他家里的钥匙和一些零钱 。奥雷里亚诺却用钱买来盐酸配制王水，还把钥匙镀了层金。不过他的古怪之处与阿尔卡蒂奥和阿玛兰妲相比又算不得什么，那两个孩子早就开始换牙，却依然整天跟在印第安女人后面，顽固地不肯说卡斯蒂利亚语而只说瓜希拉土语。“你有什么可抱怨的，”乌尔苏拉对丈夫说，“有发疯的父母就有发疯的儿女。”正当她哀叹自己命不好，认定儿女们的怪癖与猪尾巴同样可怕时，奥雷里亚诺眼神定定地望着她，令她感到一阵茫然。\n　“有人要来了。”他说。\n（来的人是丽贝卡，之前做过）\n　…………\n　（关于失眠症这一段我觉得非常有趣，所以我一定要把这一段弄下来，故事接丽贝卡改掉吃土习惯）\n丽贝卡改掉食土的恶习后，被安排到其他孩子的房间睡觉。一天夜里，和他们睡在一起的印第安女人突然醒来，听见一种奇怪的响声在角落里时断时续。她以为有动物溜进房间，警觉起来，却发现丽贝卡坐在摇椅上吮着手指，双眼像猫眼一般在黑暗中放光。比西塔西翁心中充满恐惧和难逃宿命的凄苦，她在那双眼睛里认出了威胁他们的疫病，正是这种疫病逼得她和兄弟背井离乡，永远抛下了他们古老的王国，抛下了公主与王子的尊贵身份。这就是失眠症。\n　天亮的时候，印第安人卡塔乌雷失去了踪影。他姐姐比西塔西翁留了下来，认定了自己的宿命：就算逃到天边，这致命的疫病也会穷追不舍尾随而至。没有人理会她的惊恐。“要是不用睡觉，那再好不过。”何塞·阿尔卡蒂奥·布恩迪亚说，“那样我们就有更多的时间可用。”但印第安女人向他们解释，失眠症最可怕之处不在于让人毫无倦意不能入睡，而是会不可逆转地恶化到更严重的境地：遗忘。也就是说，患者慢慢习惯了无眠的状态，就开始淡忘童年的记忆，继之以事物的名称和概念，最后是各人的身份，以至失去自我，沦为没有过往的白痴。何塞·阿尔卡蒂奥·布恩迪亚笑得喘不过气来，认为这不过是又一种印第安人杜撰的疾病。乌尔苏拉为防万一，还是将丽贝卡和其他孩子隔离开来。\n　几个星期后，比西塔西翁的恐惧似乎平息了下去。有天晚上何塞·阿尔卡蒂奥·布恩迪亚在床上辗转反侧，难以入睡。乌尔苏拉也醒着，问他怎么了，他回答：“我又想起了普鲁邓希奥·阿基拉尔。”他们一刻也没睡着，但到了第二天感觉疲劳尽去，便把不眠之夜抛在了脑后。午饭时候，奥雷里亚诺惊异地讲起他如何一整夜都在实验室忙着给一枚别针镀金，准备在乌尔苏拉的生日送给她，但此刻却仍然感觉良好。到了第三天，大家在该入睡的时刻还是毫无睡意，这才意识到已连续五十多个小时没有合眼，终于警觉起来。\n　“孩子们也都醒着。”印第安女人的话里带着宿命意味，“这病一旦进了家门，谁也逃不了。”\n　他们果然染上了失眠症。乌尔苏拉从母亲那里学过各种草药的效用，熬制了乌头汤让所有人服下去，可他们仍然睡不着，整天醒着做梦，在这种清醒的梦幻中，他们不仅能看到自己梦中的形象，还能看到别人梦见的景象，一时间家里仿佛满是访客。丽贝卡坐在厨房角落里的摇椅上。梦见一个和自己相貌极其相似的男人，他身着白色亚麻衣裳，衬衫领口别着一粒金扣，给她带来一束玫瑰。陪伴他的还有一位女士，用纤细的手指拣出一枝玫瑰簪在她发间。乌尔苏拉知道那男人和女人是丽贝卡的父母，但一番努力辨认之后，还是确信从未与他们谋面。与此同时，由于何塞·阿尔卡蒂奥·布恩迪亚一个永远无法原谅自己的疏忽，家中出品的糖果小动物仍源源不断地在镇上出售。大人小孩都津津有味地吮咂着可口的绿色失眠小公鸡、美味的粉红失眠小鱼和柔软的黄色失眠小马，于是到了星期一凌晨整个镇子都醒着。一开始没人在意。恰恰相反，人们都因不用睡觉而兴高采烈，因为那时候马孔多有太多的事情要做，时间总不够用。他们夜以继日地工作，很快就把活儿都干完了，凌晨三点便无所事事，听着音乐钟数华尔兹的音符。那些想睡觉的人，不是因为疲倦而是出于对睡眠的怀念，试遍了各种消磨精力的方法。他们聚在一起不停地聊天，一连几个小时重复同样的笑话，甚至把阉鸡的故事演化到令人无法容忍的地步。那是一个讲不完的故事，讲故事的人问大家要不要听阉鸡的故事，如果大家说“要”，他就说没让大家说“要”，而是问大家要不要听阉鸡的故事；如果大家说“不要”，他就说没让大家说“不要”，而是问大家要不要听阉鸡的故事，如果大家都不说话，他就说没让大家不说话，而是问大家要不要听阉鸡的故事；而且谁也不许走，因为他没让人走，而是问大家要不要听阉鸡的故事。就这样继续下去，整夜整夜重复这一恶性循环。\n　何塞·阿尔卡蒂奥·布恩迪亚意识到失眠症已经侵入镇子，便召集起各家家长，把自己所知的失眠症情形讲给他们听。众人决定采取措施防止灾难扩展到大泽区的其他村镇。他们把用金刚鹦鹉跟阿拉伯人换来的小铃铛从山羊脖子上摘下，放在镇子入口，供那些不顾岗哨的劝告和恳求坚持进镇的来客使用。那时节走在马孔多街道上的所有外乡人都要摇动小铃铛，好让病人知道自己是健康人。他们在镇上逗留期间禁止一切饮食，因为疫病无疑只经入口之物传播，而所有食品饮料都已沾染失眠症。这项举措成功地将疫病控制在村镇之内。隔离卓有成效，后来人们就将紧急情况视为常态。生活恢复秩序，工作照常进行，没人再为睡眠这一无用的习惯担忧。\n　还是奥雷里亚诺想出了办法，在接下来的几个月中帮助人们抵御失忆。这发现本出于偶然。他属于第一批病人，已是老练的失眠者，并借此掌握了高超的金银器工艺。一天他在寻找用来捶打金属箔片的小铁砧时，却想不起它的名称。父亲告诉他：“砧子。”奥雷里亚诺把名称写在纸上，用树胶贴在小铁砧底部：砧子。这样，他相信今后就不会再忘记。当时他还没想到这便是失忆开始的症状，因为那东西的名称本不好记。没过几天，他发现自己对实验室里几乎所有器物都叫不出名来。于是他依次注明，这样只需看一下标签就可以辨认。当父亲不安地告诉他自己童年最深刻的记忆都已消失时，奥雷里亚诺向他传授了这一方法。何塞·阿尔卡蒂奥·布恩迪亚先在家中实行，而后推广到全镇。他用小刷子蘸上墨水给每样东西注明名称：桌子，椅子，钟，门，墙，床，平锅。他又到畜栏为动物和植物标上名称：奶牛，山羊，猪，母鸡，木薯，海芋，香蕉。随着对失忆各种可能症状的研究不断深入，他意识到终会有那么一天，人们即使能通过标签认出每样事物，仍会记不起它的功用。于是他又逐一详加解释。奶牛颈后所挂的名牌便是一个极好的例子，体现出马孔多居民与失忆作斗争的决心：这是奶牛，每天早晨都应挤奶，可得牛奶。牛奶应煮沸后和咖啡混合，可得牛奶咖啡。就这样，人们继续在捉摸不定的现实中生活，只是一旦标签文字的意义也被遗忘，这般靠词语暂时维系的现实终将一去不返。\n　通往大泽区的路口立起一块牌子，上写马孔多，中心大道立有一块更大的牌子，上书上帝存在。各家各户都已写好用来记住物品和情感的简要说明。这套做法需要高度的警醒和坚强的毅力，因而很多人选择了向虚拟现实的魅力屈服，寄情于自我幻想，这纵然不切实际却更能与人安慰。庇拉尔·特尔内拉在这场造梦运动中出力最多，她成功地将纸牌算命从推演未来应用到追溯过往。借助这一方法，失眠者开始生活在由纸牌萌生的模棱两可的世界中。在模糊的追忆中，父亲是四月初到来的肤色黝黑的男人，母亲是左手戴金戒指肌肤呈麦色的女人，出生日期则简化为最近一个有云雀在月桂树上啼叫的星期二。何塞·阿尔卡蒂奥·布恩迪亚对这些寻求慰藉的方式深感无奈，决定制造当初曾想用来记录吉卜赛人神奇发明的记忆机器。该装置的设计基于以下原理：每天清晨将一生获得的知识从头至尾复习一遍。他把它想象为一种旋转辞典，人坐在中轴位置用摇把操纵，在几小时内令生活中最必要的知识都从眼前经过。当他做好大约一万四千张卡片的时候，通往大泽区的路上出现了一位衣衫不整的老人，他用小铃铛摇出悲凉的声响以表示未染上失眠症，拖着一件绳索紧系的鼓囊囊的行李，拉着一辆黑布蒙住的小车。他径直来到何塞·阿尔卡蒂奥·布恩迪亚家门前。\n　比西塔西翁开了门，但并不认识他，以为他想要兜售什么，还不知道在这个已经深陷失忆泥沼的村镇任何物品都没有市场。这是一位风烛残年的老人，尽管声音也因犹疑时断时续，双手颤抖仿佛质疑着事物的真实存在，但仍可以明显看出，他来自另一个世界，来自人们可以安睡并拥有记忆的世界。何塞·阿尔卡蒂奥·布恩迪亚看见他坐在客厅里，一边用几经补缀的黑色礼帽扇风，一边带着同情的神色认真阅读贴在墙上的一个个标签。何塞·阿尔卡蒂奥·布恩迪亚分外殷勤地向他打了个招呼，担心他是曾经相识而现在已不记得的故人。但来访者看出了他的做作，感觉到自己已被遗忘，那并不是心中暂时的尚可补救的遗忘，而是另一种更残酷且不可逆转的遗忘，他对此绝不陌生，因为那正是死亡的遗忘。于是他都明白了。他打开塞满稀奇物件的行李，掏出一个小手提包，里面满是瓶瓶罐罐。他给何塞·阿尔卡蒂奥·布恩迪亚喝下一种淡色液体，重新燃起了他的记忆之光。泪水濡湿了他的双眼，随后他才意识到自己置身于一间各种物品都贴着标签的荒唐屋子里，为墙上煞有介事的蠢话而惭愧。他随即又认出了来人，脸上顿时焕发出欢喜的光彩。那人是梅尔基亚德斯。\n　马孔多欢庆重获记忆的同时，何塞·阿尔卡蒂奥·布恩迪亚和梅尔基亚德斯正在重温往昔的友情。老吉卜赛人准备就此留在镇上。他的确一度死去，但难以忍受孤独又重返人世。他因执著于生命受到惩罚，被剥夺了一切超自然能力，又被逐出了部落，便决定到这个死神尚未光顾的偏远角落栖身，专心创立一家银版照相术工作室。何塞·阿尔卡蒂奥·布恩迪亚还从未听说过这一发明，他看到自己和全家人的形象在一块闪光的金属版上凝固成永恒，顿时惊诧得说不出话来。在当时拍下的一张老照片上，何塞·阿尔卡蒂奥·布恩迪亚灰色的头发乱蓬蓬，硬挺的衬衫领子用一粒铜扣扣上。神情庄严中藏着惊诧，乌尔苏拉乐不可支地说他像“一位受惊的将军”。何塞·阿尔卡蒂奥·布恩迪亚在那个晴朗的十二月上午的确受惊不小，他以为人的形象一旦被摄到金属版上，生命就会随之日渐销蚀。有趣的是，乌尔苏拉一反常态，消除了丈夫的疑虑，并且抛下往日的怨气，决定让梅尔基亚德斯留下一起生活，只是她一直拒绝拍照，因为——按她自己的原话——不愿意将来让儿孙笑话。那天上午她给孩子们穿上最好的衣裳，在他们脸上都搽了粉，还让每人喝下一勺骨髓糖浆，好让他们面对梅尔基亚德斯壮观的机器保持近两分钟的安分。在这张唯一的全家福照片上，奥雷里亚诺身穿黑色天鹅绒正装，夹在阿玛兰妲和丽贝卡中间，那倦怠的模样和深邃的眼神与多年以后面对行刑队时一般无二。但那时他尚未感觉到命运的预示。他已是熟练的金银匠，凭着精湛的手艺在整个大泽区享有盛名。他的作坊与梅尔基亚德斯杂乱的实验室合在一起，屋里几乎听不到他的呼吸声。他父亲和老吉卜赛人为诺查丹玛斯的预言大声争论，瓶子和托盘撞击作响，酸液不时在磕磕碰碰中打翻，溴化银到处流淌，而他仿佛置身于另一个时空。他全神投入工作，加上经营有道，不久赚取的收入就超过了乌尔苏拉的美味糖果小动物生意。但所有人都觉得奇怪，他明明已是个十足的男子汉，竟然还没有结识女人。事实上他的确没有。\n　数月后，好汉弗朗西斯科回来了，他是个将近两百岁的江湖艺人，常来马孔多吟唱自编的歌谣。他通过这些歌谣不厌其详地讲述旅行途中的各地见闻，从马孔多直讲到大泽区的边界。如果有人要捎带口信或发布消息，就付两个生太伏请他加到曲目中。乌尔苏拉便是这样偶然得知母亲过世的消息，那天晚上她听着歌谣，本来还期望听到儿子何塞·阿尔卡蒂奥的下落。人们称他为好汉弗朗西斯科，是因为他曾在一次即兴赛歌会上击败魔鬼，至于其真名实姓则无人知晓。他在失眠症肆虐期间一度从马孔多消失，一天晚上又突然出现在卡塔利诺的店里。全镇人都去听他唱歌，想知道世界上发生了什么。这次和他同来的有个肥胖无比的女人，需要四个印第安人用摇椅抬着；还有一个黑白混血姑娘，一副孤单无助的神情，打着伞遮挡阳光。这天晚上奥雷里亚诺去了卡塔利诺的店里。他看见好汉弗朗西斯科像一条巨石雕成的变色龙端坐在好奇的听众中间。他用苍老走调的声音唱出世事变迁，以当年罗利爵士①【注①罗利爵士(Sir Walter Raleigh，1552 - 1618)，英国探险家，英女王伊丽莎白一世的宠臣。】在圭亚那相赠的那架古老手风琴伴奏，那双四方走遍、踩踏硝石而皴裂的大脚还打着拍子。院子深处的一扇门内不时有男人进出，门前鸨母坐在摇椅上静静地扇着扇子。卡塔利诺耳上别了一朵毡绒玫瑰，向听众兜售碗盛的甘蔗酒，并不失时机地靠近那些男人，将手放到不该放的地方。将近夜半时分，酷热难当，奥雷里亚诺已从头听到尾，没有听出什么与自家有关的消息。他正准备起身回家，鸨母挥手跟他打了个招呼。\n　“你也进去吧，”她说，“只要二十生太伏。”\n　奥雷里亚诺向鸨母腿上的钱罐里投了一枚硬币，走进房间却不知道要做什么。混血姑娘露着母狗那样的乳头，赤着身子躺在床上。在奥雷里亚诺之前，这天晚上已有六十三个男人光顾过这里。经过这么多人进进出出，房间里的空气中混合了汗水和喘息的气味，变得污浊不堪。姑娘掀起湿透的床单，请奥雷里亚诺抓着另一侧。床单沉得像粗麻布一样。他们俩抓住两头拧水，直到恢复正常重量。他们又翻过席子，汗水从另一面往下淌。奥雷里亚诺盼着这活儿永不停息。他在理论上了解情爱是怎么回事，但还是双膝发软站立不稳，皮肤滚烫毛发悚然，仍忍不住要立刻排出腹中的重负。那姑娘收拾好床铺，要他脱掉衣服时，他慌忙解释：“是他们让我进来的。要我往钱罐里投二十生太伏，还得动作快点儿。”姑娘明白了他的困惑。“如果你出去的时候再放二十生太伏，就可以多待一会儿。”她温柔地说。奥雷里亚诺脱了衣服，羞惭至极，总想着自己的裸体没法和哥哥相比。不管那姑娘怎样努力，他都愈加没有反应，愈觉孤独异常。“我会再放二十生太伏。”他绝望地说。姑娘默默地向他谢过。她的背上都已磨破。她瘦得皮包骨，呼吸间流露出无尽的疲惫。两年前，在离这里很远的地方，她睡前没有熄灭蜡烛，醒来已经身处火海。她和抚养她长大的祖母一起居住的房子化作灰烬。从此，祖母带着她走遍各个村镇，让她以二十生太伏的价钱卖身，以挣回烧毁的房屋。根据姑娘自己估算，按每夜接待七十个男人计还需要干十几年，因为她还需另付二人的旅费、饮食费以及抬摇椅的印第安人的工钱。鸨母第二次敲房门的时候，奥雷里亚诺离开了房间，什么也没做，惶惶然只想哭泣。当天夜里他想着那姑娘无法入睡，有欲望也有怜悯。他感到无可抑制的冲动，要去爱她和保护她。到天亮的时候，他已被失眠和狂热折磨得疲惫不堪，终于作出庄严的决定，要与她成婚并把她从所欠祖母的债务中解救出来，夜夜享受她给予七十个男人的满足。但上午十点他赶到卡塔利诺店里的时候，姑娘已经离开镇子。\n　时间平复了他一时的冲动，却加深了挫败感。他一心在工作中逃避。他决定认命，终生远离女人来遮掩自己无能带来的差耻。与此同时，梅尔基亚德斯已经把马孔多所有可照的都照在金属版上，然后把银版照相术工作室让给了臆想联翩的何塞·阿尔卡蒂奥·布恩迪亚，后者要用它来获取上帝存在的科学依据。他运用一套复杂的程序在家中各处采集影像叠加曝光，确信只要上帝存在，迟早会被他拍下银版照片，不然就可以一举推翻其存在的假设。梅尔基亚德斯在破解诺查丹玛斯预言方面取得了深入进展。他每每研究到深夜，缩在退色的天鹅绒坎肩里艰难喘息，用雀爪般的小手在纸上胡乱涂写，手上的戒指都已失去曾经的光彩。一天夜里，他相信已破译出一则有关马孔多未来的预言。它会变成一座光明的城市，矗立着玻璃建造的高楼大厦，却再没有布恩迪亚家的丝毫血脉存留。“一定弄错了，”何塞·阿尔卡蒂奥·布恩迪亚大发雷霆，“不是玻璃房子，是冰房子，像我梦见的那样。而且不管到什么时候，总会有布恩迪亚家的人，直到永永远远。\n　…………\n　蕾梅黛丝走近问了几个关于小金鱼的问题，奥雷里亚诺无法回答，因为他猝然间喘不过气来。他想永远这样待下去，守着她百合般的肌肤，伴着她翡翠色的眼睛，听她以对待父亲的尊敬，每问一个问题都叫一声“先生”。梅尔基亚德斯坐在角落里的书桌前，画着难以索解的符号。奥雷里亚诺恨他。他做不了别的，只能对蕾梅黛丝说要把小金鱼送给她，结果吓得她飞快地逃出了作坊。那天下午奥雷里亚诺失去了隐藏于心底的耐性，此前他正是靠这种耐性等待见面的机会。他无心干活。他竭力集中精神无数次呼唤，但蕾梅黛丝没有回应。他到她姐姐们的缝纫店寻找她，在她家窗前寻找她，去她父亲的办公室寻找她，但她的身影只出现在他心中，填满了他可怕的孤独。他和丽贝卡在客厅里一坐就是几个小吋，听着自动钢琴弹奏华尔兹。丽贝卡这样做是因为皮埃特罗·克雷斯皮曾教她如何伴着那音乐跳舞，奥雷里亚诺这样做则是因为一切，包括音乐在内，都能让他想起蕾梅黛丝。（lolicon奥雷里亚诺，当然这只是玩笑，这本书的爱情没有什么世俗制约）\n　…………\n　恢复不久的平静又被打破，这一次是梅尔基亚德斯的死。尽管这结果已在意料之中，但他死亡的情形却是人们事先所想象不到的。他归来后没几个月，便经历了一个急剧衰老的过程，很快就被归为那类无用的老翁，他们像幽灵般在卧室间步履蹒跚地游荡，高声追怀美好岁月却无人理睬，直到某天清晨死在床上才被人想起。起初，何塞·阿尔卡蒂奥·布恩迪亚出于对新奇的银版照相术和诺查丹玛斯预言的热情，还常常帮他的忙。但随着时间流逝，两人之间的交流日益困难，他最终被丢下孤独一人。他的视力和听力都在衰退，似乎把对话者混同于他在人类历史早期所结识的人物，回答他人问题时混乱使用多种语言。一天他忘了戴上夜里放在床边水杯里的假牙，从此索性不戴。乌尔苏拉着手扩建家宅的时候，特意为他盖了一个房间，紧挨着奥雷里亚诺的作坊，远离家中的忙乱喧闹，有一扇阳光充沛的窗子和一个书架。她亲自把尘侵蛾蛀几近损毁的书籍、写满难解符号的脆薄纸张和装假牙的杯子一一摆上书架，那杯子里已经长出水生植物，开着纤小的黄花。梅尔基亚德斯似乎很喜欢这个新居，因为从此再没见他出屋，甚至在饭厅也不见他的踪影。他只去奥雷里亚诺的作坊，一待就是几个小时，在随身携带的羊皮纸上涂写谜一般的文字，那纸好像由某种干燥的材料所制，像千层饼似的裂开。他就在那里吃下比西塔西翁每天两次送去的食物，但最后那段日子他没了胃口，只吃蔬菜过活。很快他就显出素食者特有的孤清模样。他的皮肤上覆着一层柔软的苔藓，与那件不分季节永不离身的坎肩上滋生的相仿，他的呼吸间散发出熟睡动物的臭气。奥雷里亚诺最终忘了他的存在，沉浸在自己的诗行里，但有一次感觉听懂了他低沉独白中的只言片语，便留了心。实际上，他滔滔不绝说出的艰深话语中唯一能够辨别出来的，只是像锤击般不断重复的一个词“二分点二分点二分点”①，【注①二分点(equinoccio)，昼夜平分点，黄道与天赤道的交点。】还有一个名字“亚历山大·冯·洪堡” ②。【注②亚历山大·冯·洪堡( Alexander Von Humboldt，1769 - 1859)，德国地理学家和博物学家。】阿尔卡蒂奥开始帮奥雷里亚诺做金银器活计的时候，曾尝试稍稍接近他。梅尔基亚德斯回应了这一沟通努力，不时吐出几个和现实毫不相干的卡斯蒂利亚语句子。然而一天下午，他好像突然间激情骤至，神采焕发。多年以后，面对行刑队，阿尔卡蒂奥将回想起梅尔基亚德斯为他朗读那一页页不可理解的文字时的颤抖，他自然是听不懂，但那铿锵的音调听起来仿佛教皇通谕的吟唱。随后，他很久以来第一次露出笑容，用西班牙语说道：“等我死的时候，请在我房间里烧上三天水银。”阿尔卡蒂奥告诉了何塞·阿尔卡蒂奥·布恩迪亚，后者试图获取更具体的信息，却只得到一句回答：“我已经达到永生。”每当梅尔基亚德斯的呼气发臭，阿尔卡蒂奧便在星期四的上午带他去河里洗澡。他看来好了些。他脱下衣服，和年轻人一起没到水里，凭着神秘的方向感绕过深凹和危险地带。“我们是水做的。”他有一次这么说道。就这样过了很长时间，没人在家里见过他，除了那天晚上他令人感动地努力修理自动钢琴，以及他腋下夹着用毛巾包好的加拉巴木果壳瓢和油椰肥皂跟阿尔卡蒂奥去河里洗澡的时候。一个星期四，在叫他去河边之前，奥雷里亚诺听见他说：“我已经发热病死在新加坡的沙洲上。”那天他下水时弄错了路线，直到第二天早上才在下游几公里的地方被找到，尸身搁浅在一处明晃晃的河湾里，一只孤零零的秃鹫落在他肚子上。乌尔苏拉哭得比自己父亲去世时还伤心。何塞·阿尔卡蒂奥·布恩迪亚不顾她的惊诧和反对，拒绝为他下葬。“他永生不死，”他说，“他自己给出了复活的配方。”他重新燃起遗忘多时的炼金炉，放上一锅水银煮沸，一旁的尸体渐渐充满蓝色的泡沫。堂阿波利纳尔·摩斯科特鼓起勇气提醒他，溺死者不安葬的话会危害公共卫生。“哪儿的话，他根本没死。”何塞·阿尔卡蒂奥·布恩迪亚如此回答。熏香一般的水银烧煮已经持续七十二小时，尸体上开始进裂出青紫色的花朵，伴随着轻微的爆响，家里充满恶臭。到了这个时候，他才同意下葬。但拒绝草率行事，而要用隆重的礼仪对待这位马孔多最大的恩人。这是镇上第一次也是参与人数最多的葬礼，一个世纪后格兰德大妈的葬礼或可与之媲美。他们将他葬在为公墓预留的空地中央，筑起一座坟墓，墓碑上铭刻着他们对他的唯一所知：梅尔基亚德斯。他们为他守灵九个夜晚。\n　　","date":"2021-08-21","permalink":"/posts/literature/melquiades/","series":[],"tags":[""],"title":"梅尔基亚德斯、炼金室及羊皮卷——我对知识的原始印象（完成度15%）"},{"categories":["文字类"],"content":"收集丽贝卡在百年孤独出现的所有片段。\nPreface 今天是端午节，非常无聊，自己又太困了，不想学习，于是想写点什么。写什么好呢？图灵？三体？星星？都不想写，又突然想到丽贝卡这位人物，于是就决定把丽贝卡在小说中所有的片段全部给复制在这篇文章上面。\n我已经将百年孤独的文档上传到了蓝奏云网盘，如果有兴趣的话，可以去这里 下载(密码:1111)。另外还可以下载一个Typora，然后将文件后缀改为.md，可以更好地阅读。\n更新日志 2021-06-13 创建。\n2021-07-11 删除一些自己的废话，简洁一下。\n2021-08-24 暑假时又看了一遍，应该没有遗漏的片段。\n丽贝卡的片段 丽贝卡的到来 多年以后，马孔多已经遍布锌顶木屋，那些最古老的街道上却依然可见巴旦杏树蒙尘的断枝残干，然而已无人知晓出自谁人手植。当父亲忙于整治市镇，母亲一心扩展家业，每天两次用树枝穿着糖制的小鸡小鱼出门销售，奥雷里亚诺则从早到晚待在被遗弃的实验室里，完全凭自己的探索掌握了金银器工艺。他身量大长，哥哥留下的衣服很快都不合身了，便开始穿父亲的衣服，只是得让比西塔西翁收紧衬衣修剪裤子，因为奥雷里亚诺没有他们那样魁伟的身材。青春期的他失去了甜美的童音，变得沉默寡言孤独入骨，但却恢复了呱呱坠地时流露出的执著眼神。他全神贯注于金银艺实验，甚至到了废寝忘食的地步。何塞·阿尔卡蒂奥·布恩迪亚担心他过于专注，认为他或许需要一个女人，便给了他家里的钥匙和一些零钱 。奥雷里亚诺却用钱买来盐酸配制王水，还把钥匙镀了层金。不过他的古怪之处与阿尔卡蒂奥和阿玛兰妲相比又算不得什么，那两个孩子早就开始换牙，却依然整天跟在印第安女人后面，顽固地不肯说卡斯蒂利亚语而只说瓜希拉土语。“你有什么可抱怨的，”乌尔苏拉对丈夫说，“有发疯的父母就有发疯的儿女。”正当她哀叹自己命不好，认定儿女们的怪癖与猪尾巴同样可怕时，奥雷里亚诺眼神定定地望着她，令她感到一阵茫然。\n　“有人要来了。”他说。\n　和往常一样，乌尔苏拉听到他发表预言又试图用家庭主妇的常识来解释。有人来再正常不过。每天都有数十个外乡人经过马孔多，从未引发混乱，更无须事先神秘预告。然而，奥雷里亚诺对一切逻辑解说浑不在意，对自己的预感确信不疑。\n　“我不知道是谁，”他坚持道，“但不管是谁，人已经在路上了。”\n　果然，到了星期天，丽贝卡来了。此时她只有十一岁。几位皮革商人带着她从马纳乌雷辛苦跋涉而来，受人之托将她连同一封信送到何塞·阿尔卡蒂奥·布恩迪亚家，却又说不清楚托付他们的人究竟是谁。她的所有行李包括一个小衣箱、一把绘有彩色小花的小摇椅和一个帆布口袋，袋里装着她父母的骨殖，一刻不停地发出咯啦咯啦的响声。那封带给何塞·阿尔卡蒂奥·布恩迪亚的信中充满温情的话语，可见纵然岁月蹉跎天各一方，写信人依然对他深情不改，并且出于基本的人道精神将这个无依无靠的孤儿送来这里。孩子算乌尔苏拉的远房表妹，因而也是何塞·阿尔卡蒂奥·布恩迪亚的亲人，尽管关系上要更远些。她是难忘的挚友尼卡诺尔·乌略亚和他可敬的妻子丽贝卡·蒙铁尔的女儿，愿他们在天国安息，一并送来他们的骨殖，盼以基督徒的礼仪安葬云云。信中提到的名字和末尾的签名都清晰可辨，然而何塞·阿尔卡蒂奥·布恩迪亚和乌尔苏拉都不记得有这些亲戚，也从不认识叫这个名字的写信人，更不用提还是在遥远的马纳乌雷。从女孩那里也无法获得更多信息。从来到的那一刻起，她就一直坐在摇椅上吮手指，一双受惊的大眼睛打量着所有人，不曾流露出能听懂别人提问的迹象。她穿着已显破旧的黑色斜纹布衣裳，脚上是漆皮脱落的短靴。头发拢到耳后，用黑带子束住两个发髻。披肩上的图案沁染汗渍已无法辨认，一颗食肉动物的犬牙配上铜托系在右手腕上当作抵抗“邪眼”的护身符。青绿色的皮肤，圆滚紧绷如一面鼓的肚子，都显示出她体弱多病、忍饥挨饿的历史甚至要比自身的年龄更久远，然而食物端上来的时候，她却任凭盘子搁在腿上尝也不尝。大家几乎要相信她是个聋哑儿，直到印第安人用他们的语言问她要不要喝点儿水的时候，她才眼神一动仿佛认出了他们，点了点头。\n　家人没有办法，只得把她收留下来。奥雷里亚诺耐心地在她面前从头到尾念了一遍圣徒节期表，但她对所有名字都没有反应，家人只好根据信中她母亲的名字叫她丽贝卡。那时马孔多还没死过人，自然没有墓地，他们只得暂时将骨殖袋收藏起来，等将来有合宜的地方再下葬。很长一段时间这些遗骨在家中到处碍事，总在意想不到的地方出现，像母鸡抱窝似的咯咯作响。丽贝卡过了很久才融入家庭生活。她总是缩到家中最偏僻的角落，坐在摇椅上吮吸手指。什么都无法引起她的注意，除了那些钟表奏出的音乐，她每过半小时就会瞪着受惊的眼睛四下寻找，仿佛想在空中某个位置找到那乐声。数天过去，她什么也不肯吃。谁都无法理解她居然没有饿死，后来印第安人——他们一刻不停、悄无声息地在家里走来走去，一切都逃不过他们的眼睛——发现她只喜欢吃院子里的湿土和用指甲刮下的石灰墙皮。显然她父母或是其他抚养人曾斥责过这一恶习，因为她总是心有愧疚暗中行事，藏起口粮来等没人时再享用。从那以后，家里开始对她严加监视。他们在院子里洒牛胆汁，往墙壁上涂辣椒油，相信用这些方法可以遏制她的恶习。然而她找寻泥土时显得异常狡黠机智，乌尔苏拉不得不采取更严厉的手段。乌尔苏拉在小锅里放入橘汁，兑上大黄晾了一整夜，次日让她空腹喝下。没人说过这就是治疗食土怪癖的特效药，但乌尔苏拉却相信任何苦味的食物进入空腹都会令肝脏产生反应。丽贝卡拼命反抗，力气之大与瘦小身量根本不符，他们不得不像扳倒一头小牛犊似的逼她服药，却难以制止她的乱踢乱踹，无法忍受她在撕咬和吐口水之余古怪难解的呼号。印第安人听得目瞪口呆，说那是他们语言中最污秽的辱骂。乌尔苏拉知道后，在药物治疗之外又加上了皮带抽打。永远无从确知，究竟是大黄或毒打，还是二者一起最终发挥了效用，总之几个星期后丽贝卡显出康复的迹象。她加入到阿尔卡蒂奥和阿玛兰妲的游戏中，他们把她当姐姐看待。她胃口颇佳，刀叉也用得不错。不久家人又发现她的卡斯蒂利亚语说得和印第安土语一样流利，手头活计也干得出色，还会哼唱音乐钟奏出的华尔兹舞曲，配上滑稽的自编歌词。大家很快就接纳她为家庭新成员。她和乌尔苏拉最亲，连乌尔苏拉的亲生儿女都比不上。她管阿玛兰妲和阿尔卡蒂奥叫小妹妹小弟弟，称奥雷里亚诺为叔叔，呼何塞·阿尔卡蒂奥·布恩迪亚为爷爷。于是，她和其他家人一样名正言顺地用上了丽贝卡·布恩迪亚的姓名，那也是她一生用过的唯一姓名，直到去世从未玷污。\n　丽贝卡改掉食土的恶习后，被安排到其他孩子的房间睡觉。一天夜里，和他们睡在一起的印第安女人突然醒来，听见一种奇怪的响声在角落里时断时续。她以为有动物溜进房间，警觉起来，却发现丽贝卡坐在摇椅上吮着手指，双眼像猫眼一般在黑暗中放光。比西塔西翁心中充满恐惧和难逃宿命的凄苦，她在那双眼睛里认出了威胁他们的疫病，正是这种疫病逼得她和兄弟背井离乡，永远抛下了他们古老的王国，抛下了公主与王子的尊贵身份。这就是失眠症。\n豆蔻年华的丽贝卡 在这个古怪的家里，乌尔苏拉尽力保持正常，她扩大了糖果小动物生意，整夜不歇地开着烤炉，产出一篮篮面包以及品种丰富的布丁、蛋白酥和小饼干，几个小时内就在通往大泽区的小路上全部售出。明明已到可以安享生活的岁数，她反倒越来越活跃。她一直忙于自己兴隆的事业，一天下午，当印第安女人帮她往面团里加糖，她无意中向院子望去，竟看见两位陌生的美丽少女在暮色中绣花。那是丽贝卡和阿玛兰妲。她们为外祖母严格守孝三年，那时刚刚脱去孝服，鲜艳的衣裳仿佛使她们在世上获得了新的地位。谁也不曾想到，丽贝卡会是两人中更漂亮的那个。她面容白皙明净，眼睛大而沉静，一双有魔力的手仿佛在将无形的丝线绣成花样。年龄小些的阿玛兰妲虽然魅力稍逊，但遗传了过世外祖母自然的气质和内心的高傲。\n丽贝卡与皮埃特罗·克雷斯皮 （为了理解下面的部分，说明一下皮埃特罗·克雷斯皮是一名意大利技师，他来帮助家里安装调试自动钢琴。阿玛兰妲简单来讲和丽贝卡是同龄人，她是家里面亲生的女儿）\n皮埃特罗·克雷斯皮重新把自动钢琴组装起来。丽贝卡和阿玛兰妲帮他理顺琴弦，听到那颠倒的华尔兹乐曲时跟他一起连连大笑。见他那样可亲又可靠，乌尔苏拉便取消了监视。在他告别的前夜，家里用修复的自动钢琴临时举行了一场舞会，他和丽贝卡联袂表演了一场美妙的现代舞。………………将近午夜时分，皮埃特罗·克雷斯皮满怀感情地发表了简短致辞，并许诺会很快回来。丽贝卡一直送他到门口，随即关闭家门，熄灭灯火，她回到自己房间里恸哭起来。那是一种难以安慰的哭泣，持续了好几天，连阿玛兰妲也不明白其中的缘由。她的守口如瓶并不奇怪。她虽然表面热情坦诚，实际秉性孤僻，从不敞开心扉。她已出落成一位亭亭玉立的少女，身材修长结实，但仍旧喜欢坐在那把和她一起到来的小木头摇椅上，那椅子加固过多次，扶手已经不见了。没人留意她到了这个年龄还是喜欢吸吮手指，她一有机会便把自己关在浴室里，并养成了面朝墙壁睡觉的习惯。雨天的下午，她和女友们待在秋海棠长廊里刺绣，每当看到潮湿的土层和蚯蚓在花园里堆起的小丘，她常常会从交谈中走神，怀念的泪水带着咸味涌上舌尖。她一开始哭泣，当年那些被橘汁和大黄压服的秘密嗜好顿时化为无法抑制的渴望爆发。她又开始吃土。第一次几乎是出于好奇，她确信那糟糕的味道将是摆脱诱惑的最佳药方。她果然无法忍受泥土在嘴里的感觉，但她没有放弃，而是受制于不断增强的渴望，渐渐恢复了旧日的胃口，恢复了对原生矿物的喜爱以及原始食物带来的满足。她将一把把泥土藏进口袋，一边传授女友们最繁难的针法，谈论其他不值得自己为之吃下石灰墙皮的男人，一边趁人不注意一点点吃掉，心中涌起既幸福又愤怒的迷乱感觉。这一把把泥土使那唯一值得她自卑自贱的男人不再遥远也更加真切，仿佛从他脚上精巧的漆皮靴在世界另一处所踏的土地传来矿物的味道，她从中品出了他鲜血的重量和温度，这感觉在她口中猛烈烧灼，在她心里留下安慰。一天下午，安帕萝·摩斯科特无缘无故请求参观新家。阿玛兰妲和丽贝卡对这突如其来的到访不明所以，礼貌而生硬地接待了她。她们向她展示扩建后的家宅，请她听自动钢琴的演奏，为她端上橘子水和小饼干。安帕萝给她们上了一课，诸如什么是端庄大方，什么是仪态可亲，什么是举止得体，给在场不过短短一会儿的乌尔苏拉留下了深刻印象。两小时后，谈话渐渐无味，安帕萝趁阿玛兰妲分神的瞬间将一封信塞给丽贝卡。她只来得及看见“可敬的丽贝卡·布恩迪亚小姐”字样，与自动钢琴说明书上的字体同样工整，以同样的绿色墨水写就，使用同样的绮丽措辞。她立刻用指尖将信折起藏进胸衣，望着安帕萝·摩斯科特的眼神中充满无尽感激，还有结下生死之盟的无声承诺。\n………………\n丽贝卡每天下午四点待在窗边绣花，等待情书的到来。明明知道运送邮件的骡子每十五天才来一次，她依然天天等候，相信他们会算错时间，任何一天都有可能到来。然而事与愿违，有一次到了预定的日期，骡子却没有出现。丽贝卡绝望得发疯，半夜爬起来，自戕般饥渴地吞下一把把花园里的泥土。她又痛苦又愤怒地哭泣，咀嚼着柔软的蚯蚓，咬碎蜗牛的硬壳崩裂牙齿，又呕吐直到天亮。她陷入一种迷狂的衰弱状态，失去意识，在毫不知耻的呓语中吐露心声。乌尔苏拉惊诧之下撬开她的衣箱，在箱底发现了用玫瑰色丝带系好的十六封香气四溢的信件，夹在旧书里的枯叶和花瓣，以及一碰就化为粉末的蝴蝶标本。\n………………\n（何塞·阿尔卡蒂奥·布恩迪亚是建村元老，不用关注）\n丽贝卡那般喊叫已经无法保守秘密，阿玛兰妲发现了她的痴恋后开始发烧。她也在为没有回应的爱情而饱受折磨。她把自己关在浴室里，写下一封封狂热的信，以摆脱没有希望的激情带来的折磨，然后把信深藏在衣箱内。乌尔苏拉同时照顾两个病人，几乎忙不过来。她费尽心机长时间询问，也没能问出阿玛兰妲委靡的缘由。最终，她又灵机一动，撬开衣箱，便发现了用玫瑰色丝带系好的信，信内塞满新鲜的百合花瓣，信上泪痕未干，封封都写给皮埃特罗·克雷斯皮，但从未寄出。乌尔苏拉眼含愤怒的泪水，诅咒自己动念购买自动钢琴的那个时刻，并取消了刺绣课程，下令进入没有死人的丧期，直到女儿们死心断念为止。………………何塞·阿尔卡蒂奥·布恩迪亚面对妻子的热情让了步，但提出一个条件：作为交换，丽贝卡要嫁给皮埃特罗·克雷斯皮。乌尔苏拉等到能腾出时间时，会带阿玛兰妲去省城观光，让她多和外人接触以淡忘自己的失落。丽贝卡听到这个结果，立时恢复了健康，给未婚夫写了一封欢喜万分的信，经父母过目后亲自送到邮局投递。阿玛兰妲假意接受了这一决定，渐渐退了烧，但在心中暗暗发誓，丽贝卡想要结婚除非从她的尸体上跨过去。\n………………\n（一个重要的人物“死”了——梅尔基亚德斯，也不用关注）\n这是镇上第一次也是参与人数最多的葬礼，一个世纪后格兰德大妈的葬礼或可与之媲美。他们将他葬在为公墓预留的空地中央，筑起一座坟墓，墓碑上铭刻着他们对他的唯一所知：梅尔基亚德斯。他们为他守灵九个夜晚。大家聚在庭院里喝咖啡、讲笑话、玩纸牌，阿玛兰妲趁着这混乱找到一个机会向皮埃特罗·克雷斯皮表白自己的爱情，后者几个星期前刚与丽贝卡正式订下婚约，并且开办了一家乐器和发条玩具店，就在当年阿拉伯人常常流连并用廉价的小玩意儿交换金刚鹦鹉的地方，也就是人们口中的土耳其人大街。意大利人那一头闪亮的鬈发常引得女人们情不自禁地赞叹，他觉得阿玛兰妲不过是个任性的小姑娘，没有把她的话当真。\n　“我有个弟弟，”他对她说，“他很快会来店里给我帮忙。”\n　阿玛兰妲感到受了侮辱，带着刻骨的怨恨告诉皮埃特罗·克雷斯皮，她下定决心要阻止姐姐的婚礼，就算横尸门前也在所不惜。意大利人对如此骇人的威胁大感震惊，忍不住告诉了丽贝卡。于是，因乌尔苏拉的繁忙一再推迟的旅行，在不到一个星期内就安排妥当。\n　阿玛兰妲没有反对，但在与丽贝卡吻别的一刻，在她耳边轻轻说道：\n　“你别做梦了。就算把我赶到天边，我也能想办法让你结不成婚，哪怕要杀了你也不在乎。”\n乌尔苏拉的离开，以及梅尔基亚德斯无形的存在——他继续悄无声息地在房间里游荡——使家里显得分外空旷。丽贝卡接管了日常家务，印第安女人负责照管面包房。每到傍晚，皮埃特罗·克雷斯皮就在一阵薰衣草的香风中到来，总带上一件玩具做礼物，他的未婚妻则在客厅里接待他，并敞开所有门窗以免引起风言风语。这种谨慎不免显得多余，因为意大利人已充分表明他的正派可靠，他甚至连姑娘的手都没有碰过，尽管她年内就将成为他的妻子。这样的来访很快使家里摆满了神奇的玩具。上了弦就能翩翩起舞的跳舞女郎，八音盒，奔跑的马儿，耍杂技的猴子，敲鼓的小丑，各种令人惊异的机械动物，皮埃特罗·克雷斯皮带来的这些玩具驱散了何塞·阿尔卡蒂奥·布恩迪亚心头悼念梅尔基亚德斯去世的悲痛，他又回到了过去那个钻研炼金术的时期。………………\n只有丽贝卡受了阿玛兰妲的威胁一直闷闷不乐。她了解妹妹的性格，了解她的高傲，因她刻毒的怨恨而担惊受怕。她连续几个小时躲在浴室里吸吮手指，竭尽全力抗拒吃土的诱惑。为了摆脱心头的忧虑，她请庇拉尔·特尔内拉为自己推算未来。说了些模棱两可的套话之后，庇拉尔·特尔内拉给出了预言：\n　“只有等你父母入士为安，你才会幸福。”\n　丽贝卡一阵颤抖。她记起好像在梦里，看见还是小女孩的自己走进家门，带着衣箱、小木头摇椅和一个口袋，而她一直不知道口袋里面装的什么。她记起一位秃顶的先生，他身着亚麻衣裳，领口别着一粒金扣，但与金杯国王毫无相似之处。她记起一位非常年轻美貌的女士，双手温和芬芳，与金元仆侍那双似乎患了风湿病的手相去甚远，那女士曾在她发间簪上鲜花，下午带她在一个绿色街巷的城镇中散步。\n　“我不明白。”她说。\n　庇拉尔·特尔内拉同样困惑。\n　“我也不明白，但牌上就是这么说的。”\n　丽贝卡被这解不开的谜团搅得忧心忡忡，便告诉了何塞·阿尔卡蒂奥·布恩迪亚。他责怪她竟然相信纸牌的预言，自己却在暗中翻遍衣柜和衣箱，挪开家具，掀起床板和地板，四处寻找那个骨殖袋。他想起自从房子扩建以后就再没见过，便偷偷找来那些泥瓦匠，其中一个承认，当时嫌那袋子碍事就把它砌在了夹壁里。他们耳朵贴在墙上四处侦听，听了好几天终于听到了低沉的咯啦咯啦声，于是凿开墙壁，发现骨殖仍完好无损地保存在袋中。当天他们便把骨殖安葬在一个没有墓碑的坟茔里，就在梅尔基亚德斯的坟墓旁。何塞·阿尔卡蒂奥·布恩迪亚回到家，心里卸下了如同对普鲁邓希奥·阿基拉尔的回忆一样的良心重负。经过厨房的时候，他吻了一下丽贝卡的额头。\n　“别胡思乱想了，”他说，“你会幸福的。”\n………………\n（蕾梅黛丝结婚了，我也会收集她的片段）\n喧闹的庆典一直持续到星期一早上，其间唯一不幸的人是丽贝卡·布恩迪亚。这本该也是她的喜事。乌尔苏拉已同意在同一天为她举行婚礼，不料皮埃特罗·克雷斯皮星期五接到的一封信带来了他母亲病危的消息。婚礼推迟了。度埃特罗·克雷斯皮接到信后一个小时即起程前往省城，在路上错过了与母亲的相遇，他母亲星期六晚上准时抵达马孔多，并在奥雷里亚诺的婚礼上献唱了本是为自己儿子婚礼准备的悲伤咏叹调。皮埃特罗·克雷斯皮为了及时赶回自己的婚礼，一路跑瘫了五匹马，但当他星期天午夜时分赶到的时候，能做的只剩下打扫喜事的残烛余烬。从未查出究竟是谁写了那封信。在乌尔苏拉的拷问下，阿玛兰妲气得哭了起来，对着木匠们尚未拆除的祭坛赌咒发誓以证明自己的无辜。\n（来主持结婚的神浦决定在这地方修一座教堂）\n从那以后，神甫担心自己的信念会动摇，就不再去探望他，全心投入教堂的建造以加快进程。丽贝卡重新燃起了希望。她的未来全系于教堂的竣工，因为有个星期天尼卡诺尔神甫来家里吃午饭时，全家人都在席间谈论教堂建成后举行的宗教仪式将是何等庄重堂皇。“最幸运的人是丽贝卡。”阿玛兰妲说。丽贝卡没有听懂她的意思，于是她带着天真的笑容解释：\n　“因为你的婚礼将是教堂落成后举行的第一个仪式。”\n　丽贝卡试图抢先作出评论。以现在的施工速度来看，教堂竣工起码要等十年。但尼卡诺尔神甫看法不同：鉴于信徒们捐赠日益慷慨，完全可以作出更乐观的估计。尽管丽贝卡暗暗生气，连饭都没有吃完，乌尔苏拉还是赞同阿玛兰妲的主意，并捐出一笔可观的款项以加速施工。尼卡诺尔神甫认为再有一笔相同数额的捐赠，教堂就能在三年内竣工。从此，丽贝卡不再和阿玛兰妲说话，确信她的用心并不像表面那样单纯无辜。“我已经手下留情了，”在当晚的激烈争吵中阿玛兰妲回答道，“这三年我都用不着杀你了。”丽贝卡接受了挑战。\n　皮埃特罗·克雷斯皮得知婚礼再次推迟，失望之极，但丽贝卡向他证明了自己的忠贞不渝。“等你准备好，咱们就私奔。”她对他说。然而皮埃特罗·克雷斯皮并不是敢于冒险的人，他不像未婚妻那样性情冲动，视对承诺的尊重为不容挥霍的资本。于是丽贝卡采取了更大胆的举措。一阵神秘的风吹灭了客厅里的灯，乌尔苏拉随即发现这对情侣在黑暗中接吻。皮埃特罗·克雷斯皮窘迫地向她解释说这要归咎于新式煤油灯的质量问题，甚至帮她在客厅里安上了更可靠的照明设施。但又一次不知是灯油出了问题还是灯芯被阻断，乌尔苏拉发现丽贝卡坐在未婚夫的腿上。她不再接受任何借口。她把面包房托付给印第安女人比西塔西翁打理，亲自坐到摇椅上监视情侣的相会，免得那些在自己的青春年代就已过时的花招得逞。“可怜的妈妈，”丽贝卡看着乌尔苏拉在一旁打着哈欠昏昏欲睡的样子，又好气又好笑，“到死也要在这把摇椅上受罪。”皮埃特罗·克雷斯皮天天去察看施工，在过了三个月受监视的爱情生活后终于厌烦了缓慢的工程进度，决定自己出钱给尼卡诺尔神甫补足完工所需的资金。阿玛兰妲并没有慌张。她每天和女友们在长廊里绣花或做编织活计，一边聊天一边酝酿新的计策。她自以为最有效的一招，即取走丽贝卡将嫁衣收入卧室衣柜之前就放好的樟脑丸，却因为估算失误落了空。她是在离教堂完工不到两个月时采取的行动，但随着婚期临近丽贝卡迫不及待地要试穿嫁衣，比阿玛兰妲预计的时间提前了许多。丽贝卡打开衣柜，依次取下包装纸和护衬布，发现从锦缎礼服、织绣纱巾直到橘花头冠都被蛾子蛀成了粉末。她确信当初在包装里放过两把樟脑丸，但这一悲剧似乎纯粹出于偶然，她不敢责怪到阿玛兰妲身上。离婚礼已不到一个月，安帕萝·摩斯科特竟慨然答允在一个星期内为她做出一身新嫁衣。那个阴雨绵绵的中午，当安帕萝抱着一堆泡沫般的织物走进家门让丽贝卡最后一次试衣时，阿玛兰妲几乎要昏厥过去。她瞬间失声，一道冷汗沿脊背下流。漫长的数月里，她一直在恐惧的战栗中等待这一刻的到来。她深信，如果最终找不到阻挠丽贝卡婚礼的办法，到了一切手段用尽的最后时刻，她不会缺乏下毒的胆量。那天下午，安帕萝以无穷无尽的耐心在丽贝卡周身上下别了千万枚别针，丽贝卡则裹在那甲胄般的缎料里热得透不过气来，与此同时，阿玛兰妲多次乱了针脚，扎了手指，但仍以可怕的冷静作出决定：日期定在婚礼前最后一个星期五，方式是在咖啡中加一剂鸦片酊。\n　不料一个更大的障碍突然出现，并且无法挽救，迫使婚礼再次无限期延迟。婚期前一个星期，小蕾梅黛丝半夜醒来，内脏打嗝般撕裂，火热的汁液爆涌浸透全身。三天后她被自己的血毒死，一对双胞胎也横死腹中。阿玛兰妲受到良心的谴责。她曾切切祈求上帝，希望发生某种可怕的事情免得自己向丽贝卡下毒，因此对蕾梅黛丝的死怀有负罪感。那并不是她日夜祈祷所期盼的障碍。\n……………………\n乌尔苏拉吩咐关闭门窗守丧，如非绝对必要不许任何人出入。她还要求一年之内不得高声说话，并将一张蕾梅黛丝的银版照片摆在停放遗体守灵的地方，照片上斜系着一根黑色饰带，前面点起一盏长明灯。此后子孙们一直保持灯火不熄，他们面对着照片上这个身着百褶裙、脚踏白色小靴子、头系蝉翼纱蝴蝶结的小女孩却不免困惑，难以将其与曾祖母的标准像联系起来。阿玛兰妲担负起照顾奥雷里亚诺·何塞的职责。她当作儿子抚养的这个孩子，将会分担她的孤独，缓解她的内疚——由于她向上帝疯狂祈求，鸦片酊误落在蕾梅黛丝的咖啡里。皮埃特罗·克雷斯皮戴着系了黑纱的帽子轻手轻脚走进家门，与一袭黑衣长袖及手、心中仿佛暗暗淌血的丽贝卡默默相会。此时此刻连重议婚期的念头也会被视为大不敬，恋人关系就此永远停滞不前，沦为无人再去理会的倦怠爱情，仿佛昔日为了亲吻而熄灭灯火的情侣已被抛弃，屈从于死神的淫威。方向迷失，希望破灭，丽贝卡又开始吃土。\n丽贝卡与何塞·阿尔卡蒂奥 （又一位与丽贝卡的重要人物出现——何塞·阿尔卡蒂奥。他在小时候跟着来卖东西的外地人走了，现在终于回来了，从以下描写中可见这人“身体很壮”，他应该是家族的第二代，第一代就是何塞元老咯）\n居丧多日后十字绣活动已经恢复，一天下午两点，酷热的死寂中突然有人推开大门。房柱震颤不已，长廊里刺绣的阿玛兰妲及其女友，卧室里吸吮手指的丽贝卡，厨房里的乌尔苏拉，作坊里的奥雷里亚诺，甚至栗树下孤零零的何塞·阿尔卡蒂奥·布恩迪亚，都感到房子在大地的震动中摇摇欲坠。来人是一个身材过人的大汉。他粗壮的胸背几乎挤不进门。他野牛似的脖子上挂着救难圣母像，双臂和胸前覆满神秘的刺青，右手腕上紧紧缠着“十字架婴孩”护符铜手链。他的身体经风吹日晒变成棕褐色，短发竖起好像骡子的鬃毛，下颌坚毅，眼神悲伤。他的腰带比马肚带宽两倍，靴子带护腿和马刺，靴跟钉了铁掌，走到哪里都给人以地震般的战栗感。他拎着几个破旧的褡裢穿过客厅和起居室，像一阵风暴般出现在秋海棠长廊，惊得阿玛兰妲和女友们一动不动，绣花针停在空中。“嗨。”他用疲倦的声音说道，随手将褡裢往缝纫桌上一丢，径直走向家中深处。“嗨。”他向丽贝卡打了个招呼，她看着他从自己卧室门前经过，吓得呆了。“嗨。”他对奥雷里亚诺说道，后者正在作坊工作台前全神贯注地干活。他没在任何人身边停留，直接走向厨房，在那里才第一次停住脚步，结束了从世界另一端起程的旅行。“嗨。”他说。乌尔苏拉瞬间愣住，看着他的眼睛，随即发出一声惊呼，扑过去搂住他的脖子，高兴得又哭又叫。他是何塞·阿尔卡蒂奥。他像离开时一样赤贫，乌尔苏拉还得给他两个比索付雇马的钱。他说的西班牙语掺杂着水手的黑话。家人问他都去了哪里，他回答：“那边。”他把吊床支在为他安排的房间里，睡了三天三夜。醒来后吃了十六个生鸡蛋，便直接去了卡塔利诺的店里，他那超常的身材在女人当中引发了好奇和恐慌。他要求奏乐并请所有人喝甘蔗酒。他打赌说能同时和五个男人掰腕子。“这不可能。”那些人确信无法撼动他的手臂后，不禁发出感慨，“他有‘十字架婴孩’。”卡塔利诺不相信这类角力花样，押上十二比索赌他挪不动柜台。何塞·阿尔卡蒂奥将柜台从原地搬起，举过头顶，又放到大街上。结果出动了十一个男人才把它搬回去。在节庆般的狂热气氛中，他在柜台上展示了自己那令人难以置信的阳物，上面红蓝两色纵横交错，覆满多种语言的刺青。那些女人饥渴地围在他身边，他问谁肯出最高价。最有钱的一个愿出二十比索。他又提议所有女人一起抽签，十比索一个签号。这是个夸张的价格，最红的姑娘一夜也不过挣八比索，然而所有女人都表示同意。她们把自己的名字写在十四张纸条上，放在一顶帽子里，然后每人抽出一张。最后抽到只剩两张了，中奖者将在其中产生。\n　“每人再出五比索，”何塞·阿尔卡蒂奥建议，“我就让你们两个分享。”\n　他以此为生。他曾与一群无国籍的水手一起周游世界六十五次。当晚与他在卡塔利诺店里同床的女人将他赤身裸体带到舞厅，让大家观赏他从前额到后背、从脖颈到脚趾，通身上下没有一丝一毫皮肤没文刺青。他没能融入家庭。他白天睡觉，晚上就去烟花巷赌赛力气。难得几次乌尔苏拉把他拉到餐桌前，他表现得迷人又可亲，特别是当他讲述异国冒险的时候。他曾经遭遇海难，在日本海漂流了两个星期，以死于日晒病的同伴尸体为食，那一次次用海水腌制，又经阳光烤熟的肉质有种甜美的味道。在孟加拉湾一个阳光灿烂的正午，他们的船杀死了一条海龙，他们还在龙腹中发现了一名十字军战士的头盔、搭扣和武器。他在加勒比海见过维克多·休斯的海盗幽灵船，船帆被死亡的阴风扯得七零八落，桅杆被海蠊蛀蚀，它再也找不到瓜德罗普岛的方向。乌尔苏拉坐在桌边哭个不停，仿佛在阅读一封封从未抵达的家书，阅读何塞·阿尔卡蒂奥讲述的英雄业绩和不幸际遇。“家里有这么多房间，我的儿子啊，”她抽泣道，“有那么多吃的都喂了猪！”但在内心深处，她无法把那个被吉卜赛人带走的男孩和这个吃午饭能吃掉半扇乳猪、放屁能令花儿枯萎的巨汉联系起来。其他家人的感觉也是如此。阿玛兰妲听到他在席间如野兽般打嗝，无法掩饰自己的厌恶。阿尔卡蒂奥从未得悉自己的身世秘密，对他刻意博取好感的问长问短，几乎不加理睬。奥雷里亚诺试图重温两人共宿一室的旧日时光，重拾少年时代的默契，但何塞·阿尔卡蒂奥都已忘却，因为海上生涯里有太多事情塞满了记忆。只有丽贝卡一见面就被他征服。那天下午看见他从自己卧室门前经过，她就觉得比起这个呼气好像火山爆发、全家都为之震颤的阳刚化身，皮埃特罗·克雷斯皮不过是个好赶时髦的文弱小子。她寻找一切借口接近他。有一次，何塞·阿尔卡蒂奥肆无忌惮地上下打量着她，对她说：“你很有女人味，小妹妹。”丽贝卡失去了自制力，又开始以往日的狂热吃泥土和墙皮，饥渴地吸吮手指，拇指上甚至都结出了茧子。她呕出混杂有死水蛭的绿色液体。她夜夜不眠，烧热得颤抖，在谵妄中挣扎，直等到凌晨时分整栋房子因何塞·阿尔卡蒂奥的归来而震颤。一天下午全家人都在午睡，她再也无法忍受，去了他的房间。她发现他穿着短裤，醒着躺在用缆绳绑在柱子上的吊床里。她盯着那花饰繁复的巨大身躯大感震惊，不禁想要退回去。“对不起，”她辩解道，“我不知道您在这儿。”她压低了声音，以免惊醒旁人。“到这儿来。”他说。丽贝卡照做了。她站在吊床前，流出冷汗，感到五脏六腑都纠结在一起，而阿尔卡蒂奥用指肚抚摸她的脚踝，然后是小腿肚，然后是大腿，嘴里喃喃地说：“小妹妹，啊，小妹妹。”一股强似龙卷风却又惊人精准的力量将她拦腰举起，三两下扯去内衣，像撕裂一只小鸟一般，她得努力支撑着才不至于死在当场。她感谢上帝让自己拥有生命，随即失去神志，沉浸在由无法承受的痛苦生出的不可思议的快感中，扑腾挣扎于吊床这热气腾腾的泥沼间，喷出的血液被泥沼像吸墨纸一般吸收了。\n　三天后，他们在五点钟的弥撒上结为夫妇。何塞·阿尔卡蒂奥前一天去了皮埃特罗·克雷斯皮的商店，看见他正在给学生上古弦琴课，但并没有把他叫到一边回避学生。“我要和丽贝卡结婚了。”他说。皮埃特罗·克雷斯皮顿时脸色煞白，把琴交给学生，宣布课程结束。等到堆满乐器和上弦玩具的厅里只剩下他们两人，皮埃特罗·克雷斯皮说：\n　“她是您的妹妹。”\n　“我无所谓。”何塞·阿尔卡蒂奥回答。\n　皮埃特罗·克雷斯皮用散发出薰衣草气味的手帕擦了擦额头。\n　“这违背天理，”他解释道，“另外，法律也不允许。”\n　何塞·阿尔卡蒂奥失去了耐性，倒不是皮埃特罗·克雷斯皮所讲的道理，而是他那副苍白的脸色更让人恼火。\n　“去他的天理，”他说，“我来是为了告诉你，不要再费心去问丽贝卡什么。”\n　但当看到皮埃特罗·克雷斯皮眼眶湿润，他粗暴的态度软了下来。\n　“好吧，”他换了一副腔调，“如果您真喜欢我们家，那还有阿玛兰妲呢。”\n　尼卡诺尔神甫在星期天的讲道中申明何塞·阿尔卡蒂奥和丽贝卡不是兄妹。乌尔苏拉视此事为不可想象的失礼，永远不肯原谅。当他们从教堂回来的时候，她禁止这对新人再迈进家门。对她来说，他们就等于死了一样。因此他们到公墓对面租了一间小屋，屋里唯一的家具是何塞·阿尔卡蒂奥的吊床。新婚之夜一只蝎子钻进拖鞋蜇了丽贝卡的脚，她的舌头为此都麻痹了，但这并不妨碍他们度过一个惊世骇俗的蜜月。邻居们因惊醒整个街区的叫声而恐慌——每夜八次，连午睡时段也有三次——祈祷那种肆无忌惮的激情不要侵扰死人的安眠。\n　奥雷里亚诺是唯一关心他们的人。他给他们买了一些家具，并送钱过去，直到何塞·阿尔卡蒂奥恢复常态，开始耕种与家中院子相邻的无主土地。阿玛兰妲却永远无法摆脱对丽贝卡的怨恨，尽管生活为她带来了超出梦想的满足：乌尔苏拉不知如何洗刷耻辱，她主动提出让皮埃特罗·克雷斯皮每个星期二仍来家中共进午餐，后者平和而不失尊严地战胜了挫折。出于对这一家人的尊敬，他在帽子上仍然系着黑纱，并很乐意亲近乌尔苏拉，为她带来异国礼物：葡萄牙沙丁鱼，土耳其玫瑰果酱，还有一次是一条精美的马尼拉大披巾。\n……………………\n（经历了一些时间）\n亲戚中只有何塞·阿尔卡蒂奥和丽贝卡知情，那时候他们与阿尔卡蒂奥的亲密关系与其说是出于亲情，倒不如说是源于同谋间的戚戚。何塞·阿尔卡蒂奥已然低头负起婚姻的重轭。丽贝卡凭着不屈的性格、贪婪的情欲和执著的野心，吸纳了丈夫超常的精力，使他从一个游手好闲、寻花问柳的男人变成一头干活的巨大牲口。他们的家清洁整齐。每天清晨丽贝卡都打开门窗，墓地的风从窗子进自院门出，裹挟着尸骨析出的硝石，在家中的墙壁和家具上都覆了一层泛白的粉末。想吃泥土的饥渴，父母骨殖的咯啦咯啦响声，皮埃特罗·克雷斯皮的优柔寡断激起的厌烦心绪，这些都被抛在了记忆的角落。她不受战乱的影响，从早到晚都在窗边刺绣，等到陶瓷的锅碗瓢盆开始在碗橱里颤抖就起身热饭。过了很久才会出现那几只邋遢的猎犬，然后是脚踏带马刺的高筒靴，肩挎双铳猎枪的巨人，他有时会带回一头鹿，更多的时候是一串兔子或野鸭。\n……………………\n丽贝卡回到孤独 （革命早就开始了，所以才上校逃走）\n　并非所有的消息都是好的，奥雷里亚诺·布恩迪亚上校逃走一年后，何塞·阿尔卡蒂奥和丽贝卡搬进了阿尔卡蒂奥建起的房子。没人知道他阻止行刑的事。新家坐落在广场最好的一角，掩映在一棵巴旦杏树的浓荫里，树上足有三个知更鸟的鸟巢。一扇大门迎送访客，四扇明窗承接阳光，他们就在这房子里安下热情好客的新家。丽贝卡旧日的女伴，包括摩斯科特家四个尚未出嫁的女儿，重新聚在一起刺绣，就像数年前在秋海棠长廊里一样。何塞·阿尔卡蒂奥继续享受掠夺来的土地收益，他的所有权已得到保守党政府的承认。每天下午都可以看见他骑马归来，扛着双铳猎枪，带着猎狗，一串兔子挂在马鞍上。九月的一天下午，眼看暴风雨迫近，他比平时提前回了家。他到饭厅和丽贝卡打过招呼，把狗拴在院中，又将兔子挂在厨房准备晚些时候腌起来，随后去卧室换衣服。丽贝卡事后声称丈夫进卧室时自己正在浴室，丝毫没有察觉。这一说法难以令人信服，但又没有更可信的其他说法，另外谁也想不出丽贝卡会有什么动机谋杀令她幸福的男人。这也许是马孔多唯一从未解开的谜团。何塞·阿尔卡蒂奥刚关上卧室的门，一声枪响震彻全屋。一道血线从门下涌出，穿过客厅，流到街上，沿着起伏不平的便道径直向前，经台阶下行，爬上路栏，绕过土耳其人大街，右拐又左拐，九十度转向直奔布恩迪亚家，从紧闭的大门下面潜入，紧贴墙边穿过客厅以免弄脏地毯，经过另一个房间，划出一道大弧线绕开餐桌，沿秋海棠长廊继续前行，无声无息地从正给奥雷里亚诺·何塞上算术课的阿玛兰妲的椅子下经过而没被察觉，钻进谷仓，最后出现在厨房，乌尔苏拉在那里正准备打上三十六个鸡蛋做面包。\n　“圣母在上！”乌尔苏拉喊了起来。\n　她沿着血流溯源而上，穿过谷仓，经过秋海棠长廊——奥雷里亚诺·何塞正在那里念诵三加三等于六、六加三等于九——又穿过饭厅和一个个房间，径直走到街上，先右拐再左拐到了土耳其人大街，忘了自己还穿着烤面包的围裙和家居拖鞋，来到广场，走进一户从未登过门的人家，推开卧室的门，险些被火药燃烧的气味呛死，发现何塞·阿尔卡蒂奥仰面躺在地上，身下压着刚脱下来的靴子，这就看到了血流的源头，而血已不再从他右耳流出。没发现他身上有任何伤口，也没找到凶器何在。另外也无法除去尸体上呛人的火药味。最初用丝瓜瓤蘸肥皂洗过三遍，然后先用盐和醋、后用草木灰和柠檬汁擦拭，最后浸到一桶碱水里泡了六个小时。经过反复揉搓擦洗，他身上的刺青花纹开始退色。他们不得已想出一个极端的方案，加入辣椒、莳萝和月桂叶用小火煮上一整天，但尸体已经开始腐烂，不得不即刻下葬。他们用一口长两米三、宽一米一，内部以铁板与钢栓加固的特制棺材将他装起来秘密下葬，但仍然在一路经过的街道上留下了气味。尼卡诺尔神甫的肝部肿胀紧绷如鼓，他只能在床上为死者祈福。此后数月，虽然为坟墓砌起层层护板，在其间撒上压实的灰土、锯末和生石灰，墓园依然飘荡着火药味，直到多年以后香蕉公司的工程师在墓上添了一层水泥，那气味才消失。从尸体被抬出的那一刻起，丽贝卡就紧闭家门，过上了活死人的生活。她将自己包覆在高傲的厚壳里，尘世间的一切诱惑都无法将其打破。她出过一次家门，那时她已进入晚年，脚下一双古银色鞋子，头上一顶缀有小花的女帽。那时正值传言中“流浪的犹太人”经过村庄带来酷暑，飞鸟都热得撞破纱窗死在卧室里。最后一次有人看到她的时候，她一枪命中，当场击毙一个企图撬门入室的小偷。除了阿尔赫尼妲，她的女仆和心腹，再也没人与她有过联系。人们一度听说她给被她视作表兄的主教写过信，但从未听说她收到过回音。她已被镇上的人遗忘。\n（丽贝卡开始封闭，另外火药味的描述很有趣）\n…………\n（上校打回来了）\n最后出于礼貌，他搁下手头的事务，抽出一个小时去见丽贝卡通知他的决定。\n　在屋内的阴影中，那位曾经见证他被压抑的爱情，并以自己的执拗救过他性命的孤零孀妇已变成往昔的幽灵。她遍体着黑直到指节，心如死灰，对战事几乎一无所知。奥雷里亚诺·布恩迪亚上校感觉她骨头的磷光从皮肤透出，感觉她在重重鬼火间行走，而凝滞的空气中还能隐隐闻到火药的味道。他开始劝说她节哀除丧，改善屋内通风，不要再为何塞·阿尔卡蒂奥的死迁怒整个世间。然而丽贝卡已经看破一切浮华。她曾经在泥土的味道中，在皮埃特罗·克雷斯皮芬芳的书信里，在丈夫如狂风暴雨的床榻上徒劳地寻寻觅觅，最终却在这个家中找到了安宁。在这里，记忆因思绪无情的力量化为实体，如同活人一般在幽闭的房间里游荡。她躺在藤摇椅里，望着奥雷里亚诺·布恩迪亚上校，仿佛他才是一个往昔的幽灵。甚至听到何塞·阿尔卡蒂奥强夺的土地都将归还原主，她也不显丝毫激动。\n　“你想怎样就怎样吧，奥雷里亚诺。”她叹息道，“我一直认为，你是个无情的人，现在更确定了。”\n……………………\n（这里的上校已经是绕了一大圈又回来的时候了）\n数月过去，奥雷里亚诺·特里斯特已为人们所熟识和喜爱，开始四处寻找房屋准备把自己的母亲和妹妹——不是上校的女儿——接来。他看上了广场一角那座似已废弃的破败宅子，便打听主人是谁。有人告诉他那房子没有主人，过去曾经住过一位以泥土和墙皮为食的孤单寡妇，她晚年时别人在街上只见过她两次。她头戴缀有细小假花的女帽，脚穿古银色的鞋子，穿过广场到邮局寄信给主教。他们说陪伴她的只有一个残忍的女仆，那女人杀死猫狗及其他一切闯入家中的动物，并把尸体抛到街上，让市镇上的人都闻得到腐烂的恶臭味。自从最后一只动物的尸体在阳光下晒干后，又过了很久，所有人都确信那女主人和她的女仆早在战争结束前就已去世，房子迄今未倒不过是因为近年来没赶上严酷的冬季，也没遇上能使房倒屋塌的暴风。铰链因锈蚀而断裂，门板靠成团的蛛网勉强支撑，窗框受潮卡死，地面长满杂草野花，其间裂缝成为蜥蜴和各种爬虫的巢穴，一切似乎都证明这里至少有半个世纪没人居住过。对冲动的奥雷里亚诺·特里斯特而言，并不需要见到这些迹象才会采取行动。他用肩膀撞了下大门，蛀蚀的木板便寂然倒塌，灰尘四溢，白蚁巢碎屑飞扬。奥雷里亚诺·特里斯特伫立在门口不动，等到尘雾落定，立时看见了客厅中央那位瘦骨嶙峋的女人。她穿着上个世纪的衣服，光秃的头顶上稀疏几根黄发，一双大眼睛仍残存着昔日的美丽，只是最后的希望之光已在其间熄灭，脸上的皮肤因孤寂而干裂。奥雷里亚诺·特里斯特被眼前非人间所有的景象震慑，险些没有察觉到那女人正用一把老旧的军用手枪指着他。\n　“抱歉。”他含糊地低声道。\n　她在堆满破烂的客厅中央一动不动，一点点仔细打量这肩宽背厚、额头有灰烬刺青的大汉。她透过尘雾看到他站在往昔的薄雾中，背上斜挎着双铳猎枪，手里拎着一串兔子。\n　“慈悲的上帝啊，”她低声惊叹道，“这不公平，现在又让我想起这些！”\n　“我想租房。”奥雷里亚诺·特里斯特说。\n　那女人举起手枪，稳稳瞄准他额间的灰烬十字，毅然决然地扣紧扳机。\n　“请出去。”她下令道。\n　当天晚上吃饭时，奥雷里亚诺·特里斯特向家人讲起自己的遭遇，乌尔苏拉难过地哭了起来。“神圣的上帝啊，”她双手抱头喊道，“她还活着！”时光流逝，战事频仍，加上平日里无数的不幸，她都把丽贝卡给忘了。自始至终清楚地知道她还活着并在蛆虫窝里腐烂的人，只有日渐衰老却毫不心软的阿玛兰妲。当天亮时心中的寒意将她从孤枕上唤醒，她会想起她；当她用肥皂擦洗自己凋零的乳房和枯萎的腹部，当她穿上老年人雪白的细棉布裙和胸衣，当她更换手上缠裹赎罪伤痕的黑纱，都会想起她。无论何时，或睡或醒，从最庄重到最卑下的时刻，她都会想起丽贝卡，因为孤独已经为她筛选记忆，将生活在她心中累积的无数垃圾尽行焚毁，并净化、升华了其他记忆，即那些最苦涩的记忆，使其永远存留。从她那里美人儿蕾梅黛丝知道了丽贝卡的存在。每当她们路过那幢破败的房子，她都会讲起丽贝卡一桩负心的事件，一个出丑的故事，想借此让侄女分享自己日渐衰竭的怨尤，并使积怨在她死后延续。但她没能成功，因为蕾梅黛丝对一切激烈的情感都具有免疫力，遑论他人恩怨。乌尔苏拉经历了与阿玛兰妲截然相反的过程，她记忆中的丽贝卡已经被净化，那个和父母的骨殖袋一起被送来的小女孩令人怜惜的形象已经掩盖了大逆不道脱离家庭的那段过往。奥雷里亚诺第二决定接她回家好生照料，但他的好意遭到丽贝卡的断然拒绝。她辛苦多年忍受折磨好不容易赢得的孤独特权，绝不肯用来换取一个被虚假迷人的怜悯打扰的晚年。\n　二月里，奥雷里亚诺·布恩迪亚上校的十六个儿子归来时额上仍带着灰烬十字的印记。奥雷里亚诺·特里斯特在欢闹中提起丽贝卡，于是他们在半天内就修复了房子外观：更换门窗，给立面漆上欢快的颜色，加固墙壁，重铺水泥地面。但他们没能得到许可进行室内装修。丽贝卡甚至没在门口露面。她任凭他们七手八脚完成了工程，随后估算了花销，让一直陪伴自己的老女仆阿尔赫尼妲送去一把在最后一场战事结束后就不再流通，而她以为还通用的硬币。这时人们才明白她与世隔绝到了何种程度，也知道只要她一息尚存，便不可能将她从顽固的自闭中解救出来。\n丽贝卡的结局 （死于乌乌尔苏拉死的那年底）\n丽贝卡死于那年年底。毕生服侍她的女仆阿尔赫尼妲请求当局强行打开卧室的房门，她的主人已经在里面关了三天。人们看到她躺在孤寂的床榻上，像虾米般缩成一团，头发因生癣而落尽，大拇指含在嘴里。奥雷里亚诺第二负责料理了丧事，并打算把房子修葺好卖掉。然而那房子已破败得无可挽救，墙皮刚抹好即纷纷脱落，刷上再厚的灰浆也无济于事，只能眼看着杂草穿透地面、蔓藤侵蚀椽柱。\n我的感觉 自己对丽贝卡印象深刻的很大一部分原因是丽贝卡吃土吧。通过吃土来逃避内心的情感，想想就感觉很刺激人，吃土的味道…………ennnnn。另外还有就是最后她回到一人的生活也挺让我印象深刻，前半生激情了那么久，依靠吃土回避感情，最终却通过这样的方式找到了内心的平静，谁杀死了何塞？原因只可能是自己自杀或者被丽贝卡杀了，我认为应该是丽贝卡杀的，和阿玛兰旭一样相似的人啊~注孤独~然后何塞死后强烈的火药是不是代表丽贝卡的什么东西呢？理解不了。\n","date":"2021-06-13","permalink":"/posts/literature/rebeca/","series":[],"tags":[""],"title":"丽贝卡的一生"},{"categories":["普通类"],"content":"阅读本篇对考试没有什么帮助，感兴趣就随便看看，看之后反而可能会学不懂概率，因为用的符号有些不一样~\nPreface 这学期排课有概率论与数理统计，其实每次学这些课程的时候都会想一些乱七八糟的东西，而且基本上和正常考试内容不沾边，属于浪费时间游玩的部分。\n注意，如果数学公式没有渲染出来需要刷新一下。推荐使用大屏幕观看，左边有目录。另外有的公式太长了，手机也放不下。补：刚刚我换了$\\KaTeX$渲染，这下应该没问题了，网站加载速度也应该变快了。编辑公式时出了一些问题，千万不能用换行符！\n更新日志  2021-05-18 01:30:20创建，2021-05-25 15:37:44发布，不想写了，以后有时间再写。兴趣文如果当成了作业性质就变化了不是吗，所以还是有兴趣时再写吧。 2021-06-05 22:27:38:要期末了，更没时间了！而且写这个根本复习不了概率！懒癌发作死ね！要不要烂尾了呢？ 2021-06-10 17:41:16：还是不写了，因为我懒了，还有就是第一章+一点点第二章字数都已经超过6000字了，写下去会没完没了，还有个重要原因是写这个根本对复习没有什么帮助！  一、概率结构 概率映射是这样的映射：\n$$ A\\ \\overset{P}{\\rightarrow} P(A) $$\n$A$为任意事件，$P(A)$为事件$A$的概率。其中集合A在概率论中又分为单个随机试验形成的样本空间与多个随机试验形成的样本空间，这和之后的独立性相关。我们在讨论独立性之前假设$S$为单个随机试验形成的样本空间。\n于是，要讨论一般的概率结构，就需要讨论集合运算$A$，概率运算$P(A)$，概率映射$P$。\n1.一点代数风味的集合运算 I 统一符号 教材中的出现的集合运算有$\\bigcup$，$ \\bigcap$，$—$，$\\overline{A}$ ，$AB$。为了统一和更有代数的感觉，本篇统一将 ”$\\bigcup$“ 写作 ”$+$“ ，将”$ \\bigcap$“写作”$\\ \\cdot\\ $ “，并且通过这两个基本运算规定其他运算。\n先来看看“$+$”运算：\n$$ \\begin{aligned} \u0026amp;A+B = B+A \\\\ \u0026amp;A+(B+C) = (A+B)+C \\\\ \u0026amp;A+B=A+C \\rightarrow B\\cdot\\overline{A} = C\\cdot \\overline{A} \\\\ \\\\ \u0026amp;for\\ any\\ A\\subset S,A+\\varnothing = A \\\\ \u0026amp;if\\ A+B = \\varnothing \\ ,\\ then\\ A = B=\\varnothing \\\\ \\\\ \u0026amp;A+\\overline{A} = S \\\\ \u0026amp;if\\ A+B =S\\ ,\\ then\\subset B\\subset S \\\\ \\end{aligned} $$\n我们可以看出，$+$运算具有交换律，结合律，有类似消去律的性质，以$\\varnothing$作为单位元，且没有逆元，如果以$S$作为单位元，没有唯一的逆元，但有个比较特殊的逆元。\n再来看看”$\\ \\cdot\\ $“运算：\n$$ \\begin{aligned} \u0026amp;A \\cdot B = B \\cdot A\\\\ \u0026amp;A \\cdot (B \\cdot C) = (A \\cdot B) \\cdot C\\\\ \u0026amp;A \\cdot B = A \\cdot C \\rightarrow A \\cdot \\overline{B} = A \\cdot \\overline{C}\\\\ \\\\ \u0026amp;for\\ any\\ A\\subset S\\ ,\\ A \\cdot S = A\\\\ \u0026amp;if\\ A\\cdot B = S\\ ,\\ A=B=S\\\\ \\\\ \u0026amp;A\\cdot\\overline{A} =\\varnothing \\\\ \u0026amp;if\\ A\\cdot B =\\varnothing\\ ,\\ then\\varnothing\\subset B\\subset \\overline{A}\\\\ \\end{aligned} $$\n可以看出，”$\\ \\cdot\\ $“运算具有交换律，结合律，类似的类似的消去律，以$S$作为单位元，没有逆元。如果以$\\varnothing$作为单位元，没有唯一逆元，但有个比较特殊的逆元。\n在集合中大小的关系就是子集的关系。对于任意两个集合，他们之间不一定是子集关系。\n II 定义逆事件，转化差事件 从上面可以看出这两种集合运算都满足一些性质，但又不完全满足我们熟悉的代数特征，并且他们两者互相有交叉。接下来我们先把$-$与$\\overline{A}$表达为这两种基本运算的形式，并看看这两种基本运算之间的反应。\n首先，对于逆事件$\\overline{A}$，我们有定义：对一给定$A$，总存在$B$，有$A+B=S$，且$A\\cdot B=\\varnothing$，我们将这个$B$记作$\\overline{A}$，称为$A$的逆事件。对于一个事件的逆事件，是通过这两种基本运算定义的，想要证明一个事件是逆事件，只需要按照上述定义证明即可。\n其次，对于减法\u0026quot;$-$\u0026ldquo;运算，我们将其表示为基础运算的形式：$A-B=A\\cdot \\overline{B}=A \\cdot \\overline{AB} = A- AB$。证明留到后面介绍了基本定理之后。其实将减法转化为交运算在做题中并不常用，更多是利用公式转化为无关联的并运算。\n III 基础定律和一些证明 下面是两个基础集合运算以及由此定义的补集他们之间的运算关系，在集合化简中起着非常基础的作用。特别说明，我这里取的$+$与$\\cdot$具有误导性，实际上这两种运算他们之间是平等的，没有优先级的高低，所以要注意括号。\n$$ \\begin{aligned} \u0026amp;A+(B\\cdot C) = (A+B)\\cdot (A+C) \\\\ \u0026amp;A\\cdot (B + C) = (A\\cdot B) + (A\\cdot C) \\\\ \u0026amp;\\overline{A+B} = \\overline{A}\\cdot \\overline{B} \\\\ \u0026amp;\\overline{A\\cdot B} = \\overline{A} + \\overline{B} \\\\ \\end{aligned} $$\n这些运算定律都可以拓展到$N$元情况，他们的形式不变。前两个的证明利用$A\\subset B$，$B\\subset A$，$A=B$即可。后面两个不常见的，我利用逆事件的定义证明一下第3条，第4同理。\n证明第3条：由\n$$ \\begin{aligned} (A+B)\\cdot (\\overline{A}\\cdot \\overline{B})\u0026amp;=(A\\cdot\\overline{A}\\cdot\\overline{B}) + (B\\cdot \\overline{A}\\cdot\\overline{B}) \\\\ \u0026amp;= \\varnothing + \\varnothing = \\varnothing \\\\ (A+B)+(\\overline{A}\\cdot\\overline{B}) \u0026amp;= (A+B+\\overline{A})\\cdot(A+B+\\overline{B}) \\\\ \u0026amp;= S \\cdot S=S\\\\ \\end{aligned} $$\n可知，$\\overline{A}\\cdot \\overline{B}$满足$A+B$逆的定义，得证。\n由于概率的计算核心是围绕概率定义中的可列可加性，需要将复杂的事件分开为互异的事件，也就是$A\\cdot B=\\varnothing$，所以我们也补上两个很重要的相关式子： $$ \\begin{aligned} \u0026amp;if\\ X\\cdot Y=\\varnothing\\ ,\\ XBCD \\cdot YEFG = \\varnothing \\\\ \u0026amp;A = A\\cdot S = A\\cdot (B+\\overline{B}) = (A\\cdot B) + (A\\cdot \\overline{B}) \\\\ \\end{aligned} $$\n第一个式子表明，两个事件中只要包含了一对互斥事件（一般情况为两事件为对立事件），这两个事件一定互斥。第二个式子用于将一个事件拆分了两个互斥事件。\n现在我们利用上面的基本定律证明一些特别的式子。\n①$A-B=A\\cdot \\overline{B}=A \\cdot \\overline{AB} = A- AB$\n证明：\n$$ \\begin{aligned} A-B\u0026amp;=A\\cdot \\overline{B}\\\\ \u0026amp;= (A\\cdot \\overline{B})+ \\varnothing\\\\ \u0026amp;=(A\\cdot \\overline{B})+ (A\\cdot\\overline{A})\\\\ \u0026amp;=A\\cdot (\\overline{A}+\\overline{B})\\\\ \u0026amp;=A\\cdot \\overline{AB} = A -AB \\\\ \\end{aligned} $$\n②$A+B = A+\\overline{A}B = B + \\overline{B}A = \\overline{A}B + AB + A\\overline{B}$\n证明：\n$$ \\begin{aligned} A + B \u0026amp;=(A+B)\\cdot S\\\\ \u0026amp;= (A + B) \\cdot (A+\\overline{A}) \\\\ \u0026amp;= A+ (\\overline{A}\\cdot B)\\\\ \u0026amp;=A +\\overline{A}B\\ (=A+(B-A)) \\\\ \\\\ A+B \u0026amp;=(A+B)\\cdot S\\\\ \u0026amp;=(A+B)\\cdot (B+\\overline{B})\\\\ \u0026amp;=B+(A\\cdot \\overline{B})\\\\ \u0026amp;=B+A\\overline{B}\\ (=B+(A-B)) \\\\ \\end{aligned} $$ 对于第三个，只需要前两个中任意一个后面补充$\\cdot (A+\\overline{A})$或者$\\cdot (B+\\overline{B})$即可证明。\n2.概率运算 概率$P(A)$实际上是一个范围为$\\left [0,1 \\right ]$的实数（也许更大？超出我的知识范围外了），所以概率的代数性质一部分继承与实数域性质但又有很大的不同，这里只写一部分比较特殊的：\n$$ \\begin{aligned} \u0026amp;for\\ any\\ P(A)\\ ,\\ P(A)+0 = P(A) \\\\ \u0026amp;if\\ P(A) + P(B) = 0\\ ,\\ P(A)=P(B)=0\\\\ \\\\ \u0026amp;for\\ any\\ P(A)\\ ,\\ P(A)\\cdot 1 = P(A) \\\\ \u0026amp;if\\ P(A)\\cdot P(B)=1\\ ,\\ P(A)=P(B)=1 \\\\ \\end{aligned} $$\n虽然概率的加运算与乘运算都没有逆元，但是概率中却有减法与除法。同时，概率的加法与乘法在很多情况下是没有意义的，当两个事件互异时，加法表示两个事件和的概率，不互异时则没有意义；乘法则要求更多，普通情况没有任何意义，只是两个实数相乘，当两个事件独立时，概率相乘表示两事件同时发生的概率。同样的对于减法与除法。\n所以，由于概率定义的限制，我们经常用各种无意义的或是大于1的，或是负数的量对概率化简，转化求解有意义的概率量。为什么会这样呢？关键是条件概率。虽然条件概率的定义中出现了普通概率，条件概率$P(\\cdot\\ |A)$和普通概率$P(\\cdot \\ )$的地位是同等的。我们需要将条件概率的$\\frac{P(AB)}{P(A)}$看作是一个整体，它和普通概率互不干涉，条件概率中事件$A$是固定的，所以它和普通概率都满足概率的定义。所以在普通概率中，是没有乘法和除法的，凡是出现了乘法除法，一定和条件概率相关，那么事件本身的范围就不局限于单个随机试验了（除了特殊情况如$\\varnothing$,$S$），比如相互独立。\n所以现在我们来看看条件概率$P(\\cdot\\ |A)$，没什么好写，都一样，因为都满足的是概率的定义，所以推导出来的都一样。\n那么乘法呢？不是将条件概率看作整体吗？如何得来？其实同样的问题减法也是如此。这个问题我想和外面平常生活中可以用减法一样，生活中大部分时间负数是无意义的，但是同样可以使用减法，是因为整个系统建立在整数域的基础上，只是有范围限制。\n3.概率映射 概率映射$P$是概率中的关键，在教材中，通过概率的定义可列可加性，化简出互异的事件来将概率化简，这里我们将采用教材中对概率的定义化简，后面一节将尝试通过重定义概率，使得化简过程不一样点。\n首先先写一下比较特殊的映射： $$ \\begin{aligned} \u0026amp;P(A+B)=P(A)+P(B) 当A,B互异 \\\\ \u0026amp;P(AB) =P(A)P(B) 当A,B独立\\\\ \\end{aligned} $$ 这两个映射遵从了这样的原则：$\\varphi (ab) = \\varphi (a)\\varphi (b)$。\n上面这两个式子在概率化简中占核心地位，我们化简其实就是围绕这两个公式，将事件转化为互异事件，当然独立事件只有题目声明或可以判断才能肯定（互异不一定独立，独立一定互异）。\n教材中通过概率的可列可加性推导出了全部概率公式。这里我们推导一些公式，并且观察观察。\n①$P(A-B)=P(A)-P(AB)=P(A-AB)$\n$$ \\begin{aligned} P(A)\u0026amp;=P(A\\cdot S)\\\\ \u0026amp;=P(A\\cdot(B+\\overline{B}))\\\\ \u0026amp;=P((A\\cdot B)+(A\\cdot\\overline{B}))\\\\ \u0026amp;=P(AB)+P(A-B)\\\\ \\end{aligned} $$ 所有的减法都不能直接推导，只能转化为加推导，负概率是没有意义的。那为什么还有负概率呢？你开心就好。这里减法也是很神奇，也许我们可以建立一支减法军团？后面试试\n②$P(A+B)=P(A)+P(B)-P(AB)$\n$$ \\begin{aligned} P(A+B) \u0026amp;=P(A+\\overline{A}B) = P(A)+P(\\overline{A}B)\\\\ \u0026amp;=P(A)+P(A-B)\\\\ \u0026amp;=P(A)+P(B)-P(AB)\\\\ \\end{aligned} $$\n同样的有减法，通过之前的式子替换。\n③$P(\\overline{A})=1-P(A)$\n这条就不证明了\n上面这三个式子是关于普通概率的式子了，下面我们开始证明条件概率的式子。条件概率中的定义式，乘法定理，全概率公式，贝叶斯公式这里不再重复写出了，我们主要看看“独立性”关系。独立性正如之前所说的，两个事件前提就是不能扯上关系，也就是不能同在一个样本空间上，我们来证明一下：\n①如果两不为空的事件$A$，$B$在一个样本空间上，他们一定不独立\n证明：如果$A$和$B$在一个样本空间上，他们一定有下列关系之一： $$ \\begin{aligned} \u0026amp;A\\cdot B = \\varnothing \\\\ \u0026amp;A\\cdot B \\neq \\varnothing\\\\ \\end{aligned} $$ 对于第一种情况，有$P(AB)=0\\neq P(A)P(B)$。对于第二种情况，有$P(AB)=P(A)+P(B)-P(A+B)=$（发现在某种特殊情况下成立）\n条件概率还有其他性质：\n②$P(B|A)+P(\\overline{B}|A) = 1$\n③如果$A$,$B$相互独立，那么$\\overline{A}$与$B$，$A$与$\\overline{B}$，$\\overline{A}$与$\\overline{B}$相互独立\n④对一组相互独立的事件作运算，所得的新事件仍然独立。\n⑤当$A$,$B$独立时，有$P(B|\\overline{A})=P(B|A)$\n我们可以由这条推出当$A,B$独立时，$P(B|A)+P(\\overline{B}|\\overline{A})=1$\n其实②③⑤都可以通过条件概率定义推出，我比较感兴趣③，下面我来证明一下③：\n证明：首先需要清楚条件，对于$A_i,i=1,2,\\dots$，有$P(\\sum_m^n A_k) = \\sum_{m}^{n}P(A_k)$，$m\u0026lt;n,m,n\\in Z^+$（这里渲染有问题，目前没有解决），所以我们只需要将基础运算组合独立证明然后再说明他们组合后即可完成证明\n4.自己重新定义概率 教材中概率的定义是这样的，只需要满足这三条即可称为概率：\n $1^{o}$非负性：对于每一事件$A$，有$P(A) \u0026gt; 0$.\n$2^{o}$规范性：对于必然事件$S$，有$P(S)=1$.\n$3^{o}$可列可加性：设$A_1$,$A_2$,$A_3$,$\\dots$是两两不相容的事件，即对于$A_{i}A_{j}=\\varnothing$,$i\\neq j$,$i$,$j=1,2,\\dots,$有$P(A_1+A_2+\\dots)=P(A_1)+P(A_2)+\\dots$\n 最重要的是第三条，教材和做题中核心思想就是将事件分解为不相容的事件，之后通过这一公式化简概率。这个条件看起来非常合理，也很容易理解，可以说是一个人们默认的东西，但是之前我们列过，集合有两种基本运算，交和并，这里只用了交定义概率，并作控制，这是不是对并有点太不公平了呢？明明我们两地位相同不是吗？气抖冷！！！（只是玩笑）下面我就来尝试利用并来定义概率，主要还是受到了普通概率公式①的启发，当然只是重新定义第三条，前两条在概率中都是根基性的，怎么改？改不了。\n I 重新定义 首先对集合减法说明一下，之前减法是二元的：$A-B=A\\cdot \\overline{B}$。现在我们需要把减法扩充到$N$元。公式： $$ \\begin{aligned} A-B_1-B_2-\\dots = A\\cdot\\overline{B_1}\\cdot\\overline{B_2}\\cdot\\dots \\end{aligned} $$\n减法很符合我们的预期，就和加法一样，其实教材中的可列可加性就是将互不相关的“块”加起来，通过Venn图想象就知道了，所以我的思路即是做减法，将互不相关的块减去即可，这个过程其实就是举一反一罢了。\n概率条件$3^{o}$：$P(A-B_1-B_2-\\dots) = P(A)-P(AB_1)-P(AB_2)-\\dots$，对于$i$,$j=1,2,\\dots$有$B_{i}B_{j}=\\varnothing$\n这个式子很符合常识，和可列可加性一样的符合常识。我们可以利用普通概率公式①将减法同交运算联系起来，下面我们证明我们定义的第三条概率和可列可加性是一回事：\n证明：可列可加性是“可列可减性”的充分必要条件\n充分性：假设可列可加性成立，利用普通概率公式①，将$B$替换为两两互斥的$B_1+B_2+\\dots$，有： $$ \\begin{aligned} P(A-(B_1+B_2+\\dots))\u0026amp;=P(A)-P(A(B_1+B_2+\\dots))\\\\ \u0026amp;=P(A)-P(AB_1)-P(AB_2)-\\dots\\\\ \\end{aligned} $$\n必要性：假设可列可减性成立，将减法项移项得： $$ \\begin{aligned} P(A-B_1-B_2-\\dots)+P(AB_1)+P(AB_2)+\\dots = P(A) \\end{aligned} $$ 我们知道$B_i$之间是互斥的，而由于$A-B_1-B_2-\\dots$中对任意$B_i$交运算的$B_i$，由之前集合运算的知识，我们知道左边事件两两互斥，现在令$A-B_1-B_2-\\dots=C$，即得： $$ \\begin{aligned} P(C+B_1+B_2+\\dots)=P(C)+P(B_1)+P(B_2)+\\dots，事件两两互斥 \\end{aligned} $$\n这样我们完成了，他们两是一个东西。而普通概率和条件概率都满足这个条件。\n那么接下来模仿教材通过“可列可减性”推导概率映射的基本性质。\n II 推导性质 ①$P(\\varnothing)=0$ 证明：令$A,B_1,B_2,\\dots-\\varnothing$，有$P(\\varnothing)=P(\\varnothing)-P(\\varnothing)-\\dots $，化简即得$P(\\varnothing)=0$\n②有限可减性\n③设$A,B$是两个事件，若$A\\subset B$，则有$P(B-A)=P(B)-P(A),P(B)\\geqslant P(A)$\n④对于任一事件$A$，$P(A)\\leqslant 1$\n⑤对于任一事件$A$，有$P(\\overline{A})=1-P(A)$\n证明：令$A=S$，$B_1=A$，$B_i=\\varnothing, i\\neq 1$，则有：$P(S-A)=P(\\overline{A})=P(S)-P(SA)=1-P(A)$\n⑥对于任一两事件$A,B$，有$P(A+B)=P(A)+P(B)-P(AB)$\n证明：令$A=A+B$,$B_1=B$,$B_i=\\varnothing$,$i\\neq 1$，得到： $$ \\begin{aligned} P((A+B)-B)=P(A+B)-P(B) \\end{aligned} $$ 由$(A+B)-B=(A+B)\\overline{B}=A\\overline{B}=A-B$，得： $$ \\begin{aligned} P(A-B)=P(A)-P(AB)=P(A+B)-P(B) \\end{aligned} $$ 移项，证毕。\n III 尝试做题 我们利用减法的思想能不能像加法一样做题呢？这里我拿了一题作尝试，是可行的。其实为了用减法，只需要将所有的并运算通过这个式子转化为减法即可：$P(A-B)+P(B)=P(A+B)$。具体我不想写了……写这个东西消耗的时间比我想象中的要长，我还是想快点结束。\n二、随机变量和分布函数 1.随机变量 为了明确一下随机变量的定义，首先我将教材中的几个定义拿出来：\n 随机试验：满足①相同条件可以重复进行②事先明确试验的所有可能结果③试验前不能确定哪一个结果出现。\n样本空间：随记实验$E$的所有可能结果组成的集合成为E的样本空间，记为$S$。\n样本点：样本空间的元素，即E的每个结果，称为样本点。\n$e$代表样本空间的元素，而将样本空间记成$\\left \\{ e \\right \\}$\n随机变量：设随机试验的样本空间为$S=\\left \\{e\\right \\}$，$X=X(e)$是定义在样本空间S上的实值单值函数，称$X=X(e)$为随机变量\n二维随机变量：设$E$是一个随机试验，它的样本空间是$S=\\left \\{e\\right \\}$，设$X=X(e)$和$Y=Y(e)$是定义在$S$上的随机变量，由它们构成的一个向量$\\left (X,Y \\right )$，叫做二维随机变量。\n 看起来蛮融洽的，但是有一个地方让我很困惑。首先，随机试验一定有结果，有动作，但是解读方式可以不同。所以，$S$中的所有元素都是有的结果，而不能是一个对象，比如$S$中的元素不能是3枚硬币，不能是一群人这种对象，而应该更具体些。所以我觉得教材关于二维随机变量的叙述有点问题，教材中在二维随机变量中举了一例（p61）：\n 样本空间：$S=\\left \\{e \\right \\} = \\left \\{ 某地区的全部学龄前儿童\\right \\}$\n 是有问题的。\n并且明确一下，普通的事件，就是对单一试验样本空间的单一解读，这个解读呢可以有一定关系，比如几次硬币朝正，也可以没有现实意义上的关系，我就想把这几个东西拉到一起形成一个事件，命名为我的事件也没问题，随机变量就是对样本空间元素的单一解读的数据抽象，数据到底取什么值，一些时候和现实意义有关，如朝正的次数1次2次，一些时候也无关，比如我随便取个数行吗？我觉得也行，没违反定义就行。而多元随机变量，有可能是单一试验样本空间的多种解读，也有可能根本就不是从一个随机试验出来的（当然这和教材的定义有驳，但确实是可以这么研究的）\n2.分布函数 I 分布函数的性质 当我们将事件转化为数字后，就可以用分析来研究概率了。而分布函数就是研究概率最重要的一个东西了。随机变量分为离散和连续还有别的，分为单元和多元，这在分布函数中都有体现，比如不连续的分布函数肯定不是连续型随机变量，有可能是离散或者混合的；分布函数的自变量和研究的随机变量的数目是对应的，有几个随机变量，就最多有几个自变量。现在我们来看看分布函数的基本性质：\n $F(x)$是$x$的单调不减 $F(x)$右连续 $F(-\\infty )=0$,$F(+\\infty )=1$  只需要满足以上3条，这个函数就是一个随机变量的分布函数！这表示我们可以随便构造满足条件的函数，然后来猜猜他对应什么随机变量。\n概率分布（分布律）和概率密度需要满足的条件：\n $\\{p_i\\}$是概率分布 $\\Leftrightarrow $ $p_i \\geq 0$，且$\\sum_{i}p_i = 1$ $f(x)$是概率密度 $\\Leftrightarrow$ $f(x) \\geq 0$，且$\\int_{-\\infty }^{+\\infty }f(x)dx = 1$   II 一些教材中的特殊分布函数 为了能更好地大展身手，我们先来看看教材中的分布函数，只是简单的列出来，当然离散的：\n①$X\\sim U(a,b)$： $$ F(x)=\\left\\{ \\begin{aligned} \u0026amp;0 \\ \\ , \u0026amp; \u0026amp; {x\u0026lt; a}\\\\ \u0026amp;\\frac{b-a}{x-a} \\ \\ , \u0026amp; \u0026amp; {a\\leq x \u0026lt; b}\\\\ \u0026amp; 1\\ \\ , \u0026amp; \u0026amp; {x \\geq b}\\\\ \\end{aligned} \\right. $$ ②$X$服从参数为$\\theta $的指数分布 $$ F(x)=\\left\\{ \\begin{aligned} \u0026amp;1-e^{-x/\\theta} \\ \\ , \u0026amp; \u0026amp; {x\u0026lt; a}\\\\ \u0026amp;0 \\ \\ , \u0026amp; \u0026amp; {其他}\\\\ \\end{aligned} \\right. $$ ③$X\\sim N(\\mu,\\sigma^2)$ $$ F(x)=\\frac{1}{\\sqrt{2\\pi }\\sigma}\\int_{-\\infty }^{x}e^{-\\frac{(t-\\mu)^2}{2\\sigma^2}}dt $$ ④$(X,Y)\\sim N(\\mu_1,\\mu_2,\\sigma_1^2,\\sigma_2^2,\\rho )$\n公式太长不写了\n离散型的概率公式也写出来，虽然不是分布函数，但是对我们构造函数也有帮助：\n⑤$X\\sim b(n,\\rho)$ $$ P\\{X=k\\} = \\binom{n}{k}p^k q^{n-k} $$ ⑥泊松分布 $$ P\\{X=k\\}=\\frac{\\lambda^k e^{-k}}{k!} $$\n可以看到连续型本质上都是初等函数，而离散型是混有阶乘的初等函数\n III现在来构造吧 利用分布律，概率密度，分布函数需要满足的条件构造一些函数。这里主要是给一点思路，有兴趣的话可以继续研究，我想快点结束文章了。。。花的时间有点久，或许以后没事干了可以把响应函数的性质给补充一下，现在大致就是概览吧。\n①多项式$f(x)=a_n x^n + a_{n-1}x^{n-1}+\\dots + a_1 x^1 + a_0$\n对于离散型，假设随机变量范围是$X=12,\\dots,N$，当多项式最高次幂为0时，随机变量每一项的概率都为常数$\\frac{1}{N}$；当多项式最高次幂为1时，随机变量每一项概率成线性变化，对于固定的$N$，系数需满足$a_1\\frac{N(N+1)}{2}+a_0 N = 1$；其他的就不写了，反正是根据函数变化。\n对于连续型，假设随机变量范围是$[a,b]$，当多项式最高次幂为0时，就是均匀分布；当多项式最高次幂为1时\u0026hellip;\n②其他有理函数\n③自然指数\n④自然对数\n⑤三角函数\n3.无记忆性 4.函数分布？ Reference [1] 盛骤,谢式千,潘承毅. 2019. 概率论与数理统计. 高等教育出版社.\n[2] 张宇. 2021. 张宇概率论与数理统计9讲. 北京理工大学出版社有限责任公司.\n​\n","date":"2021-05-25","permalink":"/posts/other/probability-theory/","series":[""],"tags":[""],"title":"学习概率论的一些随意思考"},{"categories":[],"content":"随记合集\n2022-01-22 15:36 刚睡醒就看互联网是对自己的一大不尊重。现在互联网流行因为一点小事就可以疯狂骂起来，越是看多了互联网的骂战，越是觉得非常地空洞，不知道他们为了什么了争吵。不过我已经发现了一篇净土，希望我以后远离污秽。\n2022-01-19 00:55 很久没有看过这么精彩的动漫了……魔法少女小圆是神！！！\n接下来我会写几篇关于小圆的文章的……魔法少女小圆是神！！！ 魔法少女小圆是神！！！\n2022-01-12 22:21 终于考完了。我这学期过得还是太浪了，比我之前的学期都浪。不过我想并没有违背我的愿望，我做得没有太大问题，只是可能有点不完美。另外关于Java课程和大作业，我是觉得越来越没有意思了，学校的课程，中国的课程，好像从来都不是以培养学生的技能或者锻炼他们为主要目的，而是取得虚假的high score罢了。我认真做的网站项目我很喜欢的东西并没有取得别人的认同。算了，我之后也会按照自己的思路想法行事。我以后希望能去德国学数学。\n2022-01-07 00:04 已经考完两科了，明天上午将要进行数据挖掘的考试，而我只是随便看了看。虽然我早就决定将数据挖掘放入补考行列，但是目前心情还是有些不爽……大概是因为这是我第一次正式补考将考试拖到下学期吧。没办法，我在学期最后犯了一个错误：企图用10天时间将几乎未学的7门科目复习到及格水准。也不是不行，但是这样做会很损害身体，而我现在已经不想这么做了，意味はない。不就是那个毕业证吗，是吧，没必要那么复杂。\n关于病情方面，我终于认识到这是完全是我的世界了，一切都是幻想都是假象。没错，我自己居然不知不觉地踏入了神经病的行列，而且还以为事情是真实正常的。非常魔幻有趣的经历。\n现在我仍然痛苦。希望我以后用我自己的双眼去发现事实，真实，本物。\n2021-12-01 23:21 仿佛所有东西都在努力告诉我一个 我即将领悟的东西。另外，我准备开始重新写日记了，以前初三时写了半年多。\n最近我也在建Minecraft服务器，用的Spigot，但是建了很多次访问不到，也不知道是那出问题了，我想只有先建正版的服务器了，用spigot主要是担心有些同学没买正版一起玩不了。\n2021-11-05 13:47 我之前低估了我病的程度，还需要更多时间。我现在很多认知都是错误的，这非常痛苦。但是我觉得最长也只需要一年多吧。还是继续加油吧，继续脱敏，坚持训练，好好生活，好好休息，好好工作。\n2021-09-29 21:34 距离开学已经一个月了，我还是正在稳步地恢复中，我觉得最多今年底应该可以好吧。但是也不确定哈哈。\n明天过后就放假了，希望我能实现自己的愿望，活得更加自由快乐一点。祝国庆快乐。\n2021-09-18 16:57 中秋快乐呀~ 我正在稳步恢复，但是这么多年的条件反射很难一下子消除，但是是肯定可以的，只是还多需要一点时间~ 祝看到这条message的人不管什么时间都中秋快乐，虽然并不是在中秋节。\n2021-09-10 10:19 现在的世界处于叠加态，叠加于之前错误的世界和现在我相信的世界，我相信只要我信念足够，我会很快出来的~\n2021-09-04 12:56 我慢慢出来啦！~おめでとう！！另外，猜疑链真有意思，我会拿时间来写一篇这个东西，我发现世界上几乎所有的人都受这个影响，只是影响程度参差不一。\n2021-08-24 20:33 暑假即将结束，努力抓住夏日的尾巴。这个暑假过得有好有坏，打分7分/10分吧。\n2021-07-14 11:17 1️⃣ 鸽子成长史.png。趁着自己还有兴致的时候抓紧时间完成吧。其实网络社交空间我已经写了1000字了，但发现还是太难写了，所以还需要更多的时间，于是暂鸽了。\n2️⃣ 那是那个音乐框框在手机端显示不是很好看，，得想办法改改。\n3️⃣ 另外还想说一件事，我的博客是以学习，生活为止，但是他们之间的比例很不协调，原因是我不想写总结知识点的文章，那样子太没意思了，如果要写学习相关的文章，我只会写关于教程，探索的文章，就和概率论那样，自己探索。\n马上快要选课了，溜。😊\n2021-07-10 21:53 考完试了，标志着暑假来到了，这个暑假我已经定了计划了，种类还算丰富，希望自己能过一个比之前都要好的暑假~ 具体计划就不写啦，祝看到这段话的人暑假快乐~ 追寻自己的兴趣感觉也快要接触到真实的答案了。\n2021-06-24 17:45 今日无事。刚刚过去的6月23号是太阳直射北回归线的日子，我想为什么那一天不是平均下来最热的呢？查了查百度，哦，还有很多因素，不能够单纯一元论。离谱的是百度回答还整个了病情分析在前面。\n2021-05-28 18:23 想写关于星星与诸葛亮的收集整理文，先放在这了，什么时候有空什么时候写，毕竟概率论还有一大半没有写完。向着无用的星星出发！\n最近系统换了bitstream vera sans mono字体（我也不知道是什么意思），英文是挺好看，就是中文真让人头扁。\n老习惯，放一首歌，其实网易好像直接可以生成外链播放器，但我试了几次不行。\n 好了弄好了。enjoy！这首歌不是那么大众。\n2021-05-16 19:55 写东西好麻烦，不想写了。。我估计以后写的东西大部分应该都是随便一写。我准备先写写关于我对概率论的一些思考的东西，正好复习复习。至于之前说的那两个不相干的东西，估计需要更久了😂。​\n就这样，最近一直想玩一些新的gal可惜没什么时间，之前看到了知乎有一位gal爱好者，现在是字节的实习生，看到他写的考据文章很是羡慕憧憬。我希望我也能有一个爱好，目前正在慢慢寻找中。\n最后放一首最近听的歌：\n 2021-05-08 16:06 首先送上一首歌：\n 做了小站之后发现有好多想写的东西，现在准备写“网络社交空间”与“对川农电梯的观察分析”这两篇，但目测需要至少3周的感觉（最近有点忙，但还是会写完的），想看的朋友敬请期待😋\n2021-05-04 12:51 1️⃣ 最近遇见了南登かなる（なんとかなる），一个800粉丝的V，很是喜欢，已经作为头像了（\n2️⃣ 最近乘着假期完了魔女的夜宴（サノバウィッチ）xi ttu。很喜欢里面的戸隠\n3️⃣ 顺带一提，这个hugo theme的作者是大连东软信息学院的大四学生，很厉害。\n4️⃣ 之后可能会上线评论功能，现在暂时想慢慢来，博客的需求差不多就好，毕竟我不想学网页相关的知识太多\n","date":"2021-05-04","permalink":"/tweet/essay/","series":[],"tags":[],"title":"随记合集2021.5-2022.1"},{"categories":["普通类"],"content":"广告位~广告位~\n广告位，此站点流量为一位数，所以肯定不会吃亏的！\n联系我哦\n其实是因为无聊而发表的。\n","date":"2021-05-02","permalink":"/posts/other/ads/","series":[],"tags":[],"title":"广告位招租/Advertising Space for Rent"},{"categories":[],"content":"你说我是个谜，其实我们都是谜，\n在苦痛中开始，在折磨中结束。\n被卑微的事物拖向死亡，\n把崇高的理想，背负到诸天之上。\n目前想一点一点地将技能点点满, 虽然死后什么都没有, 但我目前乐意这么做. 我现在主攻计算机和物理, 当然其他的任何东西都是允许的, 包括游戏等普遍认为不务正业的事物.\n请通过email联系我！bnaod1@qq.com\n——Update at 2024.5.25\n站点进化史  2021-05-01 五一假期时，注册域名+hugo+cloudflare建本静态网站，使用的是dream主题 2021-07-28 暑假时更换主题，主要还是想突出阅读感而不是花里胡哨。 2023-02 添加了valine无后端评论。 2024-11 移除部分js cdn, 移除KeTax, 所以目前网站有数学公式的页面会受影响. ","date":"2021-05-01","permalink":"/about/","series":[],"tags":[],"title":"关于"},{"categories":["普通类"],"content":"First post\n2021-05-01 今天是有史以来第一次弄博客，5月1号从早上弄到晚上。\n今天的经过：博客怎么弄？ \u0026gt; 看看sharzy大佬的博客吧 \u0026gt; 意外发现了cloudflare \u0026gt; 翻阅友情link发现了hugo \u0026gt; 开始整 \u0026gt; 阿里云 \u0026gt; git，ssh，rsa \u0026gt; 想把丛雨的背景加上去，但是色彩太高了 \u0026gt; 算了，大概就这样吧，之后再改。\n非常非常想让丛雨来作背景，于是之后需要将作者头像这块处理一下。之后一旦处理完毕，基本上长期不会进行改动了，还是需要多学硬知识。\n丛雨(´ω｀)！\n2021-05-02 1.调整   将背景替换为丛雨修复剑时的场景，采用画布模糊。\n  在作者栏加了一个浅色边框，更容易分辨文字了。\n  将背景进行压缩，由原来的5.58Mb变为404Kb，访问更快了。\n  数学公式，代码渲染。\n  将其他图片压缩，加入更多的defaultpicture。\n  2.没有实现的地方  category目录，link。并且暂时不打算去做  3.打算  博客只是$hugo$搭建的，很快速，我对HTML与CSS的知识也局限于单单学过一遍但没有实践的程度，所以准备页面布局暂时就这样，不会进行改动了，可能偶尔会改变一下背景。想起之前浏览过的博客有一个添加背景API功能，每次重新访问页面背景会刷新，考虑之后做一个这样的丛雨API。 之后想了解一下$cloudflare$的托管功能，不想用gitpage了。 博客本身目前打算更新的内容有：学习总结，复习，传送记录门和其他随想。学习总结的频率目测应该是4-6周，考试复习会总结知识点。 向大佬学习！推荐大佬Sharzy\u0026rsquo;s Homepage | Sharzy 。据我所知，他应该是大三大四清华大学计算机学生一枚，今年3月份参加了托福考试，平时读了很多书，数学，计算机和音乐鉴赏水平很高。昨天到今天做博客的经历真实地感受到自己的水平多么不足，一定要好好学习。  4.功能测试 之前一直没有正式在$Markdown$上认真写过东西，所以这里先测试一下需要的功能，正确写漂亮点~\nI 数学公式 $\\LaTeX$行内公式：$\\left [ G : ker \\varphi \\right ] = \\left |im \\varphi \\right |$\n 行间公式:  $$ \\left |G \\right | = \\left |ker \\varphi \\right | \\cdot \\left |im \\varphi \\right | $$\nII 图片插入 这里放没有扭曲之前的背景，可爱的丛雨。当然图片还是压缩一下。\nIII 代码 JavaScript。\n1function test() { 2 console.log(\u0026#34;Hello world!\u0026#34;); 3} 5.尾巴 暂时就这样了。\n2021-05-03 1.调整  处理好了hugo构建背景的问题。之前一直需要手动修改，每次查看都报错，经过了类似代码审计的过程，以为是多大的麻烦，结果发现是因为hugo构建public后，background的imgurl是类似这样的\u0026quot;/img\u0026quot;，如果在本地打开的话，因为是file协议浏览器会去找如\u0026quot;C:/img\u0026quot;，而网站发布了就不会存在这样的问题。这种经验问题之后应该不会再犯了= =. 加入了更多的文章cover，加入了一些可爱的图片。 category和tag目录页已经处理好了。目前准备是category放“大类”，如生活类，数学类，计算机类；tag放小类，如proxy，JavaScript，网络。 各种图片近一步压缩，以提升访问速度。 cloudflare已经弄好了。 时间调整，post图片固定。（我真是个Σ(☉▽☉\u0026quot;，改了好久没想到在config里面） 个人描述页面终于弄好了😎 文章加入了description，不再显示全文了⭐  2.之后  可能会加入评论功能，实现方法好像有很多，之后再弄了。 魔改theme！？😇  3.尾巴 这里就是结尾了。写这篇记录的时候51假期过去了55.667%（从5月1日00:00算起到5月6日00:00)。\n本来是三篇，减少位置缩减为一篇~\n","date":"2021-05-01","permalink":"/posts/other/first-post/","series":[],"tags":[],"title":"第一次弄博客"}]