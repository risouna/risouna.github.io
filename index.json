[{"categories":["计算机"],"content":"https://www.cnblogs.com/gordonchao/archive/2011/04/06/2006577.html\n目前暂时用不到，就这样吧。\n包含EUnit头文件 在erlang模块中用EUnit最简单的方法是在模块的开头增加如下代码：\n1 -include_lib(\u0026#34;eunit/include/eunit.hrl\u0026#34;). 增加这个之后会有如下作用：\n 自动输出test/0函数(除非你关闭测试，并且你的模块中没有test/0函数)，它可以用来运行在本模块所有的单元测试 所有匹配\u0026hellip;_test()或者\u0026hellip;test()的函数自动输出(除非你关闭测试，或者定义了 EUNIT_NOAUTO宏) 让EUnit中的所有宏生效来帮助测试   要想让-include_lib(...)工作，你的“搜索路径”必须包括eunit/ebin目录。当然如果lib/eunit已经安装在你的系统目录下，它的ebin子目录也就会自动加入到“搜索路径”了，你就不用再做这方面的操作了。否则你就要用erl -pa命令把这个目录加上。\n当然如果你想在与erlang交互时始终能用EUnit，你只需要这样做：在你的 $HOME/.erlang文件中增加一行：code:add_path(\u0026quot;/path/to/eunit/ebin\u0026quot;).\n 写一个简单的测试函数 用EUnit框架让你在erlang中写一个单元测试非常简单。有好几种方式可以实现。这儿我们先介绍一种最简单的办法：\n一个以\u0026hellip;test()结尾的函数在EUnit中被认为是最简单的函数，它没有参数，它要么执行成功，要么执行失败。执行成功就会返回EUnit抛出的任意值； 执行失败就会抛出一种异常。\n下面是一种简单的测试函数：\n1reverse_test() -\u0026gt; lists:reverse([1,2,3]). 它只是用来测试list:reverse(List)函数不会崩溃。这不是一个好的测试，但很多人写这样简单的函数来测试他们代码的基本功能，而这些测试不用修改就可以直接被EUnit利用，只要是它的函数名匹配(即以_test结尾)。\n运行EUnit 首先要先按照上面的步骤把声明 -include_lib(\u0026quot;eunit/include/eunit.hrl\u0026quot;)加到你的模块里面， 你只需要编译这个模块，它就会自动输出这个模块的test()函数，而不需要再用-export进行声明，一切都已经自动做好了。\n这儿你也可以用eunit:test/1函数来运行任意的测试。例如：你用eunit:test(Mod).和用Mod:test().执行的结果是一样的。但eunit:test/1方法可以进行更高级的测试，如：eunit:test({inparallel, Mod}).这个命令和Mod:test()运行的结果是一样的，只不过它是要让它们全部并行的运行。\n1、把源码和测试代码放在不同的模块里\n如果你想把你的测试代码和源码分开(当然这儿的测试代码就只能用于测试源码中输出的函数)，你可以写一个名为Mod_tests的模块(注意这儿是Mod_tests而不是Mod_test)。这样当您想测试模块Mod时，你就可以运行Mod_tests中的测试函数来实现这个功能了。\n2、EUnit会捕捉到标准的输出\n如果你想测试标准的输出函数，你会惊奇的发现在控制台上不会显示出这些文本。因为EUnit捕捉到了所有的标准输出。为了在测试时挠开EUnit好把文本直接打印到控制台，你可以用io:format(user, \u0026ldquo;~w\u0026rdquo;, [Term]).把文本打印到输出流user上。这儿推荐的方式是用EUnit的调试宏，它会让这实现的更为简单。\n写一个测试的生成函数 简单测试函数的缺点是你必须为每个测试实例写一个测试函数。一种更紧凑的方式不是写一个函数来进行测试，而是写一个函数来返回测试结果。\n一个以\u0026hellip;test()结尾的函数在EUnit中被认为是一个测试生成函数。测试生成函数返回一系列的测试函数。\n这儿说下我自己的理解：\n简单函数只能证明这个函数对应的测试没有问题，如果这个简单函数里面有N条语句进行测试，只有当所有这N条函数都执行成功时才返回成功。而测试生成函数会为每条语句生成一个测试结果，你就可以很方便的知道是哪个函数出现了问题了。\n1、用数据的方式展现测试\nThe most basic representation of a test is a single fun-expression that takes no arguments. For example, the following test generator:\n1 basic_test_() -\u0026gt; 2 fun () -\u0026gt; ?assert(1 + 1 =:= 2) end. will have the same effect as the following simple test:\n1 simple_test() -\u0026gt; 2 ?assert(1 + 1 =:= 2). (in fact, EUnit will handle all simple tests just like it handles fun-expressions: it will put them in a list, and run them one by one).\n这儿最后一句提到，它会把每一条语句放到一个列表中，然后一个个的执行它。其实就相当于为每个语句生成一个简单的测试函数。在上面的那两个例子表示效果一样的原因是它们都只有一个函数。\n2、用宏来写测试\nTo make tests more compact and readable, as well as automatically add information about the line number in the source code where a test occurred (and reduce the number of characters you have to type), you can use the _test macro (note the initial underscore character), like this:\n1 basic_test_() -\u0026gt; 2 ?_test(?assert(1 + 1 =:= 2)). The _test macro takes any expression (the \u0026ldquo;body\u0026rdquo;) as argument, and places it within a fun-expression (along with some extra information). The body can be any kind of test expression, just like the body of a simple test function.\n注：用宏来写的原因主要是为了让代码最紧凑而且减少代码的数量\n3、用有下划线前缀的宏来创建测试对象\nBut this example can be made even shorter! Most test macros, such as the family of assert macros, have a corresponding form with an initial underscore character, which automatically adds a ?_test(...) wrapper. The above example can then simply be written:\n1 basic_test_() -\u0026gt; 2 ?_assert(1 + 1 =:= 2). which has exactly the same meaning (note the _assert instead of assert). You can think of the initial underscore as signalling test object.\n注：用_assert宏可以让代码更加紧凑，而且它和前面的简单测试中用到的assert宏用法一样，更加方便。\n这儿 ?_test(?_assert(1+1 =:= 2)).的功能和?_assert(1+1 =:= 2).是一样的。\nSometimes, an example says more than a thousand words. The following small Erlang module shows how EUnit can be used in practice.\n1 -module(fib). 2 -export([fib/1]). 3 -include_lib(\u0026#34;eunit/include/eunit.hrl\u0026#34;). 4 5 fib(0) -\u0026gt; 1; 6 fib(1) -\u0026gt; 1; 7 fib(N) when N \u0026gt; 1 -\u0026gt; fib(N-1) + fib(N-2). 8 9 fib_test_() -\u0026gt; 10 [?_assert(fib(0) =:= 1), 11\t?_assert(fib(1) =:= 1), 12\t?_assert(fib(2) =:= 2), 13\t?_assert(fib(3) =:= 3), 14\t?_assert(fib(4) =:= 5), 15\t?_assert(fib(5) =:= 8), 16\t?_assertException(error, function_clause, fib(-1)), 17\t?_assert(fib(31) =:= 2178309) 18 ]. (Author\u0026rsquo;s note: When I first wrote this example, I happened to write a * instead of + in the fib function. Of course, this showed up immediately when I ran the tests.)\n关闭测试 当你想关闭测试时有两种办法：一种是在编译时定义宏NOTEST， 或者在EUnit头文件被包含之前在源文件里增加对宏的声明：\nTesting can be turned off by defining the NOTEST macro when compiling, for example as an option to erlc, as in:\n1erlc -DNOTEST my_module.erl or by adding a macro definition to the code, before the EUnit header file is included:\n1-define(NOTEST, 1).//这儿的值不重要，为1或true都没关系！ (the value is not important, but should typically be 1 or true).\nNote that unless the EUNIT_NOAUTO macro is defined, disabling testing will also automatically strip all test functions from the code, except for any that are explicitly declared as exported.\nFor instance, to use EUnit in your application, but with testing turned off by default, put the following lines in a header file:\n1 -define(NOTEST, true). 2 -include_lib(\u0026#34;eunit/include/eunit.hrl\u0026#34;). and then make sure that every module of your application includes that header file. This means that you have a only a single place to modify in order to change the default setting for testing. To override the NOTEST setting without modifying the code, you can define TEST in a compiler option, like this:\n1 erlc -DTEST my_module.erl 避免EUnit在编译时期的依赖性 If you are distributing the source code for your application for other people to compile and run, you probably want to ensure that the code compiles even if EUnit is not available. Like the example in the previous section, you can put the following lines in a common header file:\n1 -ifdef(TEST). 2 -include_lib(\u0026#34;eunit/include/eunit.hrl\u0026#34;). 3 -endif. and, of course, also make sure that you place all test code that uses EUnit macros within -ifdef(TEST) or -ifdef(EUNIT) sections.\n","date":"2025-01-20","permalink":"/posts/tech/media-erlang-eunit/","series":["媒体开发"],"tags":["","",""],"title":"eunit测试框架学习"},{"categories":["计算机"],"content":"https://blog.csdn.net/lza20001103/article/details/143363702\n概述 tcpdump，用简单的语言概括就是dump the traffic on a network，是一个运行在linux平台可以根据使用者需求对网络上传输的数据包进行捕获的抓包工具，windows平台有sniffer等工具，tcpdump可以将网络中传输的数据包的“包头”全部捕获过来进程分析，其支持网络层、特定的传输协议、数据发送和接收的主机、网卡和端口的过滤，并提供and、or、not等语句进行逻辑组合捕获数据包或去掉不用的信息。\n1-a #将网络地址和广播地址转变成名字 2-A #以ASCII格式打印出所有分组，并将链路层的头最小化 3-b #数据链路层上选择协议，包括ip/arp/rarp/ipx都在这一层 4-c #指定收取数据包的次数，即在收到指定数量的数据包后退出tcpdump 5-d #将匹配信息包的代码以人们能够理解的汇编格式输出 6-dd #将匹配信息包的代码以c语言程序段的格式输出 7-ddd #将匹配信息包的代码以十进制的形式输出 8-D #打印系统中所有可以监控的网络接口 9-e #在输出行打印出数据链路层的头部信息 10-f #将外部的Internet地址以数字的形式打印出来，即不显示主机名 11-F #从指定的文件中读取表达式，忽略其他的表达式 12-i #指定监听网络接口 13-l #使标准输出变为缓冲形式，可以数据导出到文件 14-L #列出网络接口已知的数据链路 15-n #不把网络地址转换为名字 16-N 不输出主机名中的域名部分，例如www.baidu.com只输出www 17-nn #不进行端口名称的转换 18-P #不将网络接口设置为混杂模式 19-q #快速输出，即只输出较少的协议信息 20-r #从指定的文件中读取数据，一般是-w保存的文件 21-w #将捕获到的信息保存到文件中，且不分析和打印在屏幕 22-s #从每个组中读取在开始的snaplen个字节，而不是默认的68个字节 23-S #将tcp的序列号以绝对值形式输出，而不是相对值 24-T #将监听到的包直接解析为指定的类型的报文，常见的类型有rpc（远程过程调用）和snmp（简单网络管理协议） 25-t #在输出的每一行不打印时间戳 26-tt #在每一行中输出非格式化的时间戳 27-ttt #输出本行和前面以后之间的时间差 28-tttt #在每一行中输出data处理的默认格式的时间戳 29-u #输出未解码的NFS句柄 30-v #输出稍微详细的信息，例如在ip包中可以包括ttl和服务类型的信息 31-vv#输出相信的保报文信息 关键字 表达式是一个正则表达式，tcpdump利用它作为过滤报文的条件，如果一个报文满足表达式的条件，则这个报文将会被捕获。如果没有给出任何条件，则网络上所有的信息包 将会被截获，在表达式中一般如下几种类型的关键字：\n  数据类型\n1包括host、port、net，例如host 192.168.1.1表示这是一台主机，net 192.168.0.0表示这是一个网络地址，port 22指明端口号是22，如果没有指明类型，则默认的类型是host。   数据传输方向\n1包括src、dst、dst or src、dst and src，这些关键字指明了传输的方向，比如src 192.168.1.1说明数据包源地址是192.168.1.1，dst net 192.168.0.0指明目的网络地址是192.168.0.0，默认是监控主机对主机的src和dst，即默认监听本机和目标主机的所有数据。   协议\n1包括ip、arp、rarp、tcp、udp等，   其他\nnot和！都是相同的取反的意思\n1运算类型的：or、and、not、! 2 3辅助功能型的：gateway、less、broadcast、greater 4 5and：所有的条件都需要满足，也可以表示为 \u0026amp;\u0026amp; 6or：只要有一个条件满足就可以，也可以表示为 || 7not：取反，也可以使用 ！ 8and 优先级大于 or   选项   -h\n查看所有参数\n  -i\n指定监听网络接口\n默认监听在第一块网卡上（使用 ifconfig 查看网卡信息），监听所有经过此网卡通过的数据包；但是我们可能关心的数据并不是 ens32 的接口，这时就需要指定端囗进行数据包的捕获。\n在 tcpdump 后面加一个 -i 的参数，后面跟具体需要捕获的接口名称，就可以抓取经过这个具体接口的所有数据包。tcpdump -i any 监听所有的网卡接口、用来查看是否有网络流量。\n1tcpdump -i ens32   -w\n将捕获到的信息保存到文件中，且不分析和打印在屏幕.\n报文打印在 shell 里会太多且不方便查看，我们可以保存成文件；然后通过 xftp 导出到本地，可以详细查看。\n扩展：导出的文件可以设置为 cap 或者 pcap 的格式，可以直接用 wireshark 工具打开；可以用 wireshark 工具分析报文具体信息！\n  -n\n不把 ip 转化成域名\n直接显示 ip，避免执行 DNS lookups 解析的过程，速度会快很多。\n  -nn\n不把协议和端口转化成名字，速度也会快很多。\n  -N\n不打印出 host 的域名部分，将会打印 ‘nic’ 而不是 ‘nic.ddn.mil’\n  -t\n在每行的输出中不显示时间\n  -tt\n在每行的输出中会输出时间戳\n  -ttt\n输出每两行打印的时间间隔（以毫秒为单位)\n  -tttt\n在每行打印的时间戳之前添加日期的打印（此种选项，输出的时间最直观）\n  -v\n比如包的 TTL、id 标识、数据包长度，以及 IP 包的一些选项。同时它还会打开 一些附加的包完整性检测，比如对 IP 或 ICMP 包头部的校验和。\n  -vv\n产生比 -v 更详细的输出。比如 NFS 回应包中的附加域将会被打印，SMB 数据包也会被完全解码。\n  -vvv\n产生比 -vv 更详细的输出。比如 telent 时所使用的 SB、SE 选项将会被打印，如果telnet 同时使用的是图形界面，其相应的图形选项将会以 16 进制的方式打印出来。\n  -c\n即在收到指定数量的数据包后退出 tcpdump，停止抓包。\n1tcpdump -c 5 -w tt.pcap 即在收到指定数量的数据包后退出 tcpdump，停止抓包。\n  -C\n与 -w FILE 选项配合使用\n该选项使得 tcpdump 在把原始数据包直接保存到文件中之前，检查此文件大小是否超过 file-size。如果超过了，将关闭此文件，另创一个文件继续保存原始数据包。新创建的文件名与 -w 选项指定的文件名一致，但文件名后多了一个数字，该数字会从 1 开始随着新创建文件的增多而增加。file-size 的单位是百万字节（这里指1,000,000个字节，并非1,048,576个字节）\n1tcpdump -C 1 -W 4 -w rr 指定一个单位后（1MB）就换文件，最多写 4 个文件，名字是 rr0、rr1、rr2、rr3\n  -Q\n选择是入方向还是出方向的数据包，可选项有：in、out、inout，也可以使用 \u0026ndash;direction=[options]\n1tcpdump -Q in 2tcpdump -Q out 3tcpdump -Q inout   -q\n简洁地打印输出，即打印很少的协议相关信息，从而输出行都比较简短。\n  -D\n显示所有可用网络接口的列表（网卡）\n  -L\n列出网络接口的已知数据链路。\n  -s\n指定每个包捕获的长度\n单位是 byte，而不是默认的 262144 bytes；如果超过了设定的大小限制，包就会被截断 ，而在打印行出现 [lproto] 这种标识，这个 proto 就是被截断的报文的协议名字。但是抓取 len 越长，包的处理时间越长，并且会减少 tcpdump 可缓存的数据包的数量，从而会导致数据包的丢失，所以在能抓取我们想要的包的前提下，抓取长度越小越好（tcpdump -s 0 使用默认长度 262144）。\n1tcpdump -s 50   -A\n以 ASCII 格式打印出所有的分组并且读取此文件\n这样可以使读取更加简单，方便使用 grep 等工具解析输出内容\n1tcpdump -A -r tt.pcap 2tcpdump -A | grep baidu   -X\n表示同时使用十六进制和 ASCII 字符串打印报文的全部数据。注意：-X 和 -A 两个参数不能一起使用。\n1tcpdump -X -r tt.pcap   -F\n指定使用哪个文件的过滤表达式抓包，此时命令行上的输入过滤规则将被忽略，只以文件里的规则为准。\n1#配置规则文件 2[root@mysql01 ~]# vim filter_rule 3tcp port 80 4[root@mysql01 ~]# tcpdump -F filter_rule -c10   -l\n对标准输出进行行缓冲\n在需要同时观察抓包打印以及保存抓包记录的时候很有用。比如，可通过以下命令组合来达到此抓包时保存到文件的同时查看包的内容。\n1tcpdump -l | tee tt.pcap 这命令是使用 tee 来把 tcpdump 的输出同时放到文件 tt.pcap 和标准输出中。\n1tcpdump -l \u0026gt; tt.pcap \u0026amp; tail -f tt.pcap 这个命令是通过重定向操作 ‘\u0026gt;’ 写入到文件里。\n  示例   tcpdump\n默认捕获方式，默认监听在第一块网卡上，监听所有经过此网卡通过的数据包\n  tcpdump -i eth0\n监听指定网卡eth0的所有传输数据包\n  tcpdump -i eth0 host 192.168.56.1\n捕获主机192.168.56.1经过本机网卡eth0的所有数据包（也可以是主机名，但要求可以解析出来IP地址）\n  tcpdump host 192.168.56.209 and \\( 192.168.56.210 or 192.168.56.211 \\)\n捕获主机 192.168.56.209 和主机192.168.56.210或192.168.56.211的所有通信数据包\n  tcpdump ip host node9 and not www.baidu.com\n捕获主机node9与其他主机之间（不包括www.baidu.com）通信的ip数据包\n  tcpdump ip host node9 and ! www.baidu.com\n捕获node9与其他所有主机的通信数据包（不包括www.baidu.com）\n  tcpdump -i eth0 src node10\n捕获源主机node10发送的所有的经过eth0网卡的所有数据包\n  tcpdump -i eth0 dst host www.baidu.com\n捕获所有发送到主机www.baidu.com的数据包\n  tcpdump ip dst 192.168.56.1 and src 192.168.56.210 and port 80 and host ! www.baidu.com\ntcpdump ip dst 192.168.56.1 and src 192.168.56.210 and port 80 and host not www.baidu.com\n监听主机192.168.56.1和192.168.56.210之间ip协议的80端口的且排除www.baidu.com通信的所有数据包\n  tcpdump arp\n监控指定主机的通信数据包\n  tcpdump tcp port 22 and host 192.168.56.210\n捕获主机192.168.56.210接收和发出的tcp协议的ssh的数据包\n  tcpdump udp port 53\n监听本机udp的53端口的数据包，udp是dns协议的端口，这也是一个dns域名解析的完整过程\n  tcpdump src 100.100.30.26 and port 80\n抓一个来自 100.100.30.26 主机、80 端口的包\n  tcpdump tcp port 53 or udp port 53\n抓取 UDP 53 端口或者 TCP 53 端口的包（DNS协议的报文）\n  tcpdump not tcp port 22\n抓取不是 22 端口的报文\n  tcpdump “src 10.0.2.4 and (dst port 3389 or 22)”\n多个过滤器进行组合：需要用到括号，而括号在 shell 中是特殊符号，因此你需要使用引号将其包含\n  tcpdump ip dst 192.168.56.1 and src 192.168.56.210 and port 80 and host! www.baidu.com\n监听主机 192.168.56.1 和 192.168.56.210 之间 ip 协议的80端口的且排除www.baidu.com 通信的所有数据包\n  tcpdump less 32\n抓取包大小小于 32 bytes 的数据包\n  tcpdump greater 300\n抓取包大小大于 300 bytes 的数据包\n ","date":"2025-01-17","permalink":"/posts/tech/media-tcpdump/","series":["媒体开发"],"tags":["","",""],"title":"tcpdump抓包工具学习"},{"categories":["计算机"],"content":"目前只是形成了一个大概的印象，还需要继续学习。\n资料：\nhttp://www.ietf.org/ietf/IPR/convadia-ipr-draft-saleem-msml.txt\nhttp://www.ietf.org/rfc/rfc4240.txt\n概述 https://www.docin.com/p-655138178.html\n媒体服务器标记语言（Media Server Markup Language）。\n基于SIP的媒体控制协议，它完全支持SIP协议，而不需要更改SIP协议，它将XML脚本加入到SIP INVITE and SIP INFO消息中。\nMSML是在媒体服务器中工作的一种应用层语言，用于向MS进行业务请求和控制。他协助SIP协议工作，SIP建立媒体会话和提供媒体传输通道，MSML提供应用层控制。\nMSML将媒体流和信令控制进行分类。\n在媒体服务器中媒体对象是媒体流请求和终结的实体（对话dialogs，会议conference），媒体流是在两个媒体对象之间建立起来的媒体通道。\nMSML提供如下工具：\n 创建，修改或者破坏一个媒体对象 建立或者删除媒体流 修改媒体流属性（例如：音量）  使用   通过SIP Request-RUI 在会话中标记MSML\n1INVITE sip:msml@mediaserver.example.com SIP/2.0 2INVITE sip:annc@mediaserver.example.com;play=cid:... SIP/2.0   MSML嵌套在SIP INFO消息体中\n  MSML识别目标 = RTP流\n  允许用户选择如何使用MSML\n  元素   \u0026lt;audiomix\u0026gt;\n定义了音频混合属性\n  \u0026lt;videolayout\u0026gt;\n定义了视频混合（布局）属性\n  n-loudest(e.g. \u0026lt;n-loudest n=\u0026quot;3\u0026quot;/\u0026gt;)\n音量\n  automatic speaker notification (e.g. \u0026lt;asn ri=\u0026quot;2s\u0026quot;/\u0026gt;)\n自动语言通知\n  \u0026lt;selector id=\u0026quot;1\u0026quot; method=\u0026quot;vas\u0026quot; speakersess=\u0026quot;previout\u0026quot;/\u0026gt;\n选择视频显示属性\n  \u0026lt;root size=\u0026quot;CIF\u0026quot; cvd:codec=\u0026quot;H263\u0026quot; cvd:bandwidth=\u0026quot;512\u0026quot; cvd:mpi=\u0026quot;1\u0026quot;/\u0026gt;\n通用视频显示属性\n  \u0026lt;createconference\u0026gt;\n初始创建会议\n  \u0026lt;modifyconference\u0026gt;\n修改会议布局属性，或者向会议中增加成员。如\u0026lt;asn ri=\u0026quot;0\u0026quot;/\u0026gt; 禁止asn报告\n  \u0026lt;destroyconference\u0026gt;\n删除一个会议，或者移除一个会议媒体布局（混合）。默认终结所有现存的sip对话\n  案例 1.创建一个音频或者视频会议：\n1\u0026lt;msml version=\u0026#34;1.1\u0026#34;\u0026gt; //msml版本 2 \u0026lt;createconference name=\u0026#34;conf1\u0026#34; deletewhen=\u0026#34;nocontrol\u0026#34;\u0026gt; //会议名称 会议结束标记 3 \u0026lt;audiomix id=\u0026#34;1\u0026#34;\u0026gt; //音频混合方式 4 \u0026lt;n-loudest n=\u0026#34;3\u0026#34;/\u0026gt; 5 \u0026lt;/audiomix\u0026gt; 6 \u0026lt;videolayout id=\u0026#34;1\u0026#34; type=\u0026#34;text/msml-basic-layout\u0026#34;\u0026gt; //视频布局方式 7 \u0026lt;selector id=\u0026#34;1\u0026#34; method=\u0026#34;vas\u0026#34; si=\u0026#34;1s\u0026#34;\u0026gt; 8 \u0026lt;root size=\u0026#34;CIF\u0026#34; cvd:codec=\u0026#34;H263\u0026#34; cvd:bandtwidth=\u0026#34;512\u0026#34; cvd:mpi=\u0026#34;1\u0026#34; /\u0026gt; //视频尺寸 编码类型 带宽 9 \u0026lt;/selector\u0026gt; 10 \u0026lt;/videolayout\u0026gt; 11 \u0026lt;/createconference\u0026gt; 12\u0026lt;/msml\u0026gt; 2.将一个用户（媒体流）加入到会议中：\n  将一个媒体格式为只收(receive-only)方式的用户加入会议：\ndir中都是to-id1\n  1\u0026lt;join id1:\u0026#34;conn:dh628z\u0026#34; id2=\u0026#34;conf:abc\u0026#34;\u0026gt; 2 \u0026lt;stream dir=\u0026#34;to-id1\u0026#34; media=\u0026#34;audio\u0026#34;/\u0026gt; 3 \u0026lt;stream dir=\u0026#34;to-id1\u0026#34; media=\u0026#34;video\u0026#34;/\u0026gt; 4\u0026lt;/join\u0026gt;  将一个音频用户加入会议并设置音频属性：  1\u0026lt;join id1:\u0026#34;conn:dh628z\u0026#34; id2=\u0026#34;conf:abc\u0026#34;\u0026gt; 2 \u0026lt;stream dir=\u0026#34;to-id1\u0026#34; media=\u0026#34;audio\u0026#34;\u0026gt; 3 \u0026lt;gain agc=\u0026#34;true\u0026#34;/\u0026gt; 4 \u0026lt;clamp dtmf=\u0026#34;true\u0026#34;/\u0026gt; 5 \u0026lt;/stream\u0026gt; 6 \u0026lt;stream dir=\u0026#34;to-id1\u0026#34; media=\u0026#34;audio\u0026#34;/\u0026gt; 7\u0026lt;/join\u0026gt; 3.修改会议中一个或多个用户（媒体流）的连接属性：\n关闭先前会议的自动控制(AGC)功能，由于不包含clamp标记所以DTMF不受影响，会议的媒体流（从会议发向连接，即to）是不受影响的，因为它没有在modifyustream中。\n1\u0026lt;modifystream id1=\u0026#34;conn:dh628z\u0026#34; id2=\u0026#34;conf:abc\u0026#34;\u0026gt; 2 \u0026lt;stream dir=\u0026#34;from-id1\u0026#34; media=\u0026#34;audio\u0026#34;\u0026gt; 3 \u0026lt;gain agc=\u0026#34;false\u0026#34;/\u0026gt; 4 \u0026lt;/stream\u0026gt; 5\u0026lt;/modifystream\u0026gt; 4,从会议中删除一个用户（媒体流）的连接\n在unjoin中不能修改媒体流属性。\n1\u0026lt;unjoin id1=\u0026#34;conn:dh629z\u0026#34; id2=\u0026#34;conf:abc\u0026#34;\u0026gt; 2 \u0026lt;stream dir=\u0026#34;to-id1\u0026#34; media=\u0026#34;audio\u0026#34;/\u0026gt; 3 \u0026lt;stream dir=\u0026#34;to-id1\u0026#34; media=\u0026#34;video\u0026#34;/\u0026gt; 4\u0026lt;/unjoin\u0026gt; 并将该用户设为语音只读模式\n1\u0026lt;join id1=\u0026#34;conn:dh629z\u0026#34; id2=\u0026#34;conf:abc\u0026#34;\u0026gt; 2 \u0026lt;stream dir=\u0026#34;from-id1\u0026#34; media=\u0026#34;audio\u0026#34;/\u0026gt; 3\u0026lt;/join\u0026gt; 5.开启ASN\nASN只能进行音频混合，audiomix的其他音频属性不变，\u0026lt;videolayout\u0026gt;视频属性不变\n1\u0026lt;msml version=\u0026#34;1.1\u0026#34;\u0026gt; 2 \u0026lt;modifyconference id=\u0026#34;conf:conf1\u0026#34;\u0026gt; 3 \u0026lt;audiomix id=\u0026#34;1\u0026#34;\u0026gt; 4 \u0026lt;asn r1=\u0026#34;2s\u0026#34; cvd:asth=\u0026#34;-96\u0026#34;/\u0026gt; 5 \u0026lt;/audiomix\u0026gt; 6 \u0026lt;/modifyconference\u0026gt; 7\u0026lt;/msml\u0026gt; 6.修改为音频会议\n修改后并不打断会议，只是将视频会议修改为音频会议\n\u0026lt;videolayout\u0026gt;用来判断视频混合是否被删除，但他不包含视频描述\u0026lt;selector\u0026gt;,\u0026lt;root\u0026gt;\n1\u0026lt;msml version=\u0026#34;1.1\u0026#34;\u0026gt; 2 \u0026lt;destroyconference id=\u0026#34;conf:conf1\u0026#34;\u0026gt; 3 \u0026lt;videolayout id=\u0026#34;1\u0026#34; type=\u0026#34;text.msml-basic-layout\u0026#34;/\u0026gt; 4\t\u0026lt;/destroyconference\u0026gt; 5\u0026lt;/msml\u0026gt; 7.通过sip INFO消息将请求发给ms（媒体服务器）\n1\u0026lt;msml version=\u0026#34;1.1\u0026#34;\u0026gt; 2 \u0026lt;dialogstart target=\u0026#34;conn:178d9az\u0026#34; type=\u0026#34;application/moml+xml\u0026#34; id=\u0026#34;mydialogname\u0026#34;\u0026gt; 3 \u0026lt;play cvd:barge=\u0026#34;true\u0026#34; cvd:cleardb=\u0026#34;true\u0026#34;\u0026gt; 4 \u0026lt;audio uri=\u0026#34;file://4\u0026#34;/\u0026gt; 5 \u0026lt;/play\u0026gt; 6 \u0026lt;dtmf dft=\u0026#34;3s\u0026#34; idt=\u0026#34;5s\u0026#34; edt=\u0026#34;2s\u0026#34;\u0026gt; 7 \u0026lt;pattern digits=\u0026#34;min=2;max=6;rtk=#\u0026#34; format=\u0026#34;mom1+digits\u0026#34;/\u0026gt; 8 \u0026lt;noinput/\u0026gt; 9 \u0026lt;nomatch/\u0026gt; 10 \u0026lt;/dtmf\u0026gt; 11 \u0026lt;exit namelist=\u0026#34;dtmf.end dtmf.digits\u0026#34;/\u0026gt; 12 \u0026lt;/dialogstart\u0026gt; 13\u0026lt;/msml\u0026gt; 8.通过sip INFO消息的响应消息将MSML操作请求的结果带回\n1\u0026lt;msml version=\u0026#34;1.1\u0026#34;\u0026gt; 2 \u0026lt;result response=\u0026#34;200\u0026#34;\u0026gt; 3 \u0026lt;dialogid\u0026gt;conn:178d9az;dialog:6td8\u0026lt;/dialogid\u0026gt; 4 \u0026lt;/result\u0026gt; 5\u0026lt;/msml\u0026gt; DTML收集完成后也是通过sip INFO消息体携带通知事件\n1\u0026lt;msml version=\u0026#34;1.1\u0026#34;\u0026gt; 2 \u0026lt;event name=\u0026#34;msm;.dialog.exit\u0026#34; id=\u0026#34;conn:178d9az;dialog:6td8\u0026#34;\u0026gt; 3 \u0026lt;name\u0026gt;dtmf.end\u0026lt;/name\u0026gt; 4 \u0026lt;value\u0026gt;dtmf.match\u0026lt;/value\u0026gt; 5 \u0026lt;name\u0026gt;dtmf.digits\u0026lt;/name\u0026gt; 6 \u0026lt;value\u0026gt;12345#\u0026lt;/value\u0026gt; 7 \u0026lt;/event\u0026gt; 8\u0026lt;/msml\u0026gt; 9.请求消息都是通过sip INFO消息体发送给ms的\n相比7多了一个send\n1\u0026lt;msml version=\u0026#34;1.1\u0026#34;\u0026gt; 2 \u0026lt;dialogstart target=\u0026#34;conn:178d9az\u0026#34; type=\u0026#34;application/moml+xml\u0026#34; id=\u0026#34;mydialogname\u0026#34;\u0026gt; 3 \u0026lt;play cvd:barge=\u0026#34;true\u0026#34; cvd:cleardb=\u0026#34;true\u0026#34;\u0026gt; 4 \u0026lt;audio uri=\u0026#34;file://4\u0026#34;/\u0026gt; 5 \u0026lt;/play\u0026gt; 6 \u0026lt;send target=\u0026#34;source\u0026#34; event=\u0026#34;app.playcomplete\u0026#34; namelist=\u0026#34;play.amt\u0026#34;/\u0026gt; 7 \u0026lt;dtmf dft=\u0026#34;3s\u0026#34; idt=\u0026#34;5s\u0026#34; edt=\u0026#34;2s\u0026#34;\u0026gt; 8 \u0026lt;pattern digits=\u0026#34;min=2;max=6;rtk=#\u0026#34; format=\u0026#34;mom1+digits\u0026#34;/\u0026gt; 9 \u0026lt;noinput/\u0026gt; 10 \u0026lt;nomatch/\u0026gt; 11 \u0026lt;/dtmf\u0026gt; 12 \u0026lt;exit namelist=\u0026#34;dtmf.end dtmf.digits\u0026#34;/\u0026gt; 13 \u0026lt;/dialogstart\u0026gt; 14\u0026lt;/msml\u0026gt; 10.结果通过INFO返回\n1\u0026lt;msml version=\u0026#34;1.1\u0026#34;\u0026gt; 2 \u0026lt;result response=\u0026#34;200\u0026#34;\u0026gt; 3 \u0026lt;description MSML document execution completes /\u0026gt; 4 \u0026lt;/result\u0026gt; 5\u0026lt;/msml\u0026gt; 11.放音和信号收集事件处理格式\n1\u0026lt;msml version=\u0026#34;1.1\u0026#34;\u0026gt; 2 \u0026lt;event name=\u0026#34;app.playcomplete\u0026#34; id=\u0026#34;conn:178d9az/dialog:mydialogname\u0026#34;\u0026gt; 3 \u0026lt;name\u0026gt;play.amt\u0026lt;/name\u0026gt; 4 \u0026lt;value\u0026gt;4989ms\u0026lt;/value\u0026gt; 5 \u0026lt;/event\u0026gt; 6\u0026lt;/msml\u0026gt; 7\u0026lt;msml version=\u0026#34;1.1\u0026#34;\u0026gt; 8 \u0026lt;event name=\u0026#34;msml.dialog.exit\u0026#34; id=\u0026#34;conn:178d9az/dialog:mydialogname\u0026#34;\u0026gt; 9 \u0026lt;name\u0026gt;dtmf.end\u0026lt;/name\u0026gt; 10 \u0026lt;value\u0026gt;dtmf.match\u0026lt;/value\u0026gt; 11 \u0026lt;name\u0026gt;dtmf.digits\u0026lt;/name\u0026gt; 12 \u0026lt;value\u0026gt;123456\u0026lt;/value\u0026gt; 13 \u0026lt;/event\u0026gt; 14\u0026lt;/msml\u0026gt; ","date":"2025-01-10","permalink":"/posts/tech/media-msml/","series":["媒体开发"],"tags":["","",""],"title":"MSML语言学习"},{"categories":["计算机"],"content":"建立连接前 UAC INVITE，进行SDP offer：\n1Session Initiation Protocol (INVITE) 2 Request-Line: INVITE sip:service@10.1.68.48:5080 SIP/2.0 3 Message Header 4 Via: SIP/2.0/UDP 10.4.6.199:5060;branch=z9hG4bK-33212-1-0 5 From: sipp \u0026lt;sip:sipp@10.4.6.199:5060\u0026gt;;tag=1 6 To: sut \u0026lt;sip:service@10.1.68.48:5080\u0026gt; 7 Call-ID: 1-33212@10.4.6.199 8 [Generated Call-ID: 1-33212@10.4.6.199] 9 CSeq: 1 INVITE 10 Contact: sip:sipp@10.4.6.199:5060 11 Max-Forwards: 70 12 Subject: Performance Test 13 Content-Type: application/sdp 14 Content-Length: 149 15 Message Body 16 Session Description Protocol 17 Session Description Protocol Version (v): 0 18 Owner/Creator, Session Id (o): caller 0 0 IN IP4 10.1.93.116 19 Session Name (s): MobileVrbt_UEA_User_Caller_18500000000_18600000000 20 Session Information (i): - 21 Connection Information (c): IN IP4 10.4.6.199 22 Time Description, active time (t): 0 0 23 Media Description, name and address (m): audio 5002 RTP/AVP 8 24 [Generated Call-ID: 1-33212@10.4.6.199] SIP：总的来说来说挺简单\n   Header 含义说明 举例     Call-ID 由本地设备(Client)生成，全局唯一，每次呼叫这个值唯一不变 Call-ID: asd88asd77a@1.2.3.4   From 表示请求的发起者 From: sip:user1@domain.com;tag=49583   To 表示请求的接收者 To: sip:user2@domain.com   Via Via头域是被服务器插入request中，用来检查路由环的，并且可以使response根据via找到返回的路 Via: SIP/2.0/TCP user1pc.domain.com;branch=z9hG4bK776sgdkse   Max-Forwards 用于表示这个包最多可以传送多少跳，每经过一跳都会减一当Max-Forwards==0系统会返回483。默认为70 Max-Forwards: 70   Contact 包含源的URI信息，用来给响应方直接和源建立连接用 Contact: sip:192.168.100.1:1111   Content-Type 指明消息体的类型 (SDP会话描述协议) Content-Type: text/plain；Content-Type: application/sdp; Content-Type: application/cpim;   Content-Length 指明消息体的字节大小 Content-Length: 18    SDP：\n  v：版本信息\n  o=\u0026lt;用户名\u0026gt;\u0026lt;会话ID\u0026gt;\u0026lt;会话版本\u0026gt;\u0026lt;网络类型\u0026gt;\u0026lt;地址类型\u0026gt;\u0026lt;单播地址\u0026gt;\n\u0026lt;用户名\u0026gt;：是登陆源主机的用户的名字，如果不能提供，则用\u0026quot;-\u0026ldquo;表示，用户名不能包含空格。 \u0026lt;会话ID\u0026gt;：是一个数字字符串，\u0026lt;用户名\u0026gt;\u0026lt;会话ID\u0026gt;\u0026lt;网络类型\u0026gt;和\u0026lt;单播地址\u0026gt;这个组合形成了表示该会话的唯一标识，\u0026lt;会话ID\u0026gt;通常使用NTP格式的时间戳标识。 \u0026lt;会话版本\u0026gt;：是当前会话描述的版本号，如果当前会话的数据被修改时，这个版本号会递增，同样推荐使用NTP格式的时间戳。 \u0026lt;网络类型\u0026gt;：是一个文本字符串，标志当前网络的类型，最初\u0026quot;IN”标识\u0026quot;Internet\u0026rdquo;，未来可能会定义其他的值。 \u0026lt;地址类型\u0026gt;：是一个文本字符串，标志当前地址的类型，最初只有\u0026quot;IP4\u0026quot;和\u0026quot;IP6\u0026quot;有定义，未来可能定义其他的值。 \u0026lt;单播地址\u0026gt;：是创建会话的主机的地址，可以是域名，也可以是\u0026quot;IP4\u0026quot;或\u0026quot;IP6\u0026quot;IP地址。域名是首先，除非域名不可获得。如果使用IP地址，则需要使用全球唯一的IP地址，不能使用本地IP地址。\n  s=\u0026lt;会话名字\u0026gt; 字段\u0026quot;s=\u0026ldquo;是文本类型的会话名字，每个会话描述有且仅有一个\u0026quot;s=\u0026ldquo;字段，\u0026ldquo;s=\u0026ldquo;字段不能为空，并且应该为ISO 10646字体。如果一个会话没有有意义的名字，则此字段应该为一个空格。\n  i=\u0026lt;会话描述\u0026gt; \u0026ldquo;i=\u0026ldquo;字段提供会话的文本信息，在会话层和媒体层最多出现一次。\n  c=\u0026lt;网络类型\u0026gt;\u0026lt;地址类型\u0026gt;\u0026lt;连接地址\u0026gt; 这个字段包含连接数据，一个会话描述必须在每个媒体层都包含\u0026quot;c=\u0026ldquo;字段或者在会话层包含一个\u0026quot;c=\u0026ldquo;字段。如果这两个层都出现的话，则媒体层出现的\u0026quot;c=\u0026ldquo;会覆盖会话层出现的\u0026quot;c=\u0026ldquo;字段的值。\n\u0026lt;网络类型\u0026gt;：是一个文本字符串，标志当前网络的类型，最初\u0026quot;IN”标识\u0026quot;Internet\u0026rdquo;，未来可能会定义其他的值。 \u0026lt;地址类型\u0026gt;：是一个文本字符串，标志当前地址的类型，最初只有\u0026quot;IP4\u0026quot;和\u0026quot;IP6\u0026quot;有定义，未来可能定义其他的值。 \u0026lt;连接地址\u0026gt;标志连接的地址，当\u0026lt;连接地址\u0026gt;为IP4或者IP6时，连接的定义如下： i）当回话是多播时，地址为多播地址；当会话是单播时，地址为单播地址，并且为媒体数据的原地址。 ii）如果地址是IPv4，则还需要给出TTL的值，TTL标识包的生存时间，范围是0~255.\n  t=\u0026lt;起始时间\u0026gt;\u0026lt;结束时间\u0026gt; \u0026ldquo;t=“子弹标志了会话的起始时间和结束时间，如果会话在不规则的多个时间段内有效，则可能会出现多个字段的\u0026quot;t=”。如果时间段是规则的，则应该使用\u0026quot;r=\u0026ldquo;字段，后面将会介绍。\n  m=\u0026lt;媒体类型\u0026gt;\u0026lt;端口\u0026gt;\u0026lt;协议\u0026gt;\u0026lt;格式类型\u0026gt; 一个会话描述可能包括多个媒体描述。每个媒体描述都以\u0026quot;m=\u0026ldquo;字段开始的，结束于下一个\u0026quot;m=\u0026ldquo;或者整个会话结束。\n\u0026lt;媒体类型\u0026gt;：本规范定义了视频、音频、文本、应用和消息这几种类型。 \u0026lt;端口\u0026gt;：被房媒体流的端口，这个字段的意义依赖于\u0026quot;c=\u0026ldquo;字段和\u0026lt;协议\u0026gt;字段。如果不适用连续的端口或者没有按照偶数RTP端口，奇数RTCP端口，则必须使用\u0026quot;a=rtcp:\u0026ldquo;来标识RTCP的端口。应用程序被发送到一个端口，此端口是一个奇数端口，并且出现”a=rtcp:”行时，此媒体一定不能从RTP端口减一，应用程序必须发送RTP数据到指定的端口，并且发送RTCP到”a=rtcp”属性设定的端口。对于某些应用程序，它们的媒体流通过层级解码发送到单播地址时，它们有必要设定多个传输端口。使用语法和多播地址的方式类似： m= / …。这种场景中，使用的端口依赖于传输协议类型。一些读者可能明白，通常默情况下，RTP使用偶数端口传输数据，它的RTCP使用高一位数的奇数端口控制RTP会话。表示RTP会话数量。 \u0026lt;协议\u0026gt;：它是传输协议。这里的传输协议依赖于”c=”行定义的地址类型。目前支持的主要的几个类型包括：UDP，RTP/AVP，RTP/SAVP。这里专门针对媒体格式设定不同的传输协议是因为同一网络协议时，标准的媒体格式可以通过不同的传输协议来进行传输。这样的设定可以支持不同的网络传输和满足不同检测工具部署。 \u0026lt;格式类型\u0026gt;：它表示一种媒体格式描述。前面第四个子项或者其他后续子项都表示媒体格式。媒体格式描述的解析依赖于子项的值。如果 子项是”RTP/AVP”或者”RTP/SAVP，媒体格式描述会包含RTP payload 类型号码。当给定了一个payload类型列表时(静态方式，从96-127)，这表示所有的媒体格式可以适用于此会话中，但是，通常列表中的第一个格式应该作为此会话默认支持格式。如果payload类型列表是动态的payload类型列表的话，SDP使用”a=rtpmap:”属性来执行一个映射（从RTP payload 类型号码到媒体解码名称），通过媒体类型号码到媒体解码名称的对应关系来确认payload格式。”a=fmtp:” 行可以用来设定具体的媒体格式参数。\n  MS 回信：\n100\n1Session Initiation Protocol (100) 2 Status-Line: SIP/2.0 100 Trying 3 Message Header 4 Via: SIP/2.0/UDP 10.4.6.199:5060;branch=z9hG4bK-33212-1-0 5 To: sut \u0026lt;sip:service@10.1.68.48:5080\u0026gt; 6 From: sipp \u0026lt;sip:sipp@10.4.6.199:5060\u0026gt;;tag=1 7 Call-ID: 1-33212@10.4.6.199 8 [Generated Call-ID: 1-33212@10.4.6.199] 9 CSeq: 1 INVITE 10 Content-Length: 0 200，同时SDP answer\n1Session Initiation Protocol (200) 2 Status-Line: SIP/2.0 200 OK 3 Message Header 4 Via: SIP/2.0/UDP 10.4.6.199:5060;branch=z9hG4bK-33212-1-0 5 To: sut \u0026lt;sip:service@10.1.68.48:5080\u0026gt;;tag=YRrWa7c2kH 6 From: sipp \u0026lt;sip:sipp@10.4.6.199:5060\u0026gt;;tag=1 7 Call-ID: 1-33212@10.4.6.199 8 [Generated Call-ID: 1-33212@10.4.6.199] 9 CSeq: 1 INVITE 10 Allow: ACK, BYE, CANCEL, INFO, INVITE, MESSAGE, OPTIONS, PRACK, UPDATE 11 Contact: \u0026lt;sip:service@10.1.68.48:5080\u0026gt; 12 Content-Type: application/sdp 13 Supported: 100rel, precondition 14 Content-Length: 137 15 Message Body 16 Session Description Protocol 17 Session Description Protocol Version (v): 0 18 Owner/Creator, Session Id (o): - 0 1736403692661597 IN IP4 10.1.68.48 19 Session Name (s): - 20 Session Information (i): Session description protocol 21 Connection Information (c): IN IP4 10.1.68.48 22 Time Description, active time (t): 0 0 23 Media Description, name and address (m): audio 30008 RTP/AVP 8 24 [Generated Call-ID: 1-33212@10.4.6.199] UAC ACK，连接建立：\n1Session Initiation Protocol (ACK) 2 Request-Line: ACK sip:service@10.1.68.48:5080 SIP/2.0 3 Message Header 4 Via: SIP/2.0/UDP 10.4.6.199:5060;branch=z9hG4bK-33212-1-3 5 From: sipp \u0026lt;sip:sipp@10.4.6.199:5060\u0026gt;;tag=1 6 To: sut \u0026lt;sip:service@10.1.68.48:5080\u0026gt;;tag=YRrWa7c2kH 7 Call-ID: 1-33212@10.4.6.199 8 [Generated Call-ID: 1-33212@10.4.6.199] 9 CSeq: 1 ACK 10 Contact: sip:sipp@10.4.6.199:5060 11 Max-Forwards: 70 12 Subject: Performance Test 13 Content-Length: 0 连接建立后 请求放音 UAC INFO\n1Session Initiation Protocol (INFO) 2 Request-Line: INFO sip:service@10.1.68.48:5080 SIP/2.0 3 Message Header 4 Via: SIP/2.0/UDP 10.4.6.199:5060;branch=z9hG4bK-33212-1-5 5 From: sipp \u0026lt;sip:sipp@10.4.6.199:5060\u0026gt;;tag=1 6 To: sut \u0026lt;sip:service@10.1.68.48:5080\u0026gt;;tag=YRrWa7c2kH 7 Call-ID: 1-33212@10.4.6.199 8 [Generated Call-ID: 1-33212@10.4.6.199] 9 CSeq: 2 INFO 10 Contact: sip:sipp@10.4.6.199:5060 11 Max-Forwards: 70 12 Subject: Performance Test 13 Content-Type: application/msml+xml 14 Content-Length: 330 15 Message Body 16 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt;\\r\\n 17 \u0026lt;msml version=\u0026#34;1.1\u0026#34;\u0026gt;\\r\\n 18 \u0026lt;dialogstart target=\u0026#34;conn:12345\u0026#34; name=\u0026#34;12345\u0026#34;\u0026gt;\\r\\n 19 \u0026lt;play barge=\u0026#34;true\u0026#34; iterate=\u0026#34;1\u0026#34; interval=\u0026#34;1\u0026#34; maxtime=\u0026#34;5\u0026#34; id=\u0026#34;play\u0026#34;\u0026gt;\\r\\n 20 \u0026lt;audio uri=\u0026#34;audio.wav\u0026#34; /\u0026gt;\\r\\n 21 \u0026lt;playexit\u0026gt;\\r\\n 22 \u0026lt;send target=\u0026#34;source\u0026#34; event=\u0026#34;done\u0026#34; valuelist=\u0026#34;play.end play.amt\u0026#34;/\u0026gt;\\r\\n 23 \u0026lt;/playexit\u0026gt;\\r\\n 24 \u0026lt;/play\u0026gt;\\r\\n 25 \u0026lt;/dialogstart\u0026gt;\\r\\n 26 \u0026lt;/msml\u0026gt; 27 MS 回复：\n1Session Initiation Protocol (200) 2 Status-Line: SIP/2.0 200 OK 3 Message Header 4 Via: SIP/2.0/UDP 10.4.6.199:5060;branch=z9hG4bK-33212-1-5 5 To: sut \u0026lt;sip:service@10.1.68.48:5080\u0026gt;;tag=YRrWa7c2kH 6 From: sipp \u0026lt;sip:sipp@10.4.6.199:5060\u0026gt;;tag=1 7 Call-ID: 1-33212@10.4.6.199 8 [Generated Call-ID: 1-33212@10.4.6.199] 9 CSeq: 2 INFO 10 Content-Type: application/msml+xml 11 Content-Length: 146 12 Message Body 13 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt;\\n 14 \u0026lt;msml version=\u0026#34;1.1\u0026#34;\u0026gt;\\n 15 \u0026lt;result response=\u0026#34;200\u0026#34;\u0026gt;\\n 16 \u0026lt;dialogid\u0026gt;conn:12345/dialog:12345\u0026lt;/dialogid\u0026gt;\\n 17 \u0026lt;/result\u0026gt;\\n 18 \u0026lt;/msml\u0026gt; 然后MS就通过RTP开始传输媒体了，这里放几个连续的包\n1Real-Time Transport Protocol 2 [Stream setup by SDP (frame 43)] 3 10.. .... = Version: RFC 1889 Version (2) 4 ..0. .... = Padding: False 5 ...0 .... = Extension: False 6 .... 0000 = Contributing source identifiers count: 0 7 0... .... = Marker: False 8 Payload type: ITU-T G.711 PCMA (8) 9 Sequence number: 99 10 [Extended sequence number: 65635] 11 Timestamp: 1600 12 Synchronization Source identifier: 0xeeba3c7a (4005182586) 13 Payload [truncated]: d5d5d5d5d5555555d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5555555d5d5d5d5d555d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d555d555d5d5d5555555d5d5d5d5d55555555555d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d5d55842415855dfdadb 1Real-Time Transport Protocol 2 [Stream setup by SDP (frame 43)] 3 10.. .... = Version: RFC 1889 Version (2) 4 ..0. .... = Padding: False 5 ...0 .... = Extension: False 6 .... 0000 = Contributing source identifiers count: 0 7 0... .... = Marker: False 8 Payload type: ITU-T G.711 PCMA (8) 9 Sequence number: 100 10 [Extended sequence number: 65636] 11 Timestamp: 1760 12 Synchronization Source identifier: 0xeeba3c7a (4005182586) 13 Payload [truncated]: 9c8eb6b1b2b1806e353f383c37001676d5d4d7c5f3e6ecece0f0d5e1919e838c8d87849996ecd2667154c2eb9517083c27212738371adce8969d979c99e6d06c1211c9cbfd919998848eb5b5b58e83808088b7b68c907b070d011a6de89b878c8e8d809ee8446b101b1905051a 1Real-Time Transport Protocol 2 [Stream setup by SDP (frame 43)] 3 10.. .... = Version: RFC 1889 Version (2) 4 ..0. .... = Padding: False 5 ...0 .... = Extension: False 6 .... 0000 = Contributing source identifiers count: 0 7 0... .... = Marker: False 8 Payload type: ITU-T G.711 PCMA (8) 9 Sequence number: 101 10 [Extended sequence number: 65637] 11 Timestamp: 1920 12 Synchronization Source identifier: 0xeeba3c7a (4005182586) 13 Payload [truncated]: a6a4beb784df6d6f151116681c12681e1a010b343737363735350e0605126b66707144d19392848f8fed140f3d3e383d360804114be992808d8281838787839d9380868fb5b58bb7b1b4b5b3b3b3bbb8b78710303b38383f32363135041867d4f1e6ee949d85e4621c34313630 。。。。 一直是最后几个rtp包\n1Real-Time Transport Protocol 2 [Stream setup by SDP (frame 43)] 3 10.. .... = Version: RFC 1889 Version (2) 4 ..0. .... = Padding: False 5 ...0 .... = Extension: False 6 .... 0000 = Contributing source identifiers count: 0 7 0... .... = Marker: False 8 Payload type: ITU-T G.711 PCMA (8) 9 Sequence number: 347 10 [Extended sequence number: 65883] 11 Timestamp: 41280 12 Synchronization Source identifier: 0xeeba3c7a (4005182586) 13 Payload [truncated]: 7397919d98999c96cd7d621c1101093432323d3c3c3c38383c3f360d6beb9e8e8e888b898bb4b4b3bfbaa7a7a4a5b9b9b3b688818693ed49101a02080b353534350b02010507000c0f3534340b0d05116313121a181f1c181d111c131b121763c4ec9f87838f888bb4b4b4b5b4 1Real-Time Transport Protocol 2 [Stream setup by SDP (frame 43)] 3 10.. .... = Version: RFC 1889 Version (2) 4 ..0. .... = Padding: False 5 ...0 .... = Extension: False 6 .... 0000 = Contributing source identifiers count: 0 7 0... .... = Marker: False 8 Payload type: ITU-T G.711 PCMA (8) 9 Sequence number: 348 10 [Extended sequence number: 65884] 11 Timestamp: 41440 12 Synchronization Source identifier: 0xeeba3c7a (4005182586) 13 Payload [truncated]: b8baa5bab9bdb18883859debf9516011060b32382524243a383234021b1779c5e0979e84838eb5b7b48b898d83869b91ebf35d791411121316176ec59f8cb1bfb8bbbcb18d905d171919136d7d49641416121c18040704051a05000d0e353736333c3825253a383d3609001a1c seq一直在涨，timestamp是160地增长\n停止放音 MS INFO。这个是由只前的INFO里的msml控制的时间\n1Session Initiation Protocol (INFO) 2 Request-Line: INFO sip:sipp@10.4.6.199:5060 SIP/2.0 3 Message Header 4 Via: SIP/2.0/UDP 10.1.68.48:5080;branch=z9hG4bK9MCm3mhRXjX 5 To: \u0026lt;sip:sipp@10.4.6.199:5060\u0026gt;;tag=1 6 From: \u0026lt;sip:service@10.1.68.48:5080\u0026gt;;tag=YRrWa7c2kH 7 Call-Id: 1-33212@10.4.6.199 8 [Generated Call-ID: 1-33212@10.4.6.199] 9 CSeq: 1 INFO 10 Content-Type: application/msml+xml 11 Content-Length: 216 12 Message Body 13 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt;\\n 14 \u0026lt;msml version=\u0026#34;1.1\u0026#34;\u0026gt;\\n 15 \u0026lt;event name=\u0026#34;done\u0026#34; id=\u0026#34;conn:12345/dialog:12345\u0026#34;\u0026gt;\\n 16 \u0026lt;name\u0026gt;play.end\u0026lt;/name\u0026gt;\\n 17 \u0026lt;value\u0026gt;play.complete\u0026lt;/value\u0026gt;\\n 18 \u0026lt;name\u0026gt;play.amt\u0026lt;/name\u0026gt;\\n 19 \u0026lt;value\u0026gt;5s\u0026lt;/value\u0026gt;\\n 20 \u0026lt;/event\u0026gt;\\n 21 \u0026lt;/msml\u0026gt; UAC 回复\n1Session Initiation Protocol (200) 2 Status-Line: SIP/2.0 200 OK 3 Message Header 4 Via: SIP/2.0/UDP 10.1.68.48:5080;branch=z9hG4bK9MCm3mhRXjX 5 From: \u0026lt;sip:service@10.1.68.48:5080\u0026gt;;tag=YRrWa7c2kH 6 To: \u0026lt;sip:sipp@10.4.6.199:5060\u0026gt;;tag=1 7 Call-ID: 1-33212@10.4.6.199 8 [Generated Call-ID: 1-33212@10.4.6.199] 9 CSeq: 1 INFO 10 Contact: \u0026lt;sip:10.4.6.199:5060;transport=UDP\u0026gt; 11 Content-Length: 0 断开连接 UAC BYE\n1Session Initiation Protocol (BYE) 2 Request-Line: BYE sip:service@10.1.68.48:5080 SIP/2.0 3 Message Header 4 Via: SIP/2.0/UDP 10.4.6.199:5060;branch=z9hG4bK-33212-1-9 5 From: sipp \u0026lt;sip:sipp@10.4.6.199:5060\u0026gt;;tag=1 6 To: sut \u0026lt;sip:service@10.1.68.48:5080\u0026gt;;tag=YRrWa7c2kH 7 Call-ID: 1-33212@10.4.6.199 8 [Generated Call-ID: 1-33212@10.4.6.199] 9 CSeq: 10 BYE 10 Contact: sip:sipp@10.4.6.199:5060 11 Max-Forwards: 70 12 Subject: Performance Test 13 Content-Length: 0 MS 回复\n1Session Initiation Protocol (200) 2 Status-Line: SIP/2.0 200 OK 3 Message Header 4 Via: SIP/2.0/UDP 10.4.6.199:5060;branch=z9hG4bK-33212-1-9 5 To: sut \u0026lt;sip:service@10.1.68.48:5080\u0026gt;;tag=YRrWa7c2kH 6 From: sipp \u0026lt;sip:sipp@10.4.6.199:5060\u0026gt;;tag=1 7 Call-ID: 1-33212@10.4.6.199 8 [Generated Call-ID: 1-33212@10.4.6.199] 9 CSeq: 10 BYE 10 Content-Length: 0 结合SIPP测试脚本 可以清晰地看见交互的过程，这个场景文件就是把交互流程规划好了。\n1\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34; ?\u0026gt; 2\u0026lt;!DOCTYPE scenario SYSTEM \u0026#34;sipp.dtd\u0026#34;\u0026gt; 3 4 5\u0026lt;scenario name=\u0026#34;Basic Sipstone UAC\u0026#34;\u0026gt; 6 7\u0026lt;!--------------------------------------------------------------\u0026gt; 8\u0026lt;!-- Start Conversation --\u0026gt; 9\u0026lt;!--------------------------------------------------------------\u0026gt; 10 11\u0026lt;send retrans=\u0026#34;500\u0026#34;\u0026gt; 12 \u0026lt;![CDATA[ 1314INVITE sip:[service]@[remote_ip]:[remote_port] SIP/2.0 15Via: SIP/2.0/[transport] [local_ip]:[local_port];branch=[branch] 16From: sipp \u0026lt;sip:sipp@[local_ip]:[local_port]\u0026gt;;tag=[call_number] 17To: sut \u0026lt;sip:[service]@[remote_ip]:[remote_port]\u0026gt; 18Call-ID: [call_id] 19CSeq: 1 INVITE 20Contact: sip:sipp@[local_ip]:[local_port] 21Max-Forwards: 70 22Subject: Performance Test 23Content-Type: application/sdp 24Content-Length: [len] 2526v=0 27o=caller 0 0 IN IP4 10.1.93.116 28s=MobileVrbt_UEA_User_Caller_18500000000_18600000000 29i=- 30c=IN IP4 10.4.6.199 31t=0 0 32m=audio 5002 RTP/AVP 8 33]]\u0026gt; 34\u0026lt;/send\u0026gt; 35 36\u0026lt;recv response=\u0026#34;100\u0026#34; optional=\u0026#34;true\u0026#34;\u0026gt; 37\u0026lt;/recv\u0026gt; 38 39\u0026lt;recv response=\u0026#34;200\u0026#34; rtd=\u0026#34;true\u0026#34;\u0026gt; 40\u0026lt;/recv\u0026gt; 41 42\u0026lt;!--------------------------------------------------------------\u0026gt; 43\u0026lt;!-- Start Pa --\u0026gt; 44\u0026lt;!--------------------------------------------------------------\u0026gt; 45\u0026lt;send\u0026gt; 46 \u0026lt;![CDATA[ 4748ACK sip:[service]@[remote_ip]:[remote_port] SIP/2.0 49Via: SIP/2.0/[transport] [local_ip]:[local_port];branch=[branch] 50From: sipp \u0026lt;sip:sipp@[local_ip]:[local_port]\u0026gt;;tag=[call_number] 51To: sut \u0026lt;sip:[service]@[remote_ip]:[remote_port]\u0026gt;[peer_tag_param] 52Call-ID: [call_id] 53CSeq: 1 ACK 54Contact: sip:sipp@[local_ip]:[local_port] 55Max-Forwards: 70 56Subject: Performance Test 57Content-Length: 0 5859]]\u0026gt; 60\u0026lt;/send\u0026gt; 61 62\u0026lt;pause milliseconds=\u0026#34;1000\u0026#34; /\u0026gt; 63 64\u0026lt;send retrans=\u0026#34;500\u0026#34;\u0026gt; 65 \u0026lt;![CDATA[ 6667INFO sip:[service]@[remote_ip]:[remote_port] SIP/2.0 68Via: SIP/2.0/[transport] [local_ip]:[local_port];branch=[branch] 69From: sipp \u0026lt;sip:sipp@[local_ip]:[local_port]\u0026gt;;tag=[call_number] 70To: sut \u0026lt;sip:[service]@[remote_ip]:[remote_port]\u0026gt;[peer_tag_param] 71Call-ID: [call_id] 72CSeq: 2 INFO 73Contact: sip:sipp@[local_ip]:[local_port] 74Max-Forwards: 70 75Subject: Performance Test 76Content-Type: application/msml+xml 77Content-Length: [len] 7879\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; 80\u0026lt;msml version=\u0026#34;1.1\u0026#34;\u0026gt; 81\u0026lt;dialogstart target=\u0026#34;conn:12345\u0026#34; name=\u0026#34;12345\u0026#34;\u0026gt; 82\u0026lt;play barge=\u0026#34;true\u0026#34; iterate=\u0026#34;1\u0026#34; interval=\u0026#34;1\u0026#34; maxtime=\u0026#34;5\u0026#34; id=\u0026#34;play\u0026#34;\u0026gt; 83\u0026lt;audio uri=\u0026#34;audio.wav\u0026#34; /\u0026gt; 84\u0026lt;playexit\u0026gt; 85\u0026lt;send target=\u0026#34;source\u0026#34; event=\u0026#34;done\u0026#34; valuelist=\u0026#34;play.end play.amt\u0026#34;/\u0026gt; 86\u0026lt;/playexit\u0026gt; 87\u0026lt;/play\u0026gt; 88\u0026lt;/dialogstart\u0026gt; 89\u0026lt;/msml\u0026gt;]]\u0026gt; 90\u0026lt;/send\u0026gt; 91 92\u0026lt;recv response=\u0026#34;200\u0026#34; crlf=\u0026#34;true\u0026#34;\u0026gt; 93\u0026lt;/recv\u0026gt; 94 95\u0026lt;recv request=\u0026#34;INFO\u0026#34; crlf=\u0026#34;true\u0026#34;\u0026gt; 96\u0026lt;/recv\u0026gt; 97 98\u0026lt;send\u0026gt; 99 \u0026lt;![CDATA[ 100101SIP/2.0 200 OK 102[last_Via:] 103[last_From:] 104[last_To:] 105[last_Call-ID:] 106[last_CSeq:] 107Contact: \u0026lt;sip:[local_ip]:[local_port];transport=[transport]\u0026gt; 108Content-Length: 0 109110]]\u0026gt; 111 \u0026lt;/send\u0026gt; 112 113\u0026lt;!--------------------------------------------------------------\u0026gt; 114\u0026lt;!-- End Conversation --\u0026gt; 115\u0026lt;!--------------------------------------------------------------\u0026gt; 116\u0026lt;send retrans=\u0026#34;500\u0026#34;\u0026gt; 117 \u0026lt;![CDATA[ 118119BYE sip:[service]@[remote_ip]:[remote_port] SIP/2.0 120Via: SIP/2.0/[transport] [local_ip]:[local_port];branch=[branch] 121From: sipp \u0026lt;sip:sipp@[local_ip]:[local_port]\u0026gt;;tag=[call_number] 122To: sut \u0026lt;sip:[service]@[remote_ip]:[remote_port]\u0026gt;[peer_tag_param] 123Call-ID: [call_id] 124CSeq: 10 BYE 125Contact: sip:sipp@[local_ip]:[local_port] 126Max-Forwards: 70 127Subject: Performance Test 128Content-Length: 0 129130]]\u0026gt; 131\u0026lt;/send\u0026gt; 132 133\u0026lt;recv response=\u0026#34;500\u0026#34; crlf=\u0026#34;true\u0026#34; optional=\u0026#34;true\u0026#34;\u0026gt; 134\u0026lt;/recv\u0026gt; 135 136\u0026lt;recv response=\u0026#34;200\u0026#34; crlf=\u0026#34;true\u0026#34; timeout=\u0026#34;2000\u0026#34;\u0026gt; 137\u0026lt;/recv\u0026gt; 138 139\u0026lt;!-- definition of the response time repartition table (unit is ms) --\u0026gt; 140\u0026lt;ResponseTimeRepartition value=\u0026#34;10, 20, 30, 40, 50, 100, 150, 200\u0026#34;/\u0026gt; 141 142\u0026lt;!-- definition of the call length repartition table (unit is ms) --\u0026gt; 143\u0026lt;CallLengthRepartition value=\u0026#34;10, 50, 100, 500, 1000, 5000, 10000\u0026#34;/\u0026gt; 144 145\u0026lt;/scenario\u0026gt; ","date":"2025-01-10","permalink":"/posts/tech/media-netpackage-observe/","series":["媒体开发"],"tags":["","",""],"title":"观察SIP， SDP，RTP包及MSML"},{"categories":["计算机"],"content":"https://blog.csdn.net/szkbsgy/article/details/136746831\nhttps://www.cnblogs.com/timmy6688/archive/2013/04/17/3026687.html\nSIPP是针对SIP协议 的一个性能测试的命令行工具，可以动态显示测试的统计信息（如呼叫速率、延时、消息统计等）。用户可以通过XML场景配置文件，自定义模拟各种UAC/UAS测试场景的信令交互流程，可以被用来测试IP话机、SIP代理、SIP PBX等SIP设备。\n官方网站：https://sipp.sourceforge.net/ 英文参考文档：https://sipp.sourceforge.net/doc/reference.pdf\n1Usage: 2 3 sipp remote_host[:remote_port] [options] 4 5Example: 6 7 Run SIPp with embedded server (uas) scenario: 8 ./sipp -sn uas 9 On the same host, run SIPp with embedded client (uac) scenario: 10 ./sipp -sn uac 127.0.0.1 参数   -v\n显示版本信息\n  -bg\n后台模式运行\n  -sd\n输出SIPP内嵌的默认场景\n1sipp -sd \u0026lt;uac/uas/uac_pcap\u0026gt; 2 3 uac: uac场景 4 uas: uas场景 5 uac_pcap: uac带媒体场景 将场景内容重定向到文件\n1sipp -sd uas \u0026gt; uas.xml   -sf\n加载指定的场景文件\n1sipp -sf uas.xml   -sn \u0026lt;uac/uas\u0026gt;\n使用默认的内置场景文件\n1sipp -sn uas 2sipp -sn uac   -t \u0026lt;u1/un/t1/tn\u0026gt;\n设置传输方式\n1u1: 使用一个UDP 2un: 一个呼叫用一个UDP 3t1: 使用一个TCP 4tn: 一个呼叫使用一个TCP   -i\n设置本地的IP地址，如contact,via,from\n1sip -i 192.168.1.100   -p\n设置本地的端口\n1sip -p 5060   -bind_local\n绑定本地IP地址\n  -ci\n本地控制IP\n  -cp\n本地控制PORT\n  -m\n您可以拨打指定数量的呼叫，并在完成此操作后退出SIPp。在命令行中使用-m选项\n比如 -m 1就是只打一个。\n  场景 可以从在线参考文档（https://sipp.sourceforge.net/doc/reference.pdf) 中的链接获取一些内置的测试场景的xml模板，手动改变其中的一些参数或流程形成目标场景文件。\n1.uac发送音频：还可以发rtp，具体看文档。\n1\u0026lt;nop\u0026gt; 2\t\u0026lt;action\u0026gt; 3\t\u0026lt;exec play_pcap_audio=\u0026#34;pcap/g711a.pcap\u0026#34;/\u0026gt; 4\t\u0026lt;/action\u0026gt; 5\u0026lt;/nop\u0026gt; 2.测试样例\n这里面invite中的sdp的c字段负责了收音地址，说实话我学sdp的时候不晓得有这回事。\n1\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34; ?\u0026gt; 2\u0026lt;!DOCTYPE scenario SYSTEM \u0026#34;sipp.dtd\u0026#34;\u0026gt; 3 4 5\u0026lt;scenario name=\u0026#34;Basic Sipstone UAC\u0026#34;\u0026gt; 6 7\u0026lt;!--------------------------------------------------------------\u0026gt; 8\u0026lt;!-- Start Conversation --\u0026gt; 9\u0026lt;!--------------------------------------------------------------\u0026gt; 10 11\u0026lt;send retrans=\u0026#34;500\u0026#34;\u0026gt; 12 \u0026lt;![CDATA[ 1314INVITE sip:[service]@[remote_ip]:[remote_port] SIP/2.0 15Via: SIP/2.0/[transport] [local_ip]:[local_port];branch=[branch] 16From: sipp \u0026lt;sip:sipp@[local_ip]:[local_port]\u0026gt;;tag=[call_number] 17To: sut \u0026lt;sip:[service]@[remote_ip]:[remote_port]\u0026gt; 18Call-ID: [call_id] 19CSeq: 1 INVITE 20Contact: sip:sipp@[local_ip]:[local_port] 21Max-Forwards: 70 22Subject: Performance Test 23Content-Type: application/sdp 24Content-Length: [len] 2526v=0 27o=caller 0 0 IN IP4 10.1.93.116 28s=MobileVrbt_UEA_User_Caller_18500000000_18600000000 29i=- 30c=IN IP4 10.1.68.48 31t=0 0 32m=audio 5002 RTP/AVP 8 33]]\u0026gt; 34\u0026lt;/send\u0026gt; 35 36\u0026lt;recv response=\u0026#34;100\u0026#34; optional=\u0026#34;true\u0026#34;\u0026gt; 37\u0026lt;/recv\u0026gt; 38 39\u0026lt;recv response=\u0026#34;200\u0026#34; rtd=\u0026#34;true\u0026#34;\u0026gt; 40\u0026lt;/recv\u0026gt; 41 42\u0026lt;!--------------------------------------------------------------\u0026gt; 43\u0026lt;!-- Start Pa --\u0026gt; 44\u0026lt;!--------------------------------------------------------------\u0026gt; 45\u0026lt;send\u0026gt; 46 \u0026lt;![CDATA[ 4748ACK sip:[service]@[remote_ip]:[remote_port] SIP/2.0 49Via: SIP/2.0/[transport] [local_ip]:[local_port];branch=[branch] 50From: sipp \u0026lt;sip:sipp@[local_ip]:[local_port]\u0026gt;;tag=[call_number] 51To: sut \u0026lt;sip:[service]@[remote_ip]:[remote_port]\u0026gt;[peer_tag_param] 52Call-ID: [call_id] 53CSeq: 1 ACK 54Contact: sip:sipp@[local_ip]:[local_port] 55Max-Forwards: 70 56Subject: Performance Test 57Content-Length: 0 5859]]\u0026gt; 60\u0026lt;/send\u0026gt; 61 62\u0026lt;pause milliseconds=\u0026#34;1000\u0026#34; /\u0026gt; 63 64\u0026lt;send retrans=\u0026#34;500\u0026#34;\u0026gt; 65 \u0026lt;![CDATA[ 6667INFO sip:[service]@[remote_ip]:[remote_port] SIP/2.0 68Via: SIP/2.0/[transport] [local_ip]:[local_port];branch=[branch] 69From: sipp \u0026lt;sip:sipp@[local_ip]:[local_port]\u0026gt;;tag=[call_number] 70To: sut \u0026lt;sip:[service]@[remote_ip]:[remote_port]\u0026gt;[peer_tag_param] 71Call-ID: [call_id] 72CSeq: 2 INFO 73Contact: sip:sipp@[local_ip]:[local_port] 74Max-Forwards: 70 75Subject: Performance Test 76Content-Type: application/msml+xml 77Content-Length: [len] 7879\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; 80\u0026lt;msml version=\u0026#34;1.1\u0026#34;\u0026gt; 81\u0026lt;dialogstart target=\u0026#34;conn:12345\u0026#34; name=\u0026#34;12345\u0026#34;\u0026gt; 82\u0026lt;play barge=\u0026#34;true\u0026#34; iterate=\u0026#34;1\u0026#34; interval=\u0026#34;1\u0026#34; maxtime=\u0026#34;5\u0026#34; id=\u0026#34;play\u0026#34;\u0026gt; 83\u0026lt;audio uri=\u0026#34;audio.wav\u0026#34; /\u0026gt; 84\u0026lt;playexit\u0026gt; 85\u0026lt;send target=\u0026#34;source\u0026#34; event=\u0026#34;done\u0026#34; valuelist=\u0026#34;play.end play.amt\u0026#34;/\u0026gt; 86\u0026lt;/playexit\u0026gt; 87\u0026lt;/play\u0026gt; 88\u0026lt;/dialogstart\u0026gt; 89\u0026lt;/msml\u0026gt;]]\u0026gt; 90\u0026lt;/send\u0026gt; 91 92\u0026lt;recv response=\u0026#34;200\u0026#34; crlf=\u0026#34;true\u0026#34;\u0026gt; 93\u0026lt;/recv\u0026gt; 94 95\u0026lt;recv request=\u0026#34;INFO\u0026#34; crlf=\u0026#34;true\u0026#34;\u0026gt; 96\u0026lt;/recv\u0026gt; 97 98\u0026lt;send\u0026gt; 99 \u0026lt;![CDATA[ 100101SIP/2.0 200 OK 102[last_Via:] 103[last_From:] 104[last_To:] 105[last_Call-ID:] 106[last_CSeq:] 107Contact: \u0026lt;sip:[local_ip]:[local_port];transport=[transport]\u0026gt; 108Content-Length: 0 109110]]\u0026gt; 111 \u0026lt;/send\u0026gt; 112 113\u0026lt;!--------------------------------------------------------------\u0026gt; 114\u0026lt;!-- End Conversation --\u0026gt; 115\u0026lt;!--------------------------------------------------------------\u0026gt; 116\u0026lt;send retrans=\u0026#34;500\u0026#34;\u0026gt; 117 \u0026lt;![CDATA[ 118119BYE sip:[service]@[remote_ip]:[remote_port] SIP/2.0 120Via: SIP/2.0/[transport] [local_ip]:[local_port];branch=[branch] 121From: sipp \u0026lt;sip:sipp@[local_ip]:[local_port]\u0026gt;;tag=[call_number] 122To: sut \u0026lt;sip:[service]@[remote_ip]:[remote_port]\u0026gt;[peer_tag_param] 123Call-ID: [call_id] 124CSeq: 10 BYE 125Contact: sip:sipp@[local_ip]:[local_port] 126Max-Forwards: 70 127Subject: Performance Test 128Content-Length: 0 129130]]\u0026gt; 131\u0026lt;/send\u0026gt; 132 133\u0026lt;recv response=\u0026#34;500\u0026#34; crlf=\u0026#34;true\u0026#34; optional=\u0026#34;true\u0026#34;\u0026gt; 134\u0026lt;/recv\u0026gt; 135 136\u0026lt;recv response=\u0026#34;200\u0026#34; crlf=\u0026#34;true\u0026#34; timeout=\u0026#34;2000\u0026#34;\u0026gt; 137\u0026lt;/recv\u0026gt; 138 139\u0026lt;!-- definition of the response time repartition table (unit is ms) --\u0026gt; 140\u0026lt;ResponseTimeRepartition value=\u0026#34;10, 20, 30, 40, 50, 100, 150, 200\u0026#34;/\u0026gt; 141 142\u0026lt;!-- definition of the call length repartition table (unit is ms) --\u0026gt; 143\u0026lt;CallLengthRepartition value=\u0026#34;10, 50, 100, 500, 1000, 5000, 10000\u0026#34;/\u0026gt; 144 145\u0026lt;/scenario\u0026gt; 示例   运行内置uac，uas\n1sipp -sn uas 2sipp -sn uac   指定自定义场景\n1sipp -sf my_uas.xml 2sipp -sf uas.xml -i 192.168.1.200 5060   自己测试自己\n1sipp -sn uas -i 127.0.0.1 -p 5060 1sipp -sn uac 127.0.\t0.1:5060   打一个电话\n1sipp -sf uac.xml 10.1.1.1:5060 -i 10.1.1.2 -m 1   wireshark抓包过滤，直接抓服务器的ip：\nip.dst == 10.1.68.48 || ip.src == 10.1.68.48\n","date":"2025-01-09","permalink":"/posts/tech/media-sipp/","series":["媒体开发"],"tags":["","",""],"title":"SIPP测试工具学习"},{"categories":["计算机"],"content":"没有看完，需要的时候再补充\nhttps://sunkx.blog.csdn.net/article/details/144061374\n简介 SIP（Session Initiation Protocol， 会话初始化协议）是一个用于在IP网络中建立、修改和终止多媒体会话的应用层协议，广泛应用于VoIP（Voice over IP，语音通信）、视频通话、即时消息和其他实时通信服务。SIP应用层协议。SIP和HTTP类似，都是请求-响应模式。\nSIP发展过程：RFC 2543\u0026mdash;-第一个SIP规范；RFC 3261\u0026mdash;-SIP基础确立；RFC 3262\u0026mdash;-对临时响应的可靠性作规定；RFC 3263\u0026mdash;-确立SIP代理服务器的定位规则；RFC 3264\u0026mdash;-提供提议/应答模型；RFC 3265\u0026mdash;-确定具体的事件通知。\nSIP协议的基本功能：\n 会话建立与终止： SIP的核心功能是发起、管理和终止会话。无论是语音通话、视频会议还是数据共享，SIP都能够提供会话初始化、修改以及结束的能力。 用户位置定位： SIP可以通过地址解析和位置服务，确定目标用户的当前地址（例如IP地址），使得一个用户可以通过统一的SIP地址（如sip:username@domain.com）进行联系。 多媒体传输协商： SIP不仅仅用于建立连接，还可以协商会话的媒体参数。例如，它可以确定使用哪些编解码器，视频分辨率、音频质量等，这些通过SDP（Session Description Protocol， 会话描述协议）进行描述。 支持会话修改： 在会话进行中，SIP允许动态修改会话内容，例如添加视频、改变音频编解码器、切换通话质量等。 会话控制与注册： SIP协议允许用户进行注册并通过代理服务器进行会话控制，从而支持分布式网络环境中的通信。  SIP的应用场景：\n VoIP电话： SIP是VoIP（基于IP的语音通信）技术的核心协议，用于建立和管理语音通话。通过SIP，用户可以在IP网络上进行语音通信。 视频会议： SIP不仅支持音频通话，也支持视频通话，通过协商媒体参数，用户可以在不同终端之间进行视频会议。 即时消息： SIP协议可用于实时聊天应用的消息交换，允许用户之间进行文本聊天。 多媒体流服务： 除了语音和视频，SIP也可以用于多媒体流的传输和管理，支持多种实时数据传输。  通俗地说，SIP就是用来 建立、管理和结束 语音、视频等实时通信的调度协议。帮助我们通过互联网进行类似电话通话、视频会议、即时消息等实时通讯。例如，当你打电话、视频聊天或者进行网络会议时，SIP协议会负责以下工作：\n **连接的建立：**当你想打电话给别人时，SIP负责发出请求，找到对方，并建立连接。 媒体协商：它确保你和对方都能使用相同的音频/视频格式和传输方式，比如你们都用高清音频、高清视频。 **会话管理：**在通话进行中，SIP还可以帮助你在通话过程中调整设置、。 会话终止：当通话结束时，SIP会发出通知，关闭连接。  组成部分 学习SIP，需要知道SIP中的四个角色(SIP系统组成部分)：SIP用户代理、SIP注册服务器、SIP代理服务器、SIP重定向服务器。\n1. SIP用户代理（UA，User Agent） SIP用户代理是终端设备或应用程序，用于发起和接收SIP请求和响应。可以是一个VoIP电话、软电话、视频会议终端等设备。用户代理有两种角色：\n用户代理客户端（UAC，User Agent Client）：负责发起SIP请求（例如发起呼叫请求）。例如，当你拨打电话时，你的设备就是UAC。 用户代理服务器（UAS，User Agent Server）：负责响应SIP请求。它接收来自UAC的请求，并根据请求进行相应的操作。例如，当你接听电话时，你的设备就扮演着UAS的角色。 总之，SIP用户代理是SIP协议中的端点，允许用户进行实时通信。\n2. SIP注册服务器（Registrar Server） SIP注册服务器用于接收并存储SIP用户的注册信息。当一个SIP设备（例如电话）连接到网络时，它会向SIP注册服务器发送一个注册请求，告诉服务器自己当前的IP地址或者其他信息。其他用户可以通过注册服务器来找到该设备。\n当你在不同的网络或设备上登录时，注册服务器确保其他人能够找到你并与你建立通信。 例如，SIP设备A在启动时会向注册服务器发送一个请求，告知它自己可以接受呼叫的地址或位置。\n3. SIP代理服务器（Proxy Server） SIP代理服务器是SIP通信中的中介，它负责转发SIP请求和响应。代理服务器不会直接处理呼叫或会话内容，它主要负责以下任务：\n路由请求：当一个SIP用户想要联系另一个SIP用户时，SIP代理服务器会根据请求的目标地址，决定如何转发该请求（例如，选择合适的服务器或代理）。 请求处理：代理服务器会检查和修改请求的头部信息，确保请求按照正确的路径转发。例如，如果目标用户不在线，代理服务器可能会将请求转发到备用服务器或者重定向到另一个地址。 SIP代理服务器通常也会处理认证和授权等功能，确保通信的安全性。\n4. SIP重定向服务器（Redirect Server） SIP重定向服务器的作用是告知发起请求的用户代理请求的目标地址。与代理服务器不同，重定向服务器不负责转发请求，它只提供目标地址的重定向信息。它的工作方式是：\n当SIP用户尝试联系另一方时，重定向服务器会告知用户代理“该目标用户现在在其他地方”，并提供新的目标地址或位置。发起请求的用户代理会根据这些新的信息重新发起请求，从而完成通信连接。简单来说，重定向服务器只返回一条“指路”的信息，它告诉你该向哪里去找到目标，而不是直接转发请求。\n这四个角色如何协同工作？ 假设有一个SIP用户A想要与SIP用户B建立通信：\n SIP用户A（UAC）和用户B（UAS）都向 SIP注册服务器 发送注册请求，告知服务器它们的当前位置（例如，IP地址）。 当SIP用户A想打电话给SIP用户B时，它会发送一个SIP请求到 SIP代理服务器，代理服务器负责根据B的地址和注册信息路由请求。 如果SIP代理服务器找不到SIP用户B，它可能会询问 SIP重定向服务器，后者会告诉代理服务器B的当前位置（例如B的新IP地址）。 SIP代理服务器会根据重定向信息重新发起请求，直到找到B并建立连接。  通过这些角色的协作，SIP协议能够实现跨网络、跨设备的实时通信。\nSIP注册服务器、SIP代理服务器和SIP重定向服务器通常可以是独立的服务，也可以由一个中心服务集成来共同承担这些角色。具体的实现方式取决于系统架构、需求和规模等因素。\nSIP报文概述 SIP报文格式和HTTP完全一样，只不过里面的值不一样，使用的错误码也是一样，比如200表示请求成功，40x表示客户端错误，50x表示服务端错误，这样SIP就很好理解了。HTTP有GET、POST等方法，同样SIP也有自己的方法。\nSIP中常见的方法如下：\n1INVITE：表示主叫用户发起会话，邀请其他用户加入一个会话，也可以用在呼叫建立后用于更新会话（此时INVITE又称为Re-invite) 2ACK：客户端向服务器端证实它已经收到了对INVITE请求的最终响应。 3PRACK：表示对1XX响应信息的确认请求消息。 4BYE：表示终止一个已经建立的呼叫。 5CANCEL：表示在收到对请求的最终响应之前取消该请求，对于已完成的请求则无影响。 6REGISTER：表示客户端向SIP服务器端注册列在To字段中的地址信息。 7OPTIONS：表示查询被呼叫的相关信息和功能。 ​ SIP常见的错误码如下：\n1100试呼叫（Trying) 2180振铃（Ringing） 3181呼叫正在前转（Call is Being Forwarded) 4200成功响应（OK） 5302临时迁移（Moved Temporarily) 6400错误请求（Bad Request) 7401未授权（Unauthorized) 8403禁止（Forbidden) 9404用户不存在（Not Found） 10480暂时无人接听（Temporarily Unavailable) 11486线路忙（Busy Here) 12504服务器超时（Server Time-out) 13600全忙（Busy Everywhere) SIP交互流程 介绍SIP交互流程之前需要知道SIP有两种会话模式：Session Model和Pager Model。\n会话中，对于消息体内容大于1300字节时，一般采用Session Model；对于消息体不大于1300字节时，一般采用Pager Model。\nSession Model和Pager Model区别如下：\n   特点 Session Model Pager Model     通信类型 双向实时通信 单向消息发送   会话持久性 持久的会话，双方可实时互动 息单向发送，接收方可稍后回复   建立过程 需要通过INVITE建立会话 不需要会话建立   实时性 高实时性，需要双方即时响应 较低实时性，接收方可以稍后回复   应用场景 语音、视频通话、实时聊天 短信、电子邮件、离线消息通知    Session Model 0：用户A和用户B在终端启用之后都会向注册服务器注册自己的信息（ip地址、账号等）；\n1：主叫方A发送INVITE请求到代理服务器1；\n2：代理服务器1发送100 Trying响应，试呼叫主叫方A；\n3-6：代理服务器搜索被叫方B的地址，获取地址后转发INVITE请求；\n7-9：被叫方B生成的180振铃响应，返回给主叫方A；\n10-12：被叫方B生成的200 OK响应，返回给主叫方A；\n13-17：主叫方A收到被叫方B200 OK响应后，向被叫方B发送一个ACK，会话建立；\n开始发送RTP消息流。\n18-20：会话结束后，任何参与者（A或B）都可以发送一个bye请求来终止会话；\n21-23：主叫方A发送200 OK响应来确认bye，会话终止。\n注意：连接建立之后的音视频传输就不经过代理服务器了，是用户之间直接传输（p2p）。\nPager Model Pager Model采用Message方法，Message方法本身并不建立Dialog，在多数应用中，每条IM消息都是独立的，SIP信令交互流程：用户1发送msg，到proxy，proxy发送msg到用户2,这就收到了；然后收到之后用户2发送”200ok“给proxy，proxy转发给用户1。\nPager Model息单向发送，接收方可稍后回复，所以200 OK是虚线。\nSIP信令交互中的3个定义 用户A、B之间SIP信令交互过程中有三个定义：dialog（对话）、session（会话）、transaction（事务）\n Transaction事务：是指一个请求消息以及这个请求对应的所有响应消息的集合。 Dialog对话：是两个UA之间持续一段时间的点对点的SIP连接。 Session会话：是一次通信过程中所有参与者之间的关联关系以及他们之间的媒体流的集合。  媒体传输 两个用户进行SIP信令交互的最终目的就是进行音视频通话，因此双方要进行媒体协商，SIP媒体协商使用的是SDP协议。媒体协商完毕之后，双方使用RTP协议进行音视频传输。\nSDP（Session Description Protocol） 是一种用于描述多媒体会话的格式。主要用于描述会话的多媒体内容（例如音频、视频，以及编码格式）和传输方式（如传输协议、端口号等）。\n1sip呼叫里SDP的一些字段的含义 2v=0 # sdp版本 3o=- 1 0 IN IP4 164.135.25.51 # o=\u0026lt;用户名\u0026gt; \u0026lt;会话id\u0026gt; \u0026lt;会话版本\u0026gt; \u0026lt;网络类型\u0026gt;\u0026lt;地址类型\u0026gt; \u0026lt;本机地址\u0026gt; 4s=SNS call # 用于传递会话主题 5c=IN IP4 164.135.25.51 # 记录media ip， 即接收RTP流的媒体地址，不一定是本机地址 6t=0 0 # 会话时间，一般由其它信令控制，故0 7 8m=audio 30254 RTP/AVP 0 # audio/音频接收端口(必须为偶数)/表示音频通过RTP传输/0表示允许音频的格式(见下一行\u0026#34;a=\u0026#34;) 9a=rtpmap:0 PCMU/8000 # 如果RTP头部的类型字段如果等于0，表示RTP负载用的数据是PCMU，8000采样率格式的音频 10a=sendrecv # 可以接收也可以发送音频 11 12m=video 30186 RTP/AVP 122 123 # video/视频接收端口(必须为偶数)/视频通过RTP传输/122,123表示允许视频的格式为122，123 13a=rtpmap:122 H264/90000 # 如果RTP头部的类型字段如果等于122，表示RTP负载用的数据是H264编码格式的视频 14a=fmtp:122 profle-level-id-64E01F;max-br=1152 # 122类型的视频编码参数 15a=rtpmap:123 H264/90000 # 如果RTP头部的类型字段如果等于123，表示RTP负载用的数据是H264编码格式的视频 SDP是在INVITE开始（SDP offer)，对方回复200 OK结束(SDP answer)。\nSIP消息Header字段 常见的SIP方法有：INVITE、ACK、PRACK、BYE、CANCEL、REGISTER、OPTIONS。在这些类型的SIP消息头部中包含的常见字段如下表所示：\n   Header 含义说明 举例     Call-ID 由本地设备(Client)生成，全局唯一，每次呼叫这个值唯一不变 Call-ID: asd88asd77a@1.2.3.4   From 表示请求的发起者 From: sip:user1@domain.com;tag=49583   To 表示请求的接收者 To: sip:user2@domain.com   Via Via头域是被服务器插入request中，用来检查路由环的，并且可以使response根据via找到返回的路 Via: SIP/2.0/TCP user1pc.domain.com;branch=z9hG4bK776sgdkse   Max-Forwards 用于表示这个包最多可以传送多少跳，每经过一跳都会减一当Max-Forwards==0系统会返回483。默认为70 Max-Forwards: 70   Contact 包含源的URI信息，用来给响应方直接和源建立连接用 Contact: sip:192.168.100.1:1111   Content-Type 指明消息体的类型 (SDP会话描述协议) Content-Type: text/plain；Content-Type: application/sdp; Content-Type: application/cpim;   Content-Length 指明消息体的字节大小 Content-Length: 18      via\nVia头域是收集经过的设备信息。一个SIP消息每经过一个Proxy（包括主叫），都会被加上一个Via头域，当消息到达被叫后，Via头域就记录了请求消息经过的完整路径。被叫将这些Via头域原样copy到响应消息中（包括各Via的参数，以及各Via的顺序），然后下发给第一个Via中的URI，每个Proxy转发响应消息前都会把第一个Via（也就是它自己添加的Via）删除，然后将消息转发给新的第一个Via中的URI，直到消息到达主叫。\n  tag\n用于在SIP消息中的 To 和 From 头部区分和标识不同的参与者。区分同一个会话中不同的SIP实体，尤其是当一个用户（或服务器）有多个可能的通信终端时。Tag 允许SIP协议区分从同一源发起的多个请求，通常是随机字符串或特定标识符。\nFrom: From: Alice \u0026lt;sip:alice@atlanta.com\u0026gt;;tag=client1 To: To: Bob \u0026lt;sip:bob@biloxi.com\u0026gt;;tag=client2  在这个例子中，发起方 Alice 使用了 client1 作为 From 的Tag，接收方 Bob 则使用了 client2 作为 To 的Tag。\nCall-ID、From（tag）、To （tag）这三个字段相同代表是同一个dailog对话。\n  branch\nbranch值相同，代表同一个 transaction(事务) Branch，每发起一个transaction(事务)都要重新生成一个branch；对于遵循RFC3261规范的实现，这个branch参数的值必须用magic cookie”z9hG4bK”打头. 其它部分是对“To, From, Call-ID头域和Request-URI”按一定的算法加密后得到。\n  路由","date":"2025-01-09","permalink":"/posts/tech/media-sip/","series":["媒体开发"],"tags":["","",""],"title":"SIP协议学习"},{"categories":["计算机"],"content":"安装 1git clone git://github.com/basho/rebar.git 2cd rebar 3make 4sudo cp rebar /usr/local/bin 或使用稳定的版本：\n1curl -o rebar http://cloud.github.com/downloads/basho/rebar/rebar 使用 rebar作者教程：http://vimeo.com/8311407\nrebar官方文档：https://github.com/basho/rebar/wiki\nrebar的工程配置文件 每个erlang工程会有一个rebar.config控制rebar的使用，当然rebar.config不是必须的，没有的话一切都按rebar缺省的来。rebar安装路径下有一个rebar.config.sample的文件，研究这个文件可以发现许多rebar的使用诀窍。\n使用rebar时加上-v参数可以详细的打印出rebar构建过程时的相关命令和参数，这有助于我们查看rebar.config文件的配置是否正确。\nrebar管理的工程目录结构 rebar管理的erlang工程应该遵循 erlang OTP的约定 ，项目的文件结构如下，子目录src, include下分别放置erlang源代码和hrl包含文件，priv和ebin目录分别放置编译好的lib库共享文件（或可执行文件）和beam文件（和其他文件例如app文件），这两个目录由rebar自动生成并清理，不要把重要的代码放在这两个目录下，虽然不会被rebar clean自动删掉，（不过编译好的beam文件都会删掉），但是也影响不好哈。\n此外对port drive和nif的开发，它们的c源程序应该放在c_src目录下。目前port driver和nif是被rebar无区别对待，因此有着同样的rebar控制参数。\n总结：源代码应该组织到src, include和c_src三个目录结构中，此外，eunit单元测试代码放在test目录下。rebar控制priv和ebin目录，源码或文档不要在这两个目录下。\nrebar模板的使用 rebar list-templates 子命令可以查看rebar缺省提供的工程模板（当然也可以创建自己的模板）\n模板是针对某种有着固定模式或结构的代码的，例如OTP的3个著名模式都有着各自的程序骨架，每次写一个srv或者fsm的模块，我们都得重复写许多固定的骨架代码，rebar通过模板帮我们省下了这些重复工作，我们只管往里面填应用的逻辑代码就行了。\n显然，simplesrv，simplefsm，simpleapp这三个模板是用来创建OTP的服务器模式，有限状态机模式和app应用模式的。\n注意在rebar中，这三个模式的约定名称：srv, fsm和app 。相应的，这些模板都有一个约定的控制变量，分别是srvid, fsmid和appid\n1rebar create template=simpleapp 2rebar create-app appid=anmial 3 4rebar create template=simplefsm 5 6rebar create template=simplesrv 7 8rebar compile 9rebar compile -v 10 rebar.config erl_opts 概述 使用rebar构建Erlang project的时候，通过设置rebar.config可以为rebar配置各种选项。\n其中比较常用的有 erl_opts 这个选项。\n1{erl_opts, [smp, debug_info, {d, \u0026#39;APP\u0026#39;, myproject}, {d, debug}]}. 实际上它是设置Erlang Compiler的参数。（详细说明见 http://www.erlang.org/doc/man/compile.html）\n平时我们可以在每个 .erl 文件的头部写上这种语句\n1-compile({no_auto_import,[error/1]}). 来告诉编译器编译本文件时用到的编译选项。\n如果把这些参数放在rebar.config里面设置的话，就可以对所有文件使用同一套编译参数了。\n比如在rebar.config里面：\n1{erl_opts, [smp, debug_info, nowarn_unused_function]}. 这里设置了nowarn_unused_function，即module中有未被使用的function时不触发警告。\n效果等同于在每个module文件中加入这句\n1-compile(nowarn_unused_function). {d, macro, value} 有如下情景，使用rebar.config来配置全局编译参数时会比较方便：\n在开发和调试阶段，可能有需要在console打印一些调试信息，通常会用到io:format. 但是发布的程序，在正式环境下是不需要打印这些东西的。\n那么我们可以这样做。\n在rebar.config设置erl_opts, 定义一个Macro, {d, debug}， 表示调试模式。\n1{erl_opts, [smp, no_debug_info, {d, debug}]}. 然后在一个全局的hrl文件中定义输出调试信息的Macro\n1-ifdef(debug). 2-define(TRACE(Str), io:format(Str)). 3-define(TRACE(Str, Args), io:format(Str, Args)). 4-else. 5-define(TRACE(Str), void). 6-define(TRACE(Str, Args), void). 7-endif. 这样,我们在需要打印调试信息的地方用\nTRACE(\u0026ldquo;something to show\u0026rdquo;) 而不是直接用 io:format.\n好处是， 当发布正式版本时， 只须要把rebar.config里面的{d, debug}去掉而不用改动代码，就可以不打印调试信息了。\n{i,Dir} ｛i，Dir｝-在包含文件时将Dir添加到要搜索的目录列表中。当遇到-include或-include_lib指令时，编译器会在以下目录中搜索头文件：\n “.”，文件服务器的当前工作目录 编译文件的基本名称 使用选项i指定的目录；首先搜索最后指定的目录  deps 这里面放的是依赖库，然后应用程序就可以直接调用对应模块的函数了。\nport_envs 可以在rebar.config中通过为port_envs设置环境变量CFLAGS和LDFLAGS指定编译或链接的参数。\n在port_envs哪些变量可以定制，似乎没有什么在线文档，所以直接看rebar的源代码程序：rebar_port_compiler.erl。开头的注释中就说明了可以定制哪些参数，有编译的也有链接的。\n举个例子，我最近写的一个nif模块c代码用到了c99的一些特性，还使用到了一个第三方共享库gdal。linux下nif动态库的编译并链接的命令是这样的：\n1gcc -std=c99 -fPIC -shared -o gdal_nifs.so gdal_nifs.c -I$ERL_HOME/usr/include -lgdal mac下的的编译链接命令是这样：\n1gcc -std=c99 -fPIC -bundle -undefined suppress -flat_namespace -o gdal_nifs.so gdal_nifs.c -I$ERL_HOME/usr/include -lgdal rebar已经考虑了跨平台编译链接的不同参数问题，我还需要定制以下两个参数：\n 指定 c99 标准编译； -std=c99 指定gdal动态库的链接： -lgdal  因此，我的rebar.config定制文件就是\n1{port_envs, [ 2 {\u0026#34;CFLAGS\u0026#34;, \u0026#34;$CFLAGS -std=c99\u0026#34;}, 3 {\u0026#34;LDFLAGS\u0026#34;, \u0026#34;$LDFLAGS -lgdal\u0026#34;} 4 ]}. 以后就可以通过rebar compile跨各种平台编译了。\nport_specs 要编译的文件名或通配符列表。也可能包含元组,由应用于系统的正则表达式组成,架构作为过滤器\nrebar.config.sample https://github.com/rebar/rebar/blame/b6d309417c502ca243f810e5313bea36951ef038/rebar.config.sample\n","date":"2025-01-03","permalink":"/posts/tech/media-rebar2/","series":["媒体开发"],"tags":["","",""],"title":"rebar2构建工具学习"},{"categories":["计算机"],"content":"《Erlang程序设计》  越精简的代码, 越复杂, erlang语言是精简中的精简.\n就由这本书作为我的Erlang入门吧！\n 配置Erlang环境看这里：https://blog.csdn.net/weixin_38044597/article/details/118194771\n另外我选用IDEA作为开发环境。\n这本书有非常多未填的坑，等待机会以后填。\n学习感悟  学习这本书时领会到笔记应该和书有所区别，笔记的结构应当是消化后的结构，而不是按照书上来，做笔记的时机至少应当等到一章的结束，甚至可以一本书的结束，这样才有全局的结构感。才方便作复习用笔记，而不是一个精简版书目。书目是循序渐进的，而笔记应当是全面的，大体上有顺序的。而且这么做有助于提高阅读效率和知识印象。 笔记不是查阅全书  第1章 什么是并发 并发建模 1-module(person). 2-export([init/1]). 3 4init(Name) -\u0026gt; ... 第1行-module(person).的意思是此文件包含用于person模块的代码。它应该与文件名一致（除了.erl这个文件扩展名） 。模块名必须以一个小写字母开头。从技术上说，模块名是一个原子（atom）。\n模块声明之后是一条导出声明。导出声明指明了模块里哪些函数可以从模块外部进行调用。它们类似于许多编程语言里的public声明。没有包括在导出声明里的函数是私有的，无法在模块外调用\n-export([init/1]).语法的意思是带有一个参数（/1指的就是这个意思，而不是除以1）的函数init可以在模块外调用。如果想要导出多个函数，就应该使用下面这种语法：\n1-export([FuncName1/N1, FuncName2/N2, ...]) 方括号[ \u0026hellip; ]的意思是“列表”，因此这条声明的意思是我们想要从模块里导出一个函数列表。\n创建进程 1-module(world). 2-export([start/0]). 3 4start() -\u0026gt; 5\tJoe\t= spawn(person, init, [\u0026#34;Joe\u0026#34;]), 6\tSusannah = spawn(person, init, [\u0026#34;Susannah\u0026#34;]), 7\tDave\t= spawn(person, init, [\u0026#34;Dave\u0026#34;]), 8\tAndy\t= spawn(person, init, [\u0026#34;Andy\u0026#34;]), 9\tRover\t= spawn(dog, init, [\u0026#34;Rover\u0026#34;]), 10\t... 11\tRabbit1\t= spawn(rabbit, init, [\u0026#34;Flopsy\u0026#34;]), 12\t... 13 spawn是一个Erlang基本函数，它会创建一个并发进程并返回一个进程标识符。spawn可以这样调用：\n1spawn(ModName, FuncName, [Arg1, Arg2, ..., ArgN]) 当Erlang运行时系统执行spawn时，它会创建一个新进程（不是操作系统的进程，而是一个由Erlang系统管理的轻量级进程）。当进程创建完毕后，它便开始执行参数所指定的代码。ModName是包含想要执行代码的模块名。FuncName是模块里的函数名，而[Arg1, Arg2, \u0026hellip;]是一个列表，包含了想要执行的函数参数。因此，下面这个调用的意思是启动一个执行函数person:init(\u0026ldquo;Joe\u0026rdquo;)的进程：\n1spawn(person, init, [\u0026#34;Joe\u0026#34;]) spawn的返回值是一个进程标识符（PID，Process IDentifier），可以用来与新创建的进程交互。\nErlang里的模块类似于面向对象编程语言（OOPL，Object-Oriented Programming Language）里的类，进程则类似于OOPL里的对象（或者说类实例）。在Erlang里，spawn通过运行某个模块里定义的函数创建一个新进程。而在Java里，new通过运行某个类中定义的方法创建一个新对象。在OOPL里可以用一个类创建数千个类实例。类似地，在Erlang里我们可以用一个模块创建数千甚至数百万个执行模块代码的进程。\n发送消息 启动模拟之后，我们希望在程序的不同进程之间发送消息。在Erlang里，各个进程不共享内存，只能通过发送消息来与其他进程交互。\nJoe想要对Susannah说些什么。在程序里我们会编写这样一行代码：\n1Susannah ! {self(), \u0026#34;Hope the dogs dont chase the rabbits\u0026#34;} Pid ! Msg 语法的意思是发送消息Msg到进程Pid。大括号里的self()参数标明了发送消息的进程（在此处是Joe）。\n接收消息 为了让Susannah的进程接收来自Joe的消息，要这样写：\n1receive 2\t{From, Message} -\u0026gt; 3\t... 4end 当Susannah的进程接收到一条消息时，变量From会绑定为Joe，这样Susannah就知道消息来自何处，变量Message则会包含此消息。\n并发程序和并行计算机 Erlang里的并发程序是由互相通信的多组顺序进程组成的。一个Erlang进程就是一个小小的虚拟机，可以执行单个Erlang函数。别把它和操作系统的进程相混淆。\n顺序和并发编程语言 在Erlang里，并发性由Erlang虚拟机提供，而非操作系统或任何的外部库。在大多数顺序编程语言里，并发性都是以接口的形式提供，指向主机操作系统的内部并发函数。区分基于操作系统的并发和基于语言的并发很重要，因为如果使用基于操作系统的并发，那么程序在不同的操作系统上就会有不同的工作方式。Erlang的并发在所有操作系统上都有着相同的工作方式。要用Erlang编写并发程序，只需掌握Erlang，而不必掌握操作系统的并发机制。在Erlang里，进程和并发是我们可以用来定型和解决问题的工具。这让细粒度控制程序的并发结构成为可能，而用操作系统的进程是很难做到的。\n第2章 Erlang速览 Shell初探 Erlang shell以横幅信息和计数提示符1\u0026gt;作为响应。然后输入一个表达式，并得到了执行和显示。请注意每一条表达式都必须以一个句号后接一个空白字符结尾。在这个上下文环境里，空白是指空格、制表（Tab）或者回车符。\n 可以用=操作符给变量赋值（严格来说是给变量绑定一个值）。不能重新绑定变量。Erlang是一种函数式语言，所以一旦定义了X = 123，那么X永远就是123，不允许改变！=不是一个赋值操作符，它实际上是一个模式匹配操作符。与其他函数式编程语言一样，Erlang的变量只能绑定一次。绑定变量的意思是给变量一个值，一旦这个值被绑定，以后就不能改动了。 Erlang的变量以大写字母开头。所以X、This和A_long_name都是变量。以小写字母开头的名称（比如monday或friday）不是变量，而是符号常量，它们被称为原子（atom）。  编译与调用 Erlang程序是由许多并行的进程构成的。进程负责执行模块里定义的函数。模块则是扩展名为.erl的文件，运行前必须先编译它们。编译某个模块之后，就可以在shell或者直接从操作系统环境的命令行里执行该模块中的函数了。\n1.shell编译hello.erl文件\n1-module(hello). 2-export([start/0]). 3 4start() -\u0026gt; 5\tio:format(\u0026#34;Hellow world~n\u0026#34;)/ 1$erl 2\u0026gt;c(hello). 3{ok, hello} 4\u0026gt;hello:start(). 5Hello world 6ok 7\u0026gt;halt(). c(hello)命令编译了hello.erl文件里的代码。{ok, hello}的意思是编译成功。现在代码已准备好运行了。第2行里执行了hello:start()函数。第3行里停止了Erlang shell。\n在shell里进行操作的优点是只要平台为Erlang所支持，这种编译和运行程序的方法就一定可用。在操作系统的命令行里的操作可能会因平台的不同而有所差别。\n2.shell外编译\n1$ erlc hello.erl 2$ erl -noshell -s hello start -s init stop 3Hello world erlc 从命令行启动了Erlang编译器。编译器编译了 hello.erl 里的代码并生成一个名为hello.beam的目标代码文件。\n$erl -noshell \u0026hellip;命令加载了 hello模块并执行 hello:start()函数。随后，它执行了init:stop()，这个表达式终止了Erlang会话。\n在Erlang shell之外运行Erlang编译器（erlc）是编译Erlang代码的首选方式。可以在Erlang shell里编译模块，但要这么做必须首先启动Erlang shell。使用erlc的优点在于自动化。我们可以在rakefile或makefile内运行erlc来自动化构建过程。\n并发实例 1.文件服务器进程\nafile_server.erl:\n1-module(afile_server). 2-export([start/1, loop/1]). 3 4start(Dir) -\u0026gt; spawn(afile_server, loop, [Dir]). 5 6loop(Dir) -\u0026gt; 7\treceive 8\t{Client, list_dir} -\u0026gt; 9\tClient ! {self(), file:list_dir(Dir)}; 10\t{Client, {get_file, File}} -\u0026gt; 11 % 获取绝对路径 12\tFull = filename:join(Dir, File), 13 % 调用read_file读文件 14\tClient ! {self(), file:read_file(Full)} 15\tend, 16\tloop(Dir).   Erlang编写无限循环的方法：\n1loop(Dir) -\u0026gt; 2\treceive 3 Command -\u0026gt; 4 ..... 5\tend, 6\tloop(Dir) 不用担心最后的自身调用，这不会耗尽栈空间。Erlang对代码采用了一种所谓“尾部调用”的优化，意思是此函数的运行空间是固定的。这是用Erlang编写循环的标准方式，只要在最后调用自身即可。\n  模式匹配：\n1receive 2\tPattern1 -\u0026gt; 3 Actions1; 4\tPattern2 -\u0026gt; 5 Actions2 -\u0026gt; 6 ... 7\t... 8end Erlang编译器和运行时系统会正确推断出如何在收到消息时运行适当的代码。不需要编写任何的if-then-else或switch语句来设定该做什么。\n  shell测试：\n11\u0026gt; c(afile_server). 2{ok, afile_server} 3% 编译afile_server.erl文件所包含的afile_server模块。 4 52\u0026gt; FileServer = afile_server:start(\u0026#34;.\u0026#34;). 6\u0026lt;0.47.0\u0026gt; 7% afile_server:start(Dir)调用spawn(afile_server, loop, [Dir])。 8% 这就创建出一个新的并行进程来执行函数afile_server:loop(Dir)并返回一个进程标识符 9% \u0026lt;0.47.0\u0026gt;是文件服务器进程的进程标识符。它的显示方式是尖括号内由句号分隔的三个整数。 10 113\u0026gt; FileServer ! {self(), list_dir}. 12{\u0026lt;0.31.0\u0026gt;, list_dir}. 13% 这里给文件服务器进程发送了一条{self(), list_dir}消息。Pid ! 14% Message的返回值被规定为Message，因此shell打印出{self(),list_dir}的值，即{\u0026lt;0.31.0\u0026gt;, list_dir} 15 164\u0026gt; receive X -\u0026gt; X end. 17{\u0026lt;0.47.0\u0026gt;, 18\t{ok, [\u0026#34;afile_server.beam\u0026#34;, ...]} 19} 20% receive X -\u0026gt; X end接收文件服务器发送的回复。它返回元组{\u0026lt;0.47.0\u0026gt;, {ok, ...}。 21% 该元组的第一个元素\u0026lt;0.47.0\u0026gt;是文件服务器的进程标识符。 22% 第二个参数是file:list_dir(Dir)函数的返回值   2.客户端代码\nafile_client.erl:\n1-module(afile_client). 2-export([ls/1, get_file/2]). 3 4ls(Server) -\u0026gt; 5\tServer ! {self(), list_dir}, 6\treceive 7\t{Server, FileList} -\u0026gt; 8\tFileList 9\tend. 10 11get_file(Server, File) -\u0026gt; 12\tServer ! {self(), {get_file, File}}, 13\treceive 14\t{Server, Content} -\u0026gt; 15\tContent 16\tend. 3.测试\n11\u0026gt; c(afile_server). 2{ok, afile_server} 32\u0026gt; c(afile_client). 4{ok, afile_client} 53\u0026gt; FileServer = afile_server:start(\u0026#34;.\u0026#34;). 6\u0026lt;0.43.0\u0026gt; 74\u0026gt; afile_client:get_file(FileServer, \u0026#34;missing\u0026#34;). 8{error, enoent} 95\u0026gt; afile_client:get_file(FileServer, \u0026#34;afile_server.erl\u0026#34;). 10{ok, \u0026lt;\u0026lt;\u0026#34;-modle(afile_server).\\n-export....\u0026#34;} 练习 (4)\n 运行文件客户端和服务器代码。加入一个名为put_file的命令。你需要添加何种消息？学习如何查阅手册页。查阅手册页里的file模块。\n write_file/2：https://www.erlang.org/doc/apps/kernel/file.html#write_file/2\n客户端应发送文件名及文件内容：\n1-module(afile_client). 2-export([ls/1, get_file/2, put_file/3]). 3 4ls(Server) -\u0026gt; 5\tServer ! {self(), list_dir}, 6\treceive 7\t{Server, FileList} -\u0026gt; 8\tFileList 9\tend. 10 11get_file(Server, File) -\u0026gt; 12\tServer ! {self(), {get_file, File}}, 13\treceive 14\t{Server, Content} -\u0026gt; 15\tContent 16\tend. 17 18put_file(Server, FileName, Content) -\u0026gt; 19 Server ! {self(), {FileName, Content}}, 20 receive 21 {Server, response} -\u0026gt; 22 response 23 end. 对应的Server接收文件名和内容，写入文件，并返回操作结果：\n1-module(afile_server). 2-export([start/1, loop/1]). 3 4start(Dir) -\u0026gt; spawn(afile_server, loop, [Dir]). 5 6loop(Dir) -\u0026gt; 7\treceive 8\t{Client, list_dir} -\u0026gt; 9\tClient ! {self(), file:list_dir(Dir)}; 10\t{Client, {get_file, File}} -\u0026gt; 11\tFull = filename:join(Dir, File), 12\tClient ! {self(), file:read_file(Full)}; 13 {Client, {FileName, Content}} -\u0026gt; 14 Full = filename:join(Dir, FileName), 15 response = file:write_file(Full, list_to_binary(Content)), 16 Client ! {self(), response} 17\tend, 18\tloop(Dir). 测试失败：目前暂时不去解决，不过要写的文件还是写上去了。\n11\u0026gt; c(afile_server). 2{ok,afile_server} 32\u0026gt; c(afile_client). 4{ok,afile_client} 53\u0026gt; FileServer = afile_server:start(\u0026#34;.\u0026#34;). 6\u0026lt;0.94.0\u0026gt; 74\u0026gt; afile_client:put_file(FileServer, \u0026#34;test.txt\u0026#34;, \u0026#34;Erlang file test\u0026#34;). 8=ERROR REPORT==== 4-Dec-2024::14:44:33.629142 === 9Error in process \u0026lt;0.94.0\u0026gt; with exit value: 10{{badmatch,ok},[{afile_server,loop,1,[{file,\u0026#34;afile_server.erl\u0026#34;},{line,14}]}]} 第3章 基本概念 Erlang shell 退出：\n1ctrl+c 2 3a 可能导致数据损坏 4q() 是init:stop()命令在shell里的别名。以一种受控的方式停止了系统。所有打开的文件都被刷入缓存并关闭，数据库（如果正在运行的话）会被停止，所有的应用程序都以有序的方式关停 5erlang:halt() 立即停止系统 编写命令快捷键：\n1^A 行首 2^D 删除当前字符 3^E 行尾 4^F或右箭头键 向前的字符 5^B或左箭头键 向后的字符 6^P或上箭头键 前一行 7^N或下箭头键 下一行 8^T 调换最近两个字符的位置 9Tab 尝试扩展当前模块或函数的名称 整数运算 16进制乘32进制：\n116#cafe * 32#sugar. 变量  所有变量名都必须以大写字母开头。 想知道一个变量的值，只需要输入变量名。 如果试图给变量X指派一个不同的值，就会得到一条错误消息。 在Erlang里怎样表达X = X + 1这类概念？Erlang的方式是创建一个名字未被使用过的新变量（比方说X1），然后编写X1 = X + 1。  Erlang的变量是一次性赋值变量（single-assignment variable）。已被指派一个值的变量称为绑定变量，否则称为未绑定 变量。=是一个模式匹配操作符，它在X为未绑定变量时的表现类似于赋值。\n第一次说X=SomeExpression时，Erlang对自己说：“我要做些什么才能让这条语句为真？”因为X还没有值，它可以绑定X到SomeExpression这个值上，这条语句就成立了。如果后期我们说X=AnotherExpression，那么只有在SomeExpression和Another-Expression相等的情况下匹配才会成功：\n11\u0026gt; X = (2+4). 26 32\u0026gt; Y = 10. 410 5% 在计算这个表达式之前，X等于6，因此匹配成功 63\u0026gt; X = 6. 76 84\u0026gt; X = Y. 9exception... 变量的作用域是它定义时所处的语汇单元。因此，如果X被用在一条单独的函数子句之内，它的值就不会“逃出”这个子句。没有同一函数的不同子句共享全局或私有变量这种说法。如果X出现在许多不同的函数里，那么所有这些X的值都是不相干的。(这一点让编程变得非常困难)\n浮点数  用/给两个整数做除法时，结果会自动转换成浮点数。 要从除法里获得整数结果，我们必须使用操作符div和rem：N div M是让N除以M然后舍去余数。N rem M是N除以M后剩下的余数。 Erlang在内部使用64位的IEEE 754-1985浮点数，因此使用浮点数的程序会存在和C等语言一样的浮点数取整与精度问题。  11\u0026gt; 5/3. 21.666666666666666667 32\u0026gt; 4/2. 42.0 53\u0026gt; 5 div 3. 61 74\u0026gt; 5 rem 3. 82 原子   原子以小写字母开头，后接一串字母、数字、下划线（_）或at（@）符号，例如：\n1red 2december 3cat 4meters 5yards 6joe@somehost 7a_long_name   原子还可以放在单引号（'）内。可以用这种引号形式创建以大写字母开头（否则会被解释成变量）或包含字母数字以外字符的原子，例如'Monday'、'Tuesday'、'+'、'*'和'an atomwith spaces'。甚至可以给无需引号的原子加上引号，因此\u0026rsquo;a\u0026rsquo;和a的意思完全一致。\n  在某些语言里，单引号和双引号可以互换使用。Erlang里不是这样。单引号的用法如前面所示，双引号用于给字符串字面量（string literal）定界。\n  一个原子的值就是它本身。可以充当全局常量的效果，只不过不需要再定义数字了，它本身就有含义。\n  true和false也是原子\n  元组 1.创建：\n Erlang没有类型声明，元组里的字段没有名字。 为了更容易记住元组的用途，一种常用的做法是将原子作为元组的第一个元素，用它来表示元组是什么。 元组还可以嵌套。 元组用于保存固定数量的元素。  1\u0026gt;P = {10, 45}. 2\u0026gt;P = {point, 10, 45}. 3\u0026gt;Person = {person, {name, job}, {height, 1.82}, {footsize, 42}, {eyecolour, brown}}.  如果在构建新元组时用到变量，那么新的元组会共享该变量所引用数据结构的值； 如果试图用未定义的变量创建数据结构，就会得到一个错误。  1\u0026gt;F = {firstName, joe}. 2{firstName, joe} 3\u0026gt;L = {lastName, armstrong}. 4{lastName, armstrong} 5\u0026gt;P = {person, F, L}. 6{person, {firstName, joe}, {firstName, joe}} 7 8\u0026gt;{true, Q, 23, Costs} 9** 1.variable \u0026#39;Q\u0026#39; is unbound** 2.提取元组的值：\n 如果想从某个元组里提取一些值，就会使用模式匹配操作符=。在待提取值的位置加入未绑定变量来提取该元组的值。 等号两侧的元组必须有相同数量的元素，而且两侧的对应元素必须绑定为相同的值。原子对应原子。 可以用匿名变量表示不感兴趣的值。 将_作为占位符，用于表示不感兴趣的那些变量。符号_被称为匿名变量。与正规变量不同，同一模式里的多个_不必绑定相同的值。  1\u0026gt;P = {point, 10, 45}. 2{point,10,45}. 3\u0026gt;{point, X, Y} = Point. 4{point,10,45} 5\u0026gt;X. 610 7\u0026gt;Y. 845 9% X绑定了10，Y绑定了45。根据规定，表达式Lhs = Rhs的值是Rhs，因此shell打印出{point,10,45}。 10 11\u0026gt;{point, C, C} = Point. 12** exception error.... 13% 模式{point, C, C}与{point, 10, 45}不匹配，因为C不能同时是10和45。因此，这次模式匹配失败，系统打印出了错误消息。 14 15\u0026gt;Person={person, {firstName, joe}, {firstName, joe}}. 16\u0026gt;{_,{_,First}.{_,_}} = Person. 17\u0026gt;First. 18joe 19% 如果有一个复杂的元组，就可以编写一个与该元组形状（结构）相同的模式，并在待提取值的位置加入未绑定变量来提取该元组的值。 列表  列表（list）被用来存放任意数量的事物。创建列表的方法是用中括号把列表元素括起来，并用逗号分隔它们。 列表里的各元素可以是任何类型 列表的第一个元素被称为列表头（head）。假设把列表头去掉，剩下的就被称为列表尾（tail）。 无论何时，只要用[\u0026hellip;|T]语法构建一个列表，就应该确保T是列表。可以给T的开头添加不止一个元素，写法是[E1,E2,..,En|T]。 列表用于保存可变数量的元素。  1.定义列表：\n1[1+7, hello, 2-2, {cost, apple, 30-20}, 3]. 2ThingsToBuy = [{apples, 10}, {pears, 6}, {milk, 3}]. 3ThingsToBuy1 = [{oranges, 4}, {newspaper,1}|ThingsToBuy]. 2.提取列表元素：\n可以用模式匹配操作来提取某个列表里的元素。如果有一个非空列表L，那么表达式[X|Y] = L（X和Y都是未绑定变量）会提取列表头作为X，列表尾作为Y。\n1[Buy1|ThingsToBuy2] = ThingsToBuy1. 2% 操作成功，绑定如下：Buy1 = {oranges,4} ，ThingsToBuy2 = [{newspaper,1},然后可以继续拆出{apples,10}, {pears,6}, {milk,3}]。于是我们先去买橙子（oranges）下一对商品。 字符串 1.用字符串字面量来创建一个列表\n 严格来说，Erlang里没有字符串。要在Erlang里表示字符串，可以选择一个由整数组成的列表或者一个二进制型。当字符串表示为一个整数列表时，列表里的每个元素都代表了一个Unicode代码点（codepoint）。  可以把“美元符号语法”用于这个目的。举个例子，$a实际上就是代表字符a的整数    1\u0026gt;Name = \u0026#34;Hello\u0026#34;. 2\u0026#34;Hello\u0026#34; 3 4 5\u0026gt; I = $s. 6115 7\u0026gt; [I-32, $u, $r, $p, $r, $i, $s, $e]. 8\u0026#34;Surprise\u0026#34; 9% 可以把“美元符号语法”用于这个目的。举个例子，$a实际上就是代表字符a的整数 10 11\u0026gt; X = \u0026#34;a\\x{221e}b\u0026#34; 12\u0026gt; io:format(\u0026#34;~ts~n\u0026#34;, [X]). 13a。。b 14% 用列表来表示字符串时，它里面的各个整数都代表Unicode字符。必须使用特殊的语法才能输入某些字符，在打印列表时也要选择正确的格式惯例。 15% 在第1行里，我们创建了一个包含三个整数的列表。第一个整数97是字符a的ASCII和Unicode编码。\\x{221e}这种记法的作用是输入一个代表Unicode无穷大字符的十六进制整数。98是字符b的ASCII和Unicode编码。 16% 在第2行里，我们用一个格式化I/O语句打印出这个字符串，里面使用了代表无穷大字符的正确字符图案。 2.整数列表的打印：\n 如果列表内的所有整数都代表可打印字符，它就会将其打印成字符串字面量 否则，打印成列表记法 如果shell将某个整数列表打印成字符串，而你其实想让它打印成一列整数，那就必须使用格式化的写语句  1\u0026gt;[1,2,3] 2[1,2,3] 3\u0026gt;[83,117] 4\u0026#34;Su\u0026#34; 5\u0026gt;[1,83,117] 6[1,83,117] 7 8% 列表[1,2,3]在打印时未做转换。这是因为1、2和3不是可打印字符。 9% 列表里的所有项目都是可打印字符，因此它被打#这个列表以1开头，而1不是可打印字符。因此，这个列表在打印时未做转换。印成字符串字面量。 10% 这个列表以1开头，而1不是可打印字符。因此，这个列表在打印时未做转换。 11 12 13\u0026gt;X = [97,98,99]. 14\u0026#34;abc\u0026#34; 15\u0026gt;io:format(\u0026#34;~w~n,[\u0026#34;abc\u0026#34;]). 16[97,98,99] 模式匹配再探 1[A,B,C,D] = [a,b,c,d,e,f] 2% 成功 f()命令让shell忘记现有的任何绑定。在这个命令之后，所有变量都会变成未绑定状态。\nhelp()命令提示一些函数。\n练习 (3)\n 试着用一个元组来表示一座房子，再用一个房子列表来表示一条街道。请确保你能向这些结构中加入数据或从中取出数据。\n 14\u0026gt; House1 = {house, {location,10,20}, {owner, joe}}. 2{house,{location,10,20},{owner,joe}} 35\u0026gt; House2 = {house, {location, -10, 40}, {owner, peter}}. 4{house,{location,-10,40},{owner,peter}} 56\u0026gt; Street = [House1, House2]. 6[{house,{location,10,20},{owner,joe}}, 7 {house,{location,-10,40},{owner,peter}}] 87\u0026gt; [{_,_,{_,House1Owner}},_] = Street. 9[{house,{location,10,20},{owner,joe}}, 10 {house,{location,-10,40},{owner,peter}}] 118\u0026gt; House1Owner. 12joe 第4章 模块与函数 模块介绍 1.示例程序\n1-module(geometry). 2-export([area/1]). 3 4area({rectangle, Width, Height}) -\u0026gt; Width * Height; 5area({circle, Radius}) -\u0026gt; 3.14159 * Radius * Radius; 6area({square, Side}) -\u0026gt; Side * Side. 1\u0026gt;c(geometry). 2{ok,geometry} 3\u0026gt;geometry:area({rectangle, 10, 5}). 450 5\u0026gt;geometry:area({square, 3}). 69  第一行是模块声明。声明里的模块名必须与存放该模块的主文件名相同。 第二行是导出声明。Name/N这种记法是指一个带有N个参数的函数Name，N被称为函数的元数（arity）。export的参数是由Name/N项目组成的一个列表。 未从模块里导出的函数只能在模块内调用。 area函数有三个子句。这些子句由一个分号隔开，最后的子句以句号加空白结束。每条子句都有一个头部和一个主体，两者用箭头（-\u0026gt;）分隔。头部包含一个函数名，后接零个或更多个模式，主体则包含一列表达式，它们会在头部里的模式与调用参数成功匹配时执行。这些子句会根据它们在函数定义里出现的顺序进行匹配。 命令c(geometry)，它的作用是编译geometry.erl文件里的代码。编译器返回了{ok,geometry}，意思是编译成功，而且geometry模块已被编译和加载。编译器会在当前目录创建一个名为geometry.beam的目标代码模块。 在第2行和第3行调用了geometry模块里的函数。请注意，需要给函数名附上模块名，这样才能准确标明想调用的是哪个函数。 我们的函数并不处理模式匹配失败的情形，程序会以一个运行时错误结束。这是有意而为的，是在Erlang里编程的方式。 Erlang代码里，我们只需要编写模式，Erlang编译器就会生成最佳的模式匹配代码，用它来选择正确的程序入口点。 逗号（,）分隔函数调用、数据构造和模式中的参数。 分号（ ; ）分隔子句。我们能在很多地方看到子句，例如函数定义，以及 case 、 if 、try..catch和receive表达式 句号（.）（后接空白）分隔函数整体，以及shell里的表达式。  2.Erlang shell内建命令\n pwd()打印当前工作目录。 ls()列出当前工作目录里所有的文件名。 cd(Dir)修改当前工作目录至Dir。  结算程序 shop.erl:\n1-module(shop). 2-export([cost/1]). 3 4cost(oranges) -\u0026gt; 5; 5cost(newspaper) -\u0026gt; 8; 6cost(apples) -\u0026gt; 2; 7cost(pears) -\u0026gt; 9; 8cost(milk) -\u0026gt; 7; shop1.erl:\n1-module(shop1). 2-export([total/1]). 3 4total([What, N]|T) -\u0026gt; shop:cost(What) * N + total(T); 5total([]) -\u0026gt; 0. 1\u0026gt;c(shop). 2\u0026gt;c(shop1). 3\u0026gt;shop1:total([milk,3]). 421 5\u0026gt;shop1:total([{pears,6},{milk,3}]). 675 有点像递归调用地处理列表中的每个元组，其他的没有什么知识。这样可以创造for循环\n基本的抽象单元fun  函数式编程语言表示函数可以被用作其他函数的参数，也可以返回函数。操作其他函数的函数被称为高阶函数（higher-order function），而在Erlang中用于代表函数的数据类型被称为fun。 funs是“匿名的”函数。其他编程语言称它们为lambda抽象。 fun可以有多个不同的子句。 括号里的东西就是返回值。也可以说-\u0026gt;后面的东西。  1.基本概念\n1\u0026gt; Double = fun(X) -\u0026gt; 2*X end. 2#Fun\u0026lt;erl_eval.6.56006584\u0026gt; 3\u0026gt; Double(2). 44 5 6\u0026gt; Hypot = fun(X,Y) -\u0026gt; math:sqrt(X*X, Y*Y) end. 7\u0026gt; Hypot(3,4). 85.0\t9\u0026gt; Hypot(3). 10** exception 元数不正确 11 12\u0026gt; TempConvert = fun({c,C}) -\u0026gt; {f, 32 + C*9/5}; 13\t({f,F}) -\u0026gt; {c, (F-32)*5/9} 14\tend. 15\u0026gt;TempConvert({c,100}). 16{f,212.0} 2.以fun作为参数的函数示例\n lists:map(F,L)。这个函数返回的是一个列表，它通过给列表L里的各个元素应用fun F生成。 lists:filter(P, L)，它返回一个新的列表，内含L中所有符合条件的元素（条件是对元素E而言P(E)为true）。 =:=用来测试是否相等。  1\u0026gt; L = [1,2,3,4]. 2\u0026gt; lists:map(fun(X) -\u0026gt; 2*X end, L). 3[2,4,6,8] 4 5\u0026gt; Even = fun(X) -\u0026gt; (X rem 2) =:= 0 end. 6\u0026gt; lists:filter(Even, [1,2,3,4,5,6,8]). 7[2,4,6,8] 3.返回fun的函数示例\n对于给定列表，生成函数，用于判断单个变量是否在这个列表里面：\n1\u0026gt; Fruit = [apple,pear,orange]. 2\u0026gt; MakeTest = fun(L) -\u0026gt; (fun(X) -\u0026gt; lists:member(X,L) end) end. 3\u0026gt; IsFruit = MakeTest(Fruit). 4\u0026gt; IsFruit(pear). 5true 6\u0026gt; IsFruit(dog). 7false 指定倍数生成一个函数，这个函数的返回值是参数的指定倍数：\n1\u0026gt; Mult = fun(Times) -\u0026gt; ( fun(X) -\u0026gt; X * Times end) end. 2\u0026gt; Triple = Mult(3). 3\u0026gt; Triple(5). 415 4.自定义for循环\n 创建自己的控制结构能大大降低程序的大小，有时还能让它们更加清晰。这是因为你能精确地创建出解决问题所需要的控制结构，同时还不受编程语言自带的少量固定控制结构所限。  lib_misc.erl:\n1% 执行for(1,10,F)会创建列表[F(1), F(2), ..., F(10)] 2for(Max, Max, F) -\u0026gt; [F(Max)]; 3for(I, Max, F) -\u0026gt; [F(I)|for(I+1, Max, F)]. 1lib_misc:for(1,10,fun(I) -\u0026gt; I end). 2lib_misc:for(1,10,fun(I) -\u0026gt; I*I end). 优化结算程序 mylists.erl:\n1-module(mylists) 2-export([map/2, sum/1]). 3 4sum([H|T]) -\u0026gt; H + sum(T); 5sum([]) -\u0026gt; 0. 6 7map(_,[]) -\u0026gt;[]; 8map(F, [H|T]) -\u0026gt; [F(H)|map(F,T)]. shop2.erl:\n1-module(shop2). 2-export([total/1]). 3-import(mylists, [map/2,sum/1]). 4 5total(L) -\u0026gt; 6\tsum(map(fun({What,N}) -\u0026gt; shop:cost(What) * N end, L)). 列表推导 1.基础概念\n  列表推导（list comprehension）是无需使用fun、map或filter就能创建列表的表达式。它让程序变得更短，更容易理解。\n  列表推导最常规的形式是下面这种表达式：\n1[X || Qualifier1, Qualifier2, ...] X是任意一条表达式，后面的限定符（Qualifier）可以是生成器、位串生成器或过滤器。\n 生成器（generator）的写法是Pattern \u0026lt;- ListExpr，其中的ListExp必须是一个能够得出列表的表达式。 位 串 （ bitstring ）生成器的写法是 BitStringPattern \u0026lt;= BitStringExpr ， 其 中 的BitStringExpr必须是一个能够得出位串的表达式。 过滤器（filter）既可以是判断函数（即返回true或false的函数），也可以是布尔表达式。    这个限定符的运算顺序是从左往右的。\n  1\u0026gt; L = [1,2,3,4,5]. 2\u0026gt; lists:map(fun(X) -\u0026gt; 2*X end, L). 3\u0026gt; [2*X || X \u0026lt;- L]. 4[2,4,6,8,10] 5 6% 列表推导的购物结算程序 7\u0026gt; Buy=[{oranges,4}.{newspaper,1},{apples,10},{pears,6},{milk,3}]. 8\u0026gt; [{Name, 2*Number} || {Name, Number} \u0026lt;- Buy]. 9[{oranges,8}, {newspaper,2},{apples,20},{pears,12},{milk,6}] 10% ||符号右侧的元组{Name, Number}是一个模式 11% 左侧的元组{Name, 2*Number}则是一个构造器（constructor）。 12\u0026gt; [{shop:cost(A)* B} || {A, B} \u0026lt;- Buy]. 13[20,8,20,54,21] 14\u0026gt; lists:sum([shop:cost(A) * B || {A,B} \u0026lt;- Buy]). 15123 2.几个例子：\n归并排序：\n1qsort([]) -\u0026gt; []; 2qsort([Pivot|T]) -\u0026gt; 3\tqsort([X || X \u0026lt;- T, X \u0026lt; Pivot]) 4\t++ [Pivot] ++ 5\tqsort([X || X \u0026lt;- T, X \u0026gt;= Pivot]).  ++是中缀插入操作符。 将T分成两个列表，一个包含T里所有小于Pivot（中位数）的元素，另一个包含所有大于或等于Pivot的元素。所以这里第二个限定符就是过滤器。  查找勾股数（暴力遍历）：\n1pythag(N) -\u0026gt; 2\t[ {A,B,C} || 3\tA \u0026lt;- lists:seq(1,N), 4\tB \u0026lt;- lists:seq(1,N), 5\tC \u0026lt;- lists:seq(1,N), 6\tA+B+C =\u0026lt; N, 7\tA*A+B*B =:= C*C 8\t].  lists:seq(1, N)返回一个包含从1到N所有整数的列表。  单词字母的所有组合：\n1perms([]) -\u0026gt; [[]]; 2perms(L) -\u0026gt; [[H|T] || H \u0026lt;- L, T \u0026lt;- perms(L--[H])].  X -- Y是列表移除操作符，它从X里移除Y中的元素。 穷尽一切可能从L里提取H（单个字母），然后穷尽一切可能从perms(L \u0026ndash; [H])（即列表L移除H后的所有排列形式）里提取T，最后返回[H|T]。  内置函数   内置函数简称为BIF（built-in function），是那些作为Erlang语言定义一部分的函数。有些内置函数是用Erlang实现的，但大多数是用Erlang虚拟机里的底层操作实现的。\n  所有内置函数都表现得像是属于 erlang模块，但那些最常用的内置函数（例如 list_to_tuple）是自动导入的\n  内置函数文档：http://www.erlang.org/doc/man/erlang.html\n(在erts/erlang模块里面)\n  内置函数list_to_tuple/1能将一个列表转换成元组\n  time/0以{时，分，秒}的格式返回当前的时间。\n  关卡  关卡（guard）是一种结构，可以用它来增加模式匹配的威力。通过使用关卡，可以对某个模式里的变量执行简单的测试和比较。 关卡序列（guard sequence）是指单一或一系列的关卡，用分号（;）分隔。对于关卡序列G1;G2; \u0026hellip;; Gn，只要其中有一个关卡（G1、G2……）的值为true，它的值就为true。 关卡由一系列关卡表达式组成，用逗号（,）分隔。关卡GuardExpr1, GuardExpr2, \u0026hellip; ,GuardExprN只有在所有的关卡表达式（GuardExpr1、GuardExpr2……）都为true时才为true。 合法的关卡表达式是所有合法Erlang表达式的一个子集。 关卡不能调用用户定义的函数，因为要确保它们没有副作用并能正常结束。 合法的关卡表达式：  原子true； 其他常量（各种数据结构和已绑定变量）它们在关卡表达式里都会成为false； 调用后面表1里的关卡判断函数和表2里的内置函数； 数据结构比较（参见表6）； 算术表达式（参见表3）； 布尔表达式（参见8.7节）； 短路布尔表达式（参见8.23节）。   短路布尔表达式：orelse和andalso orelse和andalso操作符存在的原因是布尔操作符and/or原本的定义是两侧参数都需要求值。在关卡里，（and与andalso）之间和（or与orelse）之间可能会存在差别。 原子true可以被当作“来者不拒”的关卡  表1 关卡判断函数:\n   判断函数 意思     is_atom(X) X是一个原子   is_binary(X) X是一个二进制型   is_constant(X) X是一个常量   is_float(X) X是一个浮点数   is_function(X) X是一个fun   is_function(X, N) X是一个带有N个参数的fun   is_integer(X) X是一个整数   is_list(X) X是一个列表   is_map(X) X是一个映射组   is_number(X) X是一个整数或浮点数   is_pid(X) X是一个进程标识符   is_pmod(X) X是一个参数化模块的实例   is_port(X) X是一个端   is_reference(X) X是一个引用   is_tuple(X) X是一个元组   is_record(X,Tag) X是一个类型为Tag的记录   is_record(X,Tag,N) X是一个类型为Tag、大小为N的记录    表2 关卡内置函数：\n   函数 意思     abs(X) X的绝对值   byte_size(X) X的字节数，X必须是一个位串或二进制型   element(N, X) X里的元素N，注意X必须是一个元组   float(X) 将X转换成一个浮点数，X必须是一个数字   hd(X) 列表X的列表头   length(X) 列表X的长度   node() 当前的节点   node(X) 创建X的节点，X可以是一个进程、标识符、引用或端口   round(X) 将X转换成一个整数，X必须是一个数字   self() 当前进程的进程标识符   size(X) X的大小，它可以是一个元组或二进制型   trunc(X) 将X去掉小数部分取整，X必须是一个数字   tl(X) 列表X的列表尾   tuple_size(T) 元组T的大小    1max(X,Y) when X \u0026gt; Y -\u0026gt; X; 2max(X,Y) -\u0026gt; Y. 3% 子句1会在X大于Y时匹配，结果是X。如果子句1不匹配，系统就会尝试子句2。 4% 子句2总是返回第二个参数Y。Y必然是大于或等于X的，否则子句1就已经匹配了。 5 6f(X,Y) when is_integer(T), X\u0026gt;Y, Y\u0026lt;6 -\u0026gt; ... 7% 当X是一个整数，X大于Y并且Y小于6时 8is_tuple(T), tuple_size(T) =:= 6, abs(element(3,T)) \u0026gt; 5 9% T是一个包含六个元素的元组，并且T中第三个元素的绝对值大于5 10element(4,X) =:= hd(L) 11% 元组X的第4个元素与列表L的列表头相同 12A \u0026gt;= -1.0 andalso A+1\u0026gt;B 13is_atom(L) orelse (is_list(L) andalse length(L) \u0026gt; 2) 14 15f(X) when (X == 0) or (1/X \u0026gt; 2) -\u0026gt; ... 16g(X) when (X == 0) orelse (1/X \u0026gt; 2) -\u0026gt; ... 17% 当X为0时，f(X)里的关卡会失败，但g(X)里的关卡会成功。 case和if表达式   case表达式的语法如下：\n1case Expression of 2\tPattern1 [when Guard1] -\u0026gt; Expr_seq1; 3\tPattern2 [when Guard2] -\u0026gt; Expr_seq2; 4\t... 5end 首先，Expression被执行，假设它的值为Value。随后，Value轮流与Pattern1（带有可选的关卡Guard1）、Pattern2等模式进行匹配，直到匹配成功。一旦发现匹配，相应的表达式序列就会执行，而表达式序列执行的结果就是case表达式的值。如果所有模式都不匹配，就会发生异常错误（exception）。\n  条件句式if，语法如下：\n1if Guard1 -\u0026gt; 2\tExpr_seq1; 3 Guard2 -\u0026gt; 4 Expr_seq2; 5 ... 6end 首先执行Guard1。如果得到的值为true，那么if的值就是执行表达式序列Expr_seq1所得到的值。如果Guard1不成功，就会执行Guard2，以此类推，直到某个关卡成功为止。if表达式必须至少有一个关卡的执行结果为true，否则就会发生异常错误。\n  if是一种表达式，而所有的表达式都应该有值。为了避免可能的异常错误，Erlang程序员经常会在if表达式的最后添加一个true关卡。当然，如果他们想让异常错误生成，就会省略额外的true关卡。\n  if的最后一个分支不需要加符号.\n  使用case定义filter:\n1filter(P, [H|T]) -\u0026gt; 2\tcase P(H) of 3\ttrue -\u0026gt; [H|filter(P,T)]; 4\tfalse -\u0026gt; filter(P,T) 5\tend; 6\t7filter(P, []) -\u0026gt; 8\t[]. 只使用模式匹配定义filter:\n1filter(P, [H|T]) -\u0026gt; filter1(P(H), H, P, T); 2filter(P, []) -\u0026gt; []. 3 4filter1(true, H, P, T) -\u0026gt; [H|filter(P,T)]; 5filter1(false,H, P, T) -\u0026gt; filter(P, T); if例子:\n1if 2\tA\u0026gt;0 -\u0026gt; 3\tdo_this(); 4\ttrue -\u0026gt; 5\tdo_that(); 6end 构建列表的方式   构建列表最有效率的方式是向某个现成列表的头部添加元素，因此经常能看到包含以下模式的代码：\n1some_function([H|T],...,Result,...) -\u0026gt; 2\tH1 = ... H ..., 3\tsome_function(T, ..., [H1|Result], ...); 4some_function([], ..., Result, ...) -\u0026gt; 5\t{..., Result, ...}. 这段代码会遍历一个列表，提取出列表头H并根据函数的算法计算出某个值（可以称之为H1），然后把H1添加到输出列表Result里。当输入列表被穷尽后，最后的子句匹配成功，函数返回输出变量Result。\n  建议：\n 总是向列表头添加元素。 从输入列表的头部提取元素，然后把它们添加到输出列表的头部，形成的结果是与输入列表顺序相反的输出列表。 如果顺序很重要，就调用lists:reverse/1这个高度优化过的函数。    归集器 两种将列表中的元素分为奇数和偶数的代码：\n1.列表推导\n1odds_and_evens1(L) -\u0026gt; 2 Odds = [X || X \u0026lt;- L, (X rem 2) =:= 1], 3 Evens = [X || X \u0026lt;- L, (X rem 2) =:= 0], 4 {Odds, Evens}. 2.归集器\n1odds_and_evens2(L) -\u0026gt; 2 odds_and_evens_acc(L, [], []). 3 4odds_and_evens_acc([H|T], Odds, Evens) -\u0026gt; 5 case (H rem 2) of 6 1 -\u0026gt; odds_and_evens_acc(T,[H|Odds],Even); 7 0 -\u0026gt; odds_and_evens_acc(T,Odds,[H|Even]) 8 end; 9odds_and_evens_acc([],Odds,Evens) -\u0026gt; 10 {Odds, Evens}.  第一段代码遍历了两次 第二段程序只遍历列表一次，把奇偶参数分别添加到合适的列表里。这些列表被称为归集器（accumulator）。 这段代码还有一个不太明显的额外的优点：带归集器的版本比[H || filter(H)]类型结构的版本更节省空间。 第二段奇偶列表里的元素顺序是反转的。这是列表的构建方式所导致的结果。  练习 (1)\n 扩展geometry.erl。添加一些子句来计算圆和直角三角形的面积。添加一些子句来计算各种几何图形的周长。\n 1-module(geometry). 2-export([area/1, perimeter/1]). 3 4% 面积 5area({rectangle, Width, Height}) -\u0026gt; Width * Height; 6area({circle, Radius}) -\u0026gt; 3.14159 * Radius * Radius; 7area({square, Side}) -\u0026gt; Side * Side; 8area({right_triangle, Width, Height}) -\u0026gt; 0.5 * Width * Height. 9 10% 周长 11perimeter({rectangle, Width, Height}) -\u0026gt; 2 * (Width + Height); 12perimeter({circle, Radius}) -\u0026gt; 2 * 3.14159 * Radius; 13perimeter({square, Side}) -\u0026gt; 4 * Side; 14perimeter({right_triangle, Width, Height}) -\u0026gt; Width + Height + math:sqrt(Width*Width + Height*Height). (2)\n 内置函数 tuple_to_list(T) 能将元组 T 里的元素转换成一个列表。请编写一个名为my_tuple_to_list(T)的函数来做同样的事，但不要使用相同功能的内置函数。\n erlang程序看似人畜无害, 实则非常难以编写.\n delete_element(Index, Tuple1) : Returns a new tuple with element at Index removed from tuple Tuple1.  1-module(mylist). 2-export([my_tuple_to_list/1]). 3 4my_tuple_to_list({}) -\u0026gt; []; 5my_tuple_to_list(T) -\u0026gt; 6 [element(1,T)|my_tuple_to_list(erlang:delete_element(1,T))]. (3)\n 查看 erlang:now/0 、 erlang:date/0 和 erlang:time/0 的定义 。 编写一个名为my_time_func(F)的函数，让它执行fun F并记下执行时间。编写一个名为my_date_string()的函数，用它把当前的日期和时间改成整齐的格式。\n  erlang:now/0已经过期, 使用erlang:timestamp/0替代, 获取当前Erlang系统时间。 erlang:date/0将当前日期返回为{年、月、日}。 erlang:time/0将当前时间返回为｛小时、分钟、秒｝。  由于找不到如何处理时间差, 这个问题暂时就不处理了.\n(4)\n 高级练习：查找Python datetime模块的手册页。找出Python的datetime类里有多少方法可以通过erlang模块里有关时间的内置函数实现。在erlang的手册页里查找等价的函数。如果有明显的遗漏，就实现它。\n 时间开销太大, 留在这以后说.\n(5)\n 编写一个名为math_functions.erl的模块，并导出函数even/1和odd/1。even(X)函数应当在X是偶整数时返回true，否则返回false。odd(X)应当在X是奇整数时返回true。\n 1-module(math_functions). 2-export([even/1,odd/1]). 3 4even(T) -\u0026gt; 5 if 6 (T rem 2) =:= 0 andalso is_integer(T) -\u0026gt; 7 true; 8 true -\u0026gt; 9 false 10 end. 11 12 13odd(T) -\u0026gt; 14 if 15 (T rem 2) =:= 1 andalso is_integer(T) -\u0026gt; 16 true; 17 true -\u0026gt; 18 false 19 end. (6)\n 向math_functions.erl添加一个名为filter(F, L)的高阶函数，它返回L里所有符合条件的元素X（条件是F(X)为true）。\n 1-module(math_functions). 2-export([even/1,odd/1,filter/2]). 3 4even(T) -\u0026gt; 5 if 6 (T rem 2) =:= 0 andalso is_integer(T) -\u0026gt; 7 true; 8 true -\u0026gt; 9 false 10 end. 11 12 13odd(T) -\u0026gt; 14 if 15 (T rem 2) =:= 1 andalso is_integer(T) -\u0026gt; 16 true; 17 true -\u0026gt; 18 false 19 end. 20 21filter(F,L) -\u0026gt; 22 [X || X \u0026lt;- L, F(X)]. (7)\n 向math_functions.erl添加一个返回{Even, Odd}的split(L)函数，其中Even是一个包含L里所有偶数的列表，Odd是一个包含L里所有奇数的列表。请用两种不同的方式编写这个函数，一种使用归集器，另一种使用在练习6中编写的filter函数。\n 由于归集器在教材中的写法已经满足了本题的需要, 故只编写第二种.\n注意分号;是用来分隔子句的.\n1-module(math_functions). 2-export([filter/2,split/1]). 3 4 5filter(F,L) -\u0026gt; 6 [X || X \u0026lt;- L, F(X)]. 7 8split(L) -\u0026gt; 9 Even = fun(T) -\u0026gt; 10 if 11 (T rem 2) =:= 0 andalso is_integer(T) -\u0026gt; 12 true; 13 true -\u0026gt; 14 false 15 end 16 end, 17 18 19\tOdd = fun(T) -\u0026gt; 20 if 21 (T rem 2) =:= 1 andalso is_integer(T) -\u0026gt; 22 true; 23 true -\u0026gt; 24 false 25 end 26 end, 27 28 Odds = filter(Odd, L), 29 Evens = filter(Even, L), 30 {Odds, Evens}. 第5章 记录与映射组  记录其实就是元组的另一种形式。通过使用记录，可以给元组里的各个元素关联一个名称。 映射组是键值对的关联性集合。键可以是任意的Erlang数据类型。 与其记住某个数据项在复杂数据结构里的存放位置，不如使用该项的名称，让系统找到数据存放的位置。记录使用一组固定且预定义的名称，而映射组可以动态添加新的名称。  映射组/记录的选择 记录：\n 当你可以用一些预先确定且数量固定的原子来表示数据时； 当记录里的元素数量和元素名称不会随时间而改变时； 当存储空间是个问题时，典型的案例是你有一大堆元组，并且每个元组都有相同的结构。  映射组：\n 当键不能预先知道时用来表示键-值数据结构； 当存在大量不同的键时用来表示数据； 当方便使用很重要而效率无关紧要时作为万能的数据结构使用； 用作“自解释型”的数据结构，也就是说，用户容易从键名猜出值的含义； 用来表示键-值解析树，例如XML或配置文件； 用JSON来和其他编程语言通信。  记录的使用   记录声明\n1-record(Name, { 2\t%% 下面两个键带有默认值 3\tkey1 = Default1, 4\tkey2 = Default2, 5\t... 6\t%% 相当于未定义 7\tkey3, 8\t... 9}). Name是记录名。key1、key2这些是记录所含各个字段的名称，它们必须是原子。记录里的每个字段都可以带一个默认值，如果创建记录时没有指定某个字段的值，就会使用默认值。\n  引用记录定义\n记录的定义既可以保存在Erlang源代码文件里，也可以由扩展名为.hrl的文件保存，然后包含在Erlang源代码文件里\n文件包含是唯一能确保多个Erlang模块共享相同记录定义的方式。\nrecords.hrl：\n1-record(todo, {status=reminder,who=joe,text}).   shell里，必须先把记录的定义读入shell，然后才能创建记录。我们将用shell函数rr（read records的缩写，即读取记录）来实现。\n1\u0026gt; rr(\u0026#34;records.hrl\u0026#34;) 2[todo]   创建记录\n1 #todo{key1=Val1, ..., keyN=ValN} 所有的键都是原子，而且必须与记录定义里所用的一致。\n如果省略了一个键，系统就会用记录定义里的值作为该键的默认值。\n1\u0026gt; #todo{} 2#todo{status = reminder,who = joe,text = undefined} 3\u0026gt; X1 = #todo{status=urgent, text=\u0026#34;Fix errata in book\u0026#34;}. 4#todo{status = urgent,who = joe,text = \u0026#34;Fix errata in book\u0026#34;}   复制记录\n这么做生成的是原始记录的一个副本，原始记录没有变化。\n1\u0026gt; X2 = X1#todo{status=done} 2%% 创建一个X1的副本（类型必须是todo），并修改字段status的值为done。   提取记录字段\n使用模式匹配\n1\u0026gt; #todo{who=W, text=Txt} = X2. 2\u0026gt; W. 3joe 4\u0026gt; Txt. 5\u0026#34;Fix errata in book\u0026#34;   函数中模式匹配记录\n以编写模式匹配记录字段或者创建新记录的函数：\n1clear_status(#todo{status=S,who=W} = R) -\u0026gt; 2\tR#todo{status=finished} 3 4%% S和W绑定了记录里的字段值 5%% R是整个记录 匹配某个类型的记录：\n1do_something(X) when is_record(X, todo) -\u0026gt; 2\t%% ... 使用is_record函数匹配todo类型的记录。\n  记录是元组的另一种形式\n1\u0026gt; X2. 2#todo{status = done,who = joe,text = \u0026#34;Fix errata in book\u0026#34;} 3\u0026gt; rf(todo). 4ok 5\u0026gt; X2. 6{todo,done,joe,\u0026#34;Fix errata in book\u0026#34;} rf(todo)命令使shell忘了todo记录的定义。现在打印X2时，shell将X2显示成一个元组\n  映射组的使用   属性\n 映射组的语法与记录相似，不同之处是省略了记录名，并且键值分隔符是=\u0026gt;或:=。 映射组是键-值对的关联性集合。 映射组里的键可以是任何全绑定的Erlang数据类型（即数据结构里没有任何未绑定变量）。 映射组里的各个元素根据键进行排序。 在不改变键的情况下更新映射组是一种节省空间的操作。 查询映射组里某个键的值是一种高效的操作。 映射组有着明确的顺序。    创建映射组\n1#{Key1 Op Val1, Key2 Op Val2, ..., KeyN Op ValN} Op是=\u0026gt;或:=这两个符号的其中一个。\n键和值可以是任何有效的Erlang数据类型。\n1\u0026gt; F1 = #{a=\u0026gt;1, b=\u0026gt;2}. 2#{a=\u0026gt;1, b=\u0026gt;2}. 3\u0026gt; Facts = #{{wife,fred}=\u0026gt;\u0026#34;Sue\u0026#34;, {age,fred}=\u0026gt;45}.   映射组在系统内部是作为有序集合存储的，打印时总是使用各键排序后的顺序，与映射组的创建方式无关。\n1\u0026gt; F2 = #{b=\u0026gt;1, a=\u0026gt;2}. 2#{a=\u0026gt;2, b=\u0026gt;1}.   基于现有的映射组更新一个映射组：\n1NewMap = OldMap #{K1 Op V1, ..., Kn Op Vn} 表达式K =\u0026gt; V有两种用途，一种是将现有键K的值更新为新值V，另一种是给映射组添加一个全新的K-V对。这个操作总是成功的。\n表达式K := V的作用是将现有键K的值更新为新值V。如果被更新的映射组不包含键K，这个操作就会失败。\n使用映射组的最佳方式是在首次定义某个键时总是使用Key =\u0026gt; Val，而在修改具体某个键的值时都使用Key := Val。\n（操作是深拷贝的，这两个变量是不相关的）\n  模式匹配映射组字段\n用来编写映射组的=\u0026gt;语法还可以作为映射组模式使用。和之前一样，映射组模式里的键不能包含任何未绑定变量，但是值现在可以包含未绑定变量了（在模式匹配成功后绑定）。\n（TODO 我测试这段代码失败了，不管怎么匹配都是错误的，这里留一个坑。）\n1\u0026gt; Henry8 = #{class=\u0026gt;king,born=\u0026gt;1491,died=\u0026gt;1547}. 2\u0026gt; #{born =\u0026gt; B} = Henry8. 3\u0026gt; B. 41491 5\u0026gt; #{ D =\u0026gt; 1547} = Henry8. 6unbound   函数头部使用包含模式的映射组\ncount_characters(Str)函数，让它返回一个映射组，内含某个字符串里各个字符的出现次数。\n1%% 入口 2count_characters(Str) -\u0026gt; 3\tcount_characters(Str, #{}). 4 5%% 核心 6count_characters([H|T], #{ H =\u0026gt; N}=X) -\u0026gt; 7\tcount_characters(T,X#{ H := N+1}); 8%% 上一条没匹配成功，表明这个字母的计数是第一次 9count_characters([H|T], X) -\u0026gt; 10\tcount_characters(T,X#{ H =\u0026gt; 1}); 11%% 处理完毕 12count_characters([], X) -\u0026gt; 13\tX.   映射组api：\n map:new() -\u0026gt; #{} 返回一个新的空映射组。 erlang:is_map(M) -\u0026gt; bool() 如果M是映射组就返回true，否则返回false。它可以用在关卡测试或函数主体中。 maps:to_list(M) -\u0026gt; [{K1,V1, ..., {Kn,Vn}] 把映射组M里的所有键和值转换成一个键值列表。键在生成的列表里严格按升序排列。 maps:from_list([{K1,V1}, ..., {Kn,Vn}]) -\u0026gt; M把一个包含键值对的列表转换成映射组M。如果同样的键不止一次出现，就使用列表里第一个键所关联的值，后续的值都会被忽略。 maps:map_size(Map) -\u0026gt; NumberOfEntries返回映射组里的条目数量。 maps:is)key(Key,Map)-\u0026gt; bool()如果映射组包含一个键为Key的项就返回true，否则返回false。 maps:get(Key,Map)-\u0026gt;Val返回映射组里与Key关联的值，否则抛出一个异常错误。 maps:find(Key,Map)-\u0026gt;{ok,Value}|error返回映射组里与Key关联的值，否则返回error。 maps:keys(Map)-\u0026gt;[Key1,...,KeyN]返回映射组所含的键列表，按升序排列。 maps:remove(Key,M)-\u0026gt;M1返回一个新映射组M1，除了键为Key的项（如果有的话）被移除外，其他与M一致。 maps:without([Key1,...,KeyN],M)-\u0026gt;M1返回一个新映射组M1，它是M的复制，但移除了带有[Key1,\u0026hellip;,KeyN]列表里这些键的元素。 maps:difference(M1,M2)-\u0026gt;M3M3是M1的复制，但移除了那些与M2里的元素具有相同键的元素。    映射组排序规则\n映射组在比较时首先会比大小，然后再按照键的排序比较键和值。\n 如果A和B是映射组，那么当maps:size(A) \u0026lt; maps:size(B)时A \u0026lt; B。 如果A和B是大小相同的映射组，那么当maps:to_list(A) \u0026lt; maps:to_list(B)时A \u0026lt; B。 当映射组与其他Erlang数据类型相比较时，因为我们认为映射组比列表或元组“更复杂”，所以映射组总是会大于列表或元组。  1A = #{age =\u0026gt; 23, person =\u0026gt; \u0026#34;jim\u0026#34;} \u0026lt; B = # {email =\u0026gt; \u0026#34;sue@somplace.com\u0026#34;, name =\u0026gt; \u0026#34;sue\u0026#34;} 2 3%% A的最小键（age）比B的最小键（email）更小。   映射组可以通过io:format里的~p选项输出，并用io:read或file:consult读取。\n  映射组和JSON相关api\n maps:to_json(Map) -\u0026gt;Bin 把一个映射组转换成二进制型，它包含用JSON表示的该映射组。 maps:from_json(Bin) -\u0026gt; Map 把一个包含JSON数据的二进制型转换成映射组。 maps:safe_from_json(Bin) -\u0026gt; Map 把一个包含JSON数据的二进制型转换成映射组。Bin里的任何原子必须在调用此内置函数前就已存在，否则就会抛出一个异常错误。这样做是为了防止创建大量的新原子。出于效率的原因，Erlang不会垃圾回收（garbage collect）原子，所以连续不断地添加新原子会（在很长一段时间后）让Erlang虚拟机崩溃。  上面两种定义里的Map都必须是json_map()类型的实例。\n（目前maps模块已经没有这些函数了，还是需要另外查询）\n  JSON对象与Erlang值的映射关系：json_map()类型\n1-type json_map() = [{json_key(), json_value()}]. 2 3-type json_key() = 4\tatom() | binary() | io_list() 5 6-type json_value() = 7\tinteger() | binary() | float() | atom() | [json_value()] | json_map()  JSON的数字用Erlang的整数或浮点数表示。 JSON的字符串用Erlang的二进制型表示。 JSON的列表用Erlang的列表表示。 JSON的true和false用Erlang的原子true和false表示。 JSON的对象用Erlang的映射组表示，但是有限制：映射组里的键必须是原子、字符串或二进制型，而值必须可以用JSON的数据类型表示。  当来回转换JSON数据类型时，应当注意一些特定的转换限制。Erlang对整数提供了无限的精度。所以，Erlang会很自然地把映射组里的某个大数转换成JSON数据里的大数，而解码此JSON数据的程序不一定能理解它。\n  练习 (1)\n 配置文件可以很方便地用JSON数据表示。请编写一些函数来读取包含JSON数据的配置文件，并将它们转换成Erlang的映射组。再编写一些代码，对配置文件里的数据进行合理性检查。\n json:\n1{ 2\t{username, liming}, 3\t{password, 123456}, 4\t{location, beijing}, 5\t{male, true} 6} 等到以后再来。\n(2)\n 编写一个map_search_pred(Map, Pred) 函数，让它返回映射组里第一个符合条件的{Key,Value}元素（条件是Pred(Key, Value)为true）。\n 1-module(map_search). 2-export([map_search_pred/2]). 3 4map_search_pred(Map, Pred) -\u0026gt; 5\tlist_search_pred(maps:to_list(Map), Pred). 6 7list_search_pred([H|T], Pred) -\u0026gt; 8\t{K,V} = H, 9\tcase Pred(K,V) of 10\ttrue -\u0026gt; {K,V}; 11\tfalse -\u0026gt; list_search_pred(T, Pred) 12\tend; 13list_search_pred([], Pred) -\u0026gt; 14\t\u0026#34;None of them matchs\u0026#34;. 测试：\n1Pred = fun(a,V) -\u0026gt; V=:=1; 2\t(b,V) -\u0026gt; V=:=2 3\tend. 4\t5M1 = #{a=\u0026gt;2, b=\u0026gt;2}. 第6章 顺序程序的错误处理 书本内容   在Erlang里，单个进程的崩溃就不那么重要了，前提是其他某些进程能察觉这个崩溃，并接手崩溃进程原本应该做的事情。\n  Erlang里，防御式编程是内建的。在描述函数的行为时应该只考虑合法的输入参数，其他所有参数都将导致内部错误并自动被检测到。永远不能让函数对非法的参数返回值，而是应该抛出一个异常错误。这条规则被称为“任其崩溃”。\n  显式生成错误：\n exit(Why) 当你确实想要终止当前进程时就用它。如果这个异常错误没有被捕捉到，信号{\u0026lsquo;EXIT\u0026rsquo;,Pid,Why}就会被广播给当前进程链接的所有进程。 throw(Why) 抛出一个调用者可能想要捕捉的异常错误。在这种情况下，我们注明了被调用函数可能会抛出这个异常错误。有两种方法可以代替它使用：可以为通常的情形编写代码并且有意忽略异常错误，也可以把调用封装在一个try\u0026hellip;catch表达式里，然后对错误进行处理。 error(Why) 这个函数的作用是指示“崩溃性错误”，也就是调用者没有准备好处理的非常严重的问题。它与系统内部生成的错误差不多。    Erlang有两种方法来捕捉异常错误。第一种是把抛出异常错误的调用函数封装在一个try...catch表达式里，另一种是把调用封装在一个catch表达式里。\n  try catch语法\n1try FuncOrExpressionSeq of 2\tPattern1 [when Guard1] -\u0026gt; Expressions1; 3\tPattern2 [when Guard2] -\u0026gt; Expressions2; 4\t... 5catch 6\tExceptionType1: ExPattern1 [when ExGuard1] -\u0026gt; ExExpressions1; 7\tExceptionType2: ExPattern2 [when ExGuard2] -\u0026gt; ExExpressions2; 8\t... 9after 10\tAfterExoressuibs 11end 首先执行FuncOrExpessionSeq。如果执行过程没有抛出异常错误，那么函数的返回值就会与Pattern1（以及可选的关卡Guard1）、Pattern2等模式进行匹配，直到匹配成功。如果能匹配，那么整个try\u0026hellip;catch的值就通过执行匹配模式之后的表达式序列得出。\n如果FuncOrExpressionSeq在执行中抛出了异常错误，那么ExPattern1等捕捉模式就会与它进行匹配，找出应该执行哪一段表达式序列。ExceptionType是一个原子（throw、exit和error其中之一），它告诉我们异常错误是如何生成的。如果省略ExceptionType，就会使用默认值throw。\n关键字after之后的代码是用来在FuncOrExpressionSeq结束后执行清理的。这段代码一定会被执行 ， 哪怕有异常错误抛出也是如此。after区块的代码会在try或catch区块里的Expressions代码完成后立即运行。AfterExpressions的返回值会被丢弃。\n  try catch简写\n1try F 2catch 3\t... 4end   try catch样例\ntry_test.erl:\n1generate_exception(1) -\u0026gt; a; 2generate_exception(2) -\u0026gt; throw(a); 3generate_exception(3) -\u0026gt; exit(a); 4generate_exception(4) -\u0026gt; {\u0026#39;EXIT\u0026#39;, a}; 5generate_exception(5) -\u0026gt; error(a); 6 7demo1() -\u0026gt; 8 [catcher(I) || I \u0026lt;- [1,2,3,4,5]]. 9 10catcher(N) -\u0026gt; 11 try generate_exception(N) of 12 Val -\u0026gt; {N, normal, Val} 13 catch 14 throw:X -\u0026gt; {N, caught, thrown, X}; 15 exit:X -\u0026gt; {N, caught, exited, X}; 16 error:X -\u0026gt; {N, caught, error, X} 17 end. 1[{1,normal,a}, 2 {2,caught,thrown,a}, 3 {3,caught,exited,a}, 4 {4,normal,{\u0026#39;EXIT\u0026#39;,a}}, 5 {5,caught,error,a}]   用catch捕获异常\ntry_test.erl:\n1demo2() -\u0026gt; 2\t[{I, (catch generate_exception(I))} || I \u0026lt;- [1,2,3,4,5]] 1[{1,a}, 2 {2,a}, 3 {3,{\u0026#39;EXIT\u0026#39;,a}}, 4 {4,{\u0026#39;EXIT\u0026#39;,a}}, 5 {5,{\u0026#39;EXIT\u0026#39;, 6 {a,[try_test,genera....]}}}] 提供了详细的栈跟踪信息。\n  针对异常错误的代码模式\n  改进错误消息\n1sqrt(X) when X \u0026lt; 0 -\u0026gt; 2 error({squareRootNegativeArgument, X}); 3sqrt(X) -\u0026gt; 4 math:sqrt(X).   函数经常返回错误时该这么写：\n1case f(X) of 2\t{ok, Val} -\u0026gt; 3 do_some_thing_with(Val); 4 5\t{error, Why} -\u0026gt; 6 %% 处理错误 7end, 8...   错误罕见但可能有该这么写：\n1try my_func(X) 2catch 3\tthrow:{thisError, X} -\u0026gt; ... 4\tthrow:{someOtherError, X} -\u0026gt; ... 5end   捕捉一切可能的异常：\n1try Expr 2catch 3\t_:_ -\u0026gt; ... 处理所有异常错误的代码 4end 如果漏写了标签_ -\u0026gt; ...，就不会捕捉到所有的错误，因为在这种情形下系统会假设标签是默认的throw。\n    栈跟踪信息\n捕捉到一个异常错误后，可以调用erlang:get_stacktrace()来找到最近的栈跟踪信息。\n1demo3() -\u0026gt; 2\ttry generate_exception(5) 3\tcatch 4 error:X -\u0026gt; 5 {X, erlang:get_stacktrace()} 6\tend.   要牢记的一个重点是任其崩溃。永远不要在函数被错误参数调用时返回一个值，而是要抛出一个异常错误。要假定调用者会修复这个错误。在Erlang里，当系统内部或程序逻辑检测出错误时，正确的做法是立即崩溃并生成一段有意义的错误消息。立即崩溃是为了不让事情变得更糟。错误消息应当被写入永久性的错误日志，而且要包含足够多的细节，以便过后查明是哪里出了错。\n  练习 (1)\n file:read_file(File)会返回{ok, Bin}或者{error, Why}，其中File是文件名，Bin则包含了文件的内容。请编写一个myfile:read(File)函数，当文件可读取时返回Bin，否则抛出一个异常错误。\n 1-module(myfile). 2-export([read/1]) 3 4read(File) -\u0026gt; 5\tcase file:read_file(File) of 6\t{ok, Bin} -\u0026gt; 7\tBin; 8\t{error, Why} -\u0026gt; 9\tthrow(Why) 10\tend. 11 (2)\n 重写try_test.erl里的代码，让它生成两条错误消息：一条文明的消息给用户，另一条详细的消息给开发者。\n 1generate_exception(1) -\u0026gt; a; 2generate_exception(2) -\u0026gt; throw(\u0026#34;遇到2,程序异常\u0026#34;); 3generate_exception(3) -\u0026gt; exit(\u0026#34;遇到3,程序退出\u0026#34;); 4generate_exception(4) -\u0026gt; {\u0026#39;EXIT\u0026#39;, a}; 5generate_exception(5) -\u0026gt; error(\u0026#34;遇到5,程序错误\u0026#34;); 6 7demo1() -\u0026gt; 8 [catcher(I) || I \u0026lt;- [1,2,3,4,5]]. 9 10catcher(N) -\u0026gt; 11 try generate_exception(N) of 12 Val -\u0026gt; {N, normal, Val} 13 catch 14 throw:X -\u0026gt; {N, caught, thrown, X, \u0026#34;程序暂不可用\u0026#34;}; 15 exit:X -\u0026gt; {N, caught, exited, X, \u0026#34;程序退出\u0026#34;}; 16 error:X -\u0026gt; {N, caught, error, X, \u0026#34;程序错误\u0026#34;} 17 end. 第7章 二进制型与位语法 二进制型   二进制型的编写和打印形式是双小于号与双大于号之间的一列整数或字符串。\n在二进制型里使用整数时，它们必须属于0至255这个范围 。\n如果某个二进制型的内容是可打印的字符串，shell就会将这个二进制型打印成字符串，否则就打印成一列整数。\n1\u0026gt; \u0026lt;\u0026lt;5,10,20\u0026gt;\u0026gt;. 2\u0026lt;\u0026lt;5,10,20\u0026gt;\u0026gt; 3\u0026gt; \u0026lt;\u0026lt;\u0026#34;hello\u0026#34;\u0026gt;\u0026gt;. 4\u0026lt;\u0026lt;\u0026#34;hello\u0026#34;\u0026gt;\u0026gt; 5\u0026gt; \u0026lt;\u0026lt;65,66,67\u0026gt;\u0026gt;. 6\u0026lt;\u0026lt;\u0026#34;ABC\u0026#34;\u0026gt;\u0026gt;   操作二进制型的内置函数(binary模块里的函数)：\n list_to_binary(L) -\u0026gt; B list_to_binary返回一个二进制型，它是通过把io列表（iolist）L里的所有元素压扁后形成的（压扁的意思是移除列表里所有的括号）。 split_binary(Bin, Pos) -\u0026gt; {Bin1, Bin2} 这个函数在Pos处把二进制型Bin一分为二。 term_to_binary(Term) -\u0026gt; Bin 这个函数能把任何Erlang数据类型转换成一个二进制型。数据类型通过term_to_binary转换成二进制型后可以被保存在文件里，作为消息通过网络发送，等等，而转换前的初始数据类型可以在稍后重建。对于在文件里保存复杂数据结构，或者向远程机器发送复杂数据结构而言，这是极其有用的。 binary_to_term(Bin) -\u0026gt; Term 这是term_to_binary的逆向函数。 byte_size(Bin) -\u0026gt; Size 这个函数返回二进制型里的字节数。    位语法 1.概念\n  位语法表达式：\n1\u0026lt;\u0026lt;\u0026gt;\u0026gt; 2\u0026lt;\u0026lt;E1,E2,...,En\u0026gt;\u0026gt; 每个Ei元素都标识出二进制型或位串里的一个片段。单个Ei元素可以有4种形式：\n1Ei = Value | 2 Value:Size | 3 Value/TypeSpecifierList | 4 Value:Size/TypeSpecifierList 如果表达式的总位数是8的整数倍，就会构建一个二进制型，否则构建一个位串。\nSize的值指明了片段的大小。它的默认值取决于不同的数据类型，对整数来说是8，浮点数则是64，如果是二进制型就是该二进制型的大小。在模式匹配里，默认值只对最后那个元素有效。如果未指定片段的大小，就会采用默认值。\n  TypeSpecifierList （类型指定列表）是一个用连字符分隔的列表，形式为 End-Sign-Type-Unit。前面这些项中的任何一个都可以被省略，各个项也可以按任意顺序排列。如果省略了某一项，系统就会使用它的默认值。\n  End可以是big | little | native\n它指定机器的字节顺序。native是指在运行时根据机器的CPU来确定。默认值是big，也就是网络字节顺序（network byte order）。这一项只和从二进制型里打包和解包整数与浮点数有关。\nterm_to_binary和binary_to_term可以帮你搞定打包和解包整数的工作。因此，你可以在高位优先（big-endian）的机器上创建一个包含整数的元组，然后用term_to_binary把它转换成二进制型并发送至低位优先（little-endian）的机器。最后，在低位优先的机器上运行binary_to_term，这样元组里所有整数的值都会是正确的。\n  Sign可以是signed|unsigned\n这个参数只用于模式匹配。默认值是unsigned。\n  Type可以是integer|float|binary|bytes|bitstring|bits|utf8|utf16|utf32。\n默认值是integer。\n  Unit的写法是unit:1|2|…256 integer、float和bitstring的Unit默认值是1，binary则是8。utf8、utf16和utf32类型无需提供值。\n    2.例子\n  寻找MPEG数据里的同步帧\nmp3_sync.erl:\n1find_sync(Bin, N) -\u0026gt; 2 case is_header(N, Bin) of 3 {ok, Len1, _} -\u0026gt; 4 case is_header(N+Len1, Bin) of 5 {ok, Len2, _} -\u0026gt; 6 case is_header(N+Len1+Len2, Bin) of 7 {ok,_ ,_} -\u0026gt; 8 {ok, N}; 9 error -\u0026gt; 10 find_sync(Bin,N+1) 11 end; 12 error -\u0026gt; 13 find_sync(Bin,N+1) 14 end; 15 error -\u0026gt; 16 find_sync(Bin,N+1) 17 end. 18 19is_header(N, Bin) -\u0026gt; 20 unpack_header(get_word(N, Bin)). 21 22%% 提取32位数据进行分析 23get_word(N, Bin) -\u0026gt; 24 {_, \u0026lt;\u0026lt;C:4/binary,_/binary\u0026gt;\u0026gt;} = split_binary(Bin,N), 25 C. 26 27unpack_header(X) -\u0026gt; 28 try decode_header(X) 29 catch 30 _:_ -\u0026gt; error 31 end. 32 33%% 2#11111111111是个二进制整数，因此这个模式匹配11个连续的1位，指派给B2位，指派给C2位，以此类推。请注意，这段代码严格遵循之前给出的位级MPEG头规范。 34decode_header(\u0026lt;\u0026lt;2#11111111111,B:2,C:2,_D:1,E:4,F:2,G:1,Bits:9\u0026gt;\u0026gt;) -\u0026gt; 35 Vsn = case B of 36 0 -\u0026gt; {2,5}; 37 1 -\u0026gt; exit(badVsn); 38 2 -\u0026gt; 2; 39 3 -\u0026gt; 1 40 end, 41 Layer = case C of 42 0 -\u0026gt; exit(badLayer); 43 1 -\u0026gt; 3; 44 2 -\u0026gt; 2; 45 3 -\u0026gt; 1 46 end, 47 %% Protection = D, 48 BitRate = bitrate(Vsn, Layer, E) * 1000, 49 SampleRate = samplerate(Vsn, F), 50 Padding = G, 51 FrameLength = framelength(Layer, BitRate, SampleRate, Padding), 52 if 53 FrameLength \u0026lt; 21 -\u0026gt; 54 exit(frameSize); 55 ture -\u0026gt; 56 {ok, FrameLength, {Layer,BitRate,SampleRate,Vsn,Bits}} 57 end; 58decode_header(_) -\u0026gt; 59 exit(badHeader). 这个例子中\u0026lt;\u0026lt;C:4/binary,_/binary\u0026gt;\u0026gt;需要注意，这里C是匹配了32位。\n  解包COFF数据\n要展开这些宏，需要使用?DWORD和?LONG之类的语法。举个例子，宏?DWORD会展开成文本字面量32/unsigned-little-integer。\n1-define(DWORD, 32/unsigned-little-integer). 2-define(LONG, 32/unsigned-litter-integer). 3-define(WORD, 16/unsigned-litter-integer). 4-define(BYTE, 8/unsigned-litter-integer). 5 6unpack_image_resource_directory(Dir) -\u0026gt; 7 \u0026lt;\u0026lt;Characteristics : ?DWORD, 8 TimeDateStamp : ?DWORD, 9 MajorVersion: ?WORD,...   位串   没有按照8位边界对齐的数据或者可变长度数据，它们的数据长度用位而不是字节来表示。\n  1\u0026gt; B1 = \u0026lt;\u0026lt;1:8\u0026gt;\u0026gt;. 2\u0026lt;\u0026lt;1\u0026gt;\u0026gt; 3\u0026gt; byte_size(B1). 41 5 6\u0026gt; B2 = \u0026lt;\u0026lt;1:17\u0026gt;\u0026gt;. 7\u0026lt;\u0026lt;0,0,1:1\u0026gt;\u0026gt; 8\u0026gt; byte_size(B2). 93 10\u0026gt; bit_size(B2). 1117 12 13%% B1是一个二进制型，而B2是一个位串，因为它的长度是17位。 14%% 我们用语法\u0026lt;\u0026lt;1:17\u0026gt;\u0026gt;构建了B2，它被打印成\u0026lt;\u0026lt;0,0,1:1\u0026gt;\u0026gt;，也就是说，作为一个二进制型字面量，它的第三个片段是一个长度为1的位串。 15%% B2的位大小是17，而字节大小是3（这是包含该位串的二进制型的实际大小）。   位推导\n1\u0026gt; B = \u0026lt;\u0026lt;16#5f\u0026gt;\u0026gt;. 2\u0026gt; [X || \u0026lt;\u0026lt;X:1\u0026gt;\u0026gt; \u0026lt;= B]. 3[0,1,0,1,1,1,1,1] 4\u0026gt; \u0026lt;\u0026lt; \u0026lt;\u0026lt;X\u0026gt;\u0026gt; || \u0026lt;\u0026lt;X:1\u0026gt;\u0026gt; \u0026lt;= B \u0026gt;\u0026gt;. 5\u0026lt;\u0026lt;0,1,0,1,1,1,1,1\u0026gt;\u0026gt;   练习 (1)\n 编写一个函数来反转某个二进制型里的字节顺序。\n 反转的是字节顺序而不是位的顺序\n1reverseByte(Bin) -\u0026gt; 2\tlist_to_binary(reverseByteList(Bin)). 3\t4reverseByteList(Bin) when size(Bin) =:= 1 -\u0026gt; 5\t\u0026lt;\u0026lt;Val\u0026gt;\u0026gt; = Bin, 6\tVal; 7reverseByteList(Bin) -\u0026gt; 8\t{Bf, Bl} = split_binary(Bin,1), 9\t\u0026lt;\u0026lt;Val:8\u0026gt;\u0026gt; = Bf, 10\t[reverseByteList(Bl) , Val]. 11\t(2)\n 编写一个term_to_packet(Term) -\u0026gt; Packet函数，通过调用term_to_binary(Term)来生成并返回一个二进制型，它内含长度为4个字节的包头N，后跟N个字节的数据。\n 1term_to_packet(Term) -\u0026gt; 2\tB = term_to_binary(Term), 3\t\u0026lt;\u0026lt;Head:4/binary, Data\u0026gt;\u0026gt; = B, 4\t{packet, Head, Data}. (3)\n 编写一个反转函数 packet_to_term(Packet) -\u0026gt; Term，使它成为前一个函数的逆向函数。\n 1packet_to_term(Packet) -\u0026gt; 2\t{_, Head, Data} = Packet, 3\tbinary_to_term(\u0026lt;\u0026lt;Head, Data\u0026gt;\u0026gt;). (4)\n 按照4.1.3节的样式编写一些测试，测一下之前的两个函数是否能正确地把数据类型编码成数据包（packet），以及通过解码数据包来复原最初的数据类型。\n 不知道如何构造数据包，这道题就算了。\n(5)\n 编写一个函数来反转某个二进制型所包含的位。\n 1reversebit(Bit) -\u0026gt; 2\tRes = [ X || \u0026lt;\u0026lt;X:1\u0026gt;\u0026gt; \u0026lt;= Bit ], 3\tlist_to_binary(list:reverse(Res)). 第8章 Erlang顺序编程补遗 书本内容 本章知识比较杂乱，一些地方没有记，需要时翻原书。\n  内置函数apply(Mod, Func, [Arg1, Arg2, ..., ArgN])会将模块Mod里的Func函数应用到Arg1, Arg2, \u0026hellip; ArgN这些参数上。\n所有的Erlang内置函数也可以通过apply进行调用，方法是假定它们都属于erlang模块。\napply的Mod参数不必非得是一个原子，也可以是一个元组。这种机制可以用来创建“有状态的模块”（将在24.3节里讨论）和“适配器模式”（将在24.4节里讨论）。\n  算术表达式\n数字的意思是此参数可以是整数或浮点数\n   操作符 描述 参数类型 优先级     + X + X 数字 1   - X - X 数字 1   X * Y X * Y 数字 2   X / Y X / Y（浮点除法） 数字 2   bnot X 对X执行按位取反（bitwise not） 整数 2   X div Y X被Y整除 整数 2   X rem Y X除以Y的整数余数 整数 2   X band Y 对X和Y执行按位与（bitwise and） 整数 2   X + Y X + Y 数字 3   X - Y X - Y 数字 3   X bor Y 对X和Y执行按位或（bitwise or） 整数 3   X bxor Y 对X和Y执行按位异或（bitwise xor） 整数 3   X bsl N 把X向左算术位移（arithmetic bitshift）N位 整数 3   X bsr N 把X向右算术位移N位 整数 3      一个函数的元数（arity）是该函数所拥有的参数数量。在Erlang里，同一模块里的两个名称相同、元数不同的函数是完全不同的函数。除了碰巧使用同一个名称外，它们之间毫不相关。\n  模块属性的语法是-AtomTag(\u0026hellip;)，它们被用来定义文件的某些属性。（注意：-record(\u0026hellip;)和-include(\u0026hellip;)有着类似的语法，但是不算模块属性。）\n  -compile(export_all).这个编译器选项经常会在调试程序时用到。它会导出模块里的所有函数，无需再显式使用-export标识了。\n  块表达式用于以下情形：代码某处的Erlang语法要求单个表达式，但我们想使用一个表达式序列。\n在一个形式为[E || \u0026hellip;]的列表推导中，语法要求E是单个表达式，但我们也许想要在E里做不止一件事情。\n1begin 2\tExpr1, 3\tExpr2, 4\t... 5\tExprN 6end   Erlang没有单独的布尔值类型。不过原子true和false具有特殊的含义，可以用来表示布尔值。\n  布尔表达式not，and，or，xor\n  Erlang里的注释从一个百分号字符（%）开始，一直延伸到行尾。Erlang没有块注释。Erlang里的注释从一个百分号字符（%）开始，一直延伸到行尾。Erlang没有块注释。\n  动态代码载入每当调用someModule:someFunction(\u0026hellip;)时，调用的总是最新版模块里的最新版函数，哪怕当代码在模块里运行时重新编译了该模块也是如此。\n在任一时刻，Erlang允许一个模块的两个版本同时运行：当前版和旧版。重新编译某个模块时，任何运行旧版代码的进程都会被终止，当前版成为旧版，新编译的版本则成为当前版。\n  查看some_module.erl模块的预处理结果: erlc -P some_module.erl 这会生成一个名为some_module.P的清单文件。\n  可以在字符串和带引号的原子里使用转义序列来输入任何不可打印的字符。\n1\u0026gt; io:format(\u0026#34;~w~n\u0026#34;, [\u0026#34;\\b\\d\\e\\f\\n\\r\\s\\t\\v\u0026#34;]). 2[8,127,27,12,10,13,32,9,11] 3% 格式字符串里的~w是指忠实地打印列表，而不对输出结果进行美化。   在Erlang里，任何可以执行并生成一个值的事物都被称为表达式（expression）。\n表达式序列（expression sequence）是一系列由逗号分隔的表达式。它们在-\u0026gt;箭头之后随处可见。表达式序列E1, E2,\u0026hellip;, En的值被定义为序列最后那个表达式的值，而该表达式在计算时可以使用E1, E2等表达式所创建的绑定。\n  包含文件-include(Filename)\n包含库的头文件-include_lib(Name)\n按照Erlang的惯例，包含文件的扩展名是.hrl。包含文件里经常会有记录的定义。如果许多模块需要共享通用的记录定义，就会把它们放到包含文件里，再由所有需要这些定义的模块包含此文件。\n  ++和\u0026ndash;是用于列表添加和移除的中缀操作符。 A ++ B使A和B相加（也就是附加）。 A \u0026ndash; B从列表A中移除列表B。移除的意思是B中所有元素都会从A里面去除。请注意：如果符号X在B里只出现了K次，那么A只会移除前K个X。\n++也可以用在模式里。在匹配字符串时，可以编写如下模式：\n1f(\u0026#34;begin\u0026#34; ++ T) -\u0026gt;... 模式会扩展成[$b,$e,$g,$i,$n|T]。\n  宏的写法：\ndefine(Constant, Replacement).\ndefine(Func(Var1, Var2,..., Var), Replacement).\n当Erlang的预处理器epp碰到一个?MacroName形式的表达式时，就会展开这个宏。宏定义里出现的变量会匹配对应宏调用位置的完整形式。\n  还有一些预定义宏提供了关于当前模块的信息。列举如下：\n ?FILE展开成当前的文件名； ?MODULE展开成当前的模块名； ?LINE展开成当前的行号。    宏控制流。模块的内部支持下列指令，可以用它们来控制宏的展开。\n -undef(Macro). 取消宏的定义，此后就无法调用这个宏了。 -ifdef(Macro). 仅当Macro有过定义时才执行后面的代码。 -ifndef(Macro). 仅当Macro未被定义时才执行后面的代码。 -else. 可用于ifdef或ifndef语句之后。如果条件为否，else后面的语句就会被执行。 -endif. 标记ifdef或ifndef语句的结尾。    用宏实现DEBUG：\n1-module(m1). 2-export([loop/1]). 3 4-ifdef(debug_flag), 5-define(DEBUG(X), io:format(\u0026#34;DEBUG ~p:~p~p~n\u0026#34;m [?MODULE,?LINE,X])). 6% io:format(String, [Args])会根据String里的格式信息在Erlang shell 中打印出[Args]所含的变量。 7% 格式编码用一个~符号作为前缀。 8% ~p是美化打印（pretty print）的简称，~n则会生成一个新行。 9-else. 10-define(DEBUG(X), void). 11-endif 12 13loop(0) -\u0026gt; 14 done; 15loop(N) -\u0026gt; 16 ?DEBUG(X), 17 loop(N-1). 为了启用这个宏，我们在编译代码时设置了debug_flag。具体做法是给c/2添加一个额外参数如下：\n1\u0026gt; c(m1, {d,debug_flag}). 2{ok,m1} 3\u0026gt; m1:loop(4) 4DEBUG m1:13 4 5DEBUG m1:13 3 6DEBUG m1:13 2 7DEBUG m1:13 1 8done   模式的匹配操作符（把这个模式指派给一个临时变量Z）\n1func([{tag, {one,A}=Z1, B}=Z2|T]) -\u0026gt; 2\t... 3\t...f(...,Z2,...), 4\t...g(...,Z1,...),   整数可以有三种不同的写法：\n 传统写法 K进制整数 K#Digits $ 写法：$C这种写法代表了ASCII字符C的整数代码。    进程字典：每个Erlang进程都有一个被称为进程字典（process dictionary）的私有数据存储区域。进程字典是一个关联数组（在其他语言里可能被称作map、hashmap或者散列表），它由若干个键和值组成。每个键只有一个值。\nAPI：\n  put(Key,Value) -\u0026gt; OldValue.\n给进程字典添加一个Key, Value组合。put的值是OldValue，也就是Key之前关联的值。如果没有之前的值，就返回原子undefined。\n  get(Key) -\u0026gt; Value.\n查找Key的值。如果字典里存在Key, Value组合就返回Value，否则返回原子undefined。\n  get() -\u0026gt; [{Key,Value}].\n返回整个字典，形式是一个由{Key,Value}元组所构成的列表。\n  get_keys(Value) -\u0026gt;[Key].\n返回一个列表，内含字典里所有值为Value的键。\n  erase(Key) -\u0026gt; Value.\n返回Key的关联值，如果不存在则返回原子undefined。最后，删除Key的关联值。\n  erase() -\u0026gt; [{Key,Value}].\n删除整个进程字典。返回值是一个由{Key,Value}元组所构成的列表，代表了字典删除之前的状态。\n    引用（reference）是一种全局唯一的Erlang数据类型。它们由内置函数erlang:make_ref()创建。引用的用途是创建独一无二的标签，把它存放在数据里并在后面用于比较是否相等。\n  短路布尔表达式（short-circuit boolean expression）是一种只在必要时才对参数求值的表达式。在对应的布尔表达式里（A or B和A and B），两边的参数总会被执行，即使表达式的真值只需要第一个表达式的值就能确定也是如此。\n1Expr1 orelse Expr2 2% 它会首先执行Expr1。如果Expr1的执行结果是true，Expr2就不再执行。如果Expr1的执行结果是false，则会执行Expr2。 3 4Expr1 andalso Expr2 5% 它会首先执行Expr1。如果Expr1的执行结果是true，则会执行Expr2。如果Expr1的执行结果是false，Expr2就不再执行。   比较数据类型\n     操作符 含义     X \u0026gt; Y X大于Y   X \u0026lt; Y X小于Y   X =\u0026lt; Y X等于或小于Y   X \u0026gt;= Y X大于或等于Y   X == Y X等于Y   X /= Y X不等于Y   X =:= Y X与Y完全相同   X =/= Y X与Y不完全相同      数据类型做了全排序（total ordering）的定义：\nnumber \u0026lt; atom \u0026lt; reference \u0026lt; fun \u0026lt; port \u0026lt; pid \u0026lt; tuple(record) \u0026lt; map \u0026lt; list \u0026lt; binary\n  所有的数据类型比较操作符（除了=:=和=/=）在参数全为数字时具有以下行为:\n如果一个参数是整数而另一个是浮点数，那么整数会先转换成浮点数，然后再进行比较。\n如果两个参数都是整数或者都是浮点数，就会“按原样”使用，也就是不做转换。\n  如果==的参数不包含任何浮点数的话，那么这两个操作符的行为就是相同的。\n  函数的子句匹配总是意味着精确的模式匹配，所以如果定义了一个fun F =fun(12) -\u0026gt; \u0026hellip; end，那么试图执行F(12.0)就会出错。\n    下划线变量,_VarName 这种特殊语法代表一个常规变量（normalvariable），而不是匿名变量。\n下划线变量有两种主要的用途:\n  命名一个我们不打算使用的变量。例如，相比open(File, _)，open(File, _Mode)这种写法能让程序的可读性更高。\n  用于调试:\n1some_func(X) -\u0026gt; 2\t{P,Q} = some_other_func(X), 3\t%% io:format(\u0026#34;Q = ~p~n\u0026#34;, [Q]), 4\tP. 5% 如果编译它，编译器就会生成一个变量Q未使用的警告。 1some_func(X) -\u0026gt; 2\t{P,_Q} = some_other_func(X), 3\t%% io:format(\u0026#34;_Q = ~p~n\u0026#34;, [_Q]), 4\tP. 5% 编译器也不会再抱怨了。 一般来说，当某个变量在子句里只使用了一次时，编译器会生成一个警告，因为这通常是出错的信号。但如果这个只用了一次的变量以下划线开头，就不会有错误消息。\n    练习 (2)\n code:all_loaded()命令会返回一个由{Mod,File}对构成的列表，内含所有Erlang系统载入的模块。使用内置函数Mod:module_info()了解这些模块。编写一些函数来找出哪个模块导出的函数最多，以及哪个函数名最常见。编写一个函数来找出所有不带歧义的函数名，也就是那些只在一个模块里出现过的函数名。\n 我们从code:all_loaded()开始：\n12\u0026gt; code:all_loaded(). 2[{erpc,\u0026#34;/usr/lib/erlang/lib/kernel-8.5.4.2/ebin/erpc.beam\u0026#34;}, 3 {rpc,\u0026#34;/usr/lib/erlang/lib/kernel-8.5.4.2/ebin/rpc.beam\u0026#34;}, 4 {os,\u0026#34;/usr/lib/erlang/lib/kernel-8.5.4.2/ebin/os.beam\u0026#34;}, 5 {inet_parse,\u0026#34;/usr/lib/erlang/lib/kernel-8.5.4.2/ebin/inet_parse.beam\u0026#34;}, 6 {prim_inet,preloaded}, 7 {erts_dirty_process_signal_handler,preloaded}, 8 {socket_registry,preloaded}, 9 {error_logger,\u0026#34;/usr/lib/erlang/lib/kernel-8.5.4.2/ebin/error_logger.beam\u0026#34;}, 10 {logger_proxy,\u0026#34;/usr/lib/erlang/lib/kernel-8.5.4.2/ebin/logger_proxy.beam\u0026#34;}, 11 {logger_backend,\u0026#34;/usr/lib/erlang/lib/kernel-8.5.4.2/ebin/logger_backend.beam\u0026#34;}, 12 {proplists,\u0026#34;/usr/lib/erlang/lib/stdlib-4.3.1.3/ebin/proplists.beam\u0026#34;}, 13 {gb_trees,\u0026#34;/usr/lib/erlang/lib/stdlib-4\t.3.1.3/ebin/gb_trees.beam\u0026#34;}, 14 {logger_handler_watcher,\u0026#34;/usr/lib/erlang/lib/kernel-8.5.4.2/ebin/logger_handler_watcher.beam\u0026#34;}, 15 {logger_sup,\u0026#34;/usr/lib/erlang/lib/kernel-8.5.4.2/ebin/logger_sup.beam\u0026#34;}, 16 {erl_parse,\u0026#34;/usr/lib/erlang/lib/stdlib-4.3.1.3/ebin/erl_parse.beam\u0026#34;}, 17 {init,preloaded}, 18 {erl_features,\u0026#34;/usr/lib/erlang/lib/stdlib-4.3.1.3/ebin/erl_features.beam\u0026#34;}, 19 {application_controller,\u0026#34;/usr/lib/erlang/lib/kernel-8.5.4.2/ebin/application_controller.beam\u0026#34;}, 20 {user_sup,\u0026#34;/usr/lib/erlang/lib/kernel-8.5.4.2/ebin/user_sup.beam\u0026#34;}, 21 {io,\u0026#34;/usr/lib/erlang/lib/stdlib-4.3.1.3/ebin/io.beam\u0026#34;}, 22 {edlin,\u0026#34;/usr/lib/erlang/lib/stdlib-4.3.1.3/ebin/edlin.beam\u0026#34;}, 23 {erl_distribution,\u0026#34;/usr/lib/erlang/lib/kernel-8.5.4.2/ebin/erl_distribution.beam\u0026#34;}, 24 {prim_socket,preloaded}, 25 {logger_filters,\u0026#34;/usr/lib/erlang/lib/kernel-8.5.4.2/ebin/logger_filters.beam\u0026#34;}, 26 {io_lib,\u0026#34;/usr/lib/erlang/lib/stdlib-4.3.1.3/ebin/io_lib.beam\u0026#34;}, 27 {error_handler,\u0026#34;/usr/lib/erlang/lib/kernel-8.5.4.2/ebin/error_handler.beam\u0026#34;}, 28 {prim_buffer,preloaded}, 29 {zlib,...}, 30 {...}|...] 返回的以一个列表，里面都是模块名+位置组成的元组，我们只需要模块名即可。\n拿到一个模块名，我们就调用Mod:module_info()：\n14\u0026gt; erlang:module_info(). 2[{module,erlang}, 3 {exports,[{binary_to_atom,1}, 4 {binary_to_existing_atom,1}, 5 {binary_to_integer,1}, 6 {binary_to_integer,2}, 7 {check_process_code,2}, 8 {check_process_code,3}, 9 {alias,0}, 10 {garbage_collect,1}, 11 {garbage_collect,2}, 12 {garbage_collect_message_area,0}, 13 {is_alive,0}, 14 {list_to_integer,2}, 15 {process_display,2}, 16 {process_flag,3}, 17 {setnode,3}, 18 {suspend_process,2}, 19 {suspend_process,1}, 20 {trace_pattern,2}, 21 {spawn,2}, 22 {spawn_link,2}, 23 {spawn_monitor,2}, 24 {spawn_monitor,3}, 25 {spawn_opt,2}, 26 {spawn_opt,...}, 27 {...}|...]}, 28 {attributes,[]}, 29 {compile,[]}, 30 {md5,\u0026lt;\u0026lt;192,119,22,112,208,85,113,68,95,199,120,159,236, 31 64,31,14\u0026gt;\u0026gt;}] 32 所以每一个调用又返回一个列表，我们需要的是{export,[]}这个，里面全是函数名和元数，我们拿到这些东西就可以进行处理了。\n三个问题：\n 找出哪个模块导出的函数最多 哪个函数名最常见 找出所有不带歧义的函数名，也就是那些只在一个模块里出现过的函数名  先就做到这程度。编程里面涉及到严重的问题，普通循环和遍历到底该怎么写？还有Erlang中的变量不可再绑定这也是个问题，只能将我们想要的值输入或者输出了。\n1-module(analyse_loaded). 2-export([get_max_count/0]). 3 4% code:all_loaded/0本身返回会不完全，这一点我们不处理 5init() -\u0026gt; 6\t% 拿到所有模块 7\tM = [ Module || {Module, _Location} \u0026lt;- code:all_loaded()], 8\t% 使用apply拿到每个模块导出的函数信息 9\tget_func(M). 10\t11\t12get_func([]) -\u0026gt; 13\t[]; 14get_func(M) -\u0026gt; 15\t[H|T] = M, 16\t% 由于module_info格式是固定的，可以这样做不过有点丑 17\t[_|Other]= apply(H, module_info,[]), 18\t[{exports,Func} | _] = Other, 19\t% 这样做会多一个列表符号 20\t% Func = [ B || {A,B} \u0026lt;- apply(H, module_info,[]), A =:= exports], 21\t[{H,Func}|get_func(T)]. 22\t23\t24% 处理数目问题 25get_max_count() -\u0026gt; 26\tNumber = [size(list_to_tuple(Func)) || {Module, Func} \u0026lt;- init()], 27\tlists:max(Number). 28\t29\t第9章 类型 Erlang 的类型表示法 1.语法\n  T1 :: A|B|C...\n类型定义可以使用的非正式语法。T1被定义为A、B或C其中之一。\n  type NewTypeName(TVar1, TVar2, ..., TVarN) :: Type.\n定义新的类型可以使用语法。TVar1至TVarN是可选的类型变量，Type是一个类型表达式。\n  1-spec plan_route(point(),point()) -\u0026gt; route(). 2% 如果调用plan_route/2函数时使用了两个类型为point()的参数，此函数就会返回一个类型为route()的对象。 3-type direction() :: north | south | east | west. 4% 引入一个名为direction()的新类型，它的值是下列原子之一：north、south、east或west。 5-type point () :: {integer(),integer()}. 6% 指point()类型是一个包含两个整数的元组（integer()是预定义类型）。 7-type route() :: [{go,direction(),integer()}]. 8% 将route()类型定义为一个由三元组（3-tuple）构成的列表，每个元组都包含一个原子go，一个类型为direction的对象和一个整数。[X]这种表示法的意思是一个由X类型构成的列表。 9 10 11-type onOff() :: on | off. 12-type person() :: {person, name(), age()}. 13-type people() :: [person()]. 14-type name() :: {firstname, string()}. 15-type age() :: integer(). 16-type dict(Key,Val) :: [{Key,Val}]. 2.预定义类型\n1-type term() :: any(). 2-type boolean() :: true | false. 3-type byte() :: 0..255. 4-type char() :: 0..16#10ffff. 5-type number() :: integer() | float(). 6-type list() :: [any()]. 7-type maybe_improper_list() :: maybe_improper_list(any(),any()). 8-type maybe_improper_list(T) :: maybe_imperper_list(T,any()). 9-type string() :: [char()]. 10-type nonempty_string() :: [char(),...]. 11-type module() ::atom(). 12-type mfa() :: {atom(),atom(), atom()}. 13-type node() :: atom(). 14-type timeout() :: infinity | non_neg_integer(). 15-type no_return() :: none().  .. 表示范围。 maybe_improper_list用于指定带有非空（non-nil）最终列表尾的列表类型。这样的列表很少会用到，但是指定它们的类型是可能的！ non_neg_integer()是一个非负的整数 pos_integer()是一个正整数 neg_integer()是一个负整数。 [X,\u0026hellip;]这种表示法的意思是一个由X类型构成的非空列表（可能0也可能很多）。  3.指定函数的输入输出类型\n1-spec functionName(T1, T2, ..., Tn) -\u0026gt; Tret when 2\tTi :: Typei, 3\tTj :: Typej, 4\t... T1, T2,\u0026hellip;, Tn描述了某个函数的参数类型，Tret描述了函数返回值的类型。如果有必要，可以在可选关键字when后面引入额外的类型变量。\n类型变量可以在参数里使用，如下所示：\n1-spec lists:map(fun(A) -\u0026gt; B, [A]) -\u0026gt; [B]. 2% map函数接受一个从A类型到B类型的函数和一个由A类型对象组成的列表，然后返回一个由B类型对象组成的列表 3-spec lists:filter(fun((X) -\u0026gt; bool()),[X]) -\u0026gt; [X]. 4.导出类型和本地类型\n用注解-export_type(\u0026hellip;)导出:\n1-module(a). 2-type rich_text() :: [{font(), char()}]. 3-type font() :: integer(). 4-export_type([rich_text/0, font/0]). 5... 6% 不仅声明了一个富文本和一个字体类型，还用注解-export_type(...)导出了它们。 引用：\n1-module(b). 2... 3-sepc rich_text_length(a:rich_text()) -\u0026gt; integer(). 4% rich_text_length的输入参数使用了完全限定的类型名a:rich_text() 5.不透明类型\n希望隐藏富文本数据结构的内部细节，使得只有创建此数据结构的模块才了解类型的细节\n1-module(a). 2-opaque rich_text() :: [{font(),char()}]. 3% 创建了一个名为rich_text()的不透明类型（opaque type）。 4-export_type([rich_text/0]). 5 6-export([make_text/1, bounding_box/1]). 7-spec make_text(string()) -\u0026gt; rich_text(). 8-spec bountding_box(rich_text()) -\u0026gt; {Height::integer(), Width::integer()}. 9% 使用不透明类型为函数的输出输入类型 引用不透明类型：\n1-module(b). 2... 3do_this() -\u0026gt; 4\tX = a:make_text(\u0026#34;hello word\u0026#34;). 5\t{W,H} = a:bounding_box(X) 6 % b模块永远不需要知道变量X的内部结构 1-module(c). 2... 3 4fonts_in(Str) -\u0026gt; 5 X = a:make_text(Str), 6 [F || {F,_} \u0026lt;- X]. 我们不该知道此类型的任何内部结构信息。利用此类型的内部结构信息被称为抽象违规（abstraction violation），如果正确声明了相关函数的类型可见性，这一违规就可以被dialyzer检测出来。\ndialyzer 1.创建PLT（Persistent Lookup Table（持久性查询表）），PLT应当包含标准系统里所有类型的缓存。\n1dialyzer --build_plt --apps erts kernel stdlib 2# 生成erts、stdlib和kernel的PLT。 出现未知函数的警告是因为列出的函数存在于外部的应用中，它们不再plt中。\n2.使用dialyzer\n分析程序：\n1dialyzer app.erl 例子中分析了错误使用内置函数的返回值；内置函数的错误参数；错误的程序逻辑这几种错误。\n进行函数的类型推断：\n1typer test3.erl 3.注意事项\n使用dialyzer的最佳方式是将它用于每一个开发阶段。开始编写一个新模块时，应该首先考虑类型并声明它们，然后再编写代码。要为模块里所有的导出函数编写类型规范。先完成这一步再开始写代码。可以先注释掉未完成函数的类型规范，然后在实现函数的过程中取消注释。\n如果函数是导出的，就加上类型规范；如果不是，就要考虑添加类型规范是否有助于类型分析或者能帮助我们理解程序（请记住，类型注解是很好的程序文档）。如果dialyzer发现了任何错误，就应该停下来思考并找出错误的准确含义。\n4.干扰dialyzer的情况\n 避免使用-compile(export_all)。 为模块导出函数的所有参数提供详细的类型规范。尽量给导出函数的参数设置最严格的限制。 为记录定义里的所有元素提供默认的参数。 把匿名变量用作函数的参数经常会导致结果类型不如你预想得那么精确。要尽可能地给变量添加限制。  类型推断过程 类型推断（type inference）是指通过分析代码得出函数类型的过程。要做到这一点，我们会分析程序，寻找约束条件。用这些约束条件构建出一组约束方程式，然后求解。得到的一组类型就被称为此程序的成功分型（success typing）。\n我们把函数的推断类型称为合格类型的原因，从字面上讲就是“要让函数能成功执行，它的参数就必须属于这个类型”。\n出现的一些约束条件：\n 乘法操作符的左右参数都必须是数字 加法操作符的左右参数都必须是数字 is_integer(H)说明H必须是整数 如果函数之后调用了一个函数，那么里面这个函数的约束条件通过参数扩散到外部函数。  一个反例：\n1myand1(true, true) -\u0026gt; true; 2myand1(false, _) -\u0026gt; false; 3myand1(_, false) -\u0026gt; false. 4 5bug1(X,Y) -\u0026gt; 6\tcase myand1(X,Y) of 7\ttrue -\u0026gt; 8\tX+Y 9\tend. 在这个模块上运行dialyzer，它是不会返回错误的。因为它推断myand1函数可以接收任何值，当然数字也可以了。这个例子展示了参数类型规范的不到位（即把_当作类型而非boolean()）会导致分析程序时无法发现的错误。\n练习 第10章 编译和运行程序 设置载入代码的搜索路径 1.获取当前载入的路径值\n1code:get_path(). 2.操作载入路径的函数\n1-spec code:add_patha(Dir) -\u0026gt; true | {error,bad_directory} 2% 向载入路径的开头添加一个新目录Dir。 3-spec code:add_pathz(Dir) -\u0026gt; true | {error,bad_directory} 4% 向载入路径的末端添加一个新目录Dir 3.返回一个已加载模块的总列表\n1code:all_loaded() 4.怀疑载入了错误的模块，帮助调查哪里出了错。\n1code:clash() 5.启动erl时添加载入目录\n1erl -pa Dir1 -pa Dir2... .. -pz DirK1 -pz DirK2 2 3#-pa Dir标识会把Dir添加到代码搜索路径的开头 4#-pz Dir则会把此目录添加到代码路径的末端。 在系统启动时执行一组命令 我们可以在主目录的.erlang文件里添加上一节的代码设置载入路径。\n事实上，你可以把任意的Erlang代码放入这个文件。启动Erlang时，它会首先读取并执行此文件里的所有命令。\n1$cat .erlang 2io:format(\u0026#34;This is your home .erlang file print!~n\u0026#34;). 3 4$erl 5Erlang/OTP 25 [erts-13.2.2.5] [source] [64-bit] [smp:6:6] [ds:6:6:10] [async-threads:1] [jit:ns] 6 7This is your home .erlang file print! 8Eshell V13.2.2.5 (abort with ^G) 91\u0026gt; q(). 10ok 如果Erlang启动时的当前目录里已经有一个.erlang文件 ，它就会优先于主目录里的.erlang。通过这种方式，可以让Erlang根据不同的启动位置表现出不同的行为。这对特定的应用程序来说可能很有用。\n获取主目录：\n11\u0026gt; init:get_argument(home). 2{ok,[[\u0026#34;/home/joe\u0026#34;]]} 程序运行的三种方式 hello.erl:\n1-module(hello). 2-export([start/0]). 3 4start() -\u0026gt; 5\tio:format(\u0026#34;Hello world~n\u0026#34;). 1.Erlang Shell里编译运行\n1erl 2\u0026gt; c(hello). 3\u0026gt; hello:start(). 2.命令行里运行\nerl -noshell \u0026hellip;命令可以放在shell脚本里，所以通常会制作一个shell脚本来运行程序，里面会设置路径（用-pa Directory）并启动程序。在这个例子里用了两个-s ..命令。命令行里的函数数量是不受限制的。每个-s \u0026hellip;命令都由一个apply语句执行，运行完毕后再执行下一个命令。\n1erlc hello.erl 2# erlc hello.erl编译了hello.erl文件，生成了一个名为hello.beam的目标代码文件 3 4erl -noshell -s 5#-noshell以不带交互式shell的方式启动Erlang（因此不会看到Erlang的“徽标”，也就是通常系统启动时首先显示的那些信息）。 6#-s hello start运行hello:start()函数。注意：使用-s Mod ...选项时，Mod必须是已编译的 7#-s init stop在之前的命令完成后执行init:stop()函数，从而停止系统。\t快速脚本编程，编辑+执行代码：\n1erl -eval \u0026#39;io:format(\u0026#34;Memory: ~p~n\u0026#34;, [erlang:memory(total)]).\u0026#39;\\ 2 -noshell -s init stop 3.作为Escript运行\n可以用escript来让程序直接作为脚本运行，无需事先编译它们\nhello:\n1#!/usr/bin/env escript 2 3main(Args) -\u0026gt; 4\tio:format(\u0026#34;Hello world~n\u0026#34;). 这个文件必须包含一个main(Args)函数。当它从操作系统的shell里调用时，Args会包含一列用原子表示的命令行参数。这个文件的文件模式必须设置为“可执行”\n带命令行参数程序的运行 fac.erl:\n1-module(fac). 2-export([fac/1]). 3 4fac(0) -\u0026gt; 1; 5fac(N) -\u0026gt; N*fac(N-1). 1.Erlang Shell\n1erl 2c(fac). 3fac:fac(25). 2.命令行\nfac1.erl:\n1-module(fac1). 2-export([main/1]). 3 4main([A]) -\u0026gt; 5\tI = list_to_integer(atom_to_list(A)), 6\tF = fac(I), 7\tio:format(\u0026#34;factorial ~w= ~w~n\u0026#34;,[I,F]), 8\tinit:stop(). 9 10fac(0) -\u0026gt; 1; 11fac(N) -\u0026gt; N*fac(N-1). 1erlc fac1.erl 2erl -noshell -s fac1 main 25 这个函数的名称main没有什么特殊含义，你可以给它取任何名字。重点是函数名和命令行里的名称要一致。\n3.Escript\n无需编译就可以运行它\nfactorial:\n1#!/usr/bin/env escript 2 3main([A]) -\u0026gt; 4\tI = list_to_integer(atom_to_list(A)), 5\tF = fac(I), 6\tio:format(\u0026#34;factorial ~w = ~w~n\u0026#34;,[I,F]), 7 8fac(0) -\u0026gt; 1; 9fac(N) -\u0026gt; N*fac(N-1). 使用make使编译自动化 一个makefile模板 makefile.template\n1#别碰这几行 2.SUFFIXES: .erl .beam .yrl 3 4.erl.veam: 5\terlc -W $\u0026lt; 6\t7-yrl.erl: 8\terlc -W $\u0026lt; 9\t10ERL = erl -boot start_clean 11 12#这里是一个想要编译的Erlang模块列表。 13#如果这些模块在一行里放不下， 14#就在行尾添加一个 \\ 字符然后在下一行继续。 15#编辑下面这几行 16MOD = module1 module2\\ 17\tmodule3 ... special1 ...\\ 18\t... 19\tmoduleN 20 21#任何makefile里的第一个目标就是默认的目标。 22#如果只输入了\u0026#34;make\u0026#34;，系统就会假定为\u0026#34;make all\u0026#34;。 23#（因为\u0026#34;all\u0026#34;是这个makefile里的第一个目标） 24all: compile 25 26compile: ${MODS:%=%.beam} subdirs 27 28#此处添加特殊的编译要求 29special1.beam: special1.erl 30\t${ERL} -Dflag1 -W0 special1.erl 31\t32#从makefile里运行应用程序 33application1: compile 34\t${ERL} -pa Dir1 -s application1 start Arg1 Arg2 35\t36#subdir目标会编译子目录里的代码 37subdirs: 38\tcd dir1; $(MAKE) 39\tcd dir2; $(MAKE) 40\t... 41\t42#移除所有代码 43clean: 44\trm -rf *.beam erl_crash.dump 45\tcd dir1; $(MAKE) clean 46\tcd dir2; $(MAKE) clean 精简makefile模板 1.SUFFIXED: .erl .beam 2 3.erl.beam: 4\terlc -W $\u0026lt; 5\t6ERL = erl -boot start_clean 7 8MODS = module1 module2 module3 9 10all: compile 11\t${ERL} -pa \u0026#39;/home/joe/.../this/dir\u0026#39; -s module1 start 12\t13compile: ${MODS:%=%.beam} 14 15clean: 16\trm -rf *.beam erl_crash.dump 第11章 现实世界中的并发  Erlang进程没有共享内存，每个进程都有它自己的内存。要改变其他某个进程的内存，必须向它发送一个消息，并祈祷它能收到并理解这个消息。 Erlang进程就像人类一样，有时会死去。但和人类不同的是，当它们死亡时，会用尽最后一口气喊出导 致它们死亡的准确原因。 Erlang的错误检测正是使用的这种方式：进程可以相互连接。如果其中一个进程挂了，另一 个进程就会得到一个说明前者死亡原因的错误消息。 Erlang程序由大量进程组成。这些进程间能相互发送消息。这些消息也许能被其他进程收到和理解，也许不能。如果想知道某个消息是否已被对方进程收到和理解，就必须向该进程发送一个消息并等待回复。  第12章 并发编程 在Erlang里：\n 创建和销毁进程是非常快速的； 在进程间发送消息是非常快速的； 进程在所有操作系统上都具有相同的行为方式； 可以拥有大量进程； 进程不共享任何内存，是完全独立的； 进程唯一的交互方式就是消息传递。  基本并发函数 1.Pid = spawn(Mod, Func, Args)\n创建一个新的并发进程来执行apply(Mod, Func, Args)。这个新进程和调用进程并列运行。spawn返回一个Pid（process identifier的简称，即进程标识符）。可以用Pid来给此进程发送消息。\n请注意，元数为length(Args)的Func函数必须从Mod模块导出。\n当一个新进程被创建后，会使用最新版的代码定义模块。\n2.Pid = spawn(Fun)\n创建一个新的并发进程来执行Fun()。这种形式的spawn总是使用被执行fun的当前值，而且这个fun无需从模块里导出。\n 这两种spawn形式的本质区别与动态代码升级有关。12.8节会讨论如何从这两种spawn形式中做出选择。\n 3.Pid ! Message\n向标识符为Pid的进程发送消息Message。消息发送是异步的。发送方并不等待，而是会继续之前的工作。!被称为发送操作符。\nPid ! M被定义为M。因此，Pid1 ! Pid2 !\u0026hellip;! Msg的意思是把消息Msg发送给Pid1、Pid2等所有进程。\n4.receice... end\n接收发送给某个进程的消息。它的语法如下：\n1receive 2\tPattern1 [when Guard1] -\u0026gt; 3\tExpressions1; 4\tPattern2 [when Guard2] -\u0026gt; 5\tExpression2; 6\t... 7end 当某个消息到达进程后，系统会尝试将它与Pattern1（以及可选的关卡Guard1）匹配，如果成功就执行Expressions1。如果第一个模式不匹配，就会尝试Pattern2，以此类推。如果没有匹配的模式，消息就会被保存起来供以后处理，进程则会开始等待下一条消息。\n接收语句里的模式和关卡和我们定义函数时使用的模式和关卡具有相同的语法形式和含义。\n选择MFA还是Fun进行分裂 用显式的模块、函数名和参数列表（称为MFA）来分裂一个函数是确保运行进程能够正确升级为新版模块代码（即使用中被再次编译）的恰当方式。动态代码升级机制不适用于fun的分裂，只能用于带有显式名称的MFA上。\n如果你不关心动态代码升级，或者确定程序不会在未来进行修改，就可以使用 spawn 的spawn(Fun)形式。如果有疑问，就使用spawn(MFA)。\n简单进程示例 代码\n1-module(area_server0). 2-export([loop/0]). 3 4loop() -\u0026gt; 5 receive 6 {rectangle, Width, Ht} -\u0026gt; 7 io:format(\u0026#34;Area of ractangle is ~p~n\u0026#34;, [Width * Ht]), 8 loop(); 9 {square, Side} -\u0026gt; 10 io:format(\u0026#34;Area of square is ~p~n\u0026#34;, [Side * Side]), 11 loop() 12 end. 测试\n11\u0026gt; Pid = spawn(area_server0, loop, []). 2\u0026lt;0.36.0\u0026gt; 32\u0026gt; Pid ! {rectangle, 6, 10}. 4Area of ractangle is 60 5{rectangle, 6, 10} 最后，shell打印出{rectangle, 6, 10}，这是因为Pid ! Msg的值被定义为Msg。\n客户端-服务器示例 发送请求的进程通常称为客户端。接收请求并回复客户端的进程称为服务器。\n1.初步实例\narea_server1.erl:\n1-module(area_server1). 2-export([loop/0,rpc/2]). 3 4% 客户端 5rpc(Pid, Request) -\u0026gt; 6 Pid ! {self(), Request}, 7 receive 8 Response -\u0026gt; 9 Response 10 end. 11 12%服务器 13loop() -\u0026gt; 14 receive 15 {From, {rectangle, Width, Ht}} -\u0026gt; 16 From ! Width * Ht, 17 loop(); 18 {From, {circle, R}} -\u0026gt; 19 From ! 3.14159 * R * R, 20 loop(); 21 {From, Other} -\u0026gt; 22 From ! {error, Other}, 23 loop() 24 end. 测试\n1\u0026gt; Pid = spawn(area_server1, loop, []). 2\u0026lt;0.36.0\u0026gt; 3\u0026gt; area_server1:rpc(Pid, {rectangle, 6, 8}). 448 5\u0026gt; area_server1:rpc(Pid, {circle, 6}). 6113.097 7\u0026gt; area_server1:rpc(Pid, socks). 8{error, socks}   最佳实践是确认发送给进程的每一个消息都已收到。如果发送给进程的消息不匹配原始接收语句里的任何一个模式，这条消息就会遗留在进程邮箱里，永远无法接收。\n为了解决这个问题，我们在接收语句的最后加了一个子句，让它能匹配所有发送给此进程的消息\n  小问题：客户端向服务器发送请求然后等待响应。但我们并不是等待来自服务器的响应，而是在等待任意消息。\n  2.改进使客户端只接收对应服务器的消息\narea_server2.erl:\n1-module(area_server2). 2-export([loop/0,rpc/2]). 3 4% 客户端 5rpc(Pid, Request) -\u0026gt; 6 Pid ! {self(), Request}, 7 receive 8 {Pid, Response} -\u0026gt; 9 Response 10 end. 11 12%服务器 13loop() -\u0026gt; 14 receive 15 {From, {rectangle, Width, Ht}} -\u0026gt; 16 From ! {self(), Width * Ht}, 17 loop(); 18 {From, {circle, R}} -\u0026gt; 19 From ! {self(), 3.14159 * R * R}, 20 loop(); 21 {From, Other} -\u0026gt; 22 From ! {self(), {error, Other}}, 23 loop() 24 end. 这段代码客户端多了Pid匹配，服务器多了Pid发送。\n3.封装，使spawn和rpc函数隐藏\n1-module(area_server_final). 2-export([area/2, start/0, loop/0]). 3 4% 客户端 5area(Pid, What) -\u0026gt; 6 rpc(Pid, What). 7rpc(Pid, Request) -\u0026gt; 8 Pid ! {self(), Request}, 9 receive 10 {Pid, Response} -\u0026gt; 11 Response 12 end. 13 14%服务器 15start() -\u0026gt; 16 spawn(area_server_final, loop, []). 17loop() -\u0026gt; 18 receive 19 {From, {rectangle, Width, Ht}} -\u0026gt; 20 From ! {self(), Width * Ht}, 21 loop(); 22 {From, {circle, R}} -\u0026gt; 23 From ! {self(), 3.14159 * R * R}, 24 loop(); 25 {From, Other} -\u0026gt; 26 From ! {self(), {error, Other}}, 27 loop() 28 end. 请注意，还需要把spawn的参数（也就是loop/0）从模块中导出。这是一种好的做法，因为它能让我们在不改变客户端 代码的情况下修改服务器的内部细节。（我想可能是加参数的一些东西）\n计算进程平均创建时间 processes.erl\n1-module(processes). 2-export([max/1]). 3 4% max(N) 5% 创建N个进程然后销毁 6 7max(N) -\u0026gt; 8 Max = erlang:system_info(process_limit), 9 io:format(\u0026#34;Maximum allowed processes: ~p~n\u0026#34;, [Max]), 10 statistics(runtime), 11 statistics(wall_clock), 12 L = for(1, 13 N, 14 % 创建进程wait函数 15 fun() -\u0026gt; 16 spawn(fun() 17 -\u0026gt; wait() 18 end) 19 end), 20 {_, Time1} = statistics(runtime), 21 {_, Time2} = statistics(wall_clock), 22 lists:foreach( 23 fun(Pid) -\u0026gt; 24 Pid ! die end, 25 L), 26 U1 = Time1 * 1000 / N, 27 U2 = TIme2 * 1000 / N, 28 io:format(\u0026#34;Process spawn time=~p(~p) microseconds~n\u0026#34;, [U1, U2]). 29 30wait() -\u0026gt; 31 receive 32 die -\u0026gt; void 33 end. 34 35for(N,N,F) -\u0026gt; [F()]; 36for(I,N,F) -\u0026gt; [F()|for(I+1,N,F)].   内置函数 erlang:system_info(process_limit)来找出所允许的最大进程数量。其中有一些是系统保留的进程，所以你的程序实际上不能用那么多。当超出限制值时，系统会拒绝启动更多的进程并生成一个错误报告\n  系统内设的限制值是262 144个进程。要超越这一限制，必须用+P标识启动Erlang仿真器\n1erl +P 3000000 随着进程数量的增加，进程分裂时间也在增加。如果继续增加进程的数量，最终会耗尽物理内存，导致系统开始把物理内存交换到硬盘上，运行速度明显变慢。\n  statistics(wall_clock)：Returns information about wall clock. wall_clock can be used in the same manner as runtime, except that real time is measured as opposed to runtime or CPU time.\n  statistics(runtime)：Returns information about runtime, in milliseconds.This is the sum of the runtime for all threads in the Erlang runtime system and can therefore be greater than the wall clock time.\n  超时的接收   给接收语句增加一个超时设置，设定进程等待接收消息的最长时间：\n1receive 2\tPattern1 [when Guard1] -\u0026gt; 3 Expressions1; 4\tPattern2 [when Guard2] -\u0026gt; 5 Expressions2; 6\t... 7after Time -\u0026gt; 8 Expressions 9end 如果在进入接收表达式的Time毫秒后还没有收到匹配的消息，进程就会停止等待消息，转而执行Expressions。\n当然如果在规定时间受到匹配消息，这条语句就结束了，receive end只会处理一条语句。具体原理看下一节\n  只带超时的接收：\n可以编写一个只有超时部分的receive。通过这种方法，我们可以定义一个sleep(T)函数，它会让当前的进程挂起T毫秒：\n1sleep(T) -\u0026gt; 2 receive 3 after T -\u0026gt; 4 true 5 end.   超时值为 0 的接收：\n超时值为0会让超时的主体部分立即发生，但在这之前，系统会尝试对邮箱里的消息进行匹配。（先对消息匹配，匹配完之后让超时部分立即发生）\n请记住，只有当邮箱里的所有条目都进行过模式匹配后，才会检查after部分。\n对大的邮箱使用优先接收是相当低效的，所以如果你打算使用这一技巧，请确保邮箱不要太满。\n可以用它来定义一个flush_buffer函数，它会清空进程邮箱里的所有消息：\n1flush_buffer() -\u0026gt; 2 receive 3 _Any -\u0026gt; 4 flush_buffer() 5 % 如果没有超时子句，flush_buffer就会在邮箱为空时永远挂起且不返回。 6 after 0 -\u0026gt; 7 true 还可以使用零超时来实现某种形式的“优先接收”：\n1priority_receive() -\u0026gt; 2 receive 3 % 如果存在匹配{alarm, X}的消息，这个消息就会被立即返回。 4 % 如果没有after 0语句，警告（alarm）消息就不会被首先匹配。 5 {alarm,X} -\u0026gt; 6 {alarm,X} 7 after 0 -\u0026gt; 8 % 如果邮箱里不存在匹配{alarm, X}的消息，priority_receive就会接收邮箱里的第一个消息。 9 % 如果没有任何消息，它就会在最里面的接收语句处挂起，并返回它收到的第一个消息。 10 receive 11 Any -\u0026gt; 12 Any 13 end 14 end.   超时值为无穷大的接收：\n如果接收语句里的超时值是原子infinity（无穷大），就永远不会触发超时。这对那些在接收语句之外计算超时值的程序可能很有用。有时候计算的结果是返回一个实际的超时值，其他的时候则是让接收语句永远等待下去。\n  可以用接收超时来实现一个简单的定时器：\nstimer.erl：\n1-module(stimer). 2-export([start/2, cancel/1]). 3 4start(Time, Fun) -\u0026gt; spawn(fun() -\u0026gt; timer(Time,Fun) end). 5% 向进程发送消息cancel 6cancel(Pid) -\u0026gt; Pid ! cancel. 7timer(Time, Fun) -\u0026gt; 8 receive 9 % 在Time前收到消息cancel则会关闭这个定时器 10 cancel -\u0026gt; 11 void 12 after Time -\u0026gt; 13 Fun() 14 end. 1\u0026gt; Pid = stimer:start(5000, fun() -\u0026gt; io:format(\u0026#34;timer event~n\u0026#34;) end). 2\u0026lt;0.42.0\u0026gt; 3timer event 1\u0026gt; Pid1 = stimer:start(25000, fun() -\u0026gt; io:format(\u0026#34;timer event~n\u0026#34;) end). 2\u0026lt;0.49.0\u0026gt; 3\u0026gt; stimer:cancel(Pid1). 4cancel   receive的工作方式   进入receive语句时会启动一个定时器（但只有当表达式包含after部分时才会如此）。\n  取出邮箱里的第一个消息，尝试将它与Pattern1、Pattern2等模式匹配。\n  如果匹配成功，系统就会从邮箱中移除这个消息，并执行模式后面的表达式。\n如果receive语句里的所有模式都不匹配邮箱的第一个消息，系统就会从邮箱中移除这个消息并把它放入一个“保存队列”\n然后继续尝试邮箱里的第二个消息。这一过程会不断重复，直到发现匹配的消息或者邮箱里的所有消息都被检查过了为止。\n  如果邮箱里的所有消息都不匹配，进程就会被挂起并重新调度，直到新的消息进入邮箱才会继续执行。新消息到达后，保存队列里的消息不会重新匹配，只有新消息才会进行匹配。\n  后面一旦某个消息匹配成功，保存队列里的所有消息就会按照到达进程的顺序重新进入邮箱。如果设置了定时器，就会清除它。\n  如果定时器在我们等待消息时到期了，系统就会执行表达式ExpressionsTimeout，并把所有保存的消息按照它们到达进程的顺序重新放回邮箱。\n  注册进程 如果想给一个进程发送消息，就需要知道它的PID，但是当进程创建时，只有父进程才知道它的PID。系统里没有其他进程知道它的存在。\nErlang有一种公布进程标识符的方法，它让系统里的任何进程都能与该进程通信。这样的进程被称为注册进程（registered process）。管理注册进程的内置函数有四个：\n  register(AnAtom, Pid)\n用AnAtom（一个原子）作为名称来注册进程Pid。如果AnAtom已被用于注册某个进程，这次注册就会失败。\n  unregister(AnAtom)\n移除与AnAtom关联的所有注册信息。如果某个注册进程崩溃了，就会自动取消注册。\n  whereis(AnAtom) -\u0026gt; Pid | undefined\n检查AnAtom是否已被注册。如果是就返回进程标识符Pid，如果没有找到与AnAtom关联的进程就返回原子undefined。\n  registered() -\u0026gt; [AnAtom::atom()]\n返回一个包含系统里所有注册进程的列表。\n  示例：\n一旦名称注册完成，就可以用注册的原子给它发送消息\n1\u0026gt; Pid = spawn(area_server0, loop, []). 2\u0026lt;0.51.0\u0026gt; 3\u0026gt; register(area, Pid). 4true 5\u0026gt; area ! {rectangle, 4, 5}. 6Area of rectangle is 20 7{rectangle, 4, 5} 一个模拟时钟的进程：\n1-module(clock). 2-export([start/2, stop/0]). 3 4% 创建一个tick进程并注册为clock 5start(Time, Fun) -\u0026gt; 6 register(clock, spawn(fun() -\u0026gt; tick(Time, Fun) end)). 7% 给名为clock的注册进程发送消息stop 8stop() -\u0026gt; clock ! stop. 9%每隔Time执行一次Fun，然后重复 10tick(Time, Fun) -\u0026gt; 11 receive 12 stop -\u0026gt; 13 void 14 after Time -\u0026gt; 15 Fun(), 16 tick(Time, Fun) 17 end. 1\u0026gt; clock:start(5000, fun() -\u0026gt; io:format(\u0026#34;TICK ~p~n\u0026#34;, [erlang:now()]) end).\t2 3\u0026gt; clock:stop(). 尾递归 如果你仔细观察，就会发现每当我们收到消息时就会处理它并立即再次调用loop()。这一过程被称为尾递归（tail-recursive）。可以对一个尾递归的函数进行特别编译，把语句序列里的最后一次函数调用替换成跳至被调用函数的开头。这就意味着尾递归的函数无需消耗栈空间也能一直循环下去。\n假设编写了以下（不正确的）代码：\n1loop() -\u0026gt; 2 receive 3 {From, {rectangle, Width, Ht}} -\u0026gt; 4 From ! {self(), Width * Ht}, 5 loop(), 6 someOtherFunc(); 7 {From, {circle, R}} -\u0026gt; 8 .... 9\tend 10end 我们在第5行里调用了loop()，但是编译器必然推断出“当我调用loop()后必须返回这里，因为我得调用第6行里的someOtherFunc()”。于是它把someOtherFunc的地址推入栈，然后跳到loop的开头。这么做的问题在于loop()是永不返回的，它会一直循环下去。所以，每次经过第5行，就会有一个返回地址被推入控制栈，最终系统的空间会消耗殆尽。\n避免这个问题的方法很简单，如果你编写的函数F是永不返回的（就像loop()一样），就要确保在调用F之后不再调用其他任何东西，并且别把F用在列表或元组构造器里。\n并发程序模板 1-module(ctemplate). 2-compile(export_all). 3 4start() -\u0026gt; 5 spawn(?MODULE, loop, []). 6 7rpc(Pid, Request) -\u0026gt; 8 Pid ! {self(), Request}, 9 receive 10 {Pid, Response} -\u0026gt; 11 Response 12 end. 13 14loop(X) -\u0026gt; 15 receive 16 Any -\u0026gt; 17 io:format(\u0026#34;Received:~p~n\u0026#34;, [Any]), 18 loop(X) 19 end. 给接收循环添加一个匹配模式并重新运行程序。这一技巧在相当程度上决定了我编写程序的顺序：从一个小程序开始，逐渐扩展它，并在开发过程中不断进行测试。\n练习 (3)\n 编写一个环形计时测试。创建一个由N个进程组成的环。把一个消息沿着环发送M次，这样总共发送的消息数量是N * M。记录不同的N和M值所花费的时间。\n 创建这些进程是非常麻烦的，如果是同步创建，那么不能绑定Pid，只能在发送的时候寻找Pid，那么就必须要注册，而注册使用的原子需要是不一样且有规律的，所以说需要字符串处理拼接。\n字符串拼接不熟悉，先放这。\n1%%%------------------------------------------------------------------- 2%%% @author bnaod1 3%%% @copyright (C) 2024, \u0026lt;COMPANY\u0026gt; 4%%% @doc 5%%% 6%%% @end 7%%% Created : 12. 12月 2024 15:25 8%%%------------------------------------------------------------------- 9-module(ring_timer). 10-author(\u0026#34;bnaod1\u0026#34;). 11 12%% API 13-export([]). 14 15 16init(N) -\u0026gt; 17 % 创建N个进程 18 L = for(1, N, fun() -\u0026gt; spawn(fun() -\u0026gt; ring() end) end), 19 % 注册进程 20 21 22registerN([]) -\u0026gt; 23 void; 24registerN(L) -\u0026gt; 25 [H|T] = L, 26 register(,H), 27 registerN(T). 28 29 30ring() -\u0026gt; 31 receive 32 _Any -\u0026gt; 33 % 将消息发给下一个进程 34 Pid = find_next(self()), 35 Pid ! _Any, 36 io:format(\u0026#34;Send msg ~pto ~p~n\u0026#34;, [Pid, _Any]), 37 ring() 38 end. 39 40 41 42for(N,N,F) -\u0026gt; [F()]; 43for(I,N,F) -\u0026gt; [F()|for(I+1,N,F)]. 44 45 第13章 并发程序中的错误 在Erlang里，我们有大量的进程可供支配，因此任何单进程故障都不算特别重要。通常只需编写少量的防御性代码，而把重点放在编写纠正性代码上。我们采取各种措施检测错误，然后在错误发生后纠正它们。\n检测错误和找出故障原因内建于Erlang虚拟机底层的功能，也是Erlang编程语言的一部分。标准OTP库提供了构建互相监视的进程组和在检测到错误时采取纠正措施的功能，23.5节中会进行相关介绍。这一章介绍的是语言层面的错误检测和恢复。\n错误处理的理念   让其他进程修复错误：要让一个进程监控另一个，就必须在它们之间创建一个连接（link）或监视（monitor）。如果被连接或监视的进程挂了，监控进程就会得到通知。\n这可以作为顺序代码错误处理的延伸。虽然可以捕捉顺序代码里的异常并尝试纠正错误（这是第6章的主题），但如果失败了或者整台机器出了故障，就要让其他进程来修复错误。\n  任其崩溃：如果在错误发生后第一时间举旗示意，就能得到非常好的错误诊断。在错误发生后继续运行经常会导致更多错误发生，让调试变得更加困难。\n  错误处理的术语   进程\n进程有两种：普通进程和系统进程。\nspawn创建的是普通进程。\n普通进程可以通过执行内置函数process_flag(trap_exit, true)变成系统进程。\n  连接\n进程可以互相连接。如果A和B两个进程有连接，而A出于某种原因终止了，就会向B发送一个错误信号，反之亦然。\n  连接组\n进程P的连接组是指与P相连的一组进程。\n  监视\n监视和连接很相似，但它是单向的。如果A监视B，而B出于某种原因终止了，就会向A发送一个“宕机”消息，而不是退出信号。但反过来就不行了\n当你想要不对称的错误处理时，可以使用监视，对称的错误处理则适合使用连接。监视通常会被服务器用来监视客户端的行为。\n  消息和错误信号\n进程协作的方式是交换消息或错误信号。\n消息是通过基本函数send发送的，错误信号则是进程崩溃或进程终止时自动发送的。错误信号会发送给终止进程的连接组。\n  错误信号的接收\n当系统进程收到错误信号时，该信号会被转换成{\u0026lsquo;EXIT\u0026rsquo;, Pid, Why}形式的消息。Pid是终止进程的标识，Why是终止原因（有时候被称为退出原因）。如果进程是无错误终止，Why就会是原子normal，否则Why会是错误的描述。（基于这个特性，系统进程可以充当防火墙的作用）\n当普通进程收到错误信号时，如果退出原因不是normal，该进程就会终止。当它终止时，同样会向它的连接组广播一个退出信号。\n  显式错误信号\n任何执行exit(Why)的进程都会终止（如果代码不是在catch或try的范围内执行的话），并向它的连接组广播一个带有原因Why的退出信号。\n进程可以通过执行exit(Pid, Why)来发送一个“虚假”的错误信号。在这种情况下，Pid会收到一个带有原因Why的退出信号。调用exit/2的进程则不会终止（这是有意如此的）。\n  不可捕捉的退出信号\n系统进程收到摧毁信号（kill signal）时会终止。摧毁信号是通过调用exit(Pid, kill)生成的。这种信号会绕过常规的错误信号处理机制，不会被转换成消息。摧毁信号只应该用在其他错误处理机制无法终止的顽固进程上。\n  基本错误处理函数   -spec spawn_link(Fun) -\u0026gt; Pid\n-spec spawn_link(Mod, Fnc, Args) -\u0026gt; Pid\n它们的行为类似于spawn(Fun)和spawn(Mod,Func,Args)，同时还会在父子进程之间创建连接。\n  -spec spawn_monitor(Fun) -\u0026gt; {Pid, Ref}\n-spec spawn_monitor(Mod, Func, Args) -\u0026gt; {Pid, Ref}\n它与spawn_link相似，但创建的是监视而非连接。Pid是新创建进程的进程标识符，Ref是该进程的引用。如果这个进程因为Why的原因终止了，消息{\u0026lsquo;DOWN\u0026rsquo;,Ref,process,Pid,Why}就会被发往父进程。\n  -spec process_flag(trap_exit, true)\n它会把当前进程转变成系统进程。系统进程是一种能接收和处理错误信号的进程。\n  -spec link(Pid) -\u0026gt; true\n它会创建一个与进程Pid的连接。连接是双向的。如果进程A执行了link(B)，就会与B相连。实际效果就和B执行link(A)一样。\n如果进程Pid不存在，就会抛出一个noproc退出异常。\n如果执行link(B)时A已经连接了B（或者相反），这个调用就会被忽略。\n  -spec unlink(Pid) -\u0026gt; true\n它会移除当前进程和进程Pid之间的所有连接。\n  -spec erlang:monitor(process, Item) -\u0026gt; Ref\n它会设立一个监视。Item可以是进程的Pid，也可以是它的注册名称。\n  -sepc demonitor(Ref) -\u0026gt; true\n它会移除以Ref作为引用的监视。\n  -spec exit(Why) -\u0026gt; none()\n它会使当前进程因为Why的原因终止。如果执行这一语句的子句不在catch语句的范围内，此进程就会向当前连接的所有进程广播一个带有参数Why的退出信号。它还会向所有监视它的进程广播一个DOWN消息。\n  -spec exit(Pid, Why) -\u0026gt; true\n它会向进程Pid发送一个带有原因Why的退出信号。执行这个内置函数的进程本身不会终止。它可以用于伪造退出信号。\n  容错式编程示例 1.在进程终止时执行操作\n1on_exit(Pid, Fun) -\u0026gt; 2 spawn(fun() -\u0026gt; 3 Ref = monitor(process, Pid), 4 receive 5 {\u0026#39;DOWN\u0026#39;, Ref, process, Pid, Why} -\u0026gt; 6 Fun(Why) 7 end 8 end). 11\u0026gt; F = fun() -\u0026gt; 2\treceive 3\tX -\u0026gt; list_to_atom(X) 4\tend 5\tend. 62\u0026gt; Pid = spawn(F). 7 83\u0026gt; lib_misc:on_exit(Pid, 9\tfun(Why) -\u0026gt; 10\tio:format(\u0026#34; ~p died with:~p~n\u0026#34;, [Pid, Why]) 11\tend). 12# 如果向Pid发送一个原子，这个进程就会挂掉（因为它试图对非列表类型执行list_to_atom） 134\u0026gt; Pid ! hello. 14hello 155\u0026gt; 16=ERROR REPORT====  进程挂掉时触发的函数可以执行任何它喜欢的计算：它可以忽略错误，记录错误或者重启应用程序。这个选择完全取决于程序员。  2.让一组进程共同终止\n1start(Fs) -\u0026gt; 2 spawn(fun() -\u0026gt; 3 % 创建进程并且建立连接 4 [spawn_link(F) || F \u0026lt;- Fs], 5 receive 6 after 7 infinity -\u0026gt; true 8 end 9 end). 1Pid = start([F1,F2,...]), 2on_exit(Pid, fun(Why) -\u0026gt; 3\t... 4\t... 5\tend)  各个进程通过start函数创建的进程连接，于是一个挂了发送的退出信号全部都会接收，于是全都会终止  3.生成一个永不终止的进程\n1keep_alive(Name,Fun) -\u0026gt; 2 register(Name, Pid = spawn(Fun)), 3 on_exit(Pid, fun(_Why) -\u0026gt; keep_alive(Name, Fun) end).  可能会在register和on_exit这两个语句之间挂掉。如果进程在on_exit被执行之前终止，就不会创建连接，on_exit进程的行为就会和预计的不同。如果有两个程序同时尝试用相同的Name值执行keep_alive，这个错误就会发生这被称为竞争状况（race condition）：两段代码（都是这段）和on_exit里执行连接操作的代码片段正在互相竞争。如果这里出了错，程序就可能会表现出你预料之外的行为。 一般语言解决并发程序竞争时可以加锁或者设置信号量，不过Erlang语言的全局变量不太好搞定。  练习 (1)\n 编写一个my_spawn(Mod, Func, Args)函数。它的行为类似spawn(Mod, Func, Args)，但有一点区别。如果分裂出的进程挂了，就应打印一个消息，说明进程挂掉的原因以及在此之前存活了多长时间。\n 使用spawn函数需要注意，模块里面的函数使用spawn最好时MFA的形式，而匿名函数使用Fun的形式，不然会有一些奇怪的问题。\n1%%%------------------------------------------------------------------- 2%%% @author bnaod1 3%%% @copyright (C) 2024, \u0026lt;COMPANY\u0026gt; 4%%% @doc 5%%% 6%%% @end 7%%% Created : 13. 12月 2024 09:10 8%%%------------------------------------------------------------------- 9-module(my_spawn). 10-author(\u0026#34;bnaod1\u0026#34;). 11 12%% API 13-export([my_spawn/3, test/0]). 14 15 16my_spawn(Mod, Func, Argc) -\u0026gt; 17 Pid = spawn(Mod, Func, Argc), 18 io:format(\u0026#34;Process ~pstart.~n\u0026#34;, [Pid]), 19 statistics(runtime), 20 Ref = monitor(process, Pid), 21 receive 22 {\u0026#39;DOWN\u0026#39;, Ref, process, Pid, Why} -\u0026gt; 23 {_, Time} = statistics(runtime), 24 U = Time, 25 io:format(\u0026#34;Process ~psurvived ~pseconds.~n\u0026#34;, [Pid, U]), 26 io:format(\u0026#34;Process ~pdied for reason ~p~n\u0026#34;, [Pid, Why]) 27 end 28 . 29 30 31 32test() -\u0026gt; 33 receive 34 X -\u0026gt; list_to_atom(X) 35 end. 11\u0026gt; c(my_spawn). 2{ok,my_spawn} 32\u0026gt; Pid = spawn(my_spawn, my_spawn, [my_spawn, test, []]). 4Process \u0026lt;0.90.0\u0026gt; start. 5\u0026lt;0.89.0\u0026gt; 63\u0026gt; \u0026lt;0.90.0\u0026gt; ! e1. 7Process \u0026lt;0.90.0\u0026gt; survived 9 seconds. 8=ERROR REPORT==== 13-Dec-2024::10:38:36.634989 === 9Error in process \u0026lt;0.90.0\u0026gt; with exit value: 10{badarg,[{erlang,list_to_atom, 11 [e1], 12 [{error_info,#{module =\u0026gt; erl_erts_errors}}]}, 13 {my_spawn,test,0,[{file,\u0026#34;my_spawn.erl\u0026#34;},{line,34}]}]} 14 15e1 16Process \u0026lt;0.90.0\u0026gt; died for reason {badarg, 17 [{erlang,list_to_atom, 18 [e1], 19 [{error_info, 20 #{module =\u0026gt; erl_erts_errors}}]}, 21 {my_spawn,test,0, 22 [{file,\u0026#34;my_spawn.erl\u0026#34;},{line,34}]}]} 234\u0026gt; (2)\n 用本章前面展示的on_exit函数来完成上一个练习。\n 这个题就是count函数，如果传函数定义的话是不行的，只能使用匿名函数。\n破案了，原来是spawn里面参数不能加括号。\n1%%%------------------------------------------------------------------- 2%%% @author bnaod1 3%%% @copyright (C) 2024, \u0026lt;COMPANY\u0026gt; 4%%% @doc 5%%% 6%%% @end 7%%% Created : 13. 12月 2024 10:40 8%%%------------------------------------------------------------------- 9-module(question2). 10-author(\u0026#34;bnaod1\u0026#34;). 11 12%% API 13-export([time/0,on_exit/2,test/0,sleep/2]). 14 15 16time() -\u0026gt; 17 %% 创建测试进程 18 Pid = spawn(question2, test, []), 19 %% 开始计时 20 statistics(wall_clock), 21 %% 创建监视进程，一旦死亡执行count计算时间 22 on_exit(Pid, fun() -\u0026gt; 23 {_, Time} = statistics(wall_clock), 24 io:format(\u0026#34;Duration: ~p~n\u0026#34;, [Time]) 25 end), 26 %% 创建一个进程，隔一定时间使进程死亡 27 sleep(Pid, 3000), 28 done. 29 30%% 监视器 31on_exit(Pid, Fun) -\u0026gt; 32 spawn(fun() -\u0026gt; 33 Ref = monitor(process, Pid), 34 receive 35 {\u0026#39;DOWN\u0026#39;, Ref, process, Pid, Why} -\u0026gt; 36 Fun() 37 end 38 end). 39 40%% 计算存活时间 41%%count() -\u0026gt; 42%% {_, Time} = statistics(runtime), 43%% io:format(\u0026#34;Duration: ~p~n\u0026#34;, [Time]). 44 45%% 隔一定时间发送死亡通知 46sleep(Pid, T) -\u0026gt; 47 spawn(fun() -\u0026gt; 48 receive 49 after T -\u0026gt; 50 Pid ! seterror 51 end 52 end 53 ). 54 55 56%% 测试函数 57test() -\u0026gt; 58 receive 59 X -\u0026gt; list_to_atom(X) 60 end. (3)\n 编写一个my_spawn(Mod, Func, Args, Time)函数。它的行为类似spawn(Mod, Func,Args)，但有一点区别。如果分裂出的进程存活超过了Time秒，就应当被摧毁。\n 使用spawn函数时，放入的函数只能是名字，不能加括号。\n1%%%------------------------------------------------------------------- 2%%% @author bnaod1 3%%% @copyright (C) 2024, 四川农业大学 4%%% @doc 5%%% 6%%% @end 7%%% Created : 13. 12月 2024 11:19 8%%%------------------------------------------------------------------- 9-module(question3). 10-author(\u0026#34;bnaod1\u0026#34;). 11 12%% API 13-export([start/0,my_spawn/4,test/0]). 14 15start() -\u0026gt; 16 spawn(question3, my_spawn, [question3, test, [], 3000]). 17 18my_spawn(Mod, Func, Args, Time) -\u0026gt; 19 Pid = spawn(Mod, Func, Args), 20 receive 21 after Time -\u0026gt; 22 Pid ! shutdown 23 end. 24 25test() -\u0026gt; 26 io:format(\u0026#34;test is running.~n\u0026#34;), 27 receive 28 shutdown -\u0026gt; 29 exit(\u0026#34;Time limit~n\u0026#34;) 30 after 1000 -\u0026gt; 31 test() 32 end. 33 (4)\n 编写一个函数，让它创建一个每隔5秒就打印一次“我还在运行”的注册进程。\n编写一个函数来监视这个进程，如果进程挂了就重启它。\n启动公共进程和监视进程，然后摧毁公共进程，检查它是否会被监视进程重启。\n 1%%%------------------------------------------------------------------- 2%%% @author bnaod1 3%%% @copyright (C) 2024, 四川农业大学 4%%% @doc 5%%% 6%%% @end 7%%% Created : 13. 12月 2024 14:35 8%%%------------------------------------------------------------------- 9-module(question4). 10-author(\u0026#34;bnaod1\u0026#34;). 11 12%% API 13-export([start/0,make/0,print/0,monitor_print/0]). 14 15start() -\u0026gt; 16 make(), 17 spawn(question4, monitor_print, []). 18 19 20make() -\u0026gt; 21 register(period, spawn(question4, print, [])). 22 23print() -\u0026gt; 24 receive 25 {_, die} -\u0026gt; 26 io:format(\u0026#34;died~n\u0026#34;), 27 exit(\u0026#34;command die\u0026#34;); 28 {Pid, comfirm} -\u0026gt; 29 Pid ! {self(), \u0026#34;still alive\u0026#34;} 30 after 5000 -\u0026gt; 31 io:format(\u0026#34;Im still running.~n\u0026#34;), 32 print() 33 end. 34 35monitor_print() -\u0026gt; 36 Ref = monitor(process, period), 37 receive 38 {\u0026#39;DOWN\u0026#39;, Ref, process, Pid, Why} -\u0026gt; 39 io:format(\u0026#34;Process period died, restart...~n\u0026#34;), 40 make(), 41 spawn(question4, monitor_print, []) 42 end. 43 44 45 (5)\n 编写一个函数来启动和监视多个工作进程。如果任何一个工作进程非正常终止，就重启它。\n 1  编写一个函数来启动和监视多个工作进程。如果任何一个工作进程非正常终止，就摧毁所有工作进程，然后重启它们。\n 1 第14章 分布式编程 分布式优势  性能：可以通过安排程序的不同部分在不同的机器上并行运行来让程序跑得更快。 可靠性：可以通过让系统运行在数台机器上来实现容错式系统。如果一台机器出了故障，可以在另一台机器上继续。 可扩展性：随着我们把应用程序越做越大，即使机器的处理能力再强大也迟早会耗尽。到那时，就必须添加更多的机器来提升处理能力。添加一台新机器应当是一次简单的操作，不需要对应用程序的架构做出大的修改。  分布式Erlang示例 本质上都是通过rpc在远程节点上执行操作然后返回。注意这里就有节点的称呼了。\n不同阶段处理的问题主要是最开始的连通问题，而不是代码问题，他们都是使用rpc对远程服务器进行的方法调用。所以本质来说我认为只有一个服务器节点。\n第1阶段：双方在同一节点 一个简单的名称服务器。这步的代码和我们之前所学的一样\nsocket_dist/kvs.erl:\n1-module(kvs). 2-export([start/0, store/2, lookup/1]). 3 4%注册服务器进程为kvs 5start() -\u0026gt; register(kvs, spawn(fun() -\u0026gt; loop() end)). 6 7%服务器：一直在接收消息中 8loop() -\u0026gt; 9 receive 10 {From, {store, Key, Value}} -\u0026gt; 11 put(Key, {ok, Value}), 12 From ! {kvs, true}, 13 loop(); 14 {From, {lookup, Key}} -\u0026gt; 15 From ! {kvs, get(Key)}, 16 loop() 17 end. 18 19%封装客户端的消息 20store(Key, Value) -\u0026gt; rpc({lookup, Key}). 21lookup(Key) -\u0026gt; rpc({lookup, Key}). 22 23%客户端：每次进行一次操作然后等待服务器回信 24rpc(Q) -\u0026gt; 25 kvs ! {self(), Q}, 26 receive 27 {kvs, Reply} -\u0026gt; 28 Reply 29 end. 30 31 测试：\n1\u0026gt; kvs:start(). 2true 3\u0026gt; kvs:store({location, joe}, \u0026#34;Stockholm\u0026#34;). 4true 5\u0026gt; kvs:store(weather, raining). 6true 7\u0026gt; kvs:lookup(weather). 8{ok, raining} 9\u0026gt; kvs:lookup({location, joe}). 10{ok, \u0026#34;Stockholm\u0026#34;} 11\u0026gt; kvs:lookup({location, jane}). 12undefined 第2阶段：双方在同一主机不同节点 终端1：服务器\n1$ erl -sname gandalf 2(gandalf@localhost) 1\u0026gt; kvs:start(). 3true 终端2：客户端\n1$ erl -sname bilbo 2(bilbo@localhost) 1\u0026gt; rpc:call(gandalf@localhost, kvs, store, [weather, fine]). 3true 4(bilbo@localhost) 2\u0026gt; rpc:call(gandalf@localhost, kvs, lookup, [weather]). 5{ok, fine}   erl -sname gandalf\n参数-sname gandalf的意思是“在本地主机上启动一个名为gandalf的Erlang节点”。注意一下Erlang shell是如何把Erlang节点名打印在命令提示符前面的。\n节点名的形式是Name@Host。Name和Host都是原子，所以如果它们包含任何非原子的字符，就必须加上引号。\n  rpc:call(Node, Mod, Func, [Arg1, Arg2, .., ArgN])\nrpc是一个标准的Erlang库模块。这个函数在Node上执行一次远程过程调用。调用的函数是Mod:Func(Arg1, Arg2, \u0026hellip;, ArgN)。\n  上面这个过程是客户端远程执行服务器的函数\n  第3阶段：双方在同一局域网不同机器上 填入节点名称时需要加上单引号。然后有可能会报错，使用创建节点：\n1erl -name gandalf@doris.myerl.example.com -setcookie abc 机器1终端：服务器\n1doris $ erl -name gandalf -setcookie abc 2(gandalf@doris.myerl.example.com) 1\u0026gt; kvs:start(). 3true 机器2终端：客户端\n1george $ erl -name bilbo -setcookie abc 2(bilbo@george.myerl.example.com) 1\u0026gt; rpc:call(gandalf@doris.myerl.example.com, kvs, store, [weather, cold]). 3true 4(bilbo@george.myerl.example.com) 2\u0026gt; rpc:call(gandalf@doris.myerl.example.com, kvs, lookup, [weather]). 5{ok, cold}   用-name参数启动Erlang。\n我们在同一台机器上运行两个节点时使用了“短”（short）名称（通过-sname标识体现）。但如果它们属于不同的网络，我们就要使用-name。\n当两台机器位于同一个子网时我们也可以使用-sname。而且如果没有DNS服务，-sname就是唯一可行的方式。\n  使用命令行参数-setcookie abc， 确保两个节点拥有相同的cookie。\n当我们在同一台机器上运行两个节点时，因为它们都能访问同一个cookie文件$HOME/.erlang.cookie，所以我们不需要在Erlang命令行里添加cookie。\n  确保相关节点的完全限定主机名（fully qualified hostname）可以被DNS解析。对于我来说，域名myerl.example.com完全属于我的家庭网络，通过在/etc/hosts里添加一个条目来实现本地解析。\n  确保两个系统拥有相同版本的代码和相同版本的Erlang。如果不这么做，就可能会得到严重而离奇的错误。\n  第4阶段：双方在互联网不同主机上 原则上，这和第3阶段是一样的，但现在我们必须更加关注安全性。\n  确保4369端口对TCP和UDP流量都开放。这个端口会被一个名为epmd的程序使用（它是Erlang Port Mapper Daemon的缩写，即Erlang端口映射守护进程）。\n  选择一个或一段连续端口给分布式Erlang使用，并确保这些端口是开放的。如果这些端口位于Min和Max之间（只想用一个端口就让Min=Max），就用以下命令启动Erlang：\n1$ erl -name ... -setcookie ... -kernel inet_dist_listen_min Min inet_dist_listen_max Max   两种分布式模型 1.分布式Erlang\n 编写的程序会在Erlang的节点（node）上运行。节点是一个独立的Erlang系统，包含一个自带地址空间和进程组的完整虚拟机。 分布式Erlang应用程序运行在一个可信环境中。因为任何节点都可以在其他Erlang节点上执行任意操作，所以这涉及高度的信任。虽然分布式Erlang应用程序可以运行在开放式网络上，但它们通常是运行在属于同一个局域网的集群上，并受防火墙保护。  2.基于套接字的分布式模型\n 可以用TCP/IP套接字来编写运行在不可信环境中的分布式应用程序。这个编程模型不如分布式Erlang那样强大，但是更安全。  一、分布式编程的库和内置函数 在我的理解中，Node也是进程。\n分布式相关库：\n  rpc提供了许多远程过程调用服务。\ncall(Node, Mod ,Function, Args) -\u0026gt; Result | {badrpc, Reason}： 它会在Node上执行apply(Mod, Function, Args)，然后返回结果Result，如果调用失败则返回{badrpc, Reason}。\n  global里的函数可以用来在分布式系统里注册名称和加锁，以及维护一个全连接网络。\n  erlang模块有很多基本函数\n  erlang库中的分布式基本函数：\n  net_adm:ping(NodeName) 连接节点\n  -spec monitor_node(Node, Flag) -\u0026gt; true\n如果Flag是true就会开启监视，Flag是false就会关闭监视。如果开启了监视，那么当Node加入或离开Erlang互连节点组时，执行这个内置函数的进程就会收到{nodeup, Node}或{nodedown, Node}的消息。\n  -spec node() -\u0026gt; Node\n它会返回本地节点的名称。如果节点不是分布式的则会返回nonode@nohost。\n  -spec node(Arg) -\u0026gt;Node\n它会返回Arg所在的节点。Arg可以是PID、引用或者端口。如果本地节点不是分布式的，则会返回nonode@nohost。\n  -spec nodes() -\u0026gt; [Node]\n它会返回一个列表，内含网络里其他所有与我们相连的节点。\n  spec is_alive() -\u0026gt; bool()\n如果本地节点是活动的，并且可以成为分布式系统的一部分，就返回true，否则返回false。\n  -spec spawn(Node, Fun) -\u0026gt; Pid\n它的工作方式和spawn(Fun)完全一致，只是新进程是在Node上分裂的进程。\n  -spec spawn(Node, Mod, Func, ArgList) -\u0026gt; Pid\n它的工作方式和spawn(Mod, Func, ArgList)完全一致，只是新进程是在Node上分裂的。spawn(Mod, Func, Args)会创建一个执行apply(Mod, Func, Args)的新进程。它会返回这个新进程的PID。\n这种形式的spawn比spawn(Node, Fun)更加健壮。如果运行在多个分布式节点上的特定模块不是完全相同的版本，spawn(Node, Fun)就可能会出错。\n  -spec spawn_link(Node, Fun) -\u0026gt; Pid\n它的工作方式和spawn_link(Fun)完全一致，只是新进程是在Node上分裂的。所以新分裂的进程会连接Node节点。\n  -spec spawn_link(Node, Mod, Func, ArgList) -\u0026gt; Pid\n它的工作方式类似spawn(Node, Mod, Func, ArgList)，但是新进程会与当前进程相连接。\n  -spec disconnect_node(Node) -\u0026gt; bool() | ignored\n它会强制断开与某个节点的连接。\n  远程分裂示例 这个示例在本质上也是rpc调用。\ndist_demo.erl\n1-module(dist_demo). 2-export([rpc/4, start/1]). 3 4start(Node) -\u0026gt; 5 spawn(Node, fun() -\u0026gt; loop() end). 6 7rpc(Pid, M, F, A) -\u0026gt; 8 Pid ! {rpc, self(), M, F, A}, 9 receive 10 {Pid, Response} -\u0026gt; 11 Response 12 end. 13 14%% 服务器根据匹配的消息创建进程 15loop() -\u0026gt; 16 receive 17 {rpc, Pid, M, F, A} -\u0026gt; 18 Pid ! {self(), (catch apply(M, F, A))}, 19 loop() 20 end.  (catch apply(M, F, A))：就是运行MFA，然后有异常捕获异常  测试1：\n 主机1：服务器  1doris $ erl -name gandalf -setcookie abc 2(gandalf@doris.myerl.example.com) 1\u0026gt;  主机2：客户端  1george $ erl -name bilbo -setcookie abc 2(bilbo@george.myerl.example.com) 1\u0026gt; Pid = dist_demo:start(\u0026#39;gandalf@doris.myerl.example.com\u0026#39;). 3\u0026lt;5094.40.0\u0026gt; 4# spawn让远程节点（gandalf）分裂一个进程 5# Pid是这个远程节点进程的标识符 6(bilbo@george.myerl.example.com) 2\u0026gt; dist_demo:rpc(Pid, erlang, node, []). 7\u0026#39;gandalf@doris.myerl.example.com\u0026#39; 8%% 远程分裂：在远程节点上执行erlang:node()并返回一个值。 测试2：文件服务器\n由于可以在远程主机执行任何erl代码，所以可以充当文件服务器：\n1(bilbo@george.myerl.example.com) 1\u0026gt; Pid = dist_demo:start(\u0026#39;gandalf@doris.myerl.example.com\u0026#39;). 2(bilbo@george.myerl.example.com) 2\u0026gt; dist_demo:rpc(Pid, file, get_cwd, []). 3{ok, \u0026#34;/home/joe/projects/book/code\u0026#34;} 4(bilbo@george.myerl.example.com) 3\u0026gt; dist_demo:rpc(Pid, file, list_dir, [\u0026#34;.\u0026#34;]). 5{ok, [\u0026#34;adapter_db1.erl\u0026#34;, \u0026#34;processes.erl\u0026#34;, ...]} 6(bilbo@george.myerl.example.com) 4\u0026gt; dist_demo:Pid, file, read_file, [\u0026#34;dist_demo.erl\u0026#34;]). 7{ok, \u0026lt;\u0026lt;\u0026#34;-module...\u0026#34;} 使用file模块里的三个函数来访问gandalf主机的文件系统 ：\n file:get_cwd() 返回文件服务器的当前工作目录 file:list_dir(Dir)返回Dir里所有文件的列表 file:read_file(File) 读取文件File。  测试3：远程命令执行摧毁计算机\n分布式Erlang适合编写那些可信任其他参与者的集群应用程序\n分布式Erlang的主要问题在于客户端可以自行决定在服务器上分裂出各种进程。因此，要摧毁你的系统，只需执行下面的命令：\n1rpc:multicall(nodes(), os, cmd, [\u0026#34;cd /\u0026#39; rm -rf *\u0026#39;\u0026#34;]) cookie 保护系统 cookie系统让访问单个或一组节点变得更安全。每个节点都有一个cookie，如果它想与其他任何节点通信，它的cookie就必须和对方节点的cookie相同。为了确保cookie相同，分布式Erlang系统里的所有节点都必须以相同的“神奇”（magic）cookie启动，或者通过执行erlang:set_cookie把它们的cookie修改成相同的值。Erlang集群的定义就是一组带有相同cookie的互连节点。\ncookie保护系统被设计用来创建运行在局域网（LAN）上的分布式系统，LAN本身应该受防火墙保护，与互联网隔开。\n可以用三种方法设置cookie：\n 在文件$HOME/.erlang.cookie里存放相同的cookie。这个文件包含一个随机字符串，是Erlang第一次在你的机器上运行时自动创建的。这个文件可以被复制到所有想要参与分布式Erlang会话的机器上。也可以显式设置它的值。 当Erlang启动时，可以用命令行参数-setcookie C来把神奇cookie设成C。（这种方法Unix系统里的任何用户都可以用ps命令来查看你的cookie。） 内置函数erlang:set_cookie(node(), C)能把本地节点的cookie设成原子C。  cookie从不会在网络中明文传输，它只用来对某次会话进行初始认证。分布式Erlang会话不是加密的，但可以被设置成在加密通道中运行。\n二、lib_chan模块 这个lib_chan模块并不是官方库，可能是作者自己写的，正式的服务器还是等到OTP再说。\nlib_chan模块让用户能够显式控制自己的机器能分裂出哪些进程：\n  -spec start_server() -\u0026gt; true\n它会在本地主机上启动一个服务器。这个服务器的行为由文件$HOME/.erlang_config/lib_chan.conf决定。\n  -spec start_server(Conf) -\u0026gt; true\n它会在本地主机上启动一个服务器。这个服务器的行为由文件Conf决定，它包含一个由下列形式的元组所组成的列表：\n{port, NNNN}：它会开始监听端口号NNNN。\n{service, S, password, P, mfa, SomeMod, SomeFunc, SomeArgsS}：它会定义一个被密码P保护的服务S。如果这个服务启动了，就会通过分裂SomeMod:SomeFunc(MM, ArgsC, SomeArgsS)创建一个进程，负责处理来自客户端的消息。这里的MM是一个代理进程的PID，可以用来向客户端发送消息。参数ArgsC来自于客户端的连接调用。\n  -spec connect(Host, Port, S, P, ArgsC) -\u0026gt; {ok, Pid} | {error, Why}\n尝试开启主机Host上的端口Port，然后尝试激活被密码P保护的服务S。如果密码正确，就会返回{ok, Pid}。Pid是一个代理进程的标识符，可以用来向服务器发送消息。\n当客户端调用connect/5建立连接后，就会分裂出两个代理进程，一个在客户端，另一个在服务器端。这些代理进程负责把Erlang消息转换成TCP包数据，捕捉来自控制进程的退出信号，以及套接字关闭。\n  基于套接字的分布式模型示例 服务器 配置文件：\n1{port, 1234}. 2{service, nameServer, password, \u0026#34;ABXy45\u0026#34;, mfa, mod_name_server, start_me_up, notUsed}. 它的意思是我们将在自己机器的1234端口上提供一个名为nameServer的服务。这个服务被密码ABXy45保护。\nsocket_dist/mod_name_server.erl:\n1-module(mod_name_server). 2-export([start_me_up/3]). 3 4start_me_up(MM, _ArgsC, _ArgS) -\u0026gt; 5 loop(MM). 6 7loop(MM) -\u0026gt; 8 receive 9 {chan, MM, {store, K, V}} -\u0026gt; 10 kvs:store(K,V), 11 loop(MM); 12 {chan, MM, {lookup, K}} -\u0026gt; 13 MM ! {send, kvs:lookup(K)}, 14 loop(MM); 15 {chan_closed, MM} -\u0026gt; 16 true 17 end. mod_name_server遵循以下协议：\n 如果客户端向服务器发送一个消息{send, X}，这个消息在mod_name_server里就会变 成{chan, MM, X}的形式（MM是服务器代理进程的PID）。 如果客户端终止或者用于通信的套接字出于任何原因关闭了，服务器就会收到一个 {chan_closed, MM}形式的消息。 如果服务器想给客户端发送一个消息X，就会通过调用MM ! {send, X}实现。 如果服务器想要显式关闭连接，就会通过执行MM ! close实现。  这个协议是一个中间人协议，客户端代码和服务器代码都遵循它。本书附录B里的“lib_chan_mm：中间人”一节会更详细地解释套接字中间人代码。\n测试 服务器\n11\u0026gt; kvs:start(). 2true 32\u0026gt; lib_chan:start_server(). 4Starting a port server on 1234.... 5true 客户端\n11\u0026gt; {ok, Pid} = lib_chan:connnect(\u0026#34;localhost\u0026#34;, 1234, nameServer, \u0026#34;ABXy45\u0026#34;, \u0026#34;\u0026#34;). 2{ok, \u0026lt;0.43.0\u0026gt;} 32\u0026gt; lib_chan:cast(Pid, {store, joe, \u0026#34;writing a book\u0026#34;}). 4{send, {store, joe, \u0026#34;writing a book\u0026#34;}} 53\u0026gt; lib_chan:rpc(Pid, {lookup, joe}). 6{ok, \u0026#34;writing a book\u0026#34;} 74\u0026gt; lib_chan:rpc(Pid, {lookup, jim}). 8undefined 在这个案例里，决定配置文件内容的是远程机器的所有者。配置文件指定了哪些应用程序是这台机器允许运行的，以及哪个端口是用来与这些应用程序通信的。\n练习 (1) 在同一主机上启动两个节点。查询rpc模块的手册页。对这两个节点执行一些远程过程调用。\n(2) 重复上一个练习，这次使用同一局域网里的两个节点。\n(3) 重复上一个练习，这次使用不同网络里的两个节点。\n(4) 用lib_chan里的库编写YAFS（Yet Another File Server的缩写，即“又一个文件服务器”） 。你会从中学到很多知识。给你的文件服务器添加一些“装饰品”。\n附录：lib_chan模块实现原理 TODO，在附录\n第15章 接口技术 可以用多种方式建立外部语言程序与Erlang之间的接口：\n 让程序以外部操作系统进程的形式在Erlang虚拟机以外运行。这是一种安全的做法。即使外部语言的代码有问题，也不会让Erlang系统崩溃。Erlang通过一种名为端口（port）的对象来控制外部进程，与外部进程的通信则是通过一个面向字节的通信信道。Erlang负责启动和停止外部程序，还可以监视它，让在它崩溃后重启。外部进程被称为端口进程，因为它是通过一个Erlang端口控制的。 在Erlang内部运行操作系统命令并捕捉结果。 在Erlang虚拟机的内部运行外部语言代码。这涉及链接外部代码和Erlang虚拟机代码，是一种不安全的做法。外部语言代码里的错误可能会导致Erlang系统崩溃。虽然它不安全，但还是有用的，因为这么做比使用外部进程更高效。把代码链接到Erlang内核只适用于C这样能生成本地目标代码的语言，不适用于Java这样自身拥有虚拟机的语言。  端口概述 Erlang通过名为端口的对象与外部程序通信。如果向端口发送一个消息，此消息就会被发往与端口相连的外部程序。来自外部程序的消息则会变成来自端口的Erlang消息。\n对程序员而言，端口的行为就像是一个Erlang进程。你可以向它发送消息，可以注册它（就像进程一样），诸如此类。如果外部程序崩溃了，就会有一个退出信号发送给相连的进程。如果相连的进程挂了，外部程序就会被关闭。\n创建端口的进程被称为该端口的相连进程。相连进程有其特殊的重要性：所有发往端口的消息都必须标明相连进程的PID，所有来自外部程序的消息都会发往相连进程。\n创建端口 -spec open_port(PortName, [Opt]) -\u0026gt; Port\n其中PortName是下列选项中的一个:\n  {spawn, Command}\n启动一个外部程序。Command是这个外部程序的名称。除非能找到一个名为Command的内链驱动，否则Command会在Erlang工作空间之外运行。\n  {fd, In, Out}\n允许一个Erlang进程访问Erlang使用的任何当前打开文件描述符。文件描述符In可以用作标准输入，文件描述符Out可以用作标准输出。\n  Opt是下列选项中的一个:\n  {packet, N}\n数据包（packet）前面有N（1、2或4）个字节的长度计数。\n  stream\n发送消息时不带数据包长度信息。应用程序必须知道如何处理这些数据包。\n  {line, Max}\n发送消息时使用一次一行的形式。如果有一行超过了Max字节，就会在Max字节处被拆分。\n  {cd, Dir}\n只适用于{spawn, Command}选项。外部程序从Dir里启动。\n  {env, Env}\n只适用于{spawn, Command}选项。外部程序的环境通过Env列表里的环境变量进行扩展。Env列表由若干个{VarName, Value}对组成，其中VarName和Value是字符串。\n  端口Api PidC即是相连进程Pid\n  Port ! {PidC, {command, Data}}\n向端口发送Data（一个I/O列表）。\n  Port ! {PidC, {connect, Pid1}}\n把相连进程的PID从PidC改为Pid1。\n  Port ! {PidC, close}\n关闭端口。\n  1receive 2\t{Port, {data, Data}} -\u0026gt; 3 ... 数据从外部进程进来 ... 相连进程可以用这种方式从外部程序接收消息。\n  用端口建立外部C程序接口 规定协议 我们的最终目的是从Erlang里调用C文件方法。\nports/example1.c:\n1int sum(int x, int y) { 2\treturn x+y; 3} 4 5int twice(int x){ 6\treturn 2*x; 7} 希望能像这样调用它们：\n1X1 = example1:sum(12,23), 2Y1 = example1:twice(10), 对用户而言，example1是一个Erlang模块，因此所有与C程序接口有关的细节都应该隐藏在example1模块内部。\n要实现它，需要把sum(12,23)和twice(10)这样的函数调用转变成字节序列，通过端口发送给外部程序。端口给字节序列加上长度信息，然后把结果发给外部程序。当外部程序回复时，端口接收回复，并把结果发给与端口相连的进程。外部C程序和Erlang程序都必须遵循这一协议。下面是具体协议：\n 所有数据包都以2字节的长度代码（Len）开头，后接Len字节的数据。这个包头会被端口自动添加，因为打开端口时设置了参数{packet,2}。 把sum(N, M)调用编码成字节序列[1,N,M]。 把twice(N)调用编码成字节序列[2,N]。 参数和返回值都被假定为1字节长。  调用过程 端口驱动这个东西和端口是一个整体，应该是在创建时就有了。\n 本地驱动把函数调用 sum(12,23) 编码成字节序列 [1,12,23] ，然后向端口发送 {self(),{command, [1,12,23]}}消息。 端口驱动给这个消息加上2字节的长度包头，然后把字节序列 0,3,1,12,23 发给外部程序。 外部程序从标准输入里读取这5个字节，解包，调用sum函数，得到结果再封包，然后把字节序列0,1,35写入标准输出。 端口驱动移除长度包头，然后向相连进程发送一个{Port, {data, [35]}}消息。 相连进程解码这个消息，然后把结果返回给调用程序。  相应C应用与驱动程序 这个就相当于外部程序了。\n文件：\n  ports/example1.c：包含了我们想要调用的函数（之前已经见过它了）。\n  ports/example1_driver.c：管理字节流协议并调用example1.c里的方法。\n1#include \u0026lt;stdio.h\u0026gt;2#include \u0026lt;stdlib.h\u0026gt;3//定义1字节为byte 4typedef unsigned char byte; 5 6int read_cmd(byte *buff); 7int write_cmd(byte *buff, int len); 8int sum(int x, int y); 9int twice(int x); 10 11int main() { 12 //模式，函数调用参数一二，结果 13 int fn, arg1, arg2, result; 14 byte buff[100]; 15 16 //read_cmd函数处理协议，返回的是字节序列 [1,12,23]或 [2,10] 17 while (read_cmd(buff) \u0026gt; 0) { 18 fn = buff[0]; 19 20 //模式匹配函数 21 if (fn == 1) { 22 arg1 = buff[1]; 23 arg2 = buff[2]; 24 25 //调试语句，打印到stderr 26 //fprintf(stderr, \u0026#34;calling sum %i %i\\n\u0026#34;, arg1, arg2); 27 result = sum(arg1, arg2); 28 } else if (fn == 2) { 29 arg1 = buff[1]; 30 result = twice(arg1); 31 } else { 32 //未知错误直接退出 33 exit(EXIT_FAILURE); 34 } 35 buff[0] = result; 36 //同样write_cmd进行封装协议 37 write_cmd(buff, 1); 38 } 39}   ports/erl_comm.c：带有读取和写入内存缓冲区的方法。相当于应用驱动（协议处理）这段代码专门用于处理带有2字节长度包头的数据，因此它与提供给端口驱动程序的{packet, 2}选项匹配。\n1#include \u0026lt;unistd.h\u0026gt;2typedef unsigned char byte; 3 4//将0,3,1,12,23转化为1,12,23 5int read_cmd(byte *buf); 6//将35转化为0,1,35，len是写入的字节 7int write_cmd(byte *buf, int len); 8int read_exact(byte *buf, int len); 9int write_exact(byte *buf, int len); 10 11int read_cmd(byte *buf) 12{ 13 int len; 14 //读取长度计数，读取错误直接退出 15 if (read_exact(buf, 2) != 2) 16 return(-1); 17 //这行计算实际的参数长度，无论第一字节值是多少，都取第二字节的值 18 //执行位或运算，实际上取得就是第二字节的数字了。因为第一字节以及左移8位清零了。 19 //0,3 那么是00000000 00000011。 20 len = (buf[0] \u0026lt;\u0026lt; 8) | buf[1]; 21 return read_exact(buf, len); 22} 23 24int write_cmd(byte *buf, int len) 25{ 26 byte li; 27 //这行取出len第二个字节的值 int类型是4 3 2 1字节 28 li = (len \u0026gt;\u0026gt; 8) \u0026amp; 0Xff; 29 write_exact(\u0026amp;li, 1); 30 //这行取出len第一个字节的值（最低8位） 31 li = len \u0026amp; 0xff; 32 write_exact(\u0026amp;li, 1); 33 return write_exact(buf, len); 34} 35 36int read_exact(byte *buf, int len) 37{ 38 int i, got=0; 39 //有可能量很大，所以循环读入。 40 do { 41 //读取，如果读取不正常直接结束 42 if ((i = read(0, buf+got, len-got)) \u0026lt;= 0) 43 return(i); 44 got += i; 45 } while (got\u0026lt;len); 46 return(len); 47} 48 49int write_exact(byte *buf, int len) 50{ 51 int i, wrote = 0; 52 do { 53 if ((i = write(1, buf+wrote, len-wrote)) \u0026lt;=0) 54 return(i); 55 wrote += i; 56 } while (wrote\u0026lt;len); 57 return (len); 58} 59   涉及到的C标准库函数：\n  read (int __fd, void *__buf, size_t __nbytes)\nread 函数是C语言中用来读取文件数据的系统调用。\n参数一为文件描述符，其中0为stdin，1为stdout，2为stderr。\n参数二为存放读入的地方\n参数三为要读取的字节\n读取成功后，返回实际读取到的字节数；如果发生错误则返回-1。\n  ssize_t write(int handle, void *buf, int nbyte);\nwrite函数把buf中nbyte写入文件描述符handle所指的文档，成功时返回写的字节数，错误时返回-1.\nhandle 是 文件描述符；\nbuf是指定的缓冲区，即 指针，指向一段内存单元；\nnbyte是要写入文件指定的字节数；\n返回值：写入文档的字节数（成功）；-1（出错）\n  write（const char* str,int n)\n这个没用到，不过是同名的写一下。\nstr是 字符指针或字符数组，用来存放一个字符串。n是int型数，它用来表示输出显示字符串中字符的个数。\n  相应Erlang程序 ports/example1.erl:\n1-module(example1). 2-export([start/0, stop/0]). 3-export([twice/1, sum/2]). 4 5start() -\u0026gt; 6 register(example1, 7 spawn(fun() -\u0026gt; 8 %% 系统进程 9 process_flag(trap_exit, true), 10 %% 创建端口 11 Port = open_port({spawn, \u0026#34;./example1\u0026#34;}, [{packet, 2}]), 12 %% 相连进程执行loop，通过loop操作端口 13 loop(Port) 14 end)). 15 16stop() -\u0026gt; 17 %% ?MODULE是宏，展开成当前的模块名 18 %% 实际上是向系统进程发消息，因为模块名已经注册了。 19 ?MODULE ! stop. 20 21twice(X) -\u0026gt; call_port({twice, X}). 22sum(X,Y) -\u0026gt; call_port({sum, X, Y}). 23call_port(Msg) -\u0026gt; 24 ?MODULE ! {call, self(), Msg}, 25 receive 26 {?MODULE, Result} -\u0026gt; 27 Result 28 end. 29 30loop(Port) -\u0026gt; 31 receive 32 {call, Caller, Msg} -\u0026gt; 33 Port ! {self(), {command, encode(Msg)}}, 34 receive 35 {Port, {data, Data}} -\u0026gt; 36 Caller ! {?MODULE, decode(Data)} 37 end, 38 loop(Port); 39 stop -\u0026gt; 40 Port ! {self(), close}, 41 receive 42 {Port, closed} -\u0026gt; 43 exit(normal) 44 end; 45 {\u0026#39;EXIT\u0026#39;, Port, Reason} -\u0026gt; 46 exit({port_terminated, Reason}) 47 end. 48 49encode({sum, X, Y}) -\u0026gt; [1, X, Y]; 50encode({twice, X}) -\u0026gt; [2,X]. 51 52decode([Int]) -\u0026gt; Int. Makefile编译链接程序 prots/Makefile.mac\n1.SUFFIXES: .erl .beam .yrl 2 3.erl.beam: 4\terlc -W $\u0026lt; 5\t6MODS = example1 example1_lid unit_test 7 8all:\t${MODS:%=%.beam} example1 example1_drv.so 9\t@erl -noshell -s unit_test start 10example1: example1.c erl_comm.c example1_driver.c 11\tgcc -o example1 example1.c erl_comm.c example1_driver.c 12example1_drv.so: example1_lid.c example1.c 13\tgcc -arch i386 -I /usr/local/lib/erlang/usr/include\\ 14\t-o example1_drv.so -fPIC -bundle -flat_namespace -undefined suppress\\ 15\texample1.c example1_lid.c 16clean: 17\trm example1 example1_drv.so *.beam  .SUFFIXES：定义后缀，前者是前提，后者是目标 $\u0026lt;：第一个依赖文件  运行 11\u0026gt; example1:start(). 2true 32\u0026gt; example1:su,(45, 32). 477 在 Erlang 里调用 shell 脚本 假设想要在Erlang里调用一个shell脚本。要做到这一点，可以使用库函数os:cmd(Str)。它会运行字符串Str里的命令并捕捉结果：\n11\u0026gt; os:cmd(\u0026#34;ifconfig\u0026#34;). 2\u0026#34;lo0: flags...\u0026#34; 高级接口技术   内链驱动\n这些程序和之前讨论的端口驱动遵循相同的协议，唯一的区别是它们的驱动代码被链接到Erlang内核中，因此会在Erlang的操作系统主进程内运行。要构建一个内链驱动，就必须添加少量代码来初始化它，驱动本身必须被编译和链接到Erlang虚拟机上。\n  NIF\nNIF是指原生实现函数（Natively Implemented Function）。这些函数是用C（或其他能编译成本地代码的语言）编写的，并且被链接到Erlang虚拟机中。NIF直接将参数传递到Erlang进程的栈上，还能直接访问所有的Erlang内部数据结构。\n  C-node\nC-node是用C实现的节点，它们遵循Erlang分布式协议。一个“真正的”分布式Erlang节点不仅能够与C-node通信，还会把它当作一个Erlang节点（前提是它不在C-node上做一些花哨的事情，比如发送Erlang代码让它执行）。\n  练习 (1) 下载之前给出的端口驱动代码，然后在你的系统上测试它。\n(2) 打开git://github.com/erlang/linked_in_drivers.git，下载内链驱动的代码并在你的系统上测试。这里的难点是找到编译和链接代码的正确命令。如果不能完成这个练习，可以去Erlang邮件列表寻求帮助。\n(3) 看看能否找到一个操作系统命令，用它查看你的计算机使用的是哪种CPU。如果能找到这样的命令，请编写一个函数来返回你的CPU类型，做法是用os:cmd函数调用这个操作系统命令。\n第16章 文件编程 操作文件的模块   file\n它包含打开、关闭、读取和写入文件的方法，还有列出目录，等等。\n  filename\n这个模块里的方法能够以跨平台的方式操作文件名，这样就能在许多不同的操作系统上运行相同的代码了。\n  filelib\n这个模块是file的扩展。它包含的许多工具函数能够列出文件、检查文件类型，等等。其中大多数都是使用file里的函数编写的。\n  io\n这个模块有一些操作已打开文件的方法。它包含的方法能够解析文件里的数据，或者把格式化数据写入文件。\n  文件操作摘要（file模块）：\n   函数 描述     change_group 修改某个文件所属的组   change_owner 修改某个文件的所有者   change_time 修改某个文件的最后修改或访问时间   close 关闭某个文件   consult 从某个文件里读取Erlang数据类型   copy 复制文件内容   del_dir 删除某个目录   delete 删除某个文件   eval 执行某个文件里的Erlang表达式   format_error 返回一个描述错误原因的字符串   get_cwd 获取当前工作目录   list_dir 列出某个目录里的文件   make_dir 创建一个目录   make_link 创建指向某个文件的硬链接（hard link）   make_symlink 创建指向某个文件或目录的符号链接（symbolic link）   open 打开某个文件   position 设立在文件里的位置   pread 对文件里的某个位置进行读取   pwrite 对文件里的某个位置进行写入   read 对某个文件进行读取   read_file 读取整个文件   read_file_info 获取某个文件的信息   read_link 获得某个链接指向的位置   read_link_info 获取某个链接或文件的信息   rename 重命名某个文件   script 执行并返回某个文件里Erlang表达式的值   set_cwd 设置当前工作目录   sync 同步某个文件在内存和物理介质中的状态   truncate 截断某个文件   write 对某个文件进行写入   write_file 写入整个文件   write_file_info 修改某个文件的信息    读取文件 文件data1.dat：\n1{person, \u0026#34;joe\u0026#34;, \u0026#34;armstrong\u0026#34;, 2\t[{occupation, programmer}, 3\t{favoriteLanguage, erlang}]}. 4\t5{cat, {name, \u0026#34;zorro\u0026#34;}, 6\t{owner, \u0026#34;joe\u0026#34;}}. 读取所有数据类型 可调用file:consult来读取所有的数据类型。\nfile:consult(File)假定File包含一个由Erlang数据类型组成的序列。如果它能读取文件里的所有数据类型，就会返回{ok, [Term]}，否则会返回{error, Reason}。\n11\u0026gt; file:consult(\u0026#34;data1.dat\u0026#34;). 2{ok,[{person,\u0026#34;joe\u0026#34;,\u0026#34;armstrong\u0026#34;, 3 [{occupation,programmer},{favoriteLanguage,erlang}]}, 4 {cat,{name,\u0026#34;zorro\u0026#34;},{owner,\u0026#34;joe\u0026#34;}}]} 分次读取数据类型 如果想从文件里一次读取一个数据类型，就要首先用file:open打开文件，然后用io:read逐个读取数据类型，直到文件末尾，最后再用file:close关闭文件。\n13\u0026gt; {ok, S} = file:open(\u0026#34;data1.dat\u0026#34;, read). 2{ok,\u0026lt;0.86.0\u0026gt;} 34\u0026gt; io:read(S, \u0026#39;\u0026#39;). 4{ok,{person,\u0026#34;joe\u0026#34;,\u0026#34;armstrong\u0026#34;, 5 [{occupation,programmer},{favoriteLanguage,erlang}]}} 65\u0026gt; io:read(S,\u0026#39;\u0026#39;). 7{ok,{cat,{name,\u0026#34;zorro\u0026#34;},{owner,\u0026#34;joe\u0026#34;}}} 86\u0026gt; io:read(S, \u0026#39;\u0026#39;). 9eof 107\u0026gt; file:close(S). 11ok 涉及函数：\n  -spec file:oepn(File, read) -\u0026gt; {ok, IoDevice} | {error, Why}\n尝试打开File进行读取。如果它能打开文件就会返回{ok, IoDevice}，否则返回{error,Reason}。IoDevice是一个用来访问文件的I/O对象。\n  -spec io:read(IoDevice, Prompt) -\u0026gt; {ok, Term} | {error, Why} | eof\n从 IoDevice 读取一个Erlang数据类型 Term 。如果 IoDevice 代表一个被打开的文件，Prompt就会被忽略。只有用io:read读取标准输入时，才会用Prompt提供一个提示符。\n  -spec file:close(IoDevice) -\u0026gt; ok | {error, Why}\n关闭IoDevice。\n  用以上方法实现file:consult:\n1consult(File) -\u0026gt; 2 case file:open(File, read) of 3 {ok, S} -\u0026gt; 4 Val = consult1(S), 5 file:close(S), 6 {ok, Val}; 7 {error, Why} -\u0026gt; 8 {error, Why} 9 end. 10 11consult1(S) -\u0026gt; 12 case io:read(S, \u0026#39;\u0026#39;) of 13 {ok, Term} -\u0026gt; [Term|consult1(S)]; 14 eof -\u0026gt; []; 15 Error -\u0026gt; Error 16 end. 找到file.erl的源代码：\n可使用code:which函数来找到它，该函数能定位所有已载入模块的目标代码。\n11\u0026gt; code:which(file). 2\u0026#34;/usr/lib/erlang/lib/kernel-8.5.4.2/ebin/file.beam\u0026#34; 在标准分发套装里，每个库都有两个子目录。一个名为src，包含源代码；另一个名为ebin，包含编译后的Erlang代码。因此，file.erl的源代码应该是在下面这个目录里：\n1/usr/lib/erlang/lib/kernel-8.5.4.2/src/file.erl 分次读取文件里的行 如果把io:read改成io:get_line，就可以分次读取文件里的行。io:get_line会一直读取字符，直到遇上换行符或者文件尾。\n11\u0026gt; {ok, S} = file:open(\u0026#34;data1.dat\u0026#34;, read). 2{ok,\u0026lt;0.83.0\u0026gt;} 32\u0026gt; io:get_line(S, \u0026#39;\u0026#39;). 4\u0026#34;{person, \\\u0026#34;joe\\\u0026#34;, \\\u0026#34;armstrong\\\u0026#34;,\\n\u0026#34; 53\u0026gt; io:get_line(S, \u0026#39;\u0026#39;). 6\u0026#34;\\t\\t[{occupation, programmer},\\n\u0026#34; 74\u0026gt; io:get_line(S, \u0026#39;\u0026#39;). 8\u0026#34;\\t\\t {favoriteLanguage, erlang}]}.\\n\u0026#34; 95\u0026gt; io:get_line(S, \u0026#39;\u0026#39;). 10\u0026#34;\\t\\t \\n\u0026#34; 116\u0026gt; io:get_line(S, \u0026#39;\u0026#39;). 12\u0026#34;{cat, {name, \\\u0026#34;zorro\\\u0026#34;},\\n\u0026#34; 137\u0026gt; io:get_line(S, \u0026#39;\u0026#39;). 14\u0026#34;\\t {owner, \\\u0026#34;joe\\\u0026#34;}}.\\n\u0026#34; 158\u0026gt; io:get_line(S, \u0026#39;\u0026#39;). 16eof 179\u0026gt; file:close(S). 18ok 读取整个文件到二进制型中 可以用file:read_file(File)把整个文件读入一个二进制型，这是一次原子操作。\n如果成功，file:read_file(File)就会返回{ok, Bin}，否则返回{error, Why}。这是到目前为止最高效的文件读取方式。在大多数操作里，我会把整个文件一次性读入内存，然后操作内容并一次性保存文件（用file:write_file）。\n110\u0026gt; file:read_file(\u0026#34;data1.dat\u0026#34;). 2{ok,\u0026lt;\u0026lt;\u0026#34;{person, \\\u0026#34;joe\\\u0026#34;, \\\u0026#34;armstrong\\\u0026#34;,\\n\\t\\t[{occupation, programmer},\\n\\t\\t {favoriteLanguage, erlang}]}.\\n\\t\\t \\n{cat, {name, \u0026#34;...\u0026gt;\u0026gt;} 按字节访问读取文件 如果想要读取的文件非常大，或者它包含某种外部定义格式的二进制数据，就可以用raw模式打开这个文件，然后用file:pread读取它的任意部分。\nfile:pread(IoDevice, Start, Len)会从IoDevice读取Len个字节的数据，读取起点是字节Start处（文件里的字节会被编号，所以文件里第一个字节的位置是0）。它会返回{ok, Bin}或者{error, Why}。\n11\u0026gt; {ok, S} = file:open(\u0026#34;data1.dat\u0026#34;, [read,binary,raw]). 2{ok,{file_descriptor,prim_file, 3 #{handle =\u0026gt; #Ref\u0026lt;0.3212107313.3749838861.229403\u0026gt;, 4 owner =\u0026gt; \u0026lt;0.81.0\u0026gt;,r_ahead_size =\u0026gt; 0, 5 r_buffer =\u0026gt; #Ref\u0026lt;0.3212107313.3749838853.229337\u0026gt;}}} 62\u0026gt; file:pread(S, 22, 26). 7{ok,\u0026lt;\u0026lt;\u0026#34;rong\\\u0026#34;,\\n\\t\\t[{occupation, pro\u0026#34;\u0026gt;\u0026gt;} 83\u0026gt; file:pread(S, 1, 10). 9{ok,\u0026lt;\u0026lt;\u0026#34;person, \\\u0026#34;j\u0026#34;\u0026gt;\u0026gt;} 104\u0026gt; file:pread(S, 2, 10). 11{ok,\u0026lt;\u0026lt;\u0026#34;erson, \\\u0026#34;jo\u0026#34;\u0026gt;\u0026gt;} 125\u0026gt; file:close(S). 13ok 读取MP3元数据案例 MP3是一种二进制格式，用来保存压缩过的音频数据。MP3文件本身并不包含有关文件内容的信息。比如说，在一个包含音乐数据的MP3文件里，音频数据并不包含录制音乐的艺术家姓名。这类数据（曲目名和艺术家姓名等）以一种被称为ID3的标签块格式保存在MP3文件中。ID3标签是由一位名叫Eric Kemp的程序员发明的，用来保存描述音频文件内容的元数据。ID3格式实际上有很多种，但基于我们的目的，这里只会编写代码来访问ID3标签的两种最简单的形式，即ID3v1和ID3v1.1标签。\nID3v1标签的结构很简单：文件最后的128个字节包含了一个固定长度的标签。前三个字节包含ASCII字符TAG，接下来是一些固定长度的字段。整个128字节数据是按照以下方式打包的：\n   长度 内容     3 包含TAG字符的标签头   30 标题   30 艺术家   30 专辑   4 年份   30 备注   1 流派    ID3v1的标签里没有地方可以添加曲目编号。Michael Mutschler在ID3v1.1格式里建议了一种 做法，把30个字节的备注字段改成下面这样：\n   长度 内容     28 评论   1 0（一个零）   1 曲目编号    读取MP3文件里的ID3v1标签的程序：\nlib_find:files/3，lib_misc:dump/2函数在后面。\n1-module(id3_v1). 2-import(lists, [filter/2, map/2, reverse/1]). 3-export([test/0, dir/1, read_d3_tag]). 4test() -\u0026gt; dir(\u0026#34;/home/joe/music_keep\u0026#34;). 5 6dir(Dir) -\u0026gt; 7 %% 读取文件夹中的所有mp3文件名为一个列表 8 Files = lib_find:files(Dir, \u0026#34;*.mp3\u0026#34;, true), 9 L1 = map(fun(I) -\u0026gt; 10 {I, (catch read_id3_tag(I))} 11 end, Files), 12 %% L1 = [{File, Parse}], 其中Parse = error | [{Tag, Val}]. 13 %% Tag是ID3v1或ID3v1.1 14 %% 现在将所有Parse = error的条目从L中移出 15 %% 可以用一次filter操作实现 16 L2 = filter(fun({_,error}) -\u0026gt;false; 17 (_) -\u0026gt; true 18 end, L1), 19 lib_misc:dump(\u0026#34;mp3data\u0026#34;, L2). 20 21%% 对每个文件，取出ID3v1标签，交由parse_v1_tag处理 22%% 不能打开文件则为error 23read_id3_tag(File) -\u0026gt; 24 case file:open(File, [read,binary,raw]) of 25 {ok, S} -\u0026gt; 26 Size = filelib:file_size(File), 27 %% 读取的是最后128位 28 {ok, B2} = file:pread(S, Size-128, 128), 29 Result = parse_v1_tag(B2), 30 file:close(S), 31 Result; 32\t_Error -\u0026gt; 33 error 34 end. 35 36%% 处理128位的ID3v1.1标签 37parse_v1_tag(\u0026lt;\u0026lt;$T,$A,$G, 38 Title:30/binary, 39 Artist:30/binary, 40 Album:30/binary, 41 _Year:4/binary, 42 _Comment:28/binary, 0:8, Track:8, 43 _Genre:8\u0026gt;\u0026gt;) -\u0026gt; 44 {\u0026#34;ID3v1.1\u0026#34;, 45 [{track, Track}, 46 {title, trim(Title)}, 47 {artist, trim(Artist)}, 48 {album, trim(Album)}]}; 49%% 处理128位的ID3v1标签 50parse_v1_tag(\u0026lt;\u0026lt;$T,$A,$G, 51 Title:30/binary, 52 Artist:30/binary, 53 Album:30/binary, 54 _Year:4/binary, 55 _Comment:30/binary, 56 _Genre:8\u0026gt;\u0026gt;) -\u0026gt; 57 {\u0026#34;ID3v1\u0026#34;, 58 [{title, trim(Title)}, 59 {artist, trim(Artist)}, 60 {album, trim(Album)}]}; 61%% 错误格式 62parse_v1_tag(_) -\u0026gt; 63 error. 64 65%% 处理字符串，去掉前面多余字符 66trim(Bin) -\u0026gt; 67 list_to_binary(trim_blanks(binary_to_list(Bin))). 68trim_blanks(X) -\u0026gt; reverse(skip_blanks_and_zero(reverse(X))). 69 70skip_blanks_and_zero([$\\s|T]) -\u0026gt; skip_blanks_and_zero(T); 71skip_blanks_and_zero([o|T]) -\u0026gt; skip_blanks_and_zero(T); 72skip_blanks_and_zero(X) -\u0026gt; X. 写入文件 把数据列表写入文件 假设想要创建一个能用file:consult读取的文件。标准库里实际上并没有这样的函数，所以我们将自己编写它。不妨把这个函数称为unconsult。\nlib_misc.erl:\n1unconsult(File, L) -\u0026gt; 2 {ok, S} = file:oepn(File, write), 3 lists:foreach(fun(X_ -\u0026gt; io:format(S, \u0026#34;~p,~n\u0026#34;, [X]) end, L)) -spec io:format(IoDevice, Format, Args) -\u0026gt; ok：\n其中ioDevice是一个I/O对象（必须以write模式打开），Format是一个包含格式代码的字符串，Args是待输出的项目列表。Args里的每一项都必须对应格式字符串里的某个格式命令。格式命令以一个波浪字符（~）开头。这里有一些最常用的格式命令：\n ~n 输出一个换行符。~n很智能，会输出一个符合平台标准的换行符。比如说，~n在Unix机器上会把ASCII（10）写入输出流，在Windows机器上则会把回车换行ASCII（13, 10）写入输出流。 ~p把参数打印为美观的形式。 ~s参数是一个字符串、I/O列表或原子，打印时不带引号。 ~w用标准语法输出数据。它被用于输出各种Erlang数据类型。  格式字符串大概有几亿个参数，一个正常思维的人是记不住的。可以在io模块的手册页里找到完整的参数清单。\n   Format Result     `io:format(\u0026quot; ~10s   `io:format(\u0026quot; ~-10s   `io:format(\u0026quot; ~10.3.+s   `io:format(\u0026quot; ~10.10.+s   `io:format(\u0026quot; ~10.7.+s    把各行写入文件 还是使用io:format，每一个最后加一个~n即可。\n11\u0026gt; {ok, S} = file:open(\u0026#34;test2.dat\u0026#34;, write). 2{ok,\u0026lt;0.83.0\u0026gt;} 32\u0026gt; io:format(S, \u0026#34;~s~n\u0026#34;, [\u0026#34;Hello readers\u0026#34;]). 4ok 53\u0026gt; io:format(S, \u0026#34;~w~n\u0026#34;, [123]). 6ok 74\u0026gt; io:format(S, \u0026#34;~s~n\u0026#34;, [\u0026#34;that\u0026#39;s it\u0026#34;]). 8ok 95\u0026gt; file:close(S). 10ok 116\u0026gt; q(). 12ok 137\u0026gt; z@Ubuntu:~/code/erlang/programming-erlang/chapter16 14$cat test2.dat 15Hello readers 16123 17that\u0026#39;s it 一次性写入整个文件 这是最高效的写入文件方式。file:write_file(File, IO)会把IO里的数据（一个I/O列表）写入File。（I/O列表是一个元素为I/O列表、二进制型或0到255整数的列表。I/O列表在输出时会被自动“扁平化”，意思是所有的列表括号都会被移除。）这种方式极其高效，也是我经常用的。\n扫描html中的链接案例 scavenge_urls.erl:\n1-module(scavenge_urls). 2-export([urls2htmlFile/2, bin2urls/1]). 3-import(lists, [reverse/1, reverse/2, map/2]). 4 5%% urls2htmlFile(Urls, File)接受一个URL列表并创建HTML文件，在文件里为每个URL各创建一个可点击的链接 6url2htmlFIle(Urls, File) -\u0026gt; 7 file:write_file(File, urls2html(Urls)). 8 9%% bin2urls(Bin)遍历一个二进制型，然后返回一个包含该二进制型内所有URL的列表 10bin2urls(Bin) -\u0026gt;gather_urls(binary_to_list(Bin), []). 11 12%% URL列表制作封装 13urls2html(Urls) -\u0026gt; [h1(\u0026#34;Urls\u0026#34;), make_list(Urls)]. 14 15%% 制作标题 16h1(Title) -\u0026gt; [\u0026#34;\u0026lt;h1\u0026gt;\u0026#34;, Title, \u0026#34;\u0026lt;/h1\u0026gt;\\n\u0026#34;]. 17 18%% 制作列表 19make_list(L) -\u0026gt; 20 [\u0026#34;\u0026lt;ul\u0026gt;\\n\u0026#34;, 21 map(fun(I) -\u0026gt; [\u0026#34;\u0026lt;li\u0026gt;\u0026#34;, I, \u0026#34;\u0026lt;/li\u0026gt;\\n\u0026#34;] end, L), 22 \u0026#34;\u0026lt;/ul\u0026gt;\\n\u0026#34;]. 23 24%% 从html源文件中提取url 25gather_urls(\u0026#34;\u0026lt;a href\u0026#34; ++ T, L) -\u0026gt; 26 %% L是装Url的列表，Url是单次提取的Url，T1是剩余的网页内容 27 {Url, T1} = collect_url_body(T, reverse(\u0026#34;\u0026lt;a href\u0026#34;)), 28 gather_urls(T1, [Url|L]); 29gather_urls([_|T], L) -\u0026gt; 30 gather_urls(T, L); 31gather_urls([], L) -\u0026gt; 32 L. 33 34%% 提取出Url以及后面剩余的html内容。 35collect_url_body(\u0026#34;\u0026lt;/a\u0026gt;\u0026#34; ++ T, L) -\u0026gt; {reverse(L, \u0026#34;\u0026lt;/a\u0026gt;\u0026#34;), T}; 36collect_url_body([H|T] , L) -\u0026gt; collect_url_boy(T, [H|L]); 37collect_url_body(p[, _) -\u0026gt; {[], []}. TODO collect_url_body没看明白，特别是为什么要reverse，难道是我++的意思理解错了？\n要运行它，需要有一些数据来解析。输入数据（一个二进制型）是HTML网页的内容，所以需要找一张HTML网页来操作。我们将通过socket_examples:nano_get_url（参见17.1.1节）来实现。\n11\u0026gt; B = socket_examples:nano_get_url(\u0026#34;www.erlang.rog\u0026#34;), 2 L = scavenge_urls:bin2urls(B), 3 scavenge_urls:urls2htmlFile(L, \u0026#34;gathered.html\u0026#34;). 4ok 目录和文件操作 操作目录 file里有三个操作目录的函数:\n list_dir(Dir) 生成一个Dir里的文件列表 ，列出的文件没有特定的顺序，不会告诉你它们是文件还是目录，也没有文件大小等信息。 make_dir(Dir) 创建一个新目录 del_dir(Dir) 删除一个目录  查找文件信息 要查找文件F的信息，我们会调用file:read_file_info(F)。如果F是一个合法的文件或目录名，它就会返回{ok, Info}。Info是一个#file_info类型的记录，此类型的定义如下：\n1-record(file_info, 2 {size, % 文件的字节大小 3 type, % 原子，是device, directory, regular, other其中一个 4 access, % 原子，是read, write, read_write, none 5 atime, % 最后一次文件被读的本地时间，{{Year, Mon, Day}, {Hour, Min, Sec}} 6 mtime, % 最后一次文件被修改的本地时间 7 ctime, % 取决于操作系统，Unix是文件/inode最后一次被修改，windows是创建时间 8 mode, % 整数，文件权限 9 links, % 文件的链接数 10 ... 11 }). 为了方便起见，filelib模块导出了一些小方法，比如file_size(File)和is_dir(X)。它们只不过是 file:read_file_info 的接口。如果只想获得文件大小，更方便的做法是调用filelib:file_size，而不是调用file:read_file_info然后解包#file_info记录里的元素。\n要查找某个文件的大小和类型（我们必须包含file.hrl，因为它内含#file_info记录的定义）：\n1-include_lib(\u0026#34;kernel/include/file.hrl\u0026#34;). 2file_size_and_type(File) -\u0026gt; 3 case file:read_file_info(File) of 4 {ok, Facts} -\u0026gt; 5 {Facts#file_info.type, Facts#file_info.size}; 6 _ -\u0026gt; 7 error 8 end. 通过调用map和上面的函数，增强list_file返回的目录清单：\n1ls(Dir) -\u0026gt; 2 {ok, L} = file:list_dir(Dir), 3 lists:map(fun(I) -\u0026gt; {I, file_size_and_type(I)} end, lists:sort(L)). 11\u0026gt; lib_misc:ls(\u0026#34;.\u0026#34;). 复制和删除文件  file:copy(Source, Destination) 把文件Source复制到Destination里。 file:delete(File) 删除File。  一个查找工具函数 用file:list_dir和file:read_file_info来编写一个通用型“查找”工具。下面这段代码理解起来还是不难的，编程起来难。\nlib_find.erl:\n1-module(lib_find). 2-export([files/3, files/5]). 3-import(lists, [reverse/1]). 4 5-include_lib(\u0026#34;kernel/include/file.hrl\u0026#34;). 6 7%% 这个函数是一个封装，为可以简单地使用这个基本功能 8%% ShellRegExp是一个shell风格的通配符模式，比完整形式的正则表达式更容易编写。 9%% Flag是是否需要递归查找 true/false 10files(Dir, Re, Flag) -\u0026gt; 11 Re1 = xmerl_regexp:sh_to_awk(Re), 12 reverse(files(Dir, Re1, Flag, fun(File, Acc) -\u0026gt; [File|Acc] end, [])). 13 14%% Dir 这个目录名是文件搜索的起点 15%% RegExp 这是一个shell风格的正则表达式，用于测试我们找到的文件。 16%% 如果遇到的文件匹配这个正则表达式，就会调用Fun(File, Acc)，其中File是匹配正则表达式的文件名。 17%% Recursive = true | false 这个标记决定了搜索是否应该层层深入当前搜索目录的子目录。 18%% Fun(File, AccIn) -\u0026gt; AccOut 如果regExp匹配File，这个函数就会被应用到File上。 19%% Acc是一个初始值为Acc0的归集器。Fun在每次调用后必须返回一个新的归集值，这个值会在下次调用Fun时传递给它。 20%% 归集器的最终值就是lib_find:files/5的返回值。 21files(Dir, Reg, Recursive, Fun, Acc) -\u0026gt; 22 case file:list_dir(Dir) of 23 {ok, Files} -\u0026gt; find_files(Files, Dir, Reg, Recursive, Fun, Acc); 24 {error, _} -\u0026gt;Acc 25 end. 26 27find_files([File|T], Dir, Reg, Recursive, Fun, Acc0) -\u0026gt; 28 FullName = filename:join([Dir,File]), 29 case file_type(FullName) of 30 regular -\u0026gt; 31 case re:run(FullName, Reg, [{capture, none}]) of 32 match -\u0026gt; 33 Acc = Fun(FullName, Acc0), 34 find_files(T, Dir, Reg, Recursive, Fun, Acc); 35 nomatch -\u0026gt; 36 find_files(T, DIr, Reg, Recursive, Fun, Acc0) 37 end; 38 directory -\u0026gt; 39 case Recursive of 40 true -\u0026gt; 41 Acc1 = files(FullName, Reg, Recursive, Fun, Acc0), 42 find_files(T, Dir, Reg, Recursive, Fun, Acc1); 43 false -\u0026gt; 44 find_files(T, Dir, Reg, Recursive, Fun, Acc0) 45 end; 46 error -\u0026gt; 47 find_files(T, Dir, Reg, Recursive, Fun, Acc0) 48 end; 49find_files([], _, _, _, _, A) -\u0026gt; 50 A. 51 52%% 判别文件类型，从file_info记录解析 53%% 只接受regular和directory这两种类型 54file_type(File) -\u0026gt; 55 case file:read_file_info(File) of 56 {ok, Facts} -\u0026gt; 57 case Facts#file_info.type of 58 regular -\u0026gt; regular; 59 directory -\u0026gt; directory; 60 _ -\u0026gt; error 61 end; 62 _ -\u0026gt; 63 error 64 end. 函数：\n  xmerl_regexp:sh_to_awk 估计已经过期了\n  filename:join/2 Joins two filename components with directory separators.\n  re:run(Subject, RE, Options) Executes a regular expression matching, and returns match/{match, Captured} or nomatch.\n这里的Options用的是{capture, none}，If the capture options describe that no substring capturing is to be done ({capture, none}), the function returns the single atom match upon successful matching, otherwise the tuple {match, ValueList}\n  其他信息 请查阅手册\n 文件模式 用file:open打开文件时，我们会以某个或某一组模式来打开它。事实上，模式的数量比我们想象的要多得多。举个例子，读取和写入gzip压缩文件时可以使用compressed这个模式标记。手册页里有完整的清单。 修改时间、用户组、符号链接 可以用file里的一些方法来设置它们。 错误代码 我曾经泛泛地说过所有错误都是{error, Why}这种形式。事实上，Why是一个原子（比如用enoent表示文件不存在，等等）。错误代码的数量其实有很多，手册页里对它们都进行了描述。 filename filename模块里有一些很有用的方法，比如拆分目录里的完整文件名来获得文件扩展名，以及用各个组成部分重建文件名，等等。所有这些都是以跨平台的方式实现的。 filelib filelib模块有一些小方法能给我们减少一点工作量。举个例子，filelib:ensure_dir(Name)会确保给定文件或目录名Name的所有上级目录都存在，必要的话会尝试创建它们。  练习 (1) 编译Erlang文件X.erl后会生成一个X.beam文件（如果编译成功的话）。编写一个程序来检查某个Erlang模块是否需要重新编译。做法是比较相关Erlang文件和beam文件的最后修改时间戳。\nerror的情况没处理。\n1%%%------------------------------------------------------------------- 2%%% @author bnaod1 3%%% @copyright (C) 2024, 四川农业大学 4%%% @doc 5%%% 6%%% @end 7%%% Created : 2024 12月 18. 16:40 8%%%------------------------------------------------------------------- 9-module(question1). 10-author(\u0026#34;bnaod1\u0026#34;). 11-include_lib(\u0026#34;kernel/include/file.hrl\u0026#34;). 12%% API 13-export([]). 14 15 16%% 编写一个程序来检查某个Erlang模块是否需要重新编译 17%% 扫描erl与对应beam文件，比较时间戳时候完全相等 18 19need_compile(Module) -\u0026gt; 20 Erl = Module ++ \u0026#34;.erl\u0026#34;, 21 Beam = Module ++ \u0026#34;.beam\u0026#34;, 22 ET = file_mtime(Erl), 23 BT = file_mtime(Beam), 24 case ET =:= BT of 25 true -\u0026gt; 26 io:format(\u0026#34;beam is new, no need to update\u0026#34;); 27 false -\u0026gt; 28 io:format(\u0026#34;beam is old, need update\u0026#34;) 29 end. 30 31 32%% {{Year, Mon, Day}, {Hour, Min, Sec}} 33file_mtime(File) -\u0026gt; 34 case file:read_file_info(File) of 35 {ok, Facts} -\u0026gt; 36 Facts#file_info.mtime; 37 _ -\u0026gt; 38 error 39 end. 40 (2) 编写一个程序来计算某个小文件的MD5校验和，做法是用内置函数erlang:md5/1来计算文件数据的MD5校验和（有关这个内置函数的详情请参阅Erlang手册页）。\n  -spec md5(Data) -\u0026gt; Digest when Data :: iodata(), Digest :: binary().\nComputes an MD5 message digest from Data, where the length of the digest is 128 bits (16 bytes). Data is a binary or a list of small integers and binaries.\n  1%%%------------------------------------------------------------------- 2%%% @author bnaod1 3%%% @copyright (C) 2024, 四川农业大学 4%%% @doc 5%%% 6%%% @end 7%%% Created : 2024 12月 19. 09:12 8%%%------------------------------------------------------------------- 9-module(question2). 10-author(\u0026#34;bnaod1\u0026#34;). 11 12%% API 13-export([md5check/1]). 14 15md5check(File) -\u0026gt; 16 {ok, B} = file:read_file(File), 17 erlang:md5(B). 18 14\u0026gt; question2:md5check(\u0026#34;question2.erl\u0026#34;). 2\u0026lt;\u0026lt;82,4,10,130,183,212,219,207,106,161,64,136,77,80,150,81\u0026gt;\u0026gt; (3) 对一个大文件（比如几百MB）重复前面的练习。这次分小块读取该文件，并用erlang:md5_init、erlang:md5_update和erlang:md5_final计算该文件的MD5校验和。\n(4) 用lib_find模块查找计算机里的所有.jpg文件。计算每一个文件的MD5校验和，然后比较校验和来看看是否存在两张相同的图片。\n(5) 编写一种缓存机制，让它计算文件的MD5校验和，然后把结果和文件的最后修改时间一起保存在缓存里。当想要某个文件的MD5值时就检查缓存，看看是否已经计算过，如果文件的最后修改时间有变化就重新计算它。\n以后做，现在赶时间。\n(6) 一条推特刚好是140字节长。编写一个名为twit_store.erl的随机访问式推特存储模块，并导出下列函数：init(K)分配K条推特的空间。store(N, Buf)在存储区里保存第N（范围是1至K）条推特的数据Buf（一个140字节的二进制型）。fetch(N)取出第N条推特的数据。\n这个练习听着很有趣，但是我不知道怎么分配空间。\n第17章 套接字编程 UDP能让应用程序相互发送简短的消息（称为数据报），但是并不保证这些消息能成功到达。它们也可能会不按照发送顺序到达。而TCP能提供可靠的字节流，只要连接存在就会按顺序到达。用TCP发送数据的额外开销比用UDP发送数据更大。\n套接字编程有两个主要的库：gen_tcp用于编写TCP应用程序，gen_udp用于编写UDP应用程序。\nTCP的使用 TCP客户端 socket_examples.erl:\n1nano_get_url() -\u0026gt; 2 nano_get_url(\u0026#34;www.google.com\u0026#34;). 3 4nano_get_url(Host) -\u0026gt; 5 {ok, Socket} = gen_tcp:connect(Host, 80, [binary, {packet, 0}]), 6 ok = gen_tcp:send(Socket, \u0026#34;GET / HTTP/1.0\\r\\n\\r\\n\u0026#34;), 7 receive_data(Socket, []). 8 9receive_Data(Socket, SoFar) -\u0026gt; 10 receive 11 {tcp, Socket, Bin} -\u0026gt; 12 receive_data(Socket, [Bin|SoFar]); 13 {tcp_closed,Socket} -\u0026gt; 14 list_to_binary(reverse(SoFar)) 15 end.   调用gen_tcp:connect来打开一个到http://www.google.com 80端口的TCP套接字。\n连接调用里的binary参数告诉系统要以“二进制”模式打开套接字，并把所有数据用二进制型传给应用程序。\n{packet,0}的意思是把未经修改的TCP数据直接传给应用程序。\n  调用gen_tcp:send，把消息GET / HTTP/1.0\\r\\n\\r\\n发送给套接字，然后等待回复。这个回复并不是放在一个数据包里，而是分成多个片段，一次发送一点。这些片段会被接收成为消息序列，发送给打开（或控制）套接字的进程。\n  收到一个{tcp,Socket,Bin}消息。这个元组的\n  第三个参数是一个二进制型，原因是打开套接字时使用了二进制模式。这个消息是Web服务器发送给我们的数据片段之一。把它添加到目前已收到的片段列表中，然后等待下一个片段。\n  收到一个{tcp_closed, Socket}消息。这会在服务器完成数据发送时发生。\n  当所有片段都到达后，因为它们的保存顺序是错误的，所以反转它们并连接所有片段。\n  测试：\n1B = socket_examples:nano_get_url(). 2io:format(\u0026#34;~p~n\u0026#34;, [B]). 3string:tokens(binary_to_list(B), \u0026#34;\\r\\n\u0026#34;).  这个二进制型是被截断的.如果想查看整个二进制型，可以用io:format打印它，或者用string:tokens把它分成几部分。  TCP服务器   数据传输：\nTCP套接字数据只不过是一个无差别的字节流。这些数据在传输过程中可以被打散成任意大小的片段，所以需要事先约定，这样才能知道多少数据代表一个请求或响应。\n我们在Erlang里使用了一种简单的约定，即每个逻辑请求或响应前面都会有一个N（1、2或4）字节的长度计数。这就是gen_tcp:connect和gen_tcp:listen函数里参数{packet, N}的意思。packet这个词在这里指的是应用程序请求或响应消息的长度，而不是网络上的实际数据包。需要注意的是，客户端和服务器使用的packet参数必须一致。如果启动服务器时用了{packet,2}，客户端用了{packet,4}，程序就会失败。\n用{packet,N}选项打开一个套接字后，无需担心数据碎片的问题。Erlang驱动会确保所有碎片化的数据消息首先被重组成正确的长度，然后才会传给应用程序。\n  编码和解码：\n用term_to_binary编码Erlang数据类型，然后用它的逆函数binary_to_term解码数据。这个约定是这个程序的，而不是erlang规范。\n  socket_examples.erl:\n1start_nano_server() -\u0026gt; 2 {ok, Listen} = gen_tcp:listen(2345, [binary, {packet, 4}, 3 {reuseaddr, true}, 4 {active, true}]), 5 {ok, Socket} = gen_tcp:accept(Listen), 6 gen_tcp:close(Listen), 7 loop(Socket). 8 9loop(Socket) -\u0026gt; 10 receive 11 {tcp, Socket, Bin} -\u0026gt; 12 io:format(\u0026#34;Server received binary = ~p~n\u0026#34;, [Bin]), 13 Str = binary_to_term(Bin), 14 io:format(\u0026#34;Server (unpacked) ~p~n\u0026#34;, [Str]), 15 Reply = lib_misc:string2value(Str), 16 io:format(\u0026#34;Server replying = ~p~n\u0026#34;, [Reply]), 17 gen_tcp:send(Socket, term_to_binary(Replay)), 18 loop(Socket); 19 {tcp_closed, Socket} -\u0026gt; 20 io:format(\u0026#34;Server socket closed~n\u0026#34;) 21 end. 22 23 24%% 测试客户端程序 25nano_client_eval(Str) -\u0026gt; 26 {ok, Socket} = gen_tcp:connect(\u0026#34;localhost\u0026#34;, 2345, [binary, {packet, 4}]), 27 ok = gen_tcp:send(Socket, term_to_binary(Str)), 28 receive 29 {tcp, Socket, Bin} -\u0026gt; 30 io:format(\u0026#34;Client received binary = ~p~n\u0026#34;, [Bin]), 31 Val = binary_to_term(Bin), 32 io:format(\u0026#34;Client result = ~p~n\u0026#34;, [Val]), 33 gen_tcp:close(Socket) 34 end.   调用gen_tcp:listen来监听2345端口的连接，并设置消息的打包约定。{packet,4}的意思是每个应用程序消息前部都有一个4字节的长度包头。然后gen_tcp:listen(..)会返回{ok, Listen}或{error, Why}\n程序在gen_tcp:listen返回{error, \u0026hellip;}时抛出一个模式匹配异常错误。\n在成功的情况下，这个语句会绑定Listen到刚监听的套接字上。\n在我的理解中，listen函数更像是一种监听和通话配置。listen是监听套接字。\n  调用gen_tcp:accept(Listen)。在这个阶段，程序会挂起并等待一个连接。当我们收到连接时，这个函数就会返回变量Socket，它绑定了可以与连接客户端通信的套接字。\n可以说accept就像门卫，有客人来了就请他到一个房间Socket去。\naccept是和connect配合的，一个听一个去连接，他们返回的socket就是他们沟通的桥梁。\n  在accept返回后立即调用gen_tcp:close(Listen)。这样就关闭了监听套接字，使服务器不再接收任何新连接。这么做不会影响现有连接，只会阻止新连接。\nclose负责关闭accpet的监听。\n  close还可以负责切断两者通信的socket，它是通过向服务器发送{tcp_closed, Socket}做到的。\n  TODO 我是有疑问的，如果listen和connect中的opt有一个缺省了该怎么办，客户端可以肆意妄为吗？\n  测试：\n两个窗口\n1socket_examples:start_nano_server(). 执行完这个后处在accpet的位置，等待链接。\n1socket_examples:nano_client_eval(\u0026#34;list_to_tuple([2+3*$, 10+20])\u0026#34;). 执行完这句之后服务器窗口：\n1Server received binary = \u0026lt;\u0026lt;131,107.... 2Server (unpacked) \u0026#34;list_to_tuple([2+3*4, 10+20])\u0026#34; 3Server replying = {14, 30} 客户端窗口\n1Client received binary = \u0026lt;\u0026lt; 131... 2Client result = {14, 30} 最后服务器窗口\n1Server socket closed 改进为顺序和并行服务器 顺序服务器：一次接收一个连接 并行服务器：同时接收多个并行连接\n顺序服务器：\n1start_seq_server() -\u0026gt; 2\t{ok, Listen} = gen_tcp:listen(...), 3\tseq_loop(Listen). 4 5seq_loop(Listen) -\u0026gt; 6 {ok, Socket} = gen_tcp:accept(Listen), 7 loop(Socket), 8 seq_loop(Listen). 9 10loop(..) -\u0026gt; ... 在loop(Socket)完成后再次调用seq_loop(Listen)，让它等待下一个连接。如果一个客户端尝试连接时服务器正忙于处理现有连接，该连接就会加入队列，直至服务器完成现有连接。如果排队的连接数量超过了监听缓冲区限制，该连接就会被拒绝。\n停止服务器很简单（停止并行服务器也一样），只需终止启动单个或多个服务器的进程即可。gen_tcp自身会连接到控制进程上，如果控制进程终止，它就会关闭套接字。\n并行服务器：\n1start-parallel_server() -\u0026gt; 2\t{ok, Listen} = gen_tcp:listen(...), 3 spawn(fun() -\u0026gt; par_connect(Listen) end). 4 5par_connect(Listen) -\u0026gt; 6 {ok, Socket} = gen_tcp:accept(Listen), 7 spawn(fun() -\u0026gt; par_connect(Listen) end), 8 loop(Socket). 9 10loop(..) -\u0026gt; ... 注意事项   创建某个套接字（通过调用gen_tcp:accept或gen_tcp:connect）的进程被称为该套接字的控制进程。所有来自套接字的消息都会被发送到控制进程。如果控制进程挂了，套接字就会被关闭。某个套接字的控制进程可以通过调用gen_tcp:controlling_process(Socket, NewPid)修改成NewPid。\n  我们的并行服务器可能会创建出几千个连接，所以可以限制最大同时连接数。实现的方法可以是维护一个计数器来统计任一时刻有多少活动连接。每当收到一个新连接时就让计数器加1，每当一个连接结束时就让它减1。可以用它来限制系统里的同时连接总数。\n  接受一个连接后，显式设置必要的套接字选项是一种很好的做法，就像这样：\n1{ok, Socket} = gen_tcp:accept(Listen), 2inet:setopts(Socket, [{packet,4},binary,{nodelay,true},{active,true}]), 3loop(Socket)   Erlang 的R11B-3版开始允许多个Erlang进程对同一个监听套接字调用gen_tcp:accept/1。这让编写并行服务器变得简单了，因为你可以生成一个预先分裂好的进程池，让它们都处在gen_tcp:accept/1的等待状态。\n  假设编写了某种在线服务器，并且发现有人持续向网站发送垃圾信息。为了尽量防止这 种事发生，我们需要知道连接的来源。可以调用inet:peername(Socket)进行查看。\n@spec inet:peername(Socket) -\u0026gt; {ok, {IP_Address, Port}} | {error, Why}\n  主动和被动套接字 TODO 一个套接字指的是Listen还是Socket？难道一个Socket会有多个连接吗？\nErlang的套接字可以有三种打开模式：主动（active）、单次主动（active once）或被动（passive）。这是通过在gen_tcp:connect(Address, Port, Options)或gen_tcp:listen(Port, Options)的Options参数里加入{active, true | false | once}选项实现的。\n如果指定{active, true}就会创建一个主动套接字，指定{active, false}则是被动套接字。{active, once}创建的套接字只会主动接收一个消息，接收完之后必须重新启用才能接收下一个消息。\n 当一个主动套接字被创建后，它会在收到数据时向控制进程发送{tcp, Socket, Data}消息。控制进程无法控制这些消息流。恶意的客户端可以向系统发送成千上万的消息，而它们都会被发往控制进程。控制进程无法阻止这些消息流。 如果一个套接字是用被动模式打开的，控制进程就必须调用gen_tcp:recv(Socket, N)来从这个套接字接收数据。然后它会尝试从套接字接收N个字节。如果N = 0，套接字就会返回所有可用的字节。在这个案例里，服务器可以通过选择何时调用gen_tcp:recv来控制客户端所发的消息流。被动套接字的作用是控制通往服务器的数据流。  1.主动消息接收（非阻塞式）:\n只有在确信服务器能跟上客户端的需求时才会编写非阻塞式服务器。\n1{ok, Listen} = gen_tcp:listen(Port, [.., {active, true}...]), 2{ok, Socket} = gen_tcp:accept(Listen), 3loop(Socket). 4 5loop(Socket) -\u0026gt; 6 receive 7 {tcp, Socket, Data} -\u0026gt; 8 ... 对数据进行操作 ... 9\t{tcp_closed, Socket} -\u0026gt; 10 ... 11\tend. 2.被动消息接收（阻塞式）:\n服务器循环里的代码会在每次想要接收数据时调用gen_tcp:recv。客户端会一直被阻塞，直到服务器调用recv为止。请注意，操作系统有自己的缓冲设置，即使没有调用recv，客户端也能在阻塞前发送少量数据。\n当我们处于被动模式时，只能等待来自单个套接字的数据。这对于编写那些必须等待来自多个套接字数据的服务器来说毫无用处。\n1{ok, Listen} = gen_tcp:listen(Port, [..,{active, false}...]), 2{ok, Socket} = gen_tcp:accept(Listen), 3loop(Socket). 4 5loop(Socket) -\u0026gt; 6 case gen_tcp:recv(Socket, N) of 7 {ok, B} -\u0026gt; 8 .... 9\tloop(Socket); 10\t{error, closed} 11\t... 12\tend. 3.混合消息接收（部分阻塞式）:\n套接字在这个模式下虽然是主动的，但只针对一个消息。当控制进程收到一个消息后，必须显式调用inet:setopts才能重启下一个消息的接收，在此之前系统会处于阻塞状态。\n通过使用{active, once}选项，用户可以实现高级形式的流量控制（有时被称为流量整形），从而防止服务器被过多消息淹没。\n1{ok, Listen} = gen_tcp:listen(Port, [..,{active, once}...]), 2{ok, Socket} = gen_tcp:accept(Listen), 3loop(Socket). 4 5loop(Socket) -\u0026gt; 6 receive 7 {tcp, Socket, Data} -\u0026gt; 8 .... 9\t%% 准备好启动下一个消息接收时 10\tinet:setpots(Socket, [{active, once}]), 11 loop(Socket); 12\t{tcp_closed, Socket} -\u0026gt; 13 ... 14\tend. 套接字错误处理 每个套接字都有一个控制进程（也就是创建该套接字的进程）。如果控制进程挂了，套接字就会被自动关闭。如果我们有一个客户端和一个服务器，而服务器因为程序错误挂了，那么服务器支配的套接字就会被自动关闭，同时向客户端发送一个{tcp_closed, Socket}消息。\n实验：\n1error_Test() -\u0026gt; 2 spawn(fun() -\u0026gt; error_test_server() end), 3 lib_misc:sleep(2000), 4 {ok, Socket} = gen_tcp:connect(\u0026#34;localhost\u0026#34;, 4321, [binary, {packet,2}]), 5 io:format(\u0026#34;connected to :~p~n\u0026#34;, [Socket]), 6 gen_tcp:send(Socket, \u0026lt;\u0026lt;\u0026#34;123\u0026#34;\u0026gt;\u0026gt;), 7 receive 8 Any -\u0026gt; 9 io:format(\u0026#34;Any=~p~n\u0026#34;,[Any]) 10 end. 11 12error_test_server() -\u0026gt; 13 {ok, Listen} = gen_tcp:listen(4321, [binary, {packet,2}]), 14 {ok, Socket} = gen_tcp:accept(Listen), 15 error_test_server_loop(Socket). 16 17error_test_server_loop(Socket) -\u0026gt; 18 receive 19 {tcp, Socket, Data} -\u0026gt; 20 io:format(\u0026#34;received:~p~n\u0026#34;, [Data]), 21 _ = atom_to_list(Data), 22 error_test_server_loop(Socket) 23 end. 我们分裂出一个服务器并睡眠两秒钟来让它完成启动，然后向它发送一个包含二进制型\u0026laquo;\u0026ldquo;123\u0026rdquo;\u0026raquo; 的消息。 当这个消息到达服务器后，服务器尝试对二进制型Data 计算atom_to_list(Data)，于是立即崩溃了。系统监视器打印出了你在shell里所见到的诊断信息。因为服务器端套接字的控制进程已经崩溃，所以（服务器端的）套接字就被自动关闭了。系统随后向客户端发送一个{tcp_closed, Socket}消息。\nUDP 互联网上的机器能够通过UDP相互发送被称为数据报（datagram）的短消息。UDP数据报是不可靠的，这就意味着如果客户端向服务器发送一串UDP数据报，它们可能会不按顺序到达，不能成功到达或者不止一次到达。但是每一个数据报只要到达，就会是完好无损的。\nUDP是一种无连接协议，意思是客户端向服务器发送消息之前不必建立连接。这就意味着UDP非常适合那些大量客户端向服务器发送简短消息的应用程序。\n最简单的UDP服务器与客户端 服务器：\n1server(Port) -\u0026gt; 2 {ok, Socket} = gen_udp:open(POrt, [binary]), 3 loop(Socket). 4 5loop(Socket) -\u0026gt; 6 receive 7 {udp, Socket, Host, Port, Bin} -\u0026gt; 8 BinReply = ..., 9\tgen_udp:send(Socket, Host, Port, BinReply), 10\tloop(Socket) 11 end. 客户端：\n必须设置一个超时，因为UDP是不可靠的，我们可能会得不到回复。\n1client(Request) -\u0026gt; 2 {ok, Socket} = gen_udp:open(0, [binary]), 3 ok = gen_udp:send(Socket, \u0026#34;localhost\u0026#34;, 4000, Request), 4 Value = receive 5 {udp, Socket, _, _, Bin} -\u0026gt; 6 {ok, Bin} 7 after 2000 -\u0026gt; 8 error 9 end, 10 gen_udp:close(Socket), 11 Value. 一个UDP阶乘服务器 1-module(udp_test). 2-export([start_server0, client/1]). 3 4start_server() -\u0026gt; 5 spawn(fun() -\u0026gt; server(4000) end). 6 7%% server 8server(Port) -\u0026gt; 9 {ok, Socket} = gen_udp:open(Port, [binary]), 10 io:format(\u0026#34;server opened socket:~p~n\u0026#34;, [Socket]), 11 loop(Socket). 12 13loop(Socket) -\u0026gt; 14 receive 15 {udp, Socket, Host, Port, Bin} = Msg -\u0026gt; 16 io:format(\u0026#34;server received:~p~n\u0026#34;, [Msg]), 17 N = binary_to_term(Bin), 18 Fac = fac(N), 19 gen_udp_send(Socket, Host, Port, term_to_binary(Fac)), 20 loop(Socket) 21 end. 22 23fac(0) -\u0026gt; 1; 24fac(N) -\u0026gt; N * fac(N-1). 25 26%% client 27client(N) -\u0026gt; 28 {ok, Socket} = gen_udp:open(0, [binary]), 29 io:format(\u0026#34;client opened socket=~p~n\u0026#34;, [Socket]), 30 ok = gen_udp:send(Socket, \u0026#34;localhost\u0026#34;, 4000, term_to_binary(N)), 31 Value = receive 32 {udp, Socket, _, _, Bin} = Msg -\u0026gt; 33 io:format(\u0026#34;client received:~p~n\u0026#34;, [Msg]), 34 binary_to_term(Bin) 35 after 2000 -\u0026gt; 36 0 37 end, 38 gen_udp:close(Socket), 39 Value. 测试：\n1udp_test:start_server(). 2udp_test:client(40). UDP数据包须知  UDP是一种无连接协议，所以服务器无法通过拒绝读取来自某个客户端的数据来阻挡它。服务器对谁是客户端一无所知。 大型UDP数据包可能会分段通过网络。当UDP数据经过网络上的路由器时，如果数据大小超过了路由器允许的最大传输单元（Maximum Transfer Unit，简称MTU）大小，分段就会发生。通常的建议是在调整UDP网络时从一个较小的数据包大小开始（比如大约500字节），然后逐步增大并测量吞吐量。如果吞吐量在某个时刻骤减，你就知道数据包太大了。 UDP数据包可以传输两次（这出乎一些人的意料之外），所以在编写远程过程调用代码时一定要小心。第二次查询得到的回复可能只是第一次查询回复的复制。为防止这类问题，可以修改客户端代码来加入一个唯一的引用，然后检查服务器是否返回了这个引用。要生成一个唯一的引用，需要调用Erlang的内置函数make_ref，它能确保返回一个全局唯一的引用。  一个ref防止重发的示例：\n1client(Request) -\u0026gt; 2 {ok, Socket} = gen_udp:open(0, [binary]), 3 Ref = make_ref(), %% 生成唯一引用 4 B1 = term_to_binary({Ref, Request}), 5 ok = gen_udp:send(Socket, \u0026#34;localhost\u0026#34;, 4000, B1), 6 wait_for_ref(Socket, Ref). 7 8wait_for_ref(Socket, Ref) -\u0026gt; 9 receive 10 {udp, Socket, _, _, Bin} -\u0026gt; 11 case binary_to_term(Bin) of 12 {Ref, Val} -\u0026gt; 13 %% correct 14 Val; 15 {_SomeOtherRef, _} -\u0026gt; 16 %% incorrect, drop 17 wait_for_ref(Socket,Ref) 18 end; 19 after 1000 -\u0026gt; 20 .... 21\tend. 广播 在这里需要两个端口，一个发送广播（广播方），另一个监听回应（接听方和广播发向的端口）。我们选择了5010端口来发送广播请求，6000端口用来监听广播\n只有发送广播的进程才会打开5010端口，而网络上的所有机器都会调用broadcast:listen()来打开6000端口并监听广播消息。broadcast:send(IoList)会对局域网里的所有机器广播IoList。\n大概意思就是从5010给局域网每台机器的6000端口发消息，想要接收就听6000端口。\n1-module(broadcase). 2-compile(export_all). 3 4send(IoList) -\u0026gt; 5 case inet:ifget(\u0026#34;eth0\u0026#34;, [broadaddr]) of 6 {ok, [{broadaddr, Ip}]} -\u0026gt; 7 {ok, S} = gen_udp:open(5010, [{broadcast, true}]), 8 gen_udp:send(S, Ip, 6000, IoList), 9 gen_udp:close(S); 10 _ -\u0026gt; 11 io:format(\u0026#34;Bad interface name, or\\n\u0026#34; 12 \u0026#34;broadcasting not supported\\n\u0026#34;) 13 end. 14 15listen() -\u0026gt; 16 {ok, _} = gen_udp:open(6000), 17 loop(). 18loop() -\u0026gt; 19 receive 20 Any -\u0026gt; 21 io:format(\u0026#34;received:~p~n\u0026#34;, [Any]), 22 loop() 23 end. 案例：一个 SHOUTcast 服务器 SHOUTcast是由Nullsoft公司开发的协议，它被用于传输音频数据流。SHOUTcast使用HTTP作为传输协议来发送MP3或AAC编码的音频数据。\n练习 没时间了，以后做。\n(1) 修改nano_get_url/0的代码（17.1.1节），并在必要时添加合适的HTTP头或执行重定向来获取任意网页。在多个网站上测试它。\n(2) 输入17.1.2节里的代码，然后修改此代码来接收一个{Mod, Func, Args}元组（而不是字符串），最后计算Reply = apply(Mod, Func, Args)并把值发回套接字。编写一个nano_client_eval(Mod, Func, Args)函数（类似于本章前面所展示的版本），让它用修改版服务器代码能理解的形式编码Mod、Func和Arity。测试客户端和服务器代码能否正常工作，首先在同一台机器上，然后在同一局域网的两台机器上，最后在互联网上的两台机器上。\n(3) 用UDP代替TCP重复上一个练习。\n(4) 添加一个加密层，做法是先编码二进制型再发送给输出套接字，并在输入套接字接收之后立即解码。\n(5) 制作一个简单的“类电子邮件”系统。把Erlang数据类型作为消息存储在${HOME}/mbox目录里。\n第18章 用WebSocket和Erlang进行浏览 其实就是一个前后端的概念\nTODO 这章都是示例程序，待补。\n为了给Erlang运行时系统建立WebSocket接口，就会运行一个名为cowboy（牛仔）的简单Erlang服务器，让它管理套接字和WebSocket协议。第25章会详细介绍如何安装cowboy。为了简化讨论，我们假定Erlang和浏览器之间传递的所有消息都是JSON格式的。\n这些消息在应用程序的Erlang端体现为Erlang映射组（参见5.3节），在浏览器里则体现为JavaScript对象。\n一个数字时钟 1\u0026lt;script ... src=:./jquery...\u0026lt;/script\u0026gt; 2\u0026lt;script ... src=\u0026#34;websock.js\u0026#34; .. \u0026lt;/script\u0026gt; 3\u0026lt;body\u0026gt; 4 ... 5\u0026lt;/body\u0026gt; 6 7 8\u0026lt;script\u0026gt; 9\t$(document).ready(function(){ 10 connect(\u0026#34;localhost\u0026#34;, 2233, \u0026#34;clock1\u0026#34;); 11 }) 12\u0026lt;/script\u0026gt; websock.js包含了所有必需的代码来打开WebSocket和连接浏览器DOM对象到Erlang。它会做下列事情。\n(1) 给网页里所有属于live_button类的按钮添加点击处理函数。这些点击处理函数会在按钮被点击时向Erlang发送消息。\n(2) 尝试启动一个到http://localhost:2233的WebSocket连接。在服务器端会有一个新分裂 出 的 进 程 调 用 clock1:start(Browser) 函 数 。 所 有 这 些 都 是 通 过 调 用 JavaScript 函 数connect(\u0026ldquo;localhost\u0026rdquo;, 2233, \u0026ldquo;clock1\u0026rdquo;)实现的。2233这个数字没有什么特别的含义，任何大于1023的未使用端口号都可以用。\n现在是Erlang代码：\n1-module(clock1). 2-export([start/1, current_time/0]). 3 4start(Browser) -\u0026gt; 5 Browser ! #{ cmd =\u0026gt; fill_div, id =\u0026gt; clock, txt =\u0026gt; current_time()}, 6 running(Browser). 7 8running(Browser) -\u0026gt; 9 receive 10 {Browser, #{clicked =\u0026gt; \u0026lt;\u0026lt;\u0026#34;stop\u0026#34;\u0026gt;\u0026gt;}} -\u0026gt; 11 idle(Browser) 12 after 1000 -\u0026gt; 13 Browser ! #{cmd =\u0026gt; fill_div, id=\u0026gt; clock, txt =\u0026gt; current_time()}, 14 running(Browser) 15 end. 16 17idle(Browser) -\u0026gt; 18 receive 19 {Browser, #{clicked =\u0026gt; \u0026lt;\u0026lt;\u0026#34;start\u0026#34;\u0026gt;\u0026gt;}} -\u0026gt; 20 running(Browser) 21 end. 22 23current_time() -\u0026gt; 24 {Hour, Min, Sec} = time(), 25 list_to_binary(io_lib:format(\u0026#34;~2.2.ow:~2.2.ow:~2.2.ow\u0026#34;,[Hour,Min,Sec])). 若希望让浏览器做点什么，就向它发送一个消息。就像在Erlang里一样。我们驯服了浏览器，它看起来就像是一个Erlang进程。\n初始化之后，clock1会调用running/1。如果收到一个{clicked =\u0026gt; \u0026laquo;\u0026ldquo;stop\u0026rdquo;\u0026raquo;}消息，就会调用idle(Browser)。否则，会在一秒钟的超时到期后向浏览器发送一个更新时钟的命令，然后调用自身。idle/1等待一个start消息，然后调用running/1。\n单方聊天框 它的工作方式类似于时钟示例。每当用户在输入框里按下回车键时，输入框就会发送一个包含输入文本的消息给浏览器。管理窗口的Erlang进程接收这个消息，然后向浏览器发回一个更新显示内容的消息。\n1-module(iunteract1). 2-export([start/1]). 3 4start(Browser) -\u0026gt; running(Browser). 5 6running(Bowser) -\u0026gt; 7 receive 8 {Browser, #{entry =\u0026gt; \u0026lt;\u0026lt;\u0026#34;input\u0026#34;\u0026gt;\u0026gt;m txt =\u0026gt; Bin}} -\u0026gt; 9 Time = clock1:current_time(), 10 Browser ! #{cmd =\u0026gt; append_div, id =\u0026gt; scroll, txt =\u0026gt; list_to_binary([Time, \u0026#34;\u0026gt;\u0026#34;, Bin, \u0026#34;\u0026lt;Br\u0026gt;\u0026#34;])} 11 end, 12 running(Browser). 13 浏览器里的 Erlang shell 可以用接口模式里的代码制作一个在浏览器里运行的Erlang shell。\n1start(Browser) -\u0026gt; 2 Browser ! #{cmd =\u0026gt; append_div, id =\u0026gt; scroll, txt =\u0026gt; \u0026lt;\u0026lt;\u0026#34;Starting Erlang shell:\u0026lt;br\u0026gt;\u0026#34;\u0026gt;\u0026gt;}, 3 B0 = erl_eval:new_bindings(), 4 running(Browser, B0, 1). 5running(Browser, B0, N) -\u0026gt; 6 receive 7 {Browser, #{entry =\u0026gt; \u0026lt;\u0026lt;\u0026#34;input\u0026#34;\u0026gt;\u0026gt;}, txt =\u0026gt; Bin}} -\u0026gt; 8 {Vaule, B1} = string2value(binary_to_list(Bin), B0), 9 BV = bf(\u0026#34;~w\u0026gt; \u0026lt;font color=\u0026#39;red\u0026#39;\u0026gt;~s\u0026lt;/font\u0026gt;\u0026lt;br\u0026gt;~p\u0026lt;br\u0026gt;\u0026#34;, [N, Bin, Value]), 10 Browser ! #{cmd =\u0026gt; append_div, id =\u0026gt; scroll, txt =\u0026gt; BV}, 11 running(Brwoser, B1, N+1) 12 end. 13 14string2value(Str, Bindings0) -\u0026gt; 15 case erl_scan:string(Str, 0) of 16 {ok, Tokens, _} -\u0026gt; 17 case erl_parse:parse_exprs(Tokens) of 18 {ok, Exprs} -\u0026gt; 19 {value, Val, Bindings1} = erl_eval:exprs(Exprs, Binding0), 20 {Val, Bindings1}; 21 Other -\u0026gt; 22 io:format(\u0026#34;cannot parse:~pReason=~p~n\u0026#34;, [Tokens, Other]), 23 {parse_error, Bindings0} 24 end; 25 Other -\u0026gt; 26 io:format(\u0026#34;cannot tokenise:~pReason=~p~n\u0026#34;, [Str, Other]) 27 end. 一个聊天小部件 1-module(chat1). 2-export([start/1]). 3 4start(Browser) -\u0026gt; 5 running(Browser, []). 6 7running(Browser, L) -\u0026gt; 8 receive 9 {Brwoser, #{join =\u0026gt; Who}} -\u0026gt; 10 Browser ! #{cmd =\u0026gt; append_div, id =\u0026gt;scroll, 11 txt =\u0026gt; list_to_binary([Who, \u0026#34; joined the group\\n\u0026#34;])}, 12 L1 = [Who, \u0026#34;\u0026lt;br\u0026gt;\u0026#34;|L], 13 Browser ! #{cmd =\u0026gt; fill_div, id =\u0026gt; users, 14 txt =\u0026gt; list_to_binary(L1)}, 15 running(Browser, L1); 16 {Browser, #{entry =\u0026gt; \u0026lt;\u0026lt;\u0026#34;tell\u0026#34;\u0026gt;\u0026gt; ,txt =\u0026gt; Txt}} -\u0026gt; 17 Browser ! #{cmd =\u0026gt; append_div, id =\u0026gt; scroll, 18 txt =\u0026gt; list_to_binary([\u0026#34; \u0026gt; \u0026#34;, Txt, \u0026#34;\u0026lt;br\u0026gt;\u0026#34;])}, 19 running(Browser, L); 20 X -\u0026gt; 21 io:format(\u0026#34;chat received:~p~n\u0026#34;, [X]) 22 end, 23 running(Browser, L). 简化版 IRC IRC是Internet Relay Chat（互联网中继聊天）的缩写，它以客户端-服务器的形式进行文本消息传输。\n上一节里的聊天小部件可以轻松扩展成一个更真实的聊天程序。\n浏览器里的图形 浏览器-服务器协议 这是这一章所有程序用到的协议。\n练习 (1) shell1.erl里启动的进程不够完善。如果它崩溃了，Web应用程序就会锁定并无法运行。给这个应用程序添加错误恢复代码。添加历史命令重放的功能。\n(2) 阅读websockets.js里的代码，仔细追踪浏览器里某个活动按钮被点击后发生的事。跟着代码从JavaScript到WebSocket，再从WebSocket到Erlang。点击按钮后生成的消息是如何找到相应的Erlang控制进程的？\n(3) 简化版IRC程序是一个功能完备的聊天程序。试着运行它并检查它的功能是否正常。你可能会发现防火墙之类的因素阻止它访问服务器，让它无法正常工作。如果是这样，就进行调查并看看能否开放防火墙。尝试找到真正的IRC协议规范，你会发现它比这里的版本长很多。为什么会这样？用某种用户身份验证系统来扩展这个IRC系统。\n(4) IRC程序使用了一台中央服务器。能否修改这个程序，让它用点对点网络取代中央服务器？能否给聊天客户端添加SVG图形，或者用HTML5里的音频接口发送和接收声音数据？\n第19章 用ETS和DETS存储数据 基本概念  ETS是Erlang Term Storage（Erlang数据存储）的缩写，DETS则是Disk ETS（磁盘ETS）的缩写。 ETS和DETS执行的任务基本相同：它们提供大型的键值查询表。ETS常驻内存，DETS则常驻磁盘。DETS提供了几乎和ETS一样的接口，但它会把表保存在磁盘上。因为DETS使用磁盘存储，所以它远远慢于ETS，但是运行时的内存占用也会小很多。ETS表里的数据保存在内存里，它们是易失的。当ETS表被丢弃或者控制它的Erlang进程终止时，这些数据就会被删除。保存在DETS表里的数据是非易失的，即使整个系统崩溃也能留存下来。DETS表在打开时会进行一致性检查，如果发现有损坏，系统就会尝试修复它 ETS和DETS表是把键和值关联到一起的数据结构。最常用的表操作是插入和查找。ETS或DETS表其实就是Erlang元组的集合。 一些表被称为异键表（set），它们要求表里所有的键都是唯一的。另一些被称为同键表（bag），它们允许多个元素拥有相同的键。基本的表类型（异键表和同键表）各有两个变种，它们共同构成四种表类型：异键、有序异键（ordered set）、同键和副本同键（duplicate bag）。在异键表里，各个元组里的键都必须是独一无二的。在有序异键表里，元组会被排序。在同键表里可以有不止一个元组拥有相同的键，但是不能有两个完全相同的元组。在副本同键表里可以有多个元组拥有相同的键，而且在同一张表里可以存在多个相同的元组。  基本操作  创建一个新表或打开现有的表 用ets:new或dets:open_file实现。 向表里插入一个或多个元组 这里要调用insert(TableId, X)，其中X是一个元组或元组列表。insert在ETS和DETS里有着相同的参数和工作方式。 在表里查找某个元组 这里要调用 lookup(TableID, Key)。得到的结果是一个匹配 Key的元组列表。 lookup在ETS和DETS里都有定义。lookup的返回值始终是一个元组列表，这样就能对异键表和同键表使用同一个查找函数。如果表的类型是同键，那么多个元组可以拥有相同的键。如果表的类型是异键，那么查找成功后的列表里只会有一个元素。如果表里没有任何元组拥有所需的键，就会返回一个空列表。 丢弃某个表 用完某个表后可以告知系统，方法是调用dets:close(TableId) 或 ets:delete(TableId)。  ets_test.erl\n1-module(ets_test). 2-export([start/0]). 3 4start() -\u0026gt; 5 lists:foreach(fun test_ets/1, 6 [set, ordered_set, bag, duplicate_bag]). 7 8test_ets(Mode) -\u0026gt; 9 TableId = ets:new(test, [Mode]), 10 ets:insert(TableId, {a,1}), 11 ets:insert(TableId, {b,2}), 12 ets:insert(TableId, {a,1}), 13 ets:insert(TableId, {a,3}), 14 List = ets:tab2list(TableId), 15 io:format(\u0026#34;~-13w =\u0026gt; ~p~n\u0026#34;, [Mode, List]), 16 ets:delete(TableId). 11\u0026gt; ets_test:start(). 2set =\u0026gt; [{b,2},{a,3}] 3ordered_set =\u0026gt; [{a,3},{b,2}] 4bag\t=\u0026gt; [{b,2},{a,1},{a,3}] 5duplicate_bag =\u0026gt; [{b,2},{a,1},{a,1},{a,3}] 影响 ETS 表效率的因素 TODO 待补\n   lib_trigrams.erl:\n1for_each_trigram_in_the_english_language(F, A0) -\u0026gt; 2 {ok, Bin0} = file:read_file(\u0026#34;354984si.ngl.gz\u0026#34;), 3 Bin = zlib:gunzip(Bin0), 4 scan_word_list(binary_to_list(Bin), F, A0). 5 6scan_word_list([], _, A) -\u0026gt; 7 A; 8scan_word_list(L, F, A) -\u0026gt; 9 {Word, L1} = get_next_word(L, []), 10 A1 = scan_trigrams([$\\s|Word], F, A). 11 12%% 扫描单词，寻找\\r\\n。 13%% 第二个参数是（反转的）单词， 14%% 所以必须在找到\\r\\n或扫描完字符时把它反转回来 15%% 于是这个函数，第一个参数是一个字符串（每一行一个单词），第二个参数是结果，目的是将字符串反转（abc -\u0026gt;cba） 16 17get_next_word([$\\r,$\\n|T], L) -\u0026gt; {reverse([$\\s|L]), T}; 18get_next_word([H|T], L) -\u0026gt; get_next_word(T, [H|L]); 19get_next_word([], L) -\u0026gt; {reverse([$\\s|L]), []}. 20 21scan_trigrams([X, Y, Z], F, A) -\u0026gt; 22 F([X, Y, Z], A); 23scan_trigrams([X, Y, Z|T], F, A) -\u0026gt; 24 A1 = F([X,Y,Z], A), 25 scan_trigrams([Y,Z|T], F, A1); 26scan_trigrams(_, _, A) -\u0026gt; 27 A. 1%% 封装异键，有序异键的创建和持久化的名称 2make_ets_ordered_set() -\u0026gt; make_a_set(ordered_set, \u0026#34;trigramsOS.tab\u0026#34;). 3make_ets_set() -\u0026gt; make_a_set(set, \u0026#34;trigramsS.tab\u0026#34;). 4 5make_a_set(TYpe, FileName) -\u0026gt; 6 %% 建表 7 Tab = ets:new(table, [Type]), 8 %% 插入二进制型到表 9 F = fun(Str, _) -\u0026gt; ets:insert(Tab, {list_to_binary(Str)}) end, 10 for_each_trigram_in_the_english_language(F, 0), 11 %% 持久化到文件 12 ets:tab2file(Tab, FileName), 13 Size = ets:info(Tab, size), 14 ets:delete(Tab), 15 Size. 1%% 使用Erlang:sets创建一个包含所有三字母组合的异键表 2make_mod_set() -\u0026gt; 3 D = sets:new(), 4 F = fun(Str, Set) -\u0026gt; sets:add_element(list_to_binary(Str), Set) end, 5 D1 = for_each_trigram_in_the_english_language(F,D), 6 file:write_file(\u0026#34;trigrams.set\u0026#34;, [term_to_binary(D1)]). 1timer_tests() -\u0026gt; 1%% 封装字符串，在左右两边加个空格 2is_word(Tab, Str) -\u0026gt; is_word1(Tab, \u0026#34;\\s\u0026#34; ++ Str ++ \u0026#34;\\s\u0026#34;). 3%% 只有3个字母 4is_word1(Tab, [_,_,_]=X) -\u0026gt; is_this_a_trigram(Tab, X); 5%% 4个及更多的字母 6is_word1(Tab, [A,B,C|D]) -\u0026gt; 7 case is_this_a_trigram(Tab, [A,B,C]) of 8 true -\u0026gt; is_word1(Tab, [B,C|D]); 9 false -\u0026gt; false 10 end; 11%% 匹配到这直接错误 12is_word1(_, _) -\u0026gt; 13 false. 14 15%% 封装查询 16is_this_a_trigram(Tab, X) -\u0026gt; 17 case ets:lookup(Tab, list_to_binary(X)) of 18 [] -\u0026gt; false; 19 _ -\u0026gt; true 20 end. 21 22%% 封装打开之前生成的字典ets 23open() -\u0026gt; 24 File = filename:join(filename:dirname(code:which(?MODULE)), 25 \u0026#34;/trigramsS.tab\u0026#34;), 26 {ok, Tab} = ets:file2tab(File), 27 Tab. 28close(Tab) -\u0026gt; ets:delete(Tab). lib_filenames_dets.erl:\n1-module(lib_filenames_dets). 2-export([open/1, close/0, test/0, filename2index/1, index2filename/1]). 3 4open(File) -\u0026gt; 5 io:format(\u0026#34;dets opened:~p~n\u0026#34;, [File]), 6 %% 检查文件名的文件是否存在 7 Bool = filelib:is_file(File), 8 case dets:open_file(?MODULE, [{file, File}]) of 9 {ok, ?MODULE} -\u0026gt; 10 case Bool of 11 %% 打开一个现有文件 12 true -\u0026gt; void; 13 %% 新建文件，初始化dets表，1代表目前1的索引为空白的 14 false -\u0026gt; ok = dets:insert(?MODULE, {free,1}) 15 end, 16 true; 17 {error,Reason} -\u0026gt; 18 io:format(\u0026#34;cannot open dets table~n\u0026#34;), 19 exit({eDetOpen, FIle, Reason}) 20 end. 21 22close() -\u0026gt; dets:close(?MODULE). 23 1filename2index(FileName) when is_binary(FileName) -\u0026gt; 2 case dets:lookup(?MODULE, FileName) of 3 [] -\u0026gt; 4 %% 查询空白索引 5 [{_,Free}] = dets:lookup(?MODULE, free), 6 %% 插入数据，同时更新空白索引为下一个位置 7 ok = dets:insert(?MODULE, 8 [{Free,FileName},{FileName,Free},{free,Free+1}]), 9 Free; 10 [{_,N}] -\u0026gt; 11 N 12 end. 1%% 根据索引查询文件名 2index2filename(Index) when is_integer(Index) -\u0026gt; 3 case dets:lookup(?MODULE, Index) of 4 [] -\u0026gt; error; 5 [{_, Bin}] -\u0026gt; Bin 6 end. 练习 (1) Mod:module_info(exports)会返回Mod模块里所有导出函数的列表。用这个函数找出Erlang系统库里导出的所有函数。制作一个键值查询表，其中键是一个{Function,Arity}对，值是一个模块名。把这些数据储存在ETS和DETS表里。\n 提示 使用code:lib_dir()和code:lib_dir(LibName)来找出系统里所有模块的名称。\n (2) 制作一个共享的ETS计数表。实现一个名为count:me(Mod,Line)的函数，通过在你的代码里添加count:me(?MODULE, ?LINE)来调用它。每当这个函数被调用时，就给记录自身执行次数的计数器加1。编写一些函数来初始化和读取计数器。\n(3) 编写一个检测文本抄袭的程序。用一个双遍历（two-pass）算法来实现它。第一次遍历时，把文本打散成40个字符的小块并计算各个块的校验和，然后把校验和与文件名保存在一个ETS表里。第二次遍历时，计算数据里各个40字符块的校验和，并把它们与ETS表里的校验和进行比较。\n 提示 要做到这一点，需要计算“滚动校验和” 。举个例子，假如C1 = B1 + B2 + \u0026hellip; B40并且C2 = B2 + B3 + \u0026hellip; B41，你就可以快速计算出C2，因为通过观察能发现C2 = C1 +B41 - B1。\n 第20章 Mnesia：Erlang数据库 1erl 2\u0026gt; mnesia:create_schema([node()]). 3ok 4\u0026gt; init:stop(). 5ok 6ls 7Mnesia.nonode@nohost 1erl -name joe 2(joe@doris.myerl.example.com) 1\u0026gt; mnesia:create_schema([node()]). 3ok 4(joe@doris.myerl.example.com) 2\u0026gt; init:stop(). 5ok 6ls 7Mnesia.joe@doris.myerl.example.com 1erl -mnesia dir \u0026#39;\u0026#34;/home/joe/some/path/to.Mnesia.company\u0026#34;\u0026#39; 21\u0026gt; mnesia:create_schema([node()]). 3ok 42\u0026gt; init:stop(). 5ok test_mnesia.erl:\n1-record(shop, {item, quantity, cost}). 2-record(cost, {name, price}). 3 4do_this_once() -\u0026gt; 5 mnesia:create_schema([node()]), 6 mnesia:start(), 7 mnesia:create_table(shop, [{attributes, record_info(fields, shop)}]), 8 mnesia:create_table(cost, [{attributes, record_info(fields, cost)}]), 9 mnesia:create_table(design, [{attributes, record_info(fields, design)}]), 10 mnesia:stop(). 1%% SQL 2%% SELECT * FROM shop; 3 4demo(select_shop) -\u0026gt; 5 do(qlc:q([X || X \u0026lt;- mnesia:table(shop)])); 11\u0026gt; test_mnesia:start(). 2ok 32\u0026gt; test_mnesia:reset_tables(). 4{atomic, ok} 53\u0026gt; test_mnesia:demo(select_shop). 6[{shop,potato,2456,1.2}, 7{shop,orange,100,3.8}, 8{shop,apple,20,2.3}, 9{shop,pear,200,3.6}, 10{shop,banana,420,4.5}] 1%% SQL 2%% SELECT item, quantity FROM shop; 3 4demo(select_some) -\u0026gt; 5 do(qlc:q([{X#shop.item, X#shop.quantity} || X \u0026lt;- mnesia:table(shop)])); 6%% [{orange,100},{pear,200},{banana,420},{potato,2456},{apple,20}] 1%% SQL 2%% SELECT shop.item FROM shop 3%% WHERE shop.quantity \u0026lt; 250; 4 5demo(reorder) -\u0026gt; 6 do(qlc:q([X#shop.item || X \u0026lt;- mnesia:table(shop), 7 X#shop.quantity \u0026lt; 250 8 ])); 9%% [orange, pear, apple] 1%% SQL 2%% SELECT shop.item FROM shop, cost 3%% WHERE shop.item = cost.name 4%% AND cost.price \u0026lt; 2 AND shop.quantity \u0026lt; 250 5 6demo(join) -\u0026gt; 7 do(qlc:q([X#shop.item || X \u0026lt;- mnesia:table(shop), 8 X#shop.quantity \u0026lt; 250, 9 Y \u0026lt;- mnesia:table(cost), 10 X#shop.item =:= Y#cost.name, 11 Y#cost.price \u0026lt; 2 12 ])). 1add_shop_item(Name, Quantity, Cost) -\u0026gt; 2 Row = #shop{item=Name, quantity=Quantity, cost=Cost}, 3 F = fun() -\u0026gt; 4 mnesia:write(Row) 5 end, 6 mnesia:transaction(F). 1\u0026gt; test_mnesia:start(). 2ok 3\u0026gt; test_mnesia:reset_tables(). 4{atomic, ok} 5\u0026gt; test_mnesia:demo(select_shop). 6\u0026gt; test_mnesia:add_shop_item(orange, 236, 2.8). 7\u0026gt; test_mnesia:demo(select_shop). 1remove_shop_item(Item) -\u0026gt; 2 Oid = {shop, Item}, 3 F = fun() -\u0026gt; 4 mnesia:delete(Oid) 5 end, 6 mnesia:transaction(F). 1test_mnesia:remove_shop_item(pear). 2test_mnesia:demo(select_shop). 3mnesia:stop(). 1do(Q) -\u0026gt; 2 F = fun() -\u0026gt; qlc:e(Q) end, 3 {atomic, Val} = mnesia:transaction(F), 4 Val. test_mnesia.erl:\n1-record(design, {id, plan}). 2 3add_plans() -\u0026gt; 4 D1 = #design{id = {joe,1}, 5 plan = {circle,10}}, 6 D2 = #design{id = fred, 7 plan = {rectangle,10,5}}, 8 D3 = #design{id = {jane,{house,23}}, 9 plan = {house, 10 [{floor,1, 11 [{doors,3}, 12 {windows,12}, 13 {rooms,5}]}, 14 {floor,2, 15 [{doors,2}, 16 {rooms,4}, 17 {windows,15}]}]}}, 18 F = fun() -\u0026gt; 19 mnesia:write(D1), 20 mnesia:write(D2), 21 mnesia:write(D3) 22 end, 23 mnesia:transaction(F). 24 25get_plan(PlanId) -\u0026gt; 26 F = fun() -\u0026gt; mnesia:read({design, PlanId}) end, 27 mnesia:transaction(F). 1test_mnesia:start(). 2test_mnesia:add_plans(). 3test_mnesia:get_plan(fred). 4test_mnesia:get_plan({jane,{house,23}}). 练习 (1) 假设你要制作一个网站，让用户可以提供优秀Erlang程序的消息。制作一个包含三个表（users、tips和abuse）的Mnesia数据库来保存网站需要的所有数据。users表应当保存用户账户数据（姓名、邮箱地址和密码等）。tips表应当保存关于实用网站的消息（比如网站URL、描述和检查日期等）。abuse表应当保存某些数据来尽量防止网站滥用（比如网站访客的IP地址和网站访问次数等数据）。 配置这个数据库，让它运行在一台机器上并各有一个内存和磁盘副本。编写一些函数来读取、写入和列出这些表。\n(2) 继续上一个练习，但要把数据库配置成在两台机器上各有内存和磁盘副本。尝试在一台机器上生成更新并让它崩溃，然后检查是否能接着访问第二台机器上的数据库。\n(3) 编写一个查询来拒绝某个消息，条件是用户在一天内提交了超过10条消息，或者最近一天从三个以上的IP地址登录。 测量查询数据库所需的时间。\n第21章 性能分析、调试与跟踪 11\u0026gt; cprof:start(). %% 启动性能分析器 24501 32\u0026gt; shout:start(). %% 运行应用程序 4\u0026lt;0.35.0\u0026gt; 53\u0026gt; cprof:pause(). %% 暂停性能分析器 64844 74\u0026gt; cprof:analyse(shout). %% 分析函数调用 11\u0026gt; cover:start(). %% 启动覆盖分析器 2{ok,\u0026lt;0.34.0\u0026gt;} 32\u0026gt;cover:compile(shout). %% 编译shout.erl来进行覆盖分析 4{ok,shout} 53\u0026gt;shout:start(). %% 运行程序 6\u0026lt;0.41.0\u0026gt; 7Playing:\u0026lt;\u0026lt;\u0026#34;title: track018\u0026#34;... 84\u0026gt; %% 让程序运行一段时间 94\u0026gt; cover:analyse_to_file(shout). %% 分析结果 10{ok, \u0026#34;shout,COVER.out\u0026#34;} %% 结果文件 1cd /home/joe/2007/vsg-1.6 2rm *.beam 3erlc +debug_info *.erl 4erl 51\u0026gt; xref:d(\u0026#39;.\u0026#39;). 1foo(1,2) -\u0026gt; 2 a; 3foo(2,3,a) -\u0026gt; 4 b. 11\u0026gt; c(bad). 2./bad.erl:3: head mismatch 1foo(A,B) -\u0026gt; 2 bar(A, dothis(X), B), 3 baz(Y,X). 11\u0026gt; c(bad). 2./bad.erl:2: variable \u0026#39;X\u0026#39; is unbound 3./bad.erl:3: variable \u0026#39;Y\u0026#39; is unbound 1unterminated string starting with \u0026#34;...\u0026#34; 1foo() -\u0026gt; 2 case bar() of 3 1 -\u0026gt; 4 X = 1, 5 Y = 2; 6 2 -\u0026gt; 7 X = 3 8 end, 9 b(X). 11\u0026gt; c(bad). 2./bad.erl:5: Warning: variable \u0026#39;Y\u0026#39; is unused 3{ok, bad} 1foo() -\u0026gt; 2 case bar() of 3 1 -\u0026gt; 4 X = 1, 5 Y = 2; 6 2 -\u0026gt; 7 X = 3 8 end, 9 b(X,Y). 11\u0026gt; c(bad). 2./bad.erl:9: variable \u0026#39;Y\u0026#39; unsafe in \u0026#39;case\u0026#39; 3{ok, bad} 1foo(X, L) -\u0026gt; 2 lists:map(fun(X) -\u0026gt; 2*X end, L). 11\u0026gt; c(bad). 2./bad.erl:1: Warning: variable \u0026#39;X\u0026#39; is unused 3./bad.erl:2: Warning: variable \u0026#39;X\u0026#39; shadowed in \u0026#39;fun\u0026#39; 4{ok, bad} 1foo(Z, L) -\u0026gt; 2 lists:map(fun(X) -\u0026gt; 2*X end, L). 1deliberate_error(A) -\u0026gt; 2 bad_function(A, 12), 3 lists:reverse(A). 4 5bad_function(A, _) -\u0026gt; 6 {ok, Bin} = file:open({abc,123}, A), 7 binary_to_list(Bin). 11\u0026gt; lib_misc:deliberate_error(\u0026#34;file.erl\u0026#34;). 2** exception error: no match of right hand side value {error,badarg} 3in function lib_misc:bad_function/2 (lib_misc.erl, line 804) 4in call from lib_misc:deliberate_error/1 (lib_misc.erl, line 800) 1loop(...) -\u0026gt; 2 receive 3 Any -\u0026gt; 4 io:format(\u0026#34;*** warning unexpected message:~p~n\u0026#34;, [Any]) 5 loop(...) 6\tend. 1-define(NYI(X),(begin 2 io:format(\u0026#34;*** NYI ~p~p~p~n\u0026#34;,[?MODULE, \u0026gt;LINE, X]), 3 exit(nyi) 4 end)). 5 6glurk(X, Y) -\u0026gt; 7 ?NYI({glurk, X, Y}). 1\u0026gt; lib_misc:glurk(1,2). 2*** NYI lib_misc 83 {glurk,1,2} 3** exited: nyi * 1dump(File, Term) -\u0026gt; 2 Out = File ++ \u0026#34;.tmp\u0026#34;, 3 io:format(\u0026#34;** dumping t0 ~s~n\u0026#34;, [Out]), 4 {ok, S} = file:open(Out, [write]), 5 io:format(S, \u0026#34;~p.~n\u0026#34;, [Term]), 6 file:close(S). elog5.config\n1%% 文本错误日志 2[ {kernel, 3 [{error_logger, 4 {file, \u0026#34;/Users/joe/error_logs/debug.log\u0026#34;}}]}]. 1erl -config elog5.config 11\u0026gt; %% 重新编译lib_misc，这样就能调试它了 21\u0026gt; c(lib_misc, [debug_info]). 3{ok, lib_misc} 42\u0026gt; im(). %% 这里会弹出一个窗口，现在可以忽略它 5\u0026lt;0.42.0\u0026gt; 63\u0026gt; ii(lib_misc). 7{module,lib_misc} 84\u0026gt; iaa([init]). 9true. 105\u0026gt; lib_misc: 11... tracer_test.erl:\n1trace_module(Mod, StartFun) -\u0026gt; 2 %% 分裂一个进程来执行跟踪 3 spawn(fun() -\u0026gt; trace_module1(Mod, StartFun) end). 4 5trace_module1(Mod, StartFun) -\u0026gt; 6 %% 下一方的意思是：跟踪Mod里的所有函数调用和返回值 7 erlang:trace_pattern({Mod, \u0026#39;_\u0026#39;,\u0026#39;_\u0026#39;}, 8 [{\u0026#39;_\u0026#39;,[],[{return_trace}]}], 9 [local]), 10 %% 分裂一个函数来执行跟踪 11 S = self(), 12 Pid = spawn(fun() -\u0026gt; do_trace(S, StartFun) end), 13 %% 设置跟踪，告诉系统开始 14 %% 跟踪进程Pid 15 erlang:trace(Pid, true, [call,procs]), 16 %% 现在让Pid启动 17 Pid ! {self(), start}, 18 trace_loop(). 19 20%% do_trace会在Parent的指示下执行StartFun() 21do_trace(Parent, StartFun) -\u0026gt; 22 receive 23 {Parent, start} -\u0026gt; 24 StartFun() 25 end. 26 27%% trace_loop负责显示函数调用和返回值 28trace_loop() -\u0026gt; 29 receive 30 {trace,_,call,X} -\u0026gt; 31 io:format(\u0026#34;Call: ~p~n\u0026#34;,[X]), 32 trace_loop(); 33 {trace,_,return_from, Call, Ret} -\u0026gt; 34 io:format(\u0026#34;Return From: ~p=\u0026gt; ~p~n\u0026#34;, [Call, Ret]), 35 trace_loop(); 36 Other -\u0026gt; 37 %% 其他信息，打印 38 io:format(\u0026#34;Other = ~p~n\u0026#34;, [Other]), 39 trace_loop() 40 end. 1test2() -\u0026gt; 2 trace_module(tracer_test, fun() -\u0026gt; fib(4) end). 3 4fib(0) -\u0026gt; 1; 5fib(1) -\u0026gt; 1; 6fib(N) -\u0026gt; fib(N-1) + fib(N-2). 11\u0026gt; c(tracer_test). 22\u0026gt; tracer_test:test2(). 1test1() -\u0026gt; 2 dbg:tracer(), 3 dbg:tpl(tracer_test, fib, \u0026#39;_\u0026#39;, 4 dbg:fun2ms(fun(_) -\u0026gt; return_trace() end)), 5 dbg:p(all,[c]), 6 tracer_test:fib(4). 练习 (1) 创建一个新目录，然后复制标准库模块dict.erl到这个目录里。给dict.erl添加一个错误，使它在某一行代码被执行时会崩溃。然后编译这个模块。\n(2) 现在我们有了一个问题模块dict，但多半还不知道它有问题，所以需要引发错误。编写一个简单的测试模块来用多种方式调用dict，看看能否让dict崩溃。\n(3) 使用覆盖分析器来检查dict里的每一行代码各被执行了多少次。给你的测试模块添加更多的测试案例，看看是否覆盖了dict里的所有代码。这么做的目的是确保dict里的每一行代码都被执行。一旦知道哪些代码行未被执行，就能轻松进行反向推导，找出测试案例里的哪些代码行能导致某一行原代码被执行。 坚持做这件事，直到程序崩溃为止。崩溃迟早会发生，因为当每一行代码都被覆盖时，就意味着错误已被触发。\n(4) 现在我们有了一个错误。假装你不知道错误出在哪里，然后使用这一章里介绍的方法来找出这个错误。 当你真的不知道错误在哪里时，这个练习会更有效。找个朋友来破坏你的某些模块，然后对这些模块运行覆盖测试来引发错误。一旦引发了错误，就使用调试技术来找出问题所在。\n第22章 OTP介绍 有点像接口的概念。\n引入OTP server.erl:\n1-module(server1). 2-export([start/2, rpc/2]). 3 4%% 开启服务器进程并注册 5start(Name, Mod) -\u0026gt; 6 register(Name, spawn(fun() -\u0026gt; loop(Name, Mod, Mod:init()) end)). 7%% 给服务器发信 8rpc(Name, Request) -\u0026gt; 9 Name ! {self(), Request}, 10 receive 11 {Name, Response} -\u0026gt; Response 12 end. 13%% 服务器核心程序 14%% 这个State参数要注意 15loop(Name, Mod, State) -\u0026gt; 16 receive 17 {From, Request} -\u0026gt; 18 {Response, State1} = Mod:handle(Request, State), 19 From ! {Name,Response}, 20 loop(Name, Mod, State1) 21 end. name_server.erl:\n1-module(name_server). 2-export([init/0, add/2, find/1, handle/2]). 3-import(server1, [rpc/2]) 4 5%% 客户端方法 6add(Name, Place) -\u0026gt; rpc(name_server, {add, Name, Place}). 7find(Name) -\u0026gt; rpc(name_server, {find, Name}). 8 9%% 回调方法 10init() -\u0026gt; dict:new(). 11handle({add, Name, Place}, Dict) -\u0026gt; {ok, dict:stire(Name,Place,Dict)}; 12handle({find, Name}, Dict) -\u0026gt; {dict:find(Name, Dict), Dict}. 11\u0026gt; server1:start(name_server, name_server). 2ture 32\u0026gt; name_server:add(joe, \u0026#34;at home\u0026#34;). 4ok 53\u0026gt; name_server:find(joe). 6{ok, \u0026#34;at home\u0026#34;} server2.erl:\n1-module(server2). 2-export([start/2, rpc/2]). 3 4start(Name, Mod) -\u0026gt; 5 register(Name, spawn(fun() -\u0026gt; loop(Name, Mod, Mod:init()) end)). 6 7rpc(Name, Request) -\u0026gt; 8 Name ! {self(), Request}, 9 receive 10 {Name, crash} -\u0026gt; exit(rpc); 11 {Name, ok, Response} -\u0026gt; Response 12 end. 13 14loop(Name, Mod, OldState) -\u0026gt; 15 receive 16 {From, Request} -\u0026gt; 17 try Mod:handle(Request, OldState) of 18 {Response, NewState} -\u0026gt; 19 From ! {Name, ok, Response}, 20 loop(Name, Mod, NewState) 21 catch 22 _:Why -\u0026gt; 23 log_the_error(Name, Request, Why), 24 %% 发送一个消息让客户端崩溃 25 From ! {Name, crash}, 26 %% 以初始状态继续循环 27 loop(Name, Mod, OldState) 28 end 29 end. 30 31log_the_error(Name, Request, Why) -\u0026gt; 32 io:format(\u0026#34;Server ~prequest ~p~n\u0026#34; 33 \u0026#34;caused exception ~p~n\u0026#34;, 34 [Name, Request, Why]). server3.erl:\n1-module(server3). 2-export([start/2, rpc/2, swap_code/2]). 3 4start(Name, Mod) -\u0026gt; 5 register(Name, spawn(fun() -\u0026gt; loop(Name, Mod, Mod:init()) end)). 6 7%% 通过传入新的Mod改变运行的代码 8swap_code(Name, Mod) -\u0026gt; rpc(Name, {swap_code, Mod}). 9 10rpc(Name, Request) -\u0026gt; 11 Name ! {self(), Request}, 12 receive 13 {Name, Response} -\u0026gt; Response 14 end. 15 16loop(Name, Mod, OldState) -\u0026gt; 17 receive 18 %% 监听到改变代码的消息 19 {From, {swap_code, NewCallBackMod}} -\u0026gt; 20 From ! {Name, ack}, 21 loop(Name, NewcallBackMod, OldState); 22 %% 正常处理 23 {From, Request} -\u0026gt; 24 {Response, NewState} = Mod:handle(Request, OldState), 25 From ! {Name, Response}, 26 loop(Name, Mod, NewState) 27 end. name_server1.erl:\n1-module(name_server1). 2-export([init/0, add/2, find/1, handle/2]). 3-import(server3, [rpc/2]). 4 5%% 客户端方法 6add(Name, Place) -\u0026gt; rpc(name_server, {add, Name, Place}). 7find(Name) -\u0026gt; rpc(name_server, {find, Name}). 8 9%% 回调方法 10init() -\u0026gt; dict:new(). 11 12handle({add, Name, Place}, Dict) -\u0026gt; {ok, dict:stire(Name,Place,Dict)}; 13handle({find, Name}, Dict) -\u0026gt; {dict:find(Name, Dict), Dict}. new_name_server.erl:\n1-module(new_name_server). 2-export([init/0, add/2, all_names/0, delete/1, find/1, handle/2]). 3-import(server3, [rpc/2]). 4 5%% 接口 6all_names() -\u0026gt; rpc(name_server, allNames). 7add(Name, Place) -\u0026gt; rpc(name_server, {add, Name, Place}). 8delete(Name) -\u0026gt; rpc(name_server, {delete, Name}). 9find(Name) -\u0026gt; rpc(name_server, {find, Name}). 10 11%% 回调方法 12init() -\u0026gt; dict:new(). 13 14handle({add, Name, Place}, Dict) -\u0026gt; {ok, dict:store(Name, Place, Dict)}; 15handle(allNames, Dict) -\u0026gt; {dict:fetch_keys(Dict), Dict}; 16handle({delete, Name}, Dict) -\u0026gt; {ok, dict:erase(Name, Dict)}; 17handle({find, Name}, Dict) -\u0026gt; {dict:find(Name, Dict), Dict}. 11\u0026gt; server3:start(name_server, name_server1). 2true 32\u0026gt; name_server1:add(joe, \u0026#34;at home\u0026#34;). 4ok 53\u0026gt; name_server1:add(helen, \u0026#34;at work\u0026#34;). 6ok 74\u0026gt; c(new_name_server). 85\u0026gt; server3:swap_code(name_server, new_name_server). 9ack 106\u0026gt; new_name_server:all_names(). server4.erl:\n1-module(server4). 2-export([start/2, rpc/2, swap_code/2]). 3 4start(Name, Mod) -\u0026gt; 5 register(Name, spawn(fun() -\u0026gt; loop(Name, MOd, MOd:init()) end)). 6 7swap_code(Name, Mod) -\u0026gt; rpc(Name, {swap_code, Mod}). 8 9rpc(Name, Request) -\u0026gt; 10 Name ! {self(), Request}, 11 receive 12 {Name, crash} -\u0026gt; exit(rpc); 13 {Name, ok, Response} -\u0026gt; Response 14 end. 15 16loop(Name, Mod, OldState) -\u0026gt; 17 receive 18 {From, {swap_code, NewCallbackMod}} -\u0026gt; 19 From ! {Name, ok, ack}, 20 loop(Name, NewCallbackMod, OldState); 21 {From, Request} -\u0026gt; 22 try Mod:handle(Request, OldState) of 23 {Response, NewState} -\u0026gt; 24 From ! {Name, ok, Response}, 25 loop(Name, Mod, NewState) 26 catch 27 _: Why -\u0026gt; 28 log_the_error(Name, Request, Why), 29 From ! {Name, crash}, 30 loop(Name, Mod, OldState) 31 end 32 end. 33 34log_the_error(Name, Request, Why) -\u0026gt; 35 io:format(\u0026#34;Server ~prequest ~p~n\u0026#34; 36 \u0026#34;caused exception ~p~n\u0026#34;, 37 [Name, Request, Why]). server5.erl:\n1-module(server5). 2-export([start/0, rpc/2]). 3 4start() -\u0026gt; spawn(fun() -\u0026gt; wait() end). 5 6wait() -\u0026gt; 7 receive 8 {become, F} -\u0026gt; F() 9 end. 10 11rpc(Pid, Q) -\u0026gt; 12 Pid ! {self(), Q}, 13 receive 14 {PId, Reply} -\u0026gt; Reply 15 end. my_fac_server.erl:\n1-module(my_fac_server). 2-export([loop/0]). 3 4loop() -\u0026gt; 5 receive 6 {From, {fac, N}} -\u0026gt; 7 From ! {self(), fac(N)} 8 loop(); 9 {become, Something} -\u0026gt; 10 Something() 11 end. 12 13fac(0) -\u0026gt; 1; 14fac(N) -\u0026gt; N * fac(N-1). 11\u0026gt; Pid = server5:start(). 22\u0026gt; c(my_fac_server). 33\u0026gt; Pid ! {become, fun my_fac_server:loop/0}. 44\u0026gt; server5:rpc(Pid, {fac,30}). gen_server回调结构 应熟记。\n  gen_server:start_link(Name, Mod, InitArgs, Opts)\n创建一个名为Name的通用服务器，回调模块是Mod，Opts则控制通用服务器的行为。在这里可以指定消息记录、函数调试和其他行为。通用服务器通过调用Mod:init(InitArgs)启动。\n在通常的操作里，只会返回{ok, State}。要了解其他参数的含义，请参考gen_server的手册页。 如果返回{ok, State}，就说明我们成功启动了服务器，它的初始状态是State。\n  gen_server:call(Name, Request)\nRequest(gen_server:call/2的第二个参数) 作为handle_call/3的第一个参数重新出现。From是发送请求的客户端进程的PID，State则是客户端的当前状态。 我们通常会返回{reply, Reply, NewState}。在这种情况下，Reply会返回客户端，成为gen_server:call的返回值。NewState则是服务器接下来的状态。 其他的返回值（{noreply, ..}和{stop, ..}）相对不太常用。no reply会让服务器继续工作，但客户端会等待一个回复，所以服务器必须把回复的任务委派给其他进程。用适当的参数调用stop会停止服务器。\n  gen_server:cast(Name, Msg)\n对应的回调方法是handle_cast。这个处理函数通常只返回{noreply, NewState}或{stop, \u0026hellip;}。前者改变服务器的状态，后者停止服务器。\n  handle_info(Info, State)\n用来处理发给服务器的自发性消息。自发性消息是一切未经显式调用gen_server:call或gen_server:cast而到达服务器的消息。\n举个例子，如果服务器连接到另一个进程并捕捉退出信号，就可能会突然收到一个预料之外的{\u0026lsquo;EXIT\u0026rsquo;, Pid,What}消息。除此之外，系统里任何知道通用服务器PID的进程都可以向它发送消息。这样的消息在服务器里表现为info值。\n它的返回值和handle_cast相同。\n  terminate(Reason, NewState)\n服务器会因为许多原因而终止。某个以handle_开头的函数也许会返回一个{stop, Reason,NewState}，服务器也可能崩溃并生成{\u0026lsquo;EXIT\u0026rsquo;, reason}。在所有这些情况下，无论它们是怎样发生的，都会调用terminate(Reason, NewState)\n  code_change(_OldVsn, State, _Extra)\n可以在服务器运行时动态更改它的状态。这个回调函数会在系统执行软件升级时由版本处理子系统调用。\n  gen_server案例 my_bank.erl:\n1-module(my_bank). 2 3-behaviour(gen_server). 4-export([start/0]). 5%% gen_server回调函数 6-export([init/1, handle_call/3, handle_cast/2, handle_info/2, terminate/2, code_change/3]). 7-compile(export_all). 8-define(SERVER, ?MODULE). 9 10start() -\u0026gt; gen_server:start_link({local, ?SERVER}, ?MODULE, [], []). 11stop() -\u0026gt;gen_server:call(?MODULE, stop). 12 13new_account(Who) -\u0026gt; gen_server:call(?MODULE, {new, Who}). 14deposit(Who, Amount) -\u0026gt; gen_server:call(?MODULE, {add, Who, Amount}). 15withdraw(Who, Amount) -\u0026gt; gen_server:call(?MODULE, {remove, Who, Amount}). 16 17 18init([]) -\u0026gt; {ok, ets:new(?MODULE, [])}. 19 20handle_call({new, Who}, _From, Tab) -\u0026gt; 21 Reply = case ets:lookup(Tab, Who) of 22 [] -\u0026gt; ets:insert(Tab, {Who, 0}), 23 {welcome, Who}; 24 [_] -\u0026gt; {Who, you_already_are_a_customer} 25 end, 26 {reply, Reply, Tab}; 27handle_call({add,Who,X}, _From, Tab) -\u0026gt; 28 Reply = case etts:lookup(Tab, Who) of 29 [] -\u0026gt; not_a_customer; 30 [{Who,Balance}] -\u0026gt; 31 NewBalance = Balance + X, 32 ets:insert(Tab, {Who, NewBalance}), 33 {thanks, Who, your_balance_is, NewBalance} 34 end, 35 {reply, Reply, Tab}; 36handle_call({remove,Who, X}, _From, Tab) -\u0026gt; 37 Reply = case ets:lookup(Tab, Who) of 38 [] -\u0026gt; not_a_customer; 39 [{Who, Balance}] when X =\u0026lt; Balance -\u0026gt; 40 NewBalance = Balance - X, 41 ets:insert(Tab , {Who, NewBalance}), 42 {thanks, Who, your_balance_is, NewBalance}; 43 [{Who, Balance}] -\u0026gt; 44 {sorry,Who,you_only_have,Balance, in_the_bank} 45 end, 46 {reply, Reply, Tab}; 47 48handle_call(stop, _From, Tab) -\u0026gt; 49 {stop, normal, stopped, Tab}. 50handle_cast(_Msg, State) -\u0026gt; {noreply, State}. 51handle_info(_Info, State) -\u0026gt; {noreply, State}. 52terminate(_Reason, _State) -\u0026gt; ok. 53code_change(_OldVsn, State, _Extra) -\u0026gt; {ok, State}. 11\u0026gt; my_bank:start(). 2{ok, \u0026lt;0.33.0\u0026gt;} 32\u0026gt; my_bank:deposit(\u0026#34;joe\u0026#34;, 10). 4not_a_customer 53\u0026gt; my_bank:new_account(\u0026#34;joe\u0026#34;). 6{welcome,\u0026#34;joe\u0026#34;} 74\u0026gt; my_bank:deposit(\u0026#34;joe\u0026#34;, 10). 8{thanks,\u0026#34;joe\u0026#34;,your_balance_is,10} 95\u0026gt; my_bank:deposit(\u0026#34;joe\u0026#34;, 30). 10{thanks,\u0026#34;joe\u0026#34;,your_balance_is,40} 116\u0026gt; my_bank:withdraw(\u0026#34;joe\u0026#34;, 15). 12{thanks,\u0026#34;joe\u0026#34;,your_balance_is,25} 137\u0026gt; my_bank:withdraw(\u0026#34;joe\u0026#34;, 45). 14{sorry,\u0026#34;joe\u0026#34;,you_only_have,25,in_the_bank} 1gen_server_template.full 2%%%------------------------------------------------------------------- 3%%% @作者XXX\u0026lt;me@hostname.local\u0026gt; 4%%% @版权所有 (C) 2013, XXX 5%%% @doc 6%%% 7%%% @end 8%%% 创建于：2013年5月26日 作者XXX \u0026lt;me@hostname.local\u0026gt; 9%%%------------------------------------------------------------------- 10-module(). 11-behaviour(gen_server). 12%% API 13-export([start_link/0]). 14%% gen_server回调函数 15-export([init/1, handle_call/3, handle_cast/2, handle_info/2, 16terminate/2, code_change/3]). 17-define(SERVER, ?MODULE). 18-record(state, {}). 19%%%=================================================================== 20%%% API 21%%%=================================================================== 22%%-------------------------------------------------------------------- 23%% @doc 24%% 启动服务器 25%% 26%% @spec start_link() -\u0026gt; {ok, Pid} | ignore | {error, Error} 27%% @end 28%%-------------------------------------------------------------------- 29start_link() -\u0026gt; 30gen_server:start_link({local, ?SERVER}, ?MODULE, [], []). 31%%%=================================================================== 32%%% gen_server回调函数 33%%%=================================================================== 34%%-------------------------------------------------------------------- 35%% @private 36%% @doc 37%% 初始化服务器 38%% 39%% @spec init(Args) -\u0026gt; {ok, State} | 40%% 41{ok, State, Timeout} | 42%% 43ignore | 44%% 45{stop, Reason} 46%% @end 47%%-------------------------------------------------------------------- 48init([]) -\u0026gt; 49{ok, #state{}}. 50%%-------------------------------------------------------------------- 51%% @private 52%% @doc 53%% 处理调用消息 54%% 55%% @spec handle_call(Request, From, State) -\u0026gt; 56%% 57{reply, Reply, State} | 58%% 59{reply, Reply, State, Timeout} | 60%% 61{noreply, State} | 62%% 63{noreply, State, Timeout} | 64%% 65{stop, Reason, Reply, State} | 66%% 67{stop, Reason, State} 68%% @end 69%%-------------------------------------------------------------------- 70handle_call(_Request, _From, State) -\u0026gt; 71Reply = ok, 72{reply, Reply, State}. 73%%-------------------------------------------------------------------- 74%% @private 75%% @doc 76%% 处理播发消息 77%% 78%% @spec handle_cast(Msg, State) -\u0026gt; {noreply, State} | 79%% 80{noreply, State, Timeout} | 81%% 82{stop, Reason, State} 83%% @end 84%%-------------------------------------------------------------------- 85handle_cast(_Msg, State) -\u0026gt; 86{noreply, State}. 87%%-------------------------------------------------------------------- 88%% @private 89%% @doc 90%% 处理所有非调用/播发的消息 91%% 92%% @spec handle_info(Info, State) -\u0026gt; {noreply, State} | 93%% 94{noreply, State, Timeout} | 95%% 96{stop, Reason, State} 97%% @end 98%%-------------------------------------------------------------------- 99handle_info(_Info, State) -\u0026gt; 100{noreply, State}. 101%%-------------------------------------------------------------------- 102%% @private 103%% @doc 104%% 这个函数是在某个gen_server即将终止时调用的。它应当是Module:init/1的逆操作，并进行必要的清理。 105%% 当它返回时，gen_server终止并生成原因Reason。它的返回值会被忽略 106%% 107%% @spec terminate(Reason, State) -\u0026gt; void() 108%% @end 109%%-------------------------------------------------------------------- 110terminate(_Reason, _State) -\u0026gt; 111ok. 112%%-------------------------------------------------------------------- 113%% @private 114%% @doc 115%% 在代码更改时转换进程状态 116%% 117%% @spec code_change(OldVsn, State, Extra) -\u0026gt; {ok, NewState} 118%% @end 119%%-------------------------------------------------------------------- 120code_change(_OldVsn, State, _Extra) -\u0026gt; 121{ok, State}. 122%%%=================================================================== 123%%% 内部函数 124%%%=================================================================== 练手小项目 要求：\n建立两个node，从一个node上向另一个node请求一个字符串。做两个gen server分别运行在两个节点上，互相能发消息。将两个node上的chat的pid拿到。在chat内部直接发cast消息。不用call。要让两个chat直接通信。然后发信的时候携带Pid让对方可以回信。\n问题：\n  节点之间没有互连，setcookie不是互联而是能够互联。使用net_adm:ping/1连接节点。\n  需要让gen_server本身的进程使用cast方法，如何让进程本身发消息而不使用rpc或者其他进程给他消息？\n包装一下就行，让另一个进程发送消息触发handle，在handle里面使用cast。\n  如何获取Pid？注意是网络的Pid不是本地的Pid。\n  初步实现：\n1%%%------------------------------------------------------------------- 2%%% @author bnaod1 3%%% @copyright (C) 2024, 4%%% @doc 5%%% 6%%% @end 7%%% Created : 2024 12月26. 14:47 8%%%------------------------------------------------------------------- 9-module(chat). 10-author(\u0026#34;bnaod1\u0026#34;). 11 12-behaviour(gen_server). 13%% API 14-export([start/1]). 15-export([init/1, handle_call/3, handle_cast/2, handle_info/2, terminate/2, code_change/3]). 16 17-compile(export_all). 18%%-define(SERVER, server). 19 20start(Sname) -\u0026gt; gen_server:start_link({global, Sname}, ?MODULE, [], []). 21stop(Sname) -\u0026gt; gen_server:call({global, Sname}, stop). 22 23ask_for(Sname, Msg) -{}\u0026gt; gen_server:call({global, Sname}, {quest, Msg}). 24 25init([]) -\u0026gt; {ok, already_to_run}. 26 27handle_call({quest, Msg}, From, Tab) -\u0026gt; 28 io:format(\u0026#34;receive msg from ~p: ~n~p~n\u0026#34;, [From, Msg]), 29 Reply = \u0026#34;got_it\u0026#34;, 30 {reply, Reply, Tab}; 31handle_call(stop, _From, Tab) -\u0026gt; 32 {stop, normal, stopped, Tab}. 33 34handle_cast(_Msg, State) -\u0026gt; {noreply, State}. 35handle_info(_Info, State) -\u0026gt; {noreply, State}. 36terminate(_Reason, _State) -\u0026gt; ok. 37code_change(_OldVsn, State, _Extra) -\u0026gt; {ok, State}. 改进：\n1%%%------------------------------------------------------------------- 2%%% @author bnaod1 3%%% @copyright (C) 2024, 4%%% @doc 5%%% 6%%% @end 7%%% Created : 2024 12月26. 14:47 8%%%------------------------------------------------------------------- 9-module(chat). 10-author(\u0026#34;赵枭奇\u0026#34;). 11 12-behaviour(gen_server). 13%% API 14-export([start/1]). 15-export([init/1, handle_call/3, handle_cast/2, handle_info/2, terminate/2, code_change/3]). 16 17-compile(export_all). 18%%-define(SERVER, server). 19 20-record(state, {conn_pid}). 21 22%% 创建genserver 23start(SName) -\u0026gt; gen_server:start_link({global, SName}, ?MODULE, [], []). 24 25%% 交流前先握手获取Pid 26handshake(FromName, ToName) -\u0026gt; 27 io:format(\u0026#34;prepare handshake~n\u0026#34;), 28 gen_server:call({global, FromName}, {quest, ToName}). 29 30%% 停止genserver 31stop(SName) -\u0026gt; gen_server:cast({global, SName}, stop). 32 33%% 调试 34is_alive(SName) -\u0026gt; gen_server:call({global, SName}, is_alive). 35 36%% 正式交流 37ask(SName, Msg) -\u0026gt; gen_server:cast({global, SName}, {ask, Msg}). 38 39%% 初始化 40init([]) -\u0026gt; {ok, #state{conn_pid = null}}. 41 42handle_call({quest, SName}, _From, State) -\u0026gt; 43 gen_server:cast({global, SName}, {handshake, self()}), 44 {reply, starting_handshake, State}; 45handle_call(is_alive, From, #state{conn_pid = Pid} = State) -\u0026gt; 46 Reply = {alive, connected_process_is_, Pid}, 47 {reply, Reply, State}. 48 49handle_cast({handshake, Pid}, State) -\u0026gt; 50 io:format(\u0026#34;reply handshake~n\u0026#34;), 51 gen_server:cast(Pid, {ack, self()}), 52 {noreply, #state{conn_pid = Pid}}; 53handle_cast({ack, Pid}, State) -\u0026gt; 54 io:format(\u0026#34;handshake complete~n\u0026#34;), 55 {noreply, #state{conn_pid = Pid}}; 56handle_cast({ask, Msg}, #state{conn_pid = Pid} = State)-\u0026gt; 57 io:format(\u0026#34;send msg from ~pto ~p~n\u0026#34;, [self(), Pid]), 58 gen_server:cast(Pid, {communicate, Msg}), 59 {noreply, State}; 60handle_cast({communicate, Msg}, #state{conn_pid = Pid} = State) -\u0026gt; 61 io:format(\u0026#34;get msg from ~p: ~p~n\u0026#34;, [Pid, Msg]), 62 {noreply, State}; 63handle_cast(stop, State) -\u0026gt; 64 {stop, \u0026#34;ask for stop\u0026#34;, State}. 65 66 67handle_info(_Info, State) -\u0026gt; {noreply, State}. 68terminate(_Reason, _State) -\u0026gt; ok. 69code_change(_OldVsn, State, _Extra) -\u0026gt; {ok, State}. 70 练习 在下面这些练习里，我们将用job_centre模块制作一个服务器，它用gen_server实现一种任务管理服务。任务中心（job center）持有一个必须完成的任务队列，这些任务会被编号，任何人都能向队列添加任务。工人可以从队列请求任务，并告诉任务中心已经执行了某项任务。任务是由fun表示的，要执行任务F，工人必须执行F()函数。\n(1) 实现任务中心的基本功能，它的接口如下。\n  job_centre:start_link() -\u0026gt; true\n启动任务中心服务器。\n  job_centre:add_job(F) -\u0026gt; JobNumber\n添加任务F到任务队列，然后返回一个整数任务编号。\n  job_centre:work_wanted() -\u0026gt; {JobNumber,F} | no\n请求任务。如果工人想要一个任务，就调用job_centre:work_wanted()。如果队列里有任务，就会返回一个{JobNumber, F}元组。工人执行F()来完成任务。如果队列里没有任务，则会返回no。请确保同一项任务每次只分配给一个工人，并确保系统是公平的，意思是任务按照请求的顺序进行分配。\n  job_centre:job_done(JobNumber)\n发出任务完成的信号。如果工人完成了某一项任务，就必须调用job_centre:job_done (JobNumber)。\n  (2) 添加一个名为job_centre:statistics()的统计函数，让它报告队列内、进行中和已完成任务的状态。\n(3) 添加监视工人进程的代码。如果某个工人进程挂了，请确保它所执行的任务被返回到等待完成的任务池里。\n(4) 检查是否有懒惰的工人，也就是接受工作但不按时完成的进程。把任务请求函数修改为返回{JobNumber, JobTime, F}，其中JobTime是工人必须完成任务的秒数。如果工人在JobTime- 1时还未完成任务，服务器就应当向其发送一个hurry_up（快点儿）消息，而在JobTime + 1时应该用调用exit(Pid, youre_fired)（你被解雇了）来杀掉这个工人进程。\n(5) 可选练习：实现一个工会服务器来监督工人的权利，防止他们没收到警告就被解雇。提示：使用进程跟踪基本函数来实现它。\n第23章 用OTP构建系统 这一章也是非常重要。\n通用事件处理程序 event_handler.erl:\n1-module(event_handler). 2-export([make/1, add_handler/2, event/2]). 3 4%% 制作一个名为Name的新事件处理器 5%% 处理函数是no_op，代表部队事件做任何处理 6make(Name) -\u0026gt; 7 register(Name, spawn(fun() -\u0026gt; my_handler(fun no_op/1) end)). 8 9add_handler(Name, Fun) -\u0026gt; Name ! {add, Fun}. 10 11%%生成一个事件 12event(Name, X) -\u0026gt; Name ! {event, X}. 13 14my_handler(Fun) -\u0026gt; 15 receive 16 {add, Fun1} -\u0026gt; 17 my_handler(Fun1); 18 {event, Any} -\u0026gt; 19 (catch Fun(Any)), 20 my_handler(Fun) 21 end. 22 23no_op(_) -\u0026gt; void. motor_controller.erl: 定义错误处理函数\n1-module(motor_controller). 2-export([add_event_handler/0]). 3 4add_event_handler() -\u0026gt; 5 event_handler:add_handler(errors, fun controller/1). 6controller(too_hot) -\u0026gt; 7 io:format(\u0026#34;Turn off the motor~n\u0026#34;); 8controller(X) -\u0026gt; 9 io:format(\u0026#34;~wignored event: ~p~n\u0026#34;, [?MODULE, X]). 测试：\n11\u0026gt; event_handler:make(errors). 2true 32\u0026gt; event_handler:event(errors, hi). 4{event,hi} 53\u0026gt; c(motor_controller). 6{ok, motor_controller} 74\u0026gt; motor_controller:add_event_handler(). 8{add,#Fun...} 95\u0026gt; event_handler:event(errors, cool). 10motor_controller ignored event: cool 11{event, cool} 126\u0026gt; event_handler:event(errors, too_hot). 13Turn off the motor 14{event, too_hot} 错误记录器 OTP系统自带一个可定制的错误记录器。\n错误记录器会生成多种报告类型。\n 监控器报告 这些报告会在OTP监控器启动或停止被监控进程时生成（参见23.5节）。 进度报告 这些报告会在OTP监控器启动或停止时生成。 崩溃报告 如果某个被OTP行为启动的进程因为normal或shutdown以外的原因终止，这些报告就会 生成。  这三种报告会自动生成，程序员无须做任何事。 另外，还可以显式调用error_logger模块里的方法来生成三种类型的日志报告。这让我们能够记录错误、警告和信息消息。这三个名词没什么语义含义，只是一些标签，程序员用它们来提示错误日志条目的性质。\nAPI   -spec error_logger:error_msg(String) -\u0026gt; ok\n向错误记录器发送一个错误消息。\n  -spec error_logger:error_msg(Format, Data) -\u0026gt; ok\n向错误记录器发送一个错误消息。它的参数和io:format(Format, Data)相同。\n  -spec error_logger:error_report(Report) -\u0026gt; ok\n向错误记录器发送一个标准错误报告。\n-type Report = [{Tag, Data} | term() | string() ].\n-type Tag = term(). -type Data = term().\n  配置  标准错误记录器  它会创建一个适合进行程序开发的环境，只提供一种简单的错误记录形式。（不带启动参数的erl命令就等于erl -boot start_clean。）：\n1erl -boot start_clean 它会创建一个适合运行生产系统的环境。系统架构支持库（System Architecture SupportLibraries，简称SASL）将负责错误记录和过载保护等工作。\n1erl -boot start_sasl 日志文件的配置最好通过配置文件实现，因为没人能记住记录器的全部参数。\n无配置SASL  1erl -boot start_sasl 配置错误记录器  下面的配置文件启动系统，就只会得到错误报告，不会有进度和其他报告。所有这些错误报告只会出现在shell里。\nelog1.config:\n1%% 无tty 2[{sasl, [ 3 {sasl_error_logger, false} 4 ]}]. 1erl -boot start_sasl -config elog1 下面的配置在shell里列出错误报告，所有的进度报告则会保存在一个文件里。\nelog2.config:\n1%% 单文本文件，最小化tty 2 3[{sasl, [ 4 %% 所有报告都写入这个文件 5 {sasl_error_logger, {file, \u0026#34;/Users/joe/error_logs/THELOG\u0026#34;}} 6 ]}]. 下面的配置既能提供shell输出，又能把写入shell的所有信息复制到一个滚动日志文件里。\nelog3.config:\n1[{sasl, [ 2 {sasl_error_logger, false}, 3 %% 定义滚动日志的参数 4 %% 日志文件目录 5 {error_logger_mf_dir, \u0026#34;/Users/joe/error_logs\u0026#34;}, 6 %% 每个文件的字节数 10MB 7 {error_logger_mf_maxbytes, 10485760}, 8 %% 日志文件的最大数量 9 {error_logger_mf_maxfiles, 10} 10 ]}]. 在生产环境里，我们真正感兴趣的只有错误，而非进度或信息报告，所以只让错误记录器报告错误。\nelog4.config:\n1[{sasl, [ 2 %% 最小化shell错误记录 3 {sasl_error_logger, false}, 4 %% 只报告错误 5 {errlog_type, error}, 6 %% 定义滚动日志的参数 7 %% 日志文件目录 8 {error_logger_mf_dir,\u0026#34;/User/joe/error_lgos\u0026#34;}, 9 %% 每个日志文件的字节数 10 {error_logger_mf_maxbytes,10485760}, 11 %% 日志文件的最大数量 12 {error_logger_mf_maxfiles, 10} 13 ]}]. 分析错误 阅读错误日志是rb模块的责任\n1erl -boot start_sasl -config elog3 2%% 首先必须用正确的配置文件启动Erlang，这样才能定位错误日志 3rb:help(). 4 5%% 启动报告浏览器 6rb:start(). 7 8%% 告诉它要读取多少日志条目 9rb:start([{max,20}]). 10 11%% 列出日志里的条目 12rb:list(). 13 14%% 检查第8条 15rb:show(8). 要分离出某个错误，可以使用rb:grep(RegExp)这样的命令，它会找出所有匹配正则表达式RegExp的报告。\nrb模块里有一些函数能选择特定类型的错误或把它们提取到文件里。因此，分析错误日志的过程可以实现完全自动化。\n警报管理 这个警报处理器是OTPgen_event行为的回调模块\nmy_alarm_handler.erl\n1-module(my_alarm_handler). 2-behaviour(gen_event). 3 4-export([init/1, code_change/3, handle_event/2, handle_call/2, handle_info/2, terminate/2]). 5 6%% init必须返回{ok, State} 7init(Args) -\u0026gt; 8 io:format(\u0026#34;*** my_alarm_handler init:~p~n\u0026#34;, [Args]), 9 {ok, 0}. 10 11handle_event({set_alarm, tooHot}, N) -\u0026gt; 12 error_logger:error_msg(\u0026#34;*** Tell the Engineer to turn on the fan~n\u0026#34;), 13 {ok, N}; 14handle_event({clear_alarm, tooHot}, N) -\u0026gt; 15 error_logger:error_msg(\u0026#34;*** Danger over. Turn off the fan~n\u0026#34;), 16 {ok, N}; 17handle_event(Event, N) -\u0026gt; 18 io:format(\u0026#34;*** unmatched event:~p~n\u0026#34;, [Event]), 19 {ok, N}. 20 21handle_call(_Request, N) -\u0026gt; Reply = N, {ok, Reply, N}. 22handle_info(_Info, N) -\u0026gt; {ok, N}. 23 24terminate(_Reason, _N) -\u0026gt; ok. 25code_change(_OldVsn, State, _Extra) -\u0026gt; {ok, State}. 这段代码非常像之前在22.3节里看到的 gen_server 回调代码。其中值得注意的方法是handle_event(Event, State) ，它应当返回 {ok, NewState} 。 Event 是一个 {EventType,Event-Arg}形式的元组，其中EventType是set_event或clear_event，而EventArg是一个用户提供的参数。\n1erl -boot start_sasl -config elog3 2\u0026gt; alarm_handler:set_alarm(tooHot). 3ok 4=INFO REPORT===== 5alarm:handler: {set,tooHot} 6\u0026gt; gen_event:swap_handler(alarm_handler, {alarm_handler, swap}, 7\t{my_alarm_handler, xyz}). 8\u0026gt; alarm_handler:set_alarm(tooHot). 9ok 10=ERROR ERPORT ==== 11*** Tell the Engineet to turn on the fan 12\u0026gt; alarm_handler:clear_alarm(tooHot). 13ok 14=ERROR ERPORT ==== 15*** Danger over. Turn off the fan 应用程序服务器 两个gen_server服务器，不抄了。\n监控树 监控树是一种由进程组成的树形结构。树的上级进程（监控器）监视着下级进程（工作器）， 如果下级进程挂了就会重启它们。监控树有两种：\n 一对一监控树 在一对一监控里，如果某个工作器崩溃了，就会被监控器重启。 一对多监控树 在一对多监控里，如果任何一个工作器崩溃了，所有工作进程都会被终止（通过调用相 应回调模块里的terminate/2函数）然后重启。  监控器是用OTP supervisor行为创建的。这个行为用一个回调模块作为参数，里面指定了监 控策略以及如何启动监控树里的各个工作进程。监控树通过以下形式的函数指定：\n1init(...) -\u0026gt; 2 {ok, { 3 {RestartStrategy, MaxRestarts, Time}, 4 [Worker1, Worker2, ...] 5 }}.  RestartStrategy是原子one_for_one或one_for_all MaxRestarts和Time则指定“重启频率”。如果一个监控器在Time秒内执行了超过MaxRestarts次重启，那么这个监控器就会终止所有工作进程然后退出。这是为了防止出现一种情形，即某个进程崩溃、被重启，然后又因为相同原因崩溃而形成的无限循环。 Worker1和Worker2这些是描述如何启动各个工作进程的元组  示例：\nsellaprime_supervisor.erl:\n1-module(sellaprime_supervisor). 2-behaviour(supervisor). 3-export([start/0, start_in_shell_for_testing/0, start_link/1, init/1]). 4 5start() -\u0026gt; 6 spawn(fun() -\u0026gt; 7 supervisor:start_link({local,?MODULE}, ?MODULE, _Arg = []) 8 end). 9start_in_shell_for_testing() -\u0026gt; 10 {ok, Pid} = supervisor:start_link({local,?MODULE}, ?MODULE, _Arg = []), 11 unlink(Pid). 12start_link(Args) -\u0026gt; 13 supervisor:start_link({local,?MODULE}, ?MODULE, Args). 14 15init([]) -\u0026gt; 16 gen_event:swap_handler(alarm_handler, 17 {alarm_handler, swap}, 18 {my_alarm_handler, xyz}), 19 {ok, {{one_for_one, 3, 10}, 20 [{tag1, 21 {area_server, start_link, []}, 22 permanet, 23 10000, 24 worker, 25 [area_server]}, 26 {tag2, 27 {prime_server, start_link, []}, 28 permanet, 29 10000, 30 worker, 31 [prime_server]} 32 ]}}.   init/1返回的数据结构定义了一种监控策略。\n  Worker中的参数的意义\n1{Tag, {Mod, Func, ArgList}, 2 Restart, 3 Shutdown, 4 Type, 5 [Mod1]} Tag：这是一个原子类型的标签，将来可以用它指代工作进程（如果有必要的话）。\n{Mod, Func, ArgList}：定义了监控器用于启动工作器的函数，将被用作apply(Mod, Fun, ArgList)的参数。\nRestart = permanent | transient | temporary：permanent（永久）进程总是会被重启transient（过渡）进程只有在以非正常退出值终止时才会被重启。temporary（临时）进程不会被重启。\nShutdown：这是关闭时间，也就是工作器终止过程允许耗费的最长时间。如果超过这个时间，工作进程就会被杀掉。\nType = worker | supervisor：这是被监控进程的类型。可以用监控进程代替工作进程来构建一个由监控器组成的树。\n[Mod1]：如果子进程是监控器或者gen_server行为的回调模块，就在这里指定回调模块名。\n  启动系统 后面才是真正的启动。\n1erl -boot start_sasl -config elog3 21\u0026gt; sellaprime_supervisor:start_in_shell_for_testing(). 32\u0026gt; area_server:area({square,10}). 43\u0026gt; area_server:area({rectangle,10,20}). 54\u0026gt; area_server:area({square,25}). 65\u0026gt; prime_server:new_prime(20). 1rb:start([{max,20}]). 2rb:list(). 3rb:show(5). 应用程序 最后的工作 编写一个扩展名为.app的文件，它包含关于这个应用程序的信息。\n这是应用程序资源文件，用于\u0026rsquo;base\u0026rsquo;应用程序。\nsellaprime.app:\n1{application, sellaprime, 2 [{description, \u0026#34;The Prime Number Shop\u0026#34;}, 3 {vsn, \u0026#34;1.0\u0026#34;}, 4 {modules, [sellaprime_app, sellaprime_supervisor, area_server, prime_server, lib_lin, lib_primes, my_alarm_handler]}, 5 {registered, [area_server, prime_server, sellaprime_super]}, 6 {applications, [kernel, stdlib]}, 7 {mod, {sellaprime_app, []}}, 8 {start_phases, []} 9 ]}. 现在必须编写一个回调模块，它的名称与前面文件里的mod文件名相同\nsellaprime_app.erl\n1-module(sellaprime_app). 2-behaviour(application). 3-export([start/2, stop/1]). 4start(_Type, StartArgs) -\u0026gt; 5 sellaprime_supervisor:start_link(StartArgs). 6stop(_State) -\u0026gt; 7 ok. 它必须导出函数start/2和stop/1。做完这一切之后，就可以在shell里启动和停止应用程序了。\n启动！:\n1erl -boot start_sasl -config elog3 21\u0026gt; application:loaded_applications(). 32\u0026gt; application:load(sellaprime). 43\u0026gt; application:loaded_applications(). 54\u0026gt; application:start(sellaprime). 65\u0026gt; application:stop(sellaprime). 76\u0026gt; application:unload(sellaprime). 现在它就是一个功能完备的OTP应用程序了。我们在第2行里载入了应用程序，这么做会载入全部代码，但不会启动应用程序。第4行启动了应用程序，第5行则停止了它。请注意，启动和停止应用程序时我们能看到打印输出，因为它调用了面积服务器和质数服务器里相应的回调函数。在第6行卸载了应用程序，这样应用程序里的所有模块代码都被移除了。用OTP构建复杂的系统时，会把它们打包成应用程序。这样我们就能统一启动、停止和管理它们。\n调用路径    文件 内容     area_server.erl 面积服务器（gen_server回调模块）   prime_server.erl 质数服务器（gen_server回调模块）   sellaprime_supervisor.erl 监控器回调模块   sellaprime_app.erl 应用程序回调模块   my_alam_handler.erl 用于gen_event的事件回调模块   sellaprime.app 应用程序规范   elog4.config 错误记录器配置文件    (1) 用下列命令启动系统：\n1erl -boot -start_sasl -config elog4.config 21\u0026gt; application:start(sellaprime). sellaprime.app文件必须位于Erlang的启动根目录或它的子目录里。 应用程序控制器随后在sellaprime.app里寻找一个{mod, \u0026hellip;}声明。它包含应用程序控制器的名称，在这个案例里是模块sellaprime_app。\n(2) 回调方法sellaprime_app:start/2被调用。\n(3) sellaprime_app:start/2 调 用 sellaprime_supervisor:start_link/2 ， 启 动sellaprime监控器。\n(4) 监控器回调函数sellaprime_supervisor:init/1被调用，它会安装一个错误处理器，然后返回一个监控规范。这个监控规范说明了如何启动面积服务器和质数服务器。\n(5) sellaprime监控器启动面积服务器和质数服务器，两者都是gen_server的回调模块。停止这一切很容易，只需要调用application:stop(sellaprime)或init:stop()。\n应用程序监视器 应用程序监视器是一个用来查看应用程序的GUI。appmon:start()命令会启动应用程序查看器。\n练习 (1) 制作一个名为prime_tester_server的gen_server，让它测试给定的数字是否是质数。你可以使用lib_primes.erl里的is_prime/2函数来处理（或者自己实现一个更好的质数测试函数）。把它添加sellaprime_supervisor.erl的监控树里。\n(2) 制作由10个质数测试服务器组成的进程池。制作一个队列服务器来把请求加入队列，直到其中一个质数测试服务器处于空闲状态为止。当质数测试服务器空闲时，向它发送一个请求来测试某个数字是否是质数。\n(3) 修改质数测试服务器的代码，让它们各自维护一个请求队列，然后移除队列服务器。编写一个负载均衡器来记录各个质数测试服务器中正在进行的任务和待完成请求。测试新质数的请求现在应该发送到负载均衡器。安排负载均衡器把请求发送给负载最小的服务器。\n(4) 实现一种监控层级体系，使任何质数测试服务器崩溃后都能被重启。如果负载均衡器崩溃了，就让所有质数测试服务器都崩溃，然后全体重启。\n(5) 使全体重启所需的数据在两台机器上同步复制。\n(6) 实现一种重启策略，使整台机器崩溃后也能全体重启。\n第24章 编程术语 counter.erl:\n1-module(counter). 2-export([bump/2, read/1]). 3 4bump(N, {counter, K}) -\u0026gt; {counter, N + K}. 5read({counter, N}) -\u0026gt; N. 11\u0026gt; c(counter). 2{ok, counter} 3 42\u0026gt; C = {counter, 2}. 5{counter, 2} 6 73\u0026gt; C:read(). 82 9 104\u0026gt; C1 = C:bump(3). 11{counter, 5} 12 135\u0026gt; C1:read(). 145 对元组C和C1的调用代码来说，模块名counter和状态变量都是隐藏的。\nadapter_db1.erl:\n1-module(adapter_db1). 2-export([new/1, store/3, lookup/2]). 3 4new(dict) -\u0026gt; 5 {?MODULE, dict, dict:new()}; 6new(lists) -\u0026gt; 7 {\u0026gt;MODULE, list, []}. 8 9store(Key, Val, {_, dict, D}) -\u0026gt; 10 D1 = dict:store(Key, Val, D), 11 {?MODULE, dict, D1}; 12store(Key, Val, {_, list, L}) -\u0026gt; 13 L1 = lists:keystore(Key, 1, L, {Key, Val}), 14 {?MODULE, list, L1}. 15 16lookup(Key, {_, dict, D}) -\u0026gt; 17 dict:find(Key, D); 18lookup(Key, {_, list, L}) -\u0026gt; 19 case lists:keysearch(Key, 1, L) of 20 {value, {Key, Val}} -\u0026gt; {ok, Val}; 21 false -\u0026gt; error 22 end. adapter_db1_test.erl:\n1-module(adapter_db1_test). 2-export([test/0]). 3-import(adapter_db1, [new/1, store/2, lookup/1]). 4 5test() -\u0026gt; 6 M0 = new(dict), 7 M1 = M0:store(key1, val1), 8 M2 = M1:store(key2, val2), 9 {ok, val1} = M2:lookup(key1), 10 {ok, val2} = M2:lookup(key2), 11 error = M2:lookup(nokey), 12 13 N0 = new(lists), 14 N1 = N0:store(Key1, val1), 15 N2 = N1:store(key2, val2), 16 {ok, val1} = N2:lookup(key1), 17 {ok, val2} = N2:lookup(key2), 18 error = N2:lookup(nokey), 19 ok. 1dict:fetch(Key, Dict) = Val | EXIT 2dict:search(Key, Dict) = {found, Val} | not_found. 3dict:is_key(Key, Dict) = Boolean 练习 (1) 扩展adapter_db1里的适配器，使调用adapter_db1:new(persistent)能创建一个持久性数据存储的元组模块。\n(2) 编写一种键值存储，让它把较小的值放入内存，把较大的值放入磁盘。制作一个适配器模块来实现它，并让这个模块与本章前面的适配器具有相同的接口。\n(3) 编写一种键值存储，让它把各个键值对分为易失性存储和非易失性存储。调用put(Key,memory, Val)会把一个Key, Val对放入内存，put(Key, disk, Val)则会把数据存入磁盘。用一对进程来做这件事，一个用于易失性存储，另一个用于非易失性存储。重用本章前面的代码。\n第25章 第三方程序 rebar rebar涉及的东西只是23章的东西的一部分自动化。\n创建应用 1rebar create-app appid=bertie 1-module(bertie). 2-export([start/0]). 3 4start() -\u0026gt; io:format(\u0026#34;Hello my name is Bertie~n\u0026#34;). 1rebar compile 整合外部程序与我们的代码 bertie/bertie.erl:\n1-module(bertie). 2-export([start/0]). 3 4start() -\u0026gt; 5 Handle = bitcask:open(\u0026#34;bertie_database\u0026#34;, [read_write]), 6 N = fetch(Handle), 7 store(Handle, N+1), 8 io:format(\u0026#34;Bertie has benn run ~ptimes~n\u0026#34;, [N]), 9 bitcask:close(Handle), 10 init:stop(). 11 12store(Handle, N) -\u0026gt; 13 bitcask:put(Handle, \u0026lt;\u0026lt;\u0026#34;bertie_executions\u0026#34;\u0026gt;\u0026gt;, term_to_binary(N)). 14fetch(Handle) -\u0026gt; 15 case bitcask:get(Handle, \u0026lt;\u0026lt;\u0026#34;bertie_executions\u0026#34;\u0026gt;\u0026gt;) of 16 not_found -\u0026gt; 1; 17 {ok, Bin} -\u0026gt; binary_to_term(Bin) 18 end. bertie/rebar.config:\n1{deps, [ 2\t{bitcask, \u0026#34;.*\u0026#34;, {git, \u0026#34;git://github.com/basho/bitcask.git\u0026#34;, \u0026#34;master\u0026#34;}} 3]}. bertie/Makefile:\n1all: 2\ttest -d deps || rebar get-deps 3\trebar compile 4\t@erl -noshell -pa \u0026#39;./deps/bitcask/ebin\u0026#39; -pa \u0026#39;./ebin\u0026#39; -s bertie start rebar get-deps命令从GitHub获取bitcask并把它保存在名为deps的子目录里。bitcask自身需要一个名为meck的程序用于测试，这就是所谓的递归依赖。rebar会递归获取bitcask所需的各个依赖项，并把它们保存在deps子目录里。\nmakefile给命令行添加了一个-pa \u0026lsquo;deps/bitcask/ebin\u0026rsquo;标识，这样当程序启动时，bertie就能自动载入bitcask的代码。\n生成依赖项本地副本 ~joe/nobackup/erlang_imports/rebar.config:\n1{deps, [ 2\t{cowboy, \u0026#34;.*\u0026#34;, {git, \u0026#34;git://..\u0026#34;}}, 3\t{ranch, \u0026#34;.*\u0026#34;, {git, \u0026#34;git://...\u0026#34;}}, 4\t{bitcask, \u0026#34;.*\u0026#34;, {git, \u0026#34;git://...\u0026#34;}} 5]}. 1rebar get-deps 1Home = os:getenv(\u0026#34;HOME\u0026#34;). 2Dir = Home ++ \u0026#34;/nobackup/erlang_imports/deps\u0026#34;, 3 {ok, L} = file:list_dir(Dir). 4lists:foreach(fun(I) -\u0026gt; 5 Path = Dir ++ \u0026#34;/\u0026#34; ++ I ++ \u0026#34;/ebin\u0026#34;, 6 code:add_path(Path) 7 end, L). 练习 (1) 注册一个GitHub账号，然后按照本章开头的步骤来创建你自己的项目。\n(2) 第二个cowboy示例可能是不安全的。用户可以通过CGI调用接口请求执行任意的Erlang模块。重新设计这个接口，让它只允许调用一组事先定义的模块。\n(3) 对cowboy示例做一次安全审计，因为它的代码里有许多安全问题。例如被请求文件的值未经检查，这样用户就能访问Web服务器目录结构以外的文件。找到并修复这些安全问题。\n(4) 任何主机都能连接到cowboy服务器。修改它的代码，让它只允许来自已知IP地址的主机连接。把这些主机保存到某种持久性数据库里，比如Mnesia或bitcask。记录某个特定主机进行了多少次连接。制作一个主机黑名单，登记那些在给定时间段内连接过于频繁的主机。\n(5) 修改Web服务器，让它允许对通过CGI接口调用的模块进行动态重编译。在我们的示例里，echo.erl模块必须先编译才能调用。当某个模块通过CGI接口被调用时，读取其beam文件的时间戳并与对应.erl的时间戳进行比较，如有必要就重新编译和载入Erlang代码。\n(6) rebar是把Erlang程序作为“独立”二进制文件分发的优秀范例。请把rebar的可执行文件复制到一个空白目录并重命名为rebar.zip（rebar其实是一个zip文件），然后解压缩并检查里面的内容。用cowboy示例代码制作你自己的自执行二进制文件。\n第26章 多核CPU编程 多核高效运行 使用大量进程 避免副作用 通过在ets:new里使用某个选项，就能创建出一个public类型的表。如果你还记得的话，它的效果如下： 创建一个公共表，任何知道此表标识符的进程都能读取和写入这个表。这么做可能很危险，只有在以下条件得到满足时才是安全的：\n 每次只能有一个进程写入表，其他进程可以读取表； 写入ETS表的进程是正确的，不会把错误数据写入表。  系统一般不能满足这些条件，而是要靠程序逻辑。\n注意1：ETS表的每一种操作都是原子式的，但一系列ETS操作无法作为一个原子单元执行。虽然不会损坏ETS表里的数据，但如果多个进程试图同时更新一个共享表而又没有协调好，就可能出现逻辑上不一致的表。 注意2：ETS表类型protected的安全性要高得多。只有一个进程（即所有者）能写入表，但可以有多个进程读取这个表。这一点由系统保证。但是请记住，即使只有一个进程能写入ETS表，如果它损坏了表里的数据，也会影响到所有读取这个表的进程。 如果你使用的ETS表类型是private，那么你的程序就是安全的。上述结论也适用于DETS。可以创建能被多个不同进程写入的共享式DETS表，但不鼓励这种做法。\nETS和DETS原本并不是为了独立使用而创建的，而是为了实现Mnesia。原本的意图是如果应用程序想要模拟进程间共享内存，就应该使用Mnesia的事务机制。\n避免顺序瓶颈 当我们使程序并行化，确保有大量进程并且没有共享内存操作后，接下来的问题就是思考顺序瓶颈。有些事情本来就是顺序的，如果问题本身具有“顺序性”，我们是无法改变这一点的。在很多时候，解决顺序瓶颈的唯一方式就是改变相关的算法，没有其他捷径可走。必须把非分布式算法修改成分布式算法。\n要避免单个代理的瓶颈，可以设置两个订票代理。在销售开始时，第一个订票代理会得到所有偶数编号的票，第二个订票代理会得到所有奇数编号的票。通过这种方式，就能确保代理们不会两次销售同一张票。\n这种把单个订票代理替换成n个分布式代理（n可以随时间而变），并且各个代理可以加入和离开售票网络以及随时崩溃的做法是当前热门的分布式计算研究领域。这个研究领域被称为分布式散列表（distributed hash tables）。\n并行的map函数及测试 1pmap(F, L) -\u0026gt; 2 S = self(), 3 %% make_ref() 返回一个唯一的引用 4 Ref = erlang:make_ref(), 5 Pids = map(fun(I) -\u0026gt; 6 spawn(fun() -\u0026gt; do_f(S, Ref, F, I) end) 7 end, L), 8 %% 收集结果 9 gather(Pids, Ref). 10 11do_f(Parent, Ref, F, I) -\u0026gt; 12 Parent ! {self(), Ref, (catch F(I))}. 13gather([Pid|T], Ref) -\u0026gt; 14 receive 15 {Pid, Ref, Ret} -\u0026gt; [Ret|gather(T,Ref)] 16 end; 17gather([], _) -\u0026gt; 18 []. gather函数里的选择性receive会确保返回值里的参数顺序符合原始列表的顺序\n具有副作用的代码不能简单地用pmap取代map调用来实现并行。\n1pmap(F, L) -\u0026gt; 2 S = self(), 3 %% make_ref() 返回一个唯一的引用 4 Ref = erlang:make_ref(), 5 foreach(fun(I) -\u0026gt; 6 spawn(fun() -\u0026gt; do_f1(S, Ref, F, I) end) 7 end, L), 8 %% 收集结果 9 gather(length(L), Ref, []). 10 11do_f1(Parent, Ref, F, I) -\u0026gt; 12 Parent ! {Ref, (catch F(I))}. 13gather1(0, _, L) -\u0026gt; L; 14gather1(N, Ref, L) -\u0026gt; 15 receive 16 {ef, Ret} -\u0026gt; gather1(N-1,Ref, [Ret|L])] 17 end; 1#!/bin/sh 2echo \u0026#34;\u0026#34; \u0026gt; results 3for i in 1 2 3 4 5 6 7...\\ 4\t17 18 ... 32 5do 6\techo $i 7\terl -boot start_clean -noshell -smp +S $i\\ 8\t-s ptests tests $i \u0026gt;\u0026gt; results 9done ptests.erl:\n1-module(ptests). 2-export([tests/1, fib/1]). 3-import(lists, [map/2]). 4-import(lib_misc, [pmap/2]). 5 6tests([N]) -\u0026gt; 7 Nsched = list_to_integer(atom_to_lists(N)), 8 run_tests(1, Nsched). 9 10%% 一次运行test 1 2 3 11run_tests(N, Nsched) -\u0026gt; 12 case test(N) of 13 stop -\u0026gt; 14 init:stop(); 15 Val -\u0026gt; 16 io:format(\u0026#34;~p.~n\u0026#34;, [{Nsched, Val}]), 17 run_tests(N+1, Nsched) 18 19test(1) -\u0026gt; 20 seed(), 21 S = lists:seq(1,100), 22 L = map(fun(_) -\u0026gt; mkList(1000) end, S), 23 {Time1, S1} = timer:tc(lists, map, [fun lists:sort/1, L]), 24 {Time2, S2} = timer:tc(lib_misc, pmap, [fun lists:sort/1, L]), 25 {sort, Time1, Time2, euqal(S1, S2)}; 26test(2) -\u0026gt; 27 L = lists:duplicate(100, 27), 28 {Time1, S1} = timer:tc(lists, map, [fun ptests:fib/1, L]), 29 {Time2, S2} = timer:tc(lib_misc, pmap, [fun lists:sort/1, L]), 30 {fib, Time1, Time2, euqal(S1, S2)}; 31test(3) -\u0026gt; 32 stop. 33 34%% 测试map和pmap的计算结果时候相等 35equal(S,S) -\u0026gt; true; 36equal(S1, S2) -\u0026gt; {differ, S1, S2}. 37 38fib(0) -\u0026gt; 1; 39fib(1) -\u0026gt; 1; 40fib(N) -\u0026gt; fib(N-1) + fib(N-2). 41 42%% 重置随机数生成器，这样每次测试都能获得相同的随机数序列 43seed() -\u0026gt; random:seed(44,55,66). 44 45mkList(K) -\u0026gt; mkList(K, []). 46 47mkList(0, L) -\u0026gt; L; 48mkList(N, L) -\u0026gt; mkList(N-1, [random:uniform(1000000) | L]). mapreduce mapreduce的基本概念：这些映射（map）进程会生成由{Key,Value}对组成的消息流，并发送给一个化简（reduce）进程进行合并，后者会把具有相同键的对组合在一起。\n1-spec mapreduce(F1, F2, Acc0, L) -\u0026gt; Acc 2 F1 = funn(Pid, X) -\u0026gt; void 3 F2 = fun(Key, [Value], Acc0) -\u0026gt; Acc 4 L = [X] 5 Acc = X = term()  F1(Pid, X)是映射函数。 F1的任务是发送一个{Key, Value}消息流到Pid进程，然后终止。mapreduce会为列表L里的每一个X值分裂出一个全新进程。 F2(Key, [Value], Acc0) -\u0026gt; Acc是化简函数。 当所有映射进程都终止时，化简函数就应该已经合并某个键的所有值了。mapreduce随后对收集的各个{Key, [Value]}元组调用F2(Key, [Value], Acc)。Acc是一个初始值为Acc0 的归集器， F2 会返回一个新的归集器。（另一种描述方式是 F2 对收集的 {Key, [Value]}元组执行了折叠操作。） Acc0是归集器的初始值，在调用F2时使用。 L是一个由X值组成的列表。 F1(Pid, X)会被用于L里的每一个X值。Pid是化简进程的标识符，它是由mapreduce创建的。  mapreduce是在phofs（parallel higher-order functions的简写，即并行高阶函数）模块里定 义的：phofs.erl\n1-module(phofs). 2-export([mapreduce/4]). 3-import(lists, [foreach/2]). 4 5mapreduce(F1, F2, Acc0, L) -\u0026gt; 6 S = self(), 7 Pid= spawn(fun() -\u0026gt; reduce(S, F1, F2, Acc0, L) end), 8 receive 9 {Pid, Result} -\u0026gt; 10 Result 11 end. 12 13reduce(Parent, F1, F2, Acc0, L) -\u0026gt; 14 process_flag(trap_exit, true), 15 ReducePid = self(), 16 foreach(fun(X) -\u0026gt; 17 spawn_link(fun() -\u0026gt; do_job(ReducePid, F1, X) end) 18 end, L), 19 N = length(L), 20 Dict0 = dict:new(), 21 Dict1 = collect_replies(N, Dict0), 22 Acc = dict:fold(F2, Acc0, Dict1), 23 Parent ! {self(), Acc}. 24 25collect_replies(0, Dict) -\u0026gt; 26 Dict; 27collect_replies(N, Dict) -\u0026gt; 28 receive 29 {Key, Val} -\u0026gt; 30 case dict:is_key(Key, Dict) of 31 true -\u0026gt; 32 Dict1 = dict:append(Key, Val, Dict), 33 collect_replies(N, Dict1); 34 false -\u0026gt; 35 Dict1 = dict:store(Key, [Val], Dict), 36 collect_replies(N, Dict1) 37 end; 38 {\u0026#39;EXIT\u0026#39;, _, _Why} -\u0026gt; 39 collect_replies(N-1, Dict) 40 end. 41 42do_job(ReducePid, F, X) -\u0026gt; 43 F(ReducePid, X). 练习 (1) 我们在17.1.1节里编写了一个获取网页的程序。修改这个程序，用HEAD命令取代GET命令。可以通过发送HTTP HEAD命令来测量网站的响应时间。服务器响应HEAD命令时只会返回网页的头部，不会返回主体。编写一个名为web_profiler:ping(URL, Timeout)的函数来测量URL这个网站地址的响应速度。它应当返回{time, T}或者timeout。\n(2) 制作一个包含大量网站的列表 L ，记录 lists:map(fun(I) -\u0026gt; web_profiler:ping(URL, Timeout) end, L) 所 花 费 的 时 间 。 它 也 许 会 运 行 很 久 ， 最 坏 情 况 下 是 Timeout xlength(L)。\n(3) 用pmap代替map重复刚才的计时。现在所有的HEAD请求都应当是并行的。因此，最坏情况下的响应时间就是Timeout。\n(4) 把结果保存在一个数据库里，然后制作一个Web接口来查询这个数据库。可以从第24章里开发的数据库和Web服务器代码入手。\n(5) 如果你用一个超长的元素列表调用pmap，就可能会创建出过多的并行进程。编写一个名为pmap(F, L, Max)的函数来并行计算列表[F(I) || I \u0026lt;- L]，但限制它同时最多只能运行Max个并行进程。\n(6) 编写一个新版的pmap，让它能工作在分布式Erlang上，把任务分派给多个Erlang节点\n(7) 编写一个新版的pmap，让它能工作在分布式Erlang上，把任务分派给多个Erlang节点，并且实现各个节点之间的任务负载均衡。\n第27章 福尔摩斯的最后一案","date":"2025-01-02","permalink":"/posts/tech/media-erlang/","series":["媒体开发"],"tags":["","",""],"title":"《Erlang程序设计》"},{"categories":["普通类"],"content":"回顾 今年我做了这些事：\n 完成补习班的教学任务。 补上一直没学的体育课，终于在延毕一年后拿到毕业证。 驾照拿到手，且成功无事故开了1000公里以上。 一战顺利拿下高中数学教资初试的三门科目。 进行网络录课，还是赚了点点钱。 找了半年终于找到一份工作。 学习Java，Erlang，C，Linux，AI相关技术。 恋爱还是一直在谈的。 个人思想水平进展巨大。  总结  今年，在教学上我有深深的遗憾，如果再来一次我会做的更好，但是我以后可能不会再教书了。 顺利抗住找工作的压力，在此期间还是找了一份兼职做着。 在人际交往，人生观上思想进步巨大。  来年展望 2025年，我希望我做好以下事情：\n  贯彻好自己的思想。\n  继续提升个人思想水平。\n  通过高中教资面试。\n  好好工作，稳扎稳打学习技术，探索学习方法、技术思想。\n ","date":"2024-12-27","permalink":"/posts/other/2024/","series":[],"tags":[""],"title":"2024年终总结和来年展望"},{"categories":["计算机"],"content":"搁置\n作为理解类书籍，和其他书同样地摘抄关键的内容及大致框架，以及做课后习题。这可是一本好书呀兄弟。\n书中提供的实验练习可以去做做，在CS:APP主页上获取。\n第1章计算机系统漫游   总线：总线被设计成传送定长的字节块，也就是字（word）。字中的字节数（即字长）是一个基本的系统参数，各个系统中都不尽相同。现在的大多数机器字长要么是4个字节（32位），要么是8个字节(64位）。\n  处理器：处理器的核心是一个大小为一个字的存储设备（或寄存器），称为程序计数器（PC)。寄存器文件是一个小的存储设备，由一些单个字长的寄存器组成，每个寄存器都有唯一的名字。ALU（算术逻辑单元）计算新的数据和地址值。\n处理器看上去是它的指令集架构的简单实现，但是实际上现代处理器使用了非常复杂的机制来加速程序的执行。指令集架构描述的是每条机器代码指令的效果；而微体系结构描述的是处理器实际上是如何实现的。\n  存储器层次结构的主要思想是上一层的存储器作为低一层存储器的高速缓存。\n  操作系统有两个基本功能：(1)防止硬件被失控的应用程序滥用；(2)向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。操作系统通过几个基本的抽象概念（进程、虚拟内存和文件）来实现这两个功能。\n  操作系统决定要把控制权从当前进程转移到某个新进程时，就会进行上下文切换，即保存当前进程的上下文、恢复新进程的上下文，然后将控制权传递到新进程。新进程就会从它上次停止的地方开始。\n从一个进程到另一个进程的转换是由操作系统内核（kernel)管理的。内核是操作系统代码常驻主存的部分。内核不是一个独立的进程。相反，它是系统管理全部进程所用代码和数据结构的集合。\n  每个进程看到的虚拟地址空间由大量准确定义的区构成，每个区都有专门的功能。从最低的地址开始是程序代码和数据、堆、共享库、栈、内核虚拟内存。、\n  Amdahl 定律：要想显著加速整个系统，必须提升全系统中相当大的部分的速度。（这个地方有一些计算题）\n  ","date":"2024-12-09","permalink":"/posts/tech/media-computer-systems/","series":["媒体开发"],"tags":["","",""],"title":"《深入理解计算机系统》"},{"categories":["普通类"],"content":"计算机的学习，大部分时间学习的是人造的规则，其他部分则是工程师思维，即便是编程的灵魂算法，其目的也是工程化的，计算机就是由人类创造，为人类服务的学科；既然是为人类服务的事物，核心当然就是人，即一切不利于人便利的东西都是错误的（虽然计算机设计的初衷是为了突破人脑与意识）。\n计算机是人脑的延展，可以做到人不能做到的数量级和速度，问题只要能建模编程，在算力允许的情况下一切皆可解决，如果再优化一下，那就更猛了（所以说算法这类东西不会过时，它既可以优化，又可以对建模进行编码）。这一点来说是非常棒的，它确确实实是一个非常棒的工具，工具就取决于我们要拿它来做什么。如果遇到了人类的极限，就去用计算机来解决吧！\n目前我对计算机的兴趣有（主要是算法和编程语言），但也很脆弱，经常是稍微搞久一点就失去耐心了，不过最近被工作鞭挞得渐渐适应计算机学习了。\n物理学的学习，表层是大千宇宙，核心是数学工具（它和数学公式要严格区分，物理的所有东西需要找到现实意义），而这两方面都是说一不二的（人类的尺度）。学习物理的过程，实则是向宇宙寻求答案的过程，即便过程中有东西不懂，那也不是向什么东西妥协，而是真正地探寻真理，探索世界地去学习。所以学习的感觉是非常不一样的。虽然有能力参差不齐，难题的困扰，但学习物理是真正地一个人面向宇宙世界的过程，所以说学习物理一定要注意理论和现实的联系，以及如何由理论计算转化为现实的计算。可以说物理本身目的就是探索世界和宇宙，它借用了各种工具。\n两者都很重要，两者对我都缺一不可，我今后的步调就是计算机和物理了，一个为了个人与社会，一个为了自己内心的探索和好奇欲。\n人生的话，会遇到很多东西，果然还是想做什么事的那个idea重要，为了实现idea，我们会有各种工具，计算机和数学就是工具了，而且是顶端的工具（在可以量化的领域）。还有目前不能量化的领域：社会，人类思维，以及未知的东西（语言的边界外），它们要么是数目繁多，要么是未知的，这些东西可能就叫思想和哲学吧。\n","date":"2024-12-07","permalink":"/posts/other/physics-computer/","series":["随意思考"],"tags":["","",""],"title":"计算机和物理的一点感悟"},{"categories":["计算机"],"content":"安装 源码安装：\nhttps://blog.csdn.net/qq_41004932/article/details/117049095\n这篇文章先看“解决ffplay没有的问题”那节。\n当然也可以一步到位直接sudo apt-get ffmpeg。\n官方文档 https://ffmpeg.org/ffmpeg.html\n目前来说没必要全部阅读，有疑问去查阅即可。\n1. 概要 1ffmpeg [global_options] {[input_file_options] -i INPUT_FILE} ... {[output_file_options] OUTPUT_FILE} ...} 2. 说明 ffmpeg从输入“文件”（其可以是常规文件，管道，网络流，录制装置等），由指定任意数量的读取-i选项，并写入到任意数量的输出“文件”，只需指定一个输出的文件名。任何一个命令行中不能被解释为选项的内容都被认为是一个输出文件名。每个输入或输出文件可以在原则上，包含任意数量的不同类型（视频/音频/字幕/附件/数据）的流。输出文件中允许流的数量和类型是由输出格式容器限制决定的。输入流和输出流直接的映射可以自动完成也可以用-map选项给定（见流选择章节)。\n引用输入文件的选项时，则必须使用他们的索引（从0开始）。例如：第一输入文件是0 ，第二个是1等。类似地，一个文件中的流也通过其索引指定。例如2:3指的是在第三个输入文件中的第四数据流。参见流章节。\n作为一般规则，选项作用于下一个指定的文件。因此，命令的顺序是重要，你可以在命令行上多次相同的选项。每次选项的出现都将作用于下一个输入或输出文件。这条规则若有例外将会提前声明（例如冗余级别）。不要混合输入和输出文件。首先指定所有输入文件，那么所有的输出文件。也不要混用属于不同的文件的选项。所有选项仅适用于下一个输入或输出文件，之后选项将被重置。\n例：\n  设置输出文件以64千比特/秒的视频比特率\nffmpeg -i input.avi -b：V 64K -bufsize 64K output.avi\n  要强制输出文件为24 fps的帧速率\nffmpeg -i input.avi -r 24 output.avi\n  要强制输入文件的帧频（仅对原始格式有效），以1 FPS读入文件，以每秒24帧的帧速率输出\nffmpeg -r 1 -i input.m2v -r 24 output.avi\n  3. 详细描述 ffmpeg builds a transcoding pipeline（转码管道） out of the components listed below. The program’s operation then consists of input data chunks（数据块） flowing from the sources down the pipes towards the sinks, while being transformed by the components they encounter along the way.\nThe following kinds of components are available:\n  Demuxers (short for \u0026ldquo;demultiplexers\u0026rdquo;) （多路分流器）read an input source in order to extract\n global properties such as metadata or chapters; list of input elementary streams and their properties  One demuxer instance is created for each -i option, and sends encoded packets to decoders or muxers.\nIn other literature, demuxers are sometimes called splitters（分流器）, because their main function is splitting a file into elementary streams (though some files only contain one elementary stream).\n1┌──────────┬───────────────────────┐ 2│ demuxer │ │ packets for stream 0 3╞══════════╡ elementary stream 0 ├──────────────────────⮞ 4│ │ │ 5│ global ├───────────────────────┤ 6│properties│ │ packets for stream 1 7│ and │ elementary stream 1 ├──────────────────────⮞ 8│ metadata │ │ 9│ ├───────────────────────┤ 10│ │ │ 11│ │ ........... │ 12│ │ │ 13│ ├───────────────────────┤ 14│ │ │ packets for stream N 15│ │ elementary stream N ├──────────────────────⮞ 16│ │ │ 17└──────────┴───────────────────────┘ 18 ⯅ 19 │ 20 │ read from file, network stream, 21 │ grabbing device, etc. 22 │   Decoders（解码器） receive encoded (compressed) packets for an audio, video, or subtitle elementary stream, and decode them into raw frames (arrays of pixels for video, PCM for audio). A decoder is typically associated with (and receives its input from) an elementary stream in a demuxer, but sometimes may also exist on its own (see Loopback decoders).\n1 ┌─────────┐ 2 packets │ │ raw frames 3─────────⮞│ decoder ├────────────⮞ 4 │ │ 5 └─────────┘   Filtergraphs（滤镜图） process and transform raw audio or video frames. A filtergraph consists of one or more individual filters linked into a graph. Filtergraphs come in two flavors（风格） - simple and complex, configured with the -filter and -filter_complex options, respectively.\nA simple filtergraph（简单滤镜图）is associated with an output elementary stream; it receives the input to be filtered from a decoder and sends filtered output to that output stream’s encoder.\nA simple video filtergraph that performs deinterlacing（去隔行处理） (using the yadif deinterlacer) followed by resizing（调整大小） (using the scale filter) can look like this:\n1 ┌────────────────────────┐ 2 │ simple filtergraph │ 3 frames from ╞════════════════════════╡ frames for 4 a decoder │ ┌───────┐ ┌───────┐ │ an encoder 5────────────⮞├─⮞│ yadif ├─⮞│ scale ├─⮞│────────────⮞ 6 │ └───────┘ └───────┘ │ 7 └────────────────────────┘ A complex filtergraph（复杂滤镜图） is standalone and not associated with any specific stream. It may have multiple (or zero) inputs, potentially of different types (audio or video), each of which receiving data either from a decoder or another complex filtergraph’s output. It also has one or more outputs that feed either an encoder or another complex filtergraph’s input.\nThe following example diagram represents a complex filtergraph with 3 inputs and 2 outputs (all video):\n1 ┌─────────────────────────────────────────────────┐ 2 │ complex filtergraph │ 3 ╞═════════════════════════════════════════════════╡ 4 frames ├───────┐ ┌─────────┐ ┌─────────┐ ┌────────┤ frames 5─────────⮞│input 0├─⮞│ overlay ├─────⮞│ overlay ├─⮞│output 0├────────⮞ 6 ├───────┘ │ │ │ │ └────────┤ 7 frames ├───────┐╭⮞│ │ ╭⮞│ │ │ 8─────────⮞│input 1├╯ └─────────┘ │ └─────────┘ │ 9 ├───────┘ │ │ 10 frames ├───────┐ ┌─────┐ ┌─────┬─╯ ┌────────┤ frames 11─────────⮞│input 2├⮞│scale├⮞│split├───────────────⮞│output 1├────────⮞ 12 ├───────┘ └─────┘ └─────┘ └────────┤ 13 └─────────────────────────────────────────────────┘ Frames from second input are overlaid（覆盖） over those from the first. Frames from the third input are rescaled（重新缩放）, then the duplicated into two identical streams. One of them is overlaid over the combined first two inputs, with the result exposed as（显示） the filtergraph’s first output. The other duplicate ends up being the filtergraph’s second output.\n  ncoders receive raw audio, video, or subtitle（字幕） frames and encode them into encoded packets. The encoding (compression) process is typically lossy（有损的） - it degrades（降级） stream quality to make the output smaller; some encoders are lossless, but at the cost of much higher output size. A video or audio encoder receives its input from some filtergraph’s output, subtitle encoders receive input from a decoder (since subtitle filtering is not supported yet). Every encoder is associated with some muxer’s output elementary stream and sends its output to that muxer.\nA schematic（原理的） representation of an encoder looks like this:\n1 ┌─────────┐ 2 raw frames │ │ packets 3────────────⮞│ encoder ├─────────⮞ 4 │ │ 5 └─────────┘   Muxers (short for \u0026ldquo;multiplexers\u0026rdquo;) receive encoded packets for their elementary streams from encoders (the transcoding（转码） path) or directly from demuxers (the streamcopy（流式拷贝） path), interleave（交错） them (when there is more than one elementary stream), and write the resulting bytes into the output file (or pipe, network stream, etc.).\n1 ┌──────────────────────┬───────────┐ 2 packets for stream 0 │ │ muxer │ 3──────────────────────⮞│ elementary stream 0 ╞═══════════╡ 4 │ │ │ 5 ├──────────────────────┤ global │ 6 packets for stream 1 │ │properties │ 7──────────────────────⮞│ elementary stream 1 │ and │ 8 │ │ metadata │ 9 ├──────────────────────┤ │ 10 │ │ │ 11 │ ........... │ │ 12 │ │ │ 13 ├──────────────────────┤ │ 14 packets for stream N │ │ │ 15──────────────────────⮞│ elementary stream N │ │ 16 │ │ │ 17 └──────────────────────┴─────┬─────┘ 18 │ 19 write to file, network stream, │ 20 grabbing device, etc. │ 21 │ 22 ▼   3.1 Streamcopy The simplest pipeline in ffmpeg is single-stream streamcopy（流式拷贝）, that is copying one input elementary stream’s packets without decoding, filtering, or encoding them. As an example, consider an input file called INPUT.mkv with 3 elementary streams, from which we take the second and write it to file OUTPUT.mp4.\n1┌──────────┬─────────────────────┐ 2│ demuxer │ │ unused 3╞══════════╡ elementary stream 0 ├────────╳ 4│ │ │ 5│INPUT.mkv ├─────────────────────┤ ┌──────────────────────┬───────────┐ 6│ │ │ packets │ │ muxer │ 7│ │ elementary stream 1 ├─────────⮞│ elementary stream 0 ╞═══════════╡ 8│ │ │ │ │OUTPUT.mp4 │ 9│ ├─────────────────────┤ └──────────────────────┴───────────┘ 10│ │ │ unused 11│ │ elementary stream 2 ├────────╳ 12│ │ │ 13└──────────┴─────────────────────┘ 将INPUT.mkv的第2个流拷贝到 OUTPUT.mp4：\n1ffmpeg -i INPUT.mkv -map 0:1 -c copy OUTPUT.mp4  there is a single input INPUT.mkv; there are no input options for this input; there is a single output OUTPUT.mp4; there are two output options for this output: -map 0:1 selects the input stream to be used - from input with index 0 (i.e. the first one) the stream with index 1 (i.e. the second one); -c copy selects the copy encoder, i.e. streamcopy with no decoding or encoding.  Streamcopy is useful for changing the elementary stream count, container format, or modifying container-level metadata. Since there is no decoding or encoding, it is very fast and there is no quality loss. However, it might not work in some cases because of a variety of factors (e.g. certain information required by the target container is not available in the source). Applying filters is obviously also impossible, since filters work on decoded frames.\nMore complex streamcopy scenarios can be constructed - e.g. combining streams from two input files into a single output:\n1┌──────────┬─────────────────────┐ ┌───────────────────┬───────────┐ 2│ demuxer │ │ packets │ │ muxer 0 │ 3╞══════════╡ elementary stream 0 ├─────────⮞│elementary stream 0╞═══════════╡ 4│ │ │ │ │OUTPUT0.mp4│ 5│INPUT.mkv ├─────────────────────┤ └───────────────────┴───────────┘ 6│ │ │ packets ┌───────────────────┬───────────┐ 7│ │ elementary stream 1 ├─────────⮞│ │ muxer 1 │ 8│ │ │ │elementary stream 0╞═══════════╡ 9└──────────┴─────────────────────┘ │ │OUTPUT1.mp4│ 10 └───────────────────┴───────────┘ 将一个输入的两个流分别拷贝到不同的输出：\n1ffmpeg -i INPUT.mkv -map 0:0 -c copy OUTPUT0.mp4 -map 0:1 -c copy OUTPUT1.mp4 Note how a separate instance of the -c option is needed for every output file even though their values are the same. This is because non-global options (which is most of them) only apply in the context of the file before which they are placed.\nThese examples can of course be further generalized into arbitrary remappings of any number of inputs into any number of outputs.\n3.2 Trancoding Transcoding（串编码） is the process of decoding a stream and then encoding it again. Since encoding tends to be computationally expensive and in most cases degrades the stream quality (i.e. it is lossy), you should only transcode when you need to and perform streamcopy otherwise（否则）. Typical reasons to transcode are:\n applying filters（加过滤） - e.g. resizing, deinterlacing（反交错）, or overlaying video; resampling or mixing audio; you want to feed the stream to something that cannot decode the original codec.（交给不能解码的处理器）  Note that ffmpeg will transcode all audio, video, and subtitle streams unless you specify -c copy for them.（自动转码，除非copy）\nConsider an example pipeline that reads an input file with one audio and one video stream, transcodes the video and copies the audio into a single output file. This can be schematically represented as follows\n1┌──────────┬─────────────────────┐ 2│ demuxer │ │ audio packets 3╞══════════╡ stream 0 (audio) ├─────────────────────────────────────╮ 4│ │ │ │ 5│INPUT.mkv ├─────────────────────┤ video ┌─────────┐ raw │ 6│ │ │ packets │ video │ video frames │ 7│ │ stream 1 (video) ├─────────⮞│ decoder ├──────────────╮ │ 8│ │ │ │ │ │ │ 9└──────────┴─────────────────────┘ └─────────┘ │ │ 10 ▼ ▼ 11 │ │ 12┌──────────┬─────────────────────┐ video ┌─────────┐ │ │ 13│ muxer │ │ packets │ video │ │ │ 14╞══════════╡ stream 0 (video) │⮜─────────┤ encoder ├──────────────╯ │ 15│ │ │ │(libx264)│ │ 16│OUTPUT.mp4├─────────────────────┤ └─────────┘ │ 17│ │ │ │ 18│ │ stream 1 (audio) │⮜────────────────────────────────────╯ 19│ │ │ 20└──────────┴─────────────────────┘ 输入INPUT.mkv，对音频进行拷贝，对视频进行libx264编码：\n1ffmpeg -i INPUT.mkv -map 0:v -map 0:a -c:v libx264 -c:a copy OUTPUT.mp4 Note how it uses stream specifiers :v and :a to select input streams and apply different values of the -c option to them\n3.3 Filtering When transcoding, audio and video streams can be filtered before encoding, with either a simple or complex filtergraph.\n3.3.1 Simple filtergraphs Simple filtergraphs are those that have exactly one input and output, both of the same type (audio or video). They are configured with the per-stream -filter option (with -vf and -af aliases for -filter:v (video) and -filter:a (audio) respectively). Note that simple filtergraphs are tied to their output stream, so e.g. if you have multiple audio streams, -af will create a separate filtergraph for each one.\nTaking the trancoding example from above, adding filtering (and omitting audio, for clarity) makes it look like this:\n1┌──────────┬───────────────┐ 2│ demuxer │ │ ┌─────────┐ 3╞══════════╡ video stream │ packets │ video │ frames 4│INPUT.mkv │ ├─────────⮞│ decoder ├─────⮞───╮ 5│ │ │ └─────────┘ │ 6└──────────┴───────────────┘ │ 7 ╭───────────⮜───────────╯ 8 │ ┌────────────────────────┐ 9 │ │ simple filtergraph │ 10 │ ╞════════════════════════╡ 11 │ │ ┌───────┐ ┌───────┐ │ 12 ╰──⮞├─⮞│ yadif ├─⮞│ scale ├─⮞├╮ 13 │ └───────┘ └───────┘ ││ 14 └────────────────────────┘│ 15 │ 16 │ 17┌──────────┬───────────────┐ video ┌─────────┐ │ 18│ muxer │ │ packets │ video │ │ 19╞══════════╡ video stream │⮜─────────┤ encoder ├───────⮜───────╯ 20│OUTPUT.mp4│ │ │ │ 21│ │ │ └─────────┘ 22└──────────┴───────────────┘ 3.3.2 Complex filtergraphs 全局的。\nComplex filtergraphs are those which cannot be described as simply a linear processing chain applied to one stream. This is the case, for example, when the graph has more than one input and/or output, or when output stream type is different from input. Complex filtergraphs are configured with the -filter_complex option. Note that this option is global, since a complex filtergraph, by its nature, cannot be unambiguously associated with a single stream or file. Each instance of -filter_complex creates a new complex filtergraph, and there can be any number of them.\nA trivial example of a complex filtergraph is the overlay filter, which has two video inputs and one video output, containing one video overlaid on top of the other. Its audio counterpart is the amix filter.\n3.4 Loopback decoders While decoders are normally associated with demuxer streams, it is also possible to create \u0026ldquo;loopback\u0026rdquo; decoders that decode the output from some encoder and allow it to be fed back to complex filtergraphs. This is done with the -dec directive, which takes as a parameter the index of the output stream that should be decoded. Every such directive creates a new loopback decoder, indexed with successive integers starting at zero. These indices should then be used to refer to loopback decoders（环回解码器） in complex filtergraph link labels, as described in the documentation for -filter_complex.\nDecoding AVOptions can be passed to（传递给） loopback decoders by placing them before -dec, analogously（类似的） to input/output options.\nTODO 下面这段没看懂\nE.g. the following example:\n1ffmpeg -i INPUT \\ 2 -map 0✌️0 -c:v libx264 -crf 45 -f null - \\ 3 -threads 3 -dec 0:0 \\ 4 -filter_complex \u0026#39;[0:v][dec:0]hstack[stack]\u0026#39; \\ 5 -map \u0026#39;[stack]\u0026#39; -c:v ffv1 OUTPUT reads an input video and\n (line 2) encodes it with libx264 at low quality; (line 3) decodes this encoded stream using 3 threads; (line 4) places decoded video side by side with the original input video; (line 5) combined video is then losslessly encoded and written into OUTPUT.  Such a transcoding pipeline can be represented with the following diagram:\n1┌──────────┬───────────────┐ 2│ demuxer │ │ ┌─────────┐ ┌─────────┐ ┌────────────────────┐ 3╞══════════╡ video stream │ │ video │ │ video │ │ null muxer │ 4│ INPUT │ ├──⮞│ decoder ├──┬────────⮞│ encoder ├─┬─⮞│(discards its input)│ 5│ │ │ └─────────┘ │ │(libx264)│ │ └────────────────────┘ 6└──────────┴───────────────┘ │ └─────────┘ │ 7 ╭───────⮜──╯ ┌─────────┐ │ 8 │ │loopback │ │ 9 │ ╭─────⮜──────┤ decoder ├────⮜──╯ 10 │ │ └─────────┘ 11 │ │ 12 │ │ 13 │ │ ┌───────────────────┐ 14 │ │ │complex filtergraph│ 15 │ │ ╞═══════════════════╡ 16 │ │ │ ┌─────────────┐ │ 17 ╰─╫─⮞├─⮞│ hstack ├─⮞├╮ 18 ╰─⮞├─⮞│ │ ││ 19 │ └─────────────┘ ││ 20 └───────────────────┘│ 21 │ 22┌──────────┬───────────────┐ ┌─────────┐ │ 23│ muxer │ │ │ video │ │ 24╞══════════╡ video stream │⮜─┤ encoder ├───────⮜──────────╯ 25│ OUTPUT │ │ │ (ffv1) │ 26│ │ │ └─────────┘ 27└──────────┴───────────────┘ 4 Stream selection（流选择） ffmpeg provides the -map option for manual control of stream selection in each output file. Users can skip -map and let ffmpeg perform automatic stream selection as described below. The -vn / -an / -sn / -dn options can be used to skip inclusion of video, audio, subtitle and data streams respectively, whether manually mapped or automatically selected, except for those streams which are outputs of complex filtergraphs.\n4.1 Description The sub-sections（小节） that follow describe the various rules that are involved in stream selection. The examples that follow next show how these rules are applied in practice.\nWhile every effort is made to accurately reflect the behavior of the program, FFmpeg is under continuous development and the code may have changed since the time of this writing.\n4.1.1 Automatic stream selection In the absence of（在没有\u0026hellip;情况下） any map options for a particular output file, ffmpeg inspects the output format to check which type of streams can be included in it, viz. video, audio and/or subtitles. For each acceptable stream type, ffmpeg will pick one stream, when available, from among all the inputs.\nIt will select that stream based upon the following criteria（标准）:\n for video, it is the stream with the highest resolution, for audio, it is the stream with the most channels, for subtitles, it is the first subtitle stream found but there’s a caveat（警告）. The output format’s default subtitle encoder can be either text-based or image-based, and only a subtitle stream of the same type will be chosen.  In the case where several streams of the same type rate equally, the stream with the lowest index is chosen.\nData or attachment streams are not automatically selected and can only be included using -map.\n4.1.2 Manual stream selection When -map is used, only user-mapped streams are included in that output file, with one possible exception for filtergraph outputs described below.\n4.1.3 Complex filtergraphs If there are any complex filtergraph output streams with unlabeled pads, they will be added to the first output file. This will lead to a fatal error if the stream type is not supported by the output format. In the absence of the map option, the inclusion of these streams leads to the automatic stream selection of their types being skipped. If map options are present, these filtergraph streams are included in addition to（除了..还包括） the mapped streams.\nComplex filtergraph output streams with labeled pads must be mapped once and exactly once.\n4.1.4 Stream handling Stream handling（流处理） is independent of stream selection, with an exception for subtitles described below. Stream handling is set via the -codec option addressed to streams within a specific output file. In particular, codec options are applied by ffmpeg after the stream selection process and thus（因此） do not influence the latter. If no -codec option is specified for a stream type, ffmpeg will select the default encoder registered by the output file muxer.\nAn exception exists for subtitles. If a subtitle encoder is specified for an output file, the first subtitle stream found of any type, text or image, will be included. ffmpeg does not validate if the specified encoder can convert the selected stream or if the converted stream is acceptable within the output format. This applies generally as well: when the user sets an encoder manually, the stream selection process cannot check if the encoded stream can be muxed into the output file. If it cannot, ffmpeg will abort and all output files will fail to be processed.\n4.2 Examples The following examples illustrate the behavior, quirks（怪事） and limitations（局限性） of ffmpeg’s stream selection methods.\nThey assume the following three input files.\n1input file \u0026#39;A.avi\u0026#39; 2 stream 0: video 640x360 3 stream 1: audio 2 channels 4 5input file \u0026#39;B.mp4\u0026#39; 6 stream 0: video 1920x1080 7 stream 1: audio 2 channels 8 stream 2: subtitles (text) 9 stream 3: audio 5.1 channels 10 stream 4: subtitles (text) 11 12input file \u0026#39;C.mkv\u0026#39; 13 stream 0: video 1280x720 14 stream 1: audio 2 channels 15 stream 2: subtitles (image) Example: automatic stream selection 1ffmpeg -i A.avi -i B.mp4 out1.mkv out2.wav -map 1:a -c:a copy out3.mov There are three output files specified, and for the first two, no -map options are set, so ffmpeg will select streams for these two files automatically.\nout1.mkv is a Matroska container file and accepts video, audio and subtitle streams, so ffmpeg will try to select one of each type. For video, it will select stream 0 from B.mp4, which has the highest resolution among all the input video streams. For audio, it will select stream 3 from B.mp4, since it has the greatest number of channels. For subtitles, it will select stream 2 from B.mp4, which is the first subtitle stream from among A.avi and B.mp4.\nout2.wav accepts only audio streams, so only stream 3 from B.mp4 is selected.\nFor out3.mov, since a -map option is set, no automatic stream selection will occur. The -map 1:a option will select all audio streams from the second input B.mp4. No other streams will be included in this output file.\nFor the first two outputs, all included streams will be transcoded. The encoders chosen will be the default ones registered by each output format, which may not match the codec of the selected input streams.\nFor the third output, codec option for audio streams has been set to copy, so no decoding-filtering-encoding operations will occur, or can occur. Packets of selected streams shall be conveyed from the input file and muxed within the output file.\nExample: automatic subtitles selection 1ffmpeg -i C.mkv out1.mkv -c:s dvdsub -an out2.mkv Although out1.mkv is a Matroska container file which accepts subtitle streams, only a video and audio stream shall be selected. The subtitle stream of C.mkv is image-based and the default subtitle encoder of the Matroska muxer is text-based, so a transcode operation for the subtitles is expected to fail and hence the stream isn’t selected. However, in out2.mkv, a subtitle encoder is specified in the command and so, the subtitle stream is selected, in addition to the video stream. The presence of -an disables audio stream selection for out2.mkv.\nExample: unlabeled filtergraph outputs 1ffmpeg -i A.avi -i C.mkv -i B.mp4 -filter_complex \u0026#34;overlay\u0026#34; out1.mp4 out2.srt A filtergraph is setup here using the -filter_complex option and consists of a single video filter. The overlay filter requires exactly two video inputs, but none are specified, so the first two available video streams are used, those of A.avi and C.mkv. The output pad of the filter has no label and so is sent to the first output file out1.mp4. Due to this, automatic selection of the video stream is skipped, which would have selected the stream in B.mp4. The audio stream with most channels viz（即）. stream 3 in B.mp4, is chosen automatically. No subtitle stream is chosen however, since the MP4 format has no default subtitle encoder registered, and the user hasn’t specified a subtitle encoder.\nThe 2nd output file, out2.srt, only accepts text-based subtitle streams. So, even though the first subtitle stream available belongs to C.mkv, it is image-based and hence skipped. The selected stream, stream 2 in B.mp4, is the first text-based subtitle stream.\nExample: labeled filtergraph outputs 1ffmpeg -i A.avi -i B.mp4 -i C.mkv -filter_complex \u0026#34;[1:v]hue=s=0[outv];overlay;aresample\u0026#34; \\ 2 -map \u0026#39;[outv]\u0026#39; -an out1.mp4 \\ 3 out2.mkv \\ 4 -map \u0026#39;[outv]\u0026#39; -map 1🅰️0 out3.mkv The above command will fail, as the output pad labelled [outv] has been mapped twice. None of the output files shall be processed.\n1ffmpeg -i A.avi -i B.mp4 -i C.mkv -filter_complex \u0026#34;[1:v]hue=s=0[outv];overlay;aresample\u0026#34; \\ 2 -an out1.mp4 \\ 3 out2.mkv \\ 4 -map 1🅰️0 out3.mkv This command above will also fail as the hue filter output has a label, [outv], and hasn’t been mapped anywhere.\nThe command should be modified as follows,\n1ffmpeg -i A.avi -i B.mp4 -i C.mkv -filter_complex \u0026#34;[1:v]hue=s=0,split=2[outv1][outv2];overlay;aresample\u0026#34; \\ 2 -map \u0026#39;[outv1]\u0026#39; -an out1.mp4 \\ 3 out2.mkv \\ 4 -map \u0026#39;[outv2]\u0026#39; -map 1🅰️0 out3.mkv The video stream from B.mp4 is sent to the hue filter, whose output is cloned once using the split filter, and both outputs labelled. Then a copy each is mapped to the first and third output files.\nThe overlay filter, requiring two video inputs, uses the first two unused video streams. Those are the streams from A.avi and C.mkv. The overlay output isn’t labelled, so it is sent to the first output file out1.mp4, regardless of the presence of the -map option.\nThe aresample filter is sent the first unused audio stream, that of A.avi. Since this filter output is also unlabelled, it too is mapped to the first output file. The presence of -an only suppresses（抑制） automatic or manual stream selection of audio streams, not outputs sent from filtergraphs. Both these mapped streams shall be ordered before the mapped stream in out1.mp4.\nThe video, audio and subtitle streams mapped to out2.mkv are entirely determined by automatic stream selection.\nout3.mkv consists of the cloned video output from the hue filter and the first audio stream from B.mp4.\n5 Options（选项） 不补了，自己查吧，反正就在那。\n使用 教程   将input.mp4转换为output.avi格式：\n1ffmpeg -i input.mp4 output.avi 2ffmpeg -i input.avi output.mp4\t3 4#i：代表和输入文件   设置元数据：\n1#设置元数据键/值对。 2#可以提供可选的元数据指定器来设置流、章节或程序的元数据。有关详细信息，请参阅-map_medata文档。 3#此选项覆盖了使用-map_metadata设置的元数据。也可以使用空值删除元数据。 4 5ffmpeg -i in.avi -metadata title=\u0026#34;my title\u0026#34; out.flv 6 7#在输出文件中设置标题 8 9ffmpeg -i INPUT -metadata:s:a:0 language=eng OUTPUT 10 11#设置第一音频流的语言   将input.mp4的起始时间为00:01:30，时长为30秒钟的部分裁剪出来：\n1ffmpeg -i \u0026#34;input.mp4\u0026#34; -ss 00:01:30 -t 00:00:30 -c copy \u0026#34;output.mp4\u0026#34; 2 3#ss：当用作输入选项（在-i之前）时，在此输入文件中查找要定位的位置。 4#请注意，在大多数格式中，无法精确查找，因此ffmpeg将查找位置之前最近的查找点。 5#当启用转码和-accurate_seek（默认设置）时，寻道点和位置之间的额外段将被解码并丢弃。 6#在进行流复制或使用-noaccurate_seek时，它将被保留。 7#当用作输出选项时（在输出url之前），会解码但丢弃输入，直到时间戳到达位置。 8 9#t：当用作输入选项时（在-i之前），限制从输入文件读取数据的持续时间。 10#当用作输出选项时（在输出url之前），在持续时间达到持续时间后停止写入输出。   将video.mp4和audio.mp3合并成output.mp4：\n1ffmpeg -i \u0026#34;video.mp4\u0026#34; -i audio.mp3 -c:v copy -c:a aac -strict experimental \u0026#34;output.mp4\u0026#34; 2 3#c：为一个或多个流选择编码器（在输出文件之前使用时）或解码器（在输入文件之前使用）。 4#codec是解码器/编码器或特殊值副本（仅输出）的名称，用于指示流不进行重新编码。 5#copy就是复制   使用libx264对所有视频流进行编码，并复制所有音频流：\n1ffmpeg -i INPUT -map 0 -c:v libx264 -c:a copy OUTPUT\t  复制的所有流，除第二个视频（将使用libx264编码）和第138个音频（将使用libvorbis编码）之外：\n1ffmpeg -i INPUT -map 0 -c copy -c✌️1 libx264 -c🅰️137 libvorbis OUTPUT   将第二个音频流设置为默认流：\n1ffmpeg -i in.mkv -c copy -disposition🅰️1 default out.mkv   使第二字幕流成为默认流并从第一字幕流中删除默认配置：\n1ffmpeg -i in.mkv -c copy -disposition:s:0 0 -disposition:s:1 default out.mkv 2 3#通过设置0来清除   添加嵌入式封面/缩略图：\n1ffmpeg -i in.mp4 -i IMAGE -map 0 -map 1 -c copy -c✌️1 png -disposition✌️1 attached_pic out.mp4   在第一个音频流中添加“原始”并删除“注释”处置标志，而不删除其其他处置标志：\n1ffmpeg -i in.mkv -c copy -disposition🅰️0 +original-comment out.mkv 2 3#要删除“原始”并将“注释”处置标志添加到第一个音频流中，而不删除其其他处置标志 4ffmpeg -i in.mkv -c copy -disposition🅰️0 -original+comment out.mkv 5 6#在第一个音频流上仅设置“原始”和“注释”处置标志（并删除其其他处置标志）： 7ffmpeg -i in.mkv -c copy -disposition🅰️0 original+comment out.mkv   从第一个音频流中删除所有处置标志：\n1ffmpeg -i in.mkv -c copy -disposition🅰️0 0 out.mkv   将video.mp4压缩输出为output.mp4，降低码率以减小文件大小：\n1ffmpeg -i video.mp4 -c:v libx264 -crf 23 -c:a aac -b:a 192k output.mp4 2 3#r：作为输入选项，忽略文件中存储的任何时间戳，而是假设帧速率为恒定fps来生成时间戳。 4#\t作为输出选项在编码之前复制或删除帧，以实现恒定的输出帧率fps。视频流拷贝 5#f：强制输入或输出文件格式。 6#b:a b代表比特率，a匹配所有的音频流   将输出文件的比特率设置为64kbps：\n1ffmpeg -i input.avi -b:v 64k -bufsize 64k output.mp4   将输出文件的帧率设置为24fps：\n1ffmpeg -i input.avi -r 24 output.mp4 2 3#r：设置帧率（Hz值、分数或缩写）。 4#作为输入选项，忽略文件中存储的任何时间戳，而是假设帧速率为恒定fps来生成时间戳。 5#这与用于某些输入格式（如image2或v4l2）的-framerate选项不同（在旧版本的FFmpeg中是相同的）。如有疑问，请使用-framerate而不是输入选项-r。 6#作为输出选项： 7#视频编码： 8#在编码之前复制或删除帧，以实现恒定的输出帧率fps。 9#视频流拷贝： 10#向多路复用器指示fps是流帧率。在这种情况下，没有数据被丢弃或复制。如果fps与数据包时间戳确定的实际流帧率不匹配，则可能会产生无效文件。另请参见sets比特流过滤器。   将输入文件的帧速率（仅对原始格式有效）强制为1 fps，将输出文件的帧速率强制为24 fps：\n1ffmpeg -r 1 -i input.m2v -r 24 output.mp4   考虑一个名为input.mkv的输入文件，其中有3个基本流，我们从中提取第二个并将其写入文件OUTPUT.mp4：\n1ffmpeg -i INPUT.mkv -map 0:1 -c copy OUTPUT.mp4 2 3#0:1 表示第一个输入文件的第一个2个流。 4#-c copy：选择拷贝编码器，即不进行解码或编码的流拷贝。   将两个输入文件中的流合并到一个输出中：\n1ffmpeg -i INPUT0.mkv -i INPUT1.aac -map 0:0 -map 1:0 -c copy OUTPUT.mp4   多个流从单个输入拆分为多个输出：\n1ffmpeg -i INPUT.mkv -map 0:0 -c copy OUTPUT0.mp4 -map 0:1 -c copy OUTPUT1.mp4   读取一个包含一个音频和一个视频流的输入文件，对视频进行转码，并将音频复制到一个输出文件中：\n1ffmpeg -i INPUT.mkv -map 0:v -map 0:a -c:v libx264 -c:a copy OUTPUT.mp4 2 3#ffmpeg将对所有音频、视频和字幕流进行转码，除非您为它们指定了-c copy。   流自动选择：\n1ffmpeg -i A.avi -i B.mp4 out1.mkv out2.wav -map 1:a -c:a copy out3.mov 2 3#指定了三个输出文件，对于前两个，没有设置映射选项，因此ffmpeg将自动为这两个文件选择流。 4#out1.mkv是一个Matroska容器文件，接受视频、音频和字幕流，因此ffmpeg将尝试选择每种类型中的一种。 5#对于视频，它将从B.mp4中选择流0，B.mp4在所有输入视频流中具有最高的分辨率。 6#对于音频，它将从B.mp4中选择流3，因为它具有最多的通道。 7#对于字幕，它将从B.mp4中选择流2，这是A.avi和B.mp4之间的第一个字幕流 8#out2.wav只接受音频流，因此只选择B.mp4中的流3。因为它具有最多的通道。 9#对于out3.mov，由于设置了-map选项，因此不会自动选择流。-map 1:a选项将从第二个输入B.mp4中选择所有音频流。此输出文件中不会包含其他流。   流自动选择2（字幕）：\n1ffmpeg -i C.mkv out1.mkv -c:s dvdsub -an out2.mkv 2 3#虽然out1.mkv是一个接受字幕流的Matroska容器文件，但只能选择视频和音频流。C.mkv的字幕流是基于图像的，Matroska多路复用器的默认字幕编码器是基于文本的，因此字幕的转码操作预计会失败，因此不会选择该流。 4#然而，在out2.mkv中，命令中指定了字幕编码器，因此除了视频流外，还选择了字幕流。 5#-an的存在将禁用out2.mkv的音频流选择。   流自动选择3（没有标签的复杂滤镜图的输出）：\n1ffmpeg -i A.avi -i C.mkv -i B.mp4 -filter_complex \u0026#34;overlay\u0026#34; out1.mp4 out2.srt 2 3#这里使用-filter_complex选项设置了一个过滤器图，它由一个视频过滤器组成。叠加滤镜图需要两个视频输入，但没有指定，因此使用前两个可用的视频流，即A.avi和C.mkv。过滤器的输出焊盘没有标签，因此被发送到第一个输出文件out1.mp4。 4#因此，跳过视频流的自动选择，这将选择B.mp4中的流。自动选择具有大多数channel的音频流，即B.mp4中的流3。但是，由于MP4格式没有注册默认字幕编码器，用户也没有指定字幕编码器，因此没有选择字幕流。   流自动选择4（有标签的复杂滤镜图的输出）：\n1ffmpeg -i A.avi -i B.mp4 -i C.mkv -filter_complex \u0026#34;[1:v]hue=s=0[outv];overlay;aresample\u0026#34; \\ 2 -map \u0026#39;[outv]\u0026#39; -an out1.mp4 \\ 3 out2.mkv \\ 4 -map \u0026#39;[outv]\u0026#39; -map 1🅰️0 out3.mkv 5 6#上述命令将失败，因为标记为[outv]的输出焊盘已被映射两次。不得处理任何输出文件。 7 8ffmpeg -i A.avi -i B.mp4 -i C.mkv -filter_complex \u0026#34;[1:v]hue=s=0[outv];overlay;aresample\u0026#34; \\ 9 -an out1.mp4 \\ 10 out2.mkv \\ 11 -map 1🅰️0 out3.mkv 12 13#上述命令也将失败，因为色调过滤器输出有一个标签[outv]，并且没有映射到任何地方。 14 15ffmpeg -i A.avi -i B.mp4 -i C.mkv -filter_complex \u0026#34;[1:v]hue=s=0,split=2[outv1][outv2];overlay;aresample\u0026#34; \\ 16 -map \u0026#39;[outv1]\u0026#39; -an out1.mp4 \\ 17 out2.mkv \\ 18 -map \u0026#39;[outv2]\u0026#39; -map 1🅰️0 out3.mkv 19 20#来自B.mp4的视频流被发送到色调过滤器，使用分割过滤器（split）克隆一次色调过滤器的输出，并标记两个输出。然后，每个副本都被映射到第一个和第三个输出文件。 21#叠加滤镜图（overlay）需要两个视频输入，使用前两个未使用的视频流。这些是来自A.avi和C.mkv的流。 22#覆盖overlay的输出没有标记（label），因此无论是否存在-map选项，它都会被发送到第一个输出文件out1.mp4。 23#aresample过滤器被发送第一个未使用的音频流，即A.avi的音频流。由于此过滤器输出也未标记，因此它也被映射到第一个输出文件out1.mp4 24#-an的存在只会抑制音频流的自动或手动流选择，而不会抑制从滤镜图图发送的输出。这两个映射流应在out1.mp4中的映射流之前排序。 25#映射到out2.mkv的视频、音频和字幕流完全由自动流选择决定。 26#out3.mkv由色调滤镜图的克隆视频输出和B.mp4的第一个音频流组成。 27#1🅰️0 B.mp4的第一个音频流   从文件中加载命令：\n1ffmpeg -i INPUT -/filter:v filter.script OUTPUT 2 3#接受参数的选项支持一种特殊语法，其中命令行上给出的参数被解释为加载实际参数值的文件的路径。要使用此功能，请在选项名称之前（前导破折号之后）添加一个正斜杠“/”。 4#将从名为filter.script的文件中加载过滤器图描述   将第一个输入文件中的所有流映射到输出：\n1ffmpeg -i INPUT -map 0 output   将input中的第二个输入流映射到out.wav中的（单个）输出流：\n1ffmpeg -i INPUT -map 0:1 out.wav   从输入文件中选择所有视频和第三个音频流：\n1ffmpeg -i INPUT -map 0:v -map 0🅰️2 OUTPUT   映射除第二个音频之外的所有流，请使用负映射：\n1ffmpeg -i INPUT -map 0 -map -0🅰️1 OUTPUT   映射来自第一个输入的视频和音频流，并使用尾随？，这样如果第一输入中不存在音频流，则忽略音频映射：\n1ffmpeg -i INPUT -map 0:v -map 0:a? OUTPUT   选择英语音频流：\n1ffmpeg -i INPUT -map 0ⓜ️language:eng OUTPUT   将输出mpegts文件的流0 PID设置为33，流1 PID设置为36：\n1ffmpeg -i inurl -streamid 0:33 -streamid 1:36 out.ts   将h264_mp4toannexb比特流过滤器（将MP4封装的H.264流转换为附件B）应用于输入视频流:\n1ffmpeg -bsf:v h264_mp4toannexb -i h264.mp4 -c:v copy -an out.h264   将mov2textsub比特流过滤器（从MOV字幕中提取文本）应用于输出字幕流:\n1ffmpeg -i file.mov -an -vn -bsf:s mov2textsub -c:s copy -f rawvideo sub.txt   环回解码器+复杂滤波图应用1：\n1ffmpeg -i INPUT \\ 2 -map 0✌️0 -c:v libx264 -crf 45 -f null - \\ 3 -threads 3 -dec 0:0 \\ 4 -filter_complex \u0026#39;[0:v][dec:0]hstack[stack]\u0026#39; \\ 5 -map \u0026#39;[stack]\u0026#39; -c:v ffv1 OUTPUT 6 7# 0✌️0 第一个输入的第一个视频流， 最后面这个0是view_specifier（视图说明符） 8#-dec：对某些编码器的输出进行解码，并将其反馈给复杂的滤镜图图。这是通过-dec指令完成的，该指令将应解码的输出流的索引作为参数 9#-filter_complex：定义一个复杂的滤波图 10#[file_index:stream_specifier]：连接输入流，如果stream_specifier匹配多个流，则将使用第一个流。对于多视图视频，流说明符后面可能跟有视图说明符 11#[dec:dec_idx]：环回解码器，其中dec_idx是要连接到给定输入的环回解码器的索引。对于多视图视频，解码器索引后面可能跟有视图说明符 12#[stack]：是输出标签。   环回解码器+复杂滤波图应用2：\n1ffmpeg -i input.mkv \\ 2 -filter_complex \u0026#39;[0:v]scale=size=hd1080,split=outputs=2[for_enc][orig_scaled]\u0026#39; \\ 3 -c:v libx264 -map \u0026#39;[for_enc]\u0026#39; output.mkv \\ 4 -dec 0:0 \\ 5 -filter_complex \u0026#39;[dec:0][orig_scaled]hstack[stacked]\u0026#39; \\ 6 -map \u0026#39;[stacked]\u0026#39; -c:v ffv1 comparison.mkv 7 8# []包围的名称基本都是标签。 9#（第2行）使用具有一个输入和两个输出的复杂滤镜图图将视频缩放到1920x1080，并将结果复制到两个输出； 10#（第3行）用libx264对一个缩放输出进行编码，并将结果写入output.mkv； 11#（第4行）用环回解码器对该编码流进行解码； 12#（第5行）将环回解码器的输出（即libx264编码视频）与缩放的原始输入并排放置（hstack）； 13#（第6行）然后对组合视频进行无损编码（ffv1）并写入comparison.mkv。   将图像叠加在视频上：\n1ffmpeg -i video.mkv -i image.png -filter_complex \u0026#39;[0:v][1:v]overlay[out]\u0026#39; -map 2\u0026#39;[out]\u0026#39; out.mkv 3 4#假设每个输入文件中只有一个视频流，我们可以省略输入标签 5ffmpeg -i video.mkv -i image.png -filter_complex \u0026#39;overlay[out]\u0026#39; -map 6\u0026#39;[out]\u0026#39; out.mkv 7 8#此外，我们可以省略输出标签，过滤器图中的单个输出将自动添加到输出文件中 9ffmpeg -i video.mkv -i image.png -filter_complex \u0026#39;overlay\u0026#39; out.mkv   以MPEG-TS格式存储的DVB-T记录上硬编码字幕，将字幕延迟1秒：\n1ffmpeg -i input.ts -filter_complex \\ 2 \u0026#39;[#0x2ef] setpts=PTS+1/TB [sub] ; [#0x2d0] [sub] overlay\u0026#39; \\ 3 -sn -map \u0026#39;#0x2dc\u0026#39; output.mkv 4 5#0x2d0、0x2dc和0x2ef分别是视频、音频和字幕流的MPEG-TS PID；0:0、0:3和0:7也会奏效 6#作为一个特殊的例外，您可以使用位图字幕流作为输入：它将被转换为与文件中最大视频大小相同的视频，如果没有视频，则转换为720x576。 7#-sn：作为输入选项，阻止文件的所有字幕流被过滤或自动选择或映射到任何输出。请参阅-discard选项以单独禁用流。 8#作为输出选项，禁用字幕录制，即自动选择或映射任何字幕流。有关完全手动控制，请参阅-map选项。   使用lavfi色源生成5秒的纯红色视频：\n1ffmpeg -filter_complex \u0026#39;color=c=red\u0026#39; -t 5 out.mkv   将ID3v2.3标头而不是默认的ID3v2.4写入MP3文件，请使用MP3多路复用器的ID3v2_version私有选项：\n1ffmpeg -i input.flac -id3v2_version 3 out.mp3   添加附件：\n1ffmpeg -i INPUT -attach DejaVuSans.ttf -metadata:s:2 mimetype=application/x-truetype-font out.mkv   提取附件：\n1ffmpeg -dump_attachment:t:0 out.ttf -i INPUT 2#提取名为“out.ttf”的文件的第一个附件 3 4 5ffmpeg -dump_attachment:t \u0026#34;\u0026#34; -i INPUT 6#提取由文件名标记确定的文件的所有附件   显示输入设备的自动检测源：\n1ffmpeg -sources pulse,server=192.168.0.4   显示输出设备的自动检测接收器：\n1ffmpeg -sinks pulse,server=192.168.0.4   启用重复日志输出：\n1ffmpeg -loglevel repeat+level+verbose -i input output 2 3#允许重复日志输出而不影响当前级别前缀标志或日志级别状态： 4ffmpeg [...] -loglevel +repeat   使用32的日志级别（日志级别信息的别名）将报告输出到名为ffreport.log的文件：\n1FFREPORT=file=ffreport.log:level=32 ffmpeg -i input output   允许设置和清除cpu标志。此选项用于测试：\n1ffmpeg -cpuflags -sse+mmx ... 2ffmpeg -cpuflags mmx ... 3ffmpeg -cpuflags 0 ...   覆盖CPU计数检测。此选项用于测试：\n1ffmpeg -cpucount 2   将进度信息记录到stdout：\n1ffmpeg -progress pipe:1 -i in.mkv out.mkv   官方示例   指定了输入格式和设备，那么ffmpeg可以直接抓取视频和音频：\n1ffmpeg -f oss -i /dev/dsp -f video4linux2 -i /dev/video0 /tmp/out.mpg 2 3#使用ALSA音频源（单声道输入，卡id 1）而不是OSS： 4ffmpeg -f alsa -ac 1 -i hw:1 -f video4linux2 -i /dev/video0 /tmp/out.mpg   通过ffmpeg抓取X11显示器：\n1ffmpeg -f x11grab -video_size cif -framerate 25 -i :0.0 /tmp/out.mpg 2#使用ffmpeg通过0.0抓取X11显示器。X11服务器的屏幕号与display环境变量相同。 3 4 5ffmpeg -f x11grab -video_size cif -framerate 25 -i :0.0+10,20 /tmp/out.mpg 6#0.0是X11服务器的display.screen编号，与display环境变量相同。10是抓取的x偏移，20是抓取的y偏移。   可以使用YUV文件作为输入：\n1ffmpeg -i /tmp/test%d.Y /tmp/out.mpg 2 3#会使用文件： 4#/tmp/test0.Y, /tmp/test0.U, /tmp/test0.V, 5#/tmp/test1.Y, /tmp/test1.U, /tmp/test1.V, etc... 6#Y文件的分辨率是U和V文件的两倍。它们是原始文件，没有标题。它们可以由所有像样的视频解码器生成。如果ffmpeg无法猜测，则必须使用-s选项指定图像的大小。   从原始YUV420P文件输入\n1ffmpeg -i /tmp/test.yuv /tmp/out.avi 2 3#test.yuv是一个包含原始yuv平面数据的文件。每一帧由Y平面、U平面和V平面组成，具有半垂直和水平分辨率。   可以输出到原始YUV420P文件：\n1ffmpeg -i mydivx.avi hugefile.yuv   可以设置多个输入文件和输出文件：\n1ffmpeg -i /tmp/a.wav -s 640x480 -i /tmp/a.yuv /tmp/a.mpg 2#将音频文件a.wav和原始YUV视频文件a.YUV转换为MPEG文件a.mpg。   同时进行音频和视频转换：\n1ffmpeg -i /tmp/a.wav -ar 22050 /tmp/a.mp2 2#以22050 Hz的采样率将.wav转换为MPEG音频   同时编码为多种格式，并定义从输入流到输出流的映射：\n1ffmpeg -i /tmp/a.wav -map 0:a -b:a 64k /tmp/a.mp2 -map 0:a -b:a 128k /tmp/b.mp2 2#将.wav转换为64 kbits的a.mp2和128 kbits的b.mp2。 3#-map file:index按照输出流的定义顺序指定每个输出流使用哪个输入流。   对解密的VOB进行转码：\n1ffmpeg -i snatch_1.vob -f avi -c:v mpeg4 -b:v 800k -g 300 -bf 2 -c:a libmp3lame -b:a 128k snatch.avi 2 3#这是一个典型的DVD翻录示例；输入是VOB文件、输出是具有MPEG-4视频和MP3音频的AVI文件。 4#请注意，在此命令中，我们使用B帧，因此MPEG-4流与DivX5兼容，GOP大小为300，这意味着对于29.97fps的输入视频，每10秒有一个帧内帧。 5#此外，音频流是MP3编码的，因此您需要通过传递--enable-libmp3lame进行配置来启用LAME支持。该映射对于DVD转码以获得所需的音频语言特别有用。   从视频中提取图像：\n1ffmpeg -i foo.avi -r 1 -s WxH -f image2 foo-%03d.jpeg 2 3#这将从视频中每秒提取一个视频帧，并将其输出到名为foo-001.jpeg、foo-002.jpeg等的文件中。图像将被重新缩放以适应新的WxH值。 4#如果只想提取有限数量的帧，可以将上述命令与-frames:v或-t选项结合使用，或与-ss结合使用，从某个时间点开始提取。   从许多图像创建视频：\n1ffmpeg -f image2 -framerate 12 -i foo-%03d.jpeg -s WxH foo.avi 2 3#语法foo-%03d.jpeg指定使用由三个填充零的数字组成的十进制数来表示序列号。它与C printf函数支持的语法相同，但只有接受普通整数的格式才合适。 4#在导入图像序列时，-i还支持通过选择image2特定的-pattern_type glob选项在内部扩展类似shell的通配符模式（globbing）。 5 6ffmpeg -f image2 -pattern_type glob -framerate 12 -i \u0026#39;foo-*.jpeg\u0026#39; -s WxH foo.avi 7#为了从与glob模式foo-*.jpeg匹配的文件名创建视频   在输出中放入许多相同类型的流：\n1ffmpeg -i test1.avi -i test2.avi -map 1:1 -map 1:0 -map 0:1 -map 0:0 -c copy -y test12.nut 2 3#生成的输出文件test12.nut将以相反的顺序包含输入文件的前四个流。   强制CBR视频输出：\n1ffmpeg -i myfile.avi -b 4000k -minrate 4000k -maxrate 4000k -bufsize 1835k out.m2v   lmin、lmax、mblmin和mblmax这四个选项使用“lambda”单位，但您可以使用QP2LAMBDA常数轻松地从“q”单位转换：\n1ffmpeg -i src.ext -lmax 21*QP2LAMBDA dst.ext   场景 我目前的需求很简单，就是转换下格式及编码，还有推流。\n推流   推送rtp\n1ffmpeg - re - i cw.ts - vcodec copy - acodec copy - f rtp_mpegts rtp://238.123.46.66:8001 2 3ffmpeg -re -i chunwan.h264 -vcodec copy -f rtp rtp://233.233.233.223:6666\u0026gt;test.sdp 4#发送H.264裸流“chunwan.h264”至地址rtp://233.233.233.223:6666 5#最右边的“\u0026gt;test.sdp”用于将ffmpeg的输出信息存储下来形成一个sdp文件。该文件用于RTP的接收。当不加“\u0026gt;test.sdp”的时候，ffmpeg会直接把sdp信息输出到控制台。将该信息复制出来保存成一个后缀是.sdp文本文件，也是可以用来接收该RTP流的。加上“\u0026gt;test.sdp”后，可以直接把这些sdp信息保存成文本。   推送UDP\n1ffmpeg - re - i cw.ts - vcodec copy - acodec copy - f mpegts udp://238.123.46.66:8001 2 3ffmpeg -re -i chunwan.h264 -vcodec copy -f h264 udp://233.233.233.223:6666 4#发送H.264裸流“chunwan.h264”至地址udp://233.233.233.223:6666 5#-re一定要加，代表按照帧率发送，否则ffmpeg会一股脑地按最高的效率发送数据。 6#-vcodec copy要加，否则ffmpeg会重新编码输入的H.264裸流。 7 8ffmpeg -re -i chunwan.h264 -vcodec mpeg2video -f mpeg2video udp://233.233.233.223:6666 9#读取本地摄像头的数据，编码为MPEG2，发送至地址udp://233.233.233.223:6666。\t ","date":"2024-12-05","permalink":"/posts/tech/media-ffmpeg/","series":["媒体开发"],"tags":["","",""],"title":"FFmpeg媒体处理软件学习"},{"categories":["计算机"],"content":"先进行初步了解，如果后续有需要再看具体实现源码\nITU-T 官网 国际电联电信标准化部门（ITU-T）各研究组汇集了来自世界各地的专家，他们的工作是制定被称为ITU-T 建议书 的国际标准。这些国际标准是全球信息通信技术（ICT）基础设施的定义要素。标准对ICT的互连互通起着至关重要的作用，无论我们进行语音、视频通信还是数据消息交换，标准均可确保各国的ICT网络和设备使用相同的语言，从而实现全球通信\nITU-T的主要产品为建议书（ITU-T建议书），即确定电信工作运行和互通方法的标准。可通过以下链接获取。ITU-T建议书不具强制地位，只有在作为国家法律通过后才具有强制性。但由于其得到ITU-T秘书处和来自世界顶尖ICT公司的成员及全球各国主管部门共同保证的国际适用性和高质量，这些标准的遵从率达到很高水平。\n下载建议书：https://www.itu.int/rec/T-REC-G/e\nG711  类型：Audio\n制定者：ITU-T\n所需频宽：64Kbps\n特性：算法复杂度小，音质一般\n优点：算法复杂度低，压缩比小（CD音质\u0026gt;400kbps），编解码延时最短（相对其它技术）\n缺点：占用的带宽较高\n应用领域：voip（基于IP的语音传输（英语：Voice over Internet Protocol，缩写为VoIP））\n版税方式：Free\n备注：70年代CCITT公布的G.711 64kb/s脉冲编码调制PCM。\n 人耳只能感受到120个不同的声压级别，其在100万幅度范围内呈对数分布。换句话说，响度与声音幅度的关系是非线性的。利用人耳的这个听觉特性，可以对声音幅度进行非均匀量化，如果采用均匀量化，每个采样需要用12bit才能达到电话语音质量，采用非均匀量化，只需要8bit。\nPCMA采用A定律实现非均匀量化，PCMU采用μ定律。如图1所示，两者的曲线几乎完全相同。从图中可以直观地看到，对于幅度小的信号，量化间距较小，对于幅度大的信号，量化间距较大（因为对于幅度大的信号，轻微的幅度变化人耳并不能识别）。\n标准PCM语言编码 概述 PCM音频格式编码为A律13折线编码。\n电话信号数字化的一个国际标准。\n 电话信号频带：300～3400Hz 采样率：8000Hz（每秒采样8000个） 每个样值按A律十三折线编码规则编为8bit  ​\t于是最终速率每秒钟8*8000=64Kbps。\nA律十三折线编码规则属于对数量化，对数量化常用于解决输入信号的动态范围过大的问题。\n对数量化是非均匀量化，小信号量化更细，大信号量化相对较粗。\nA律十三折线编码规则 每个样值编为8bit： b1b2b3b4b5b6b7b8， 分为三类：b1为极性码；b2b3b4为段落码；b5b6b7b8为段内码。\n  极性码：识别输入信号的极性是正（1）还是负（0） 。\n  段落码（绝对值）：范围从0到+A。A/2到A段落的b2b3b4编号为111；A/4到A/2段落编号为110；A/8到A/4段落编号为101；A/16到A/8段落为100；A/32到A/16段落011；A/64到A/32段落为010；A/128到A/64段落为001；0到A/128段为000。\n一共是将0到A这个范围分为了8段\n  段内码：对于每一个段落， 又是一个区间，将它均匀地分为16份，一直从0000到1111。所以b5b6b7b8这四个比特表示段落内的其中的一小段。\n  例：某A律十三折线PCM编码器设计输入范围是[-6,+6]V，若采样值为x=-2.4V，求样值编码。\n首先负的，b1=0；其次2.4位于1.5到3，于是段落码为110；将1.5到3分为16个间隔，于是2.4在第九个间隔，段内码为1001。于是01101001\n同样可以从编码知道采样值为多少。\nμ律 暂时没找到。\nPCMA和PCMU差别 PCMA（A律编码）和PCMU（μ律编码）都是G.711编解码器的变种，用于数字音频传播。PCMU提供更低的动态范围，因此音质相对较差，需要的宽带更少；PCMA则相反。所以PCMU更适合低带宽环境。\nPCM是脉冲编码调制， 是一种将模拟信号转为数字信号的方式，A律和μ律则是两种不同的信号压缩算法，用于提高数字信号的精度。PCMA和PCMU都是基于PCM的编码器，用于将语音信号转换为数字信号进行传输。\nffmpeg转化格式：\n1#转为A律格式 2ffmpeg -i input.wav -acodec g711alaw -ar 8000 -ac 1 output.g711a 3#转为μ律格式 4ffmpeg -i input.wav -acodec g711mulaw -ar 8000 -ac 1 output.g711a 将WAV格式转化为G.711 A-law格式； acodec设置音频编码格式； ar采样率（Hz）；ac通道数（1为单声道）\nReferences https://wenku.csdn.net/answer/06dc0ae965434c30bb3dc5ea786a346e\nhttps://www.jianshu.com/p/0a68226c57dd\nhttps://www.bilibili.com/video/BV1YT411S73e\n","date":"2024-12-03","permalink":"/posts/tech/media-pcmu/","series":["媒体开发"],"tags":["","",""],"title":"pcmu编码学习"},{"categories":["计算机"],"content":"安装 1sudo apt-get install sox 查看音频信息 1.通过play查看音频格式：\n1play music.mp3 出错play FAIL formats: no handler for file extension `mp3\u0026rsquo;的解决：\n1sudo apt-get install libsox-fmt-mp3 效果：\n1$play music.mp3 2play WARN alsa: can\u0026#39;t encode 0-bit Unknown or not applicable 3 4music.mp3: 5 6 File Size: 8.02M Bit Rate: 195k 7 Encoding: MPEG audio 8 Channels: 2 @ 16-bit Track: 1 9Samplerate: 48000Hz Album: ノアール 10Replaygain: off Artist: 傘村トータ/小春六花 11 Duration: 00:05:28.20 Title: ノアール 12 13In:2.91% 00:00:09.56 [00:05:18.64] Out:459k [ -===|===- ] Clip:0 2.使用soxi或者sox --i：\n1$soxi music.mp3 2 3Input File : \u0026#39;music.mp3\u0026#39; 4Channels : 2 5Sample Rate : 48000 6Precision : 16-bit 7Duration : 00:05:28.20 = 15753600 samples ~ 24615 CDDA sectors 8File Size : 8.02M 9Bit Rate : 195k 10Sample Encoding: MPEG audio (layer I, II or III) 11Comments : 12Title=ノアール 13Artist=傘村トータ/小春六花 14Album=ノアール 15Tracknumber=1 16Discnumber=01 功能 1sox [global-options] 2[format-options] infile1 3[[format-options] infile2] ... 4[format-options] outfile 5[effect [effect-options]] ... 格式转化 基础知识 对于音频数据格式的描述，主要通过以下 4 种属性：\n 采样率（sample rate）：指声音由模拟信号转换成数字信号的过程中，每秒从连续信号中提取的用于组成离散信号的样本个数。 音频CD所用的采样率为 44100 Hz，数字音频磁带和许多计算机系统使用 48000 Hz，专业级音频系统通常使用 96000 Hz。 采样大小（sample size 或 Precision）：音频采样时用于存储每个样本的数据位数（bits）。如今 16 bit 的采样大小已被广泛使用，24 bit 主要用于专业音频领域。 编码格式（data encoding）：即每个音频样本的表示（即“编码”）方式。常用的编码类型包括 floating-point、μ-law、ADPCM、singed-integer PCM、MP3 和 FLAC 等。 通道（channel）：即文件中包含的音频通道的数量。其中单声道（mono）和双声道（stereo）是最常见的两种，“环绕声”音频（Surround sound）通常包含六个或更多声道。  此外，音频文件还使用比特率（Bit Rate）表示一个单位时间内编码音频信号占用的存储空间大小， 它的数值一般取决于所有的上述四个参数。 MP3 编码的立体声音乐通常具有 128-196kbps 的比特率， FLAC 编码的立体声音乐通常具有 550-760kbps 的比特率。\nSoX 可以处理 self-describing 和 raw 格式的音频文件。 self-describing 格式（如 WAV、FLAC、MP3）的文件包含一个用于描述信号和编码属性的文件头，而 raw 或 headless 格式的音频则不包含这些信息。\n所以当 raw 格式的音频作为输入文件时，需要在 sox 命令的格式选项里指定其信号和编码属性。\n常用的音频格式选项：\n   选项 描述     -b, \u0026ndash;bits BITS 每个编码样本占用的数据位数   -c, \u0026ndash;channels CHANNELS 音频文件包含的通道数   -e, \u0026ndash;encoding ENCODING 音频文件的编码类型   -r, \u0026ndash;rate RATE 音频文件的采样率   -t, \u0026ndash;type FILE-TYPE 音频文件的文件类型    上述选项适用于输入或输出文件，主要用于说明 raw（或 headless）文件作为输入时的格式信息，或格式转换时指定输出文件的具体参数。\n需要注意的是，-e参数指定的是紧跟在后面那个文件的编码，如果想要输出指定格式，就需要在input之后加上-e参数。\n命令   soxi或sox --i：命令可以通过分析音频文件的文件头，获取其元数据（如通道数、采样率、编码等）。soxi 命令跟上某个特定的选项可以只获取该选项对应的信息\n  sox \u0026lt;inputfile\u0026gt; -n stat：获取某音频文件的统计信息。\n  sox existing-file.wav −d或play existing-file.wav：播放音频\n  sox −d new-file.wav或rec new-file.wav：录制\n  play foo.wav trim 10.0 5.0或play foo.wav trim 10.0 =15.0：播放 foo.wav 文件中 10-15s 之间的音频片段\n  sox Faded.wav Faded.mp3：将 Faded.wav 文件的格式由 wav 转为 mp3\n  sox −r 48k −e float −b 32 −c 2 input.raw output.wav：将某个特定的 raw 格式的音频文件转换为 wav 格式\n-e参数在这种场景下指的是raw文件的，编码\n  sox Faded.wav Faded.raw：将音频文件 Faded.wav 转为 raw 格式\n  play -r 44800 -b 16 -e signed-integer -c 2 Faded.raw：播放 raw 格式的音频文件\n1play -r 48k -e signed-integer -b 16 -c 2 music.raw #这么播放mp3没问题 2play -r 48k -e unsigned-integer -b 16 -c 2 music.raw #换一种编码耳朵炸了   sox Faded.wav -c 1 Faded-mono.wav：将 Faded.wav 文件转换成单声（-c 1）后输出\n  音频效果 SoX 工具可以在音频处理的过程中，对输入的音频数据应用众多的效果。\nsox --help-effect all：查看所有效果的帮助信息\n1.更改声道数   sox foo.wav foostereo.wav channels 2或sox foo.wav -c 2 foostereo.wav：将单声道音频转换成双声道\n上述命令并没有创建一个“真实”的双声道音频，而是将单声道音频复制成完全一致的两个声道再合并到输出文件中。\n  sox -M left.wav right.wav stereo.wav：通过 sox 命令的 -M 选项将左右两个声道的单声道音频合并成一个双声道文件\n  sox original.wav mono.wav channels 1或sox original.wav -c 1 mono.wav：通过对双声道文件中两个声道的均一化处理，将其输出为单声道音频\n  sox stereo.wav left.wav remix 1：提取双声道音频文件中单个声道的数据并作为单声道音频输出（提取左声道音频）\n  sox stereo.wav left.wav remix 2：提取双声道音频文件中单个声道的数据并作为单声道音频输出（提取右声道音频）\n  sox stereo.wav mono.wav remix 1,2或sox stereo.wav mono.wav remix 1-2：融合双声道文件中两个声道的音频数据并作为单声道音频输出\n  sox -M stereo1.wav stereo2.wav output.wav remix 1,3 2,4：使用 -M 选项将两个双声道音频合并，再通过 remix 将合并得到的四个声道两两融合，生成一个只包含两个声道的输出文件。\n  2.改变音量   sox -v 0.5 foo.wav bar.wav：-v 选项可以用来（成倍地）改变音量的大小， 将 foo.wav 音频放大 0.5 倍音量后输出至 bar.wav 文件\n  1$ sox foo.wav -n stat -v 2\u0026gt; vc 2$ sox -v `cat vc` foo.wav foo-maxed.wav 以 sox foo.wav -n stat -v 命令返回的数字作为放大倍数，将最大化 foo.wav 的音量而不至于出现削波\n  sox --norm=-1 \u0026lt;inputfile\u0026gt; \u0026lt;outputfile\u0026gt;：选项 --norm 用来归一化音频响度。为了最大化音频的声音强度，可以在处理输入音频时将该选项设置为 -1\n  3.提取文件的某个部分   sox Input.wav Half1.wav trim 0 30:00：截取输入文件中前 30 分钟的音频\n  sox Input.wav Half2.wav trim 30:00 30:00：截取输入文件中从第 30 分钟开始到第 60 分钟的音频\ntrim 接收两个参数，一个作为裁剪片段的起始位置，另一个作为该片段持续的时间。 可以使用整数+s格式的参数以样本个数作为计量单位，也可以直接使用 ((hh:)mm:)ss(.fs) 形式的时间参数。当参数为纯整数时，单位为秒。\n  4.拼接文件 sox Half1.wav Half2.wav Full.wav：将 Half1.wav 和 Half2.wav 合并至 Full.wav 文件。\n注意合并前的音频文件需保持一致的类型和采样率等\n5.合成音频 sox -n sine.wav synth 1.0 sine 1000.0：合成频率为 1000 Hz 长度为 1 秒的正弦波，保存至 sine.wav 文件中。\nsynth 支持合成的声音类型包括 sine、square、triangle、sawtooth、trapetz (trapezoidal)、exp (exponential)、whitenoise、pinknoise 和 brownnoise。\n6.静音效果 创建静音状态的音频片段，使用 -n 选项表示没有输入，通过 trim 效果指定需要静音的片段。\nsox -n -r 48000 silence.wav trim 0.0 0.250：在 slience.wav 文件中创建一段长度为 250ms 采样率为 48000Hz 的静音片段。\n7.混合音频  sox -m sine100.wav sine250.wav sine100-250.wav：将 sine100.wav 和 sine250.wav 两个音频文件融合以后作为 sine100-250.wav 文件的音频数据。 sox -m -v0.5 music.mp3 -v2 speech.wav presentation.wav：将背景音乐（music.mp3）音量降低一半后与放大 2 倍音量的人声数据（speech.wav）融合。  play -m -v0.5 music.mp3 -v2 speech.wav：如果不确定融合效果，可以先通过 play 命令使用相同的参数对结果进行“预览”  与前面的 -M 选项不同，-m 选项倾向于对声道数据的混合，即两个单声道文件通过 -m 混合以后输出仍是单声道数据。输出文件中的单个声道包含了输入的两个声道的特征。\n而 -M 选项更倾向于对音频文件的合并，默认不对声道数据进行混合。所以两个单声道文件通过 -M 合并以后默认输出双声道音频。输出文件中的两个声道分别对应于输入的两个声道（数据没有混合）。除非通过 -c 选项手动指定输出文件的声道数量。\n8.改变播放速度   play Faded.wav stretch 0.5：以 2x 倍速播放 Faded.wav 文件，stretch同时不会导致音高的变化。\n  play Faded.wav speed 2：通过 speed 效果调节播放速度（相应地音高也会发生变化）\n这样就可以创建网络上的鬼畜音效了。\n  play Faded.wav pitch 200：使用 pitch 效果调节音频片段的音高，以音分 （cents）为单位。将 Faded.wav 文件中的音频提高 200 音分，即提高 2 个半音的音程（每一个半音的音程等于 100 音分）。\n  问题处理 sox使用时经常不支持一些格式，需要另外下载安装：\n  play FAIL formats: no handler for file extension `mp3'\n解决： sudo apt-get install libsox-fmt-mp3\n  armnb,armwb不支持\n解决：https://blog.csdn.net/weixin_39573512/article/details/111802538\n  场景 要求可以处理裸文件，带头的文件，wav(pcm,pcma,pcmu),vox, amrnb, amrwb互转。\n文件信息：\n1$soxi music.mp3 2 3Input File : \u0026#39;music.mp3\u0026#39; 4Channels : 2 5Sample Rate : 48000 6Precision : 16-bit 7Duration : 00:05:28.20 = 15753600 samples ~ 24615 CDDA sectors 8File Size : 8.02M 9Bit Rate : 195k 10Sample Encoding: MPEG audio (layer I, II or III) 11Comments : 12Title=ノアール 13Artist=傘村トータ/小春六花 14Album=ノアール 15Tracknumber=1 16Discnumber=01  转PCM：  1sox music.mp3 pcm.wav 2 3$soxi pcm.wav 4 5Input File : \u0026#39;pcm.wav\u0026#39; 6Channels : 2 7Sample Rate : 48000 8Precision : 16-bit 9Duration : 00:05:28.18 = 15752448 samples ~ 24613.2 CDDA sectors 10File Size : 63.0M 11Bit Rate : 1.54M 12Sample Encoding: 16-bit Signed Integer PCM 转PCMU：  1$sox music.mp3 -e mu-law mulaw.wav 2sox WARN dither: dither clipped 5 samples; decrease volume? 3 4$soxi mulaw.wav 5 6Input File : \u0026#39;mulaw.wav\u0026#39; 7Channels : 2 8Sample Rate : 48000 9Precision : 14-bit 10Duration : 00:05:28.18 = 15752448 samples ~ 24613.2 CDDA sectors 11File Size : 31.5M 12Bit Rate : 768k 13Sample Encoding: 8-bit u-law 转PCMA：  1$sox music.mp3 -e a-law alaw.wav 2sox WARN dither: dither clipped 4 samples; decrease volume? 3 4$soxi alaw.wav 5 6Input File : \u0026#39;alaw.wav\u0026#39; 7Channels : 2 8Sample Rate : 48000 9Precision : 13-bit 10Duration : 00:05:28.18 = 15752448 samples ~ 24613.2 CDDA sectors 11File Size : 31.5M 12Bit Rate : 768k 13Sample Encoding: 8-bit A-law 14  转vox\nvox应该是规范的问题，采样率只能8k最大，声道数只能是1，且指定不了采样大小。\n  1$sox music.mp3 -r 8k -c 1 vox.vox 2 3$play vox.vox 4play WARN alsa: can\u0026#39;t encode 0-bit Unknown or not applicable 5play WARN raw: `vox.vox\u0026#39;: sample rate not specified; trying 8kHz 6 7vox.vox: 8 9 File Size: 1.31M Bit Rate: 32.0k 10 Encoding: OKI ADPCM 11 Channels: 1 @ 12-bit 12Samplerate: 8000Hz 13Replaygain: off 14 Duration: 00:05:28.18 15 16In:4.99% 00:00:16.38 [00:05:11.79] Out:131k [ -==|==- ] Clip:0 17Aborted. ","date":"2024-12-03","permalink":"/posts/tech/media-sox/","series":["媒体开发"],"tags":["","",""],"title":"Sox媒体处理软件基本使用"},{"categories":["普通类"],"content":"如果我们的注意力不集中, 这不是好事, 但个人认为也不是坏事; 相反, 如果注意力过度集中, 那毫无疑问就是坏事了.\n为什么注意力太集中是坏事呢? 我个人认为人的思考范围就如果函数调用一般, 如果你开始做某件事, 那么你的思维范围就缩小了, 限制在一个相对较小的范围(相比发呆和无所事事的情况). 于是乎非常多的东西便不存在了, 脑中只存在几个固定的紧要的事物, 这会导致判断错误.\n判断事物应当放到世界的全局, 人生的全局, 时间的全局, 这样的尺度去判断. 当你专心致志做事时(不局限于做事), 许多东西变得不可见, 这是真正意义上的不可见, 在那种情况下, 即便你绞尽脑汁思考之外的事物也是徒劳的. 当条件模糊, 情绪起来之后, 人们便会做出非常不可靠的判断.\n诸如各类心理疾病, 自杀, 被骗等等都是如此现象. 虽然我们始终无法做到全局视角, 但是请牢记存在这一现象, 这会让你的\u0026quot;上头\u0026quot;的动量减弱.\n","date":"2024-12-02","permalink":"/posts/other/human-mind-weekness/","series":["随意思考"],"tags":[],"title":"上头与下头与suicide"},{"categories":["普通类"],"content":"搁置\n2024.12.week1 电梯生存指南：职场新人的必读宝典 | 经济学人商业 1.重点单词\n Etiquette - 礼仪\nVague - 模糊的\nExposed - 暴露的\nIncompetence - 无能\nAwkwardness - 尴尬\nElaborate - 精心设计的\nAgonisingly - 痛苦地\nProlonged - 延长的\nFeasible - 可行的\nEmit - 发出\nScurry - 匆忙跑开\nDisturbing - 令人不安的\nFixedly - 固定地\nCalibrate - 校准\nAscent - 上升\nDescent - 下降\nCrucial - 至关重要的\nTribal - 部落的\nCrackles - 噼啪作响\nignite - 点燃\nincompetence - 无能，能力不足\ninternship - 实习\nprogramme - 程序， 项目\nutterly - 完全的\nproximity - 接近，亲近\nelaborate - 复杂的，详尽的\nbowerbird - 园丁鸟\nhigh-pitched - 尖锐的，声调高的\nparachute - 跳伞\nceiling - 天花板\nConvention - 公约\nsaloon - 酒吧\nhostility - 敌意\nglare - 怒目而视\ntattoos - 纹身\n 2.词组\n Office etiquette - 办公室礼仪\nElevator pitch - 电梯演讲\nStand well back - 站得远远的\nGround-floor lift - 一楼电梯\nMeditation app - 冥想应用\nEnemy lines - 敌方阵线\nTailor your behaviour - 调整你的行为\nTake account of - 考虑到\nTricky territory - 棘手的领域\nTribal places - 部落化的地方\nwho might be earwigging - 隔墙有耳\ntake it personally - 往心里去\n 3.固定搭配\n With that in mind - 考虑到这一点\nMake your way to - 前往\nPerform a dance - 跳舞\nStep out - 走出\nStep back - 退后\nLook up - 抬头\nGet out - 出去\nChat away - 畅聊\nSqueeze right in - 挤进去\nMove on to - 转向\nit depends - 看情况\nright in front of - 非常近\nducking and bobbing - 又躲又跳\non your own - 独自\nbe prone to - 容易， 易于\u0026hellip;\nsmile thinly - 浅浅微笑\n How to behave in lifts: an office guide Life in an elevator\nA man waiting for the lift, which is full of people.\nCongratulations on joining our internship programme. For most of you this is your first experience of the workplace, and with that in mind we have prepared a guide to office etiquette. Other chapters cover what to wear (more), when to use emojis (less) and when to speak in meetings (it depends).\nThe first chapter is on lifts. If this is your first job, you may have a vague idea that this is where people make elevator pitches. Wrong. However much time you spend in a lift, you will never hear anyone proposing ideas that will change the world or ignite their careers. Instead, you will be exposed to a mixture of disappointment, incompetence and awkwardness as you gradually make your way to your destination. As a way of understanding what it’s like to be at work, in other words, it’s an ideal place to start. Here are a few basic tips.\nWhen people are waiting for a lift, someone will stand right in front of the doors, so close that their breath mists the metal. In the lift that is descending towards them, someone else will be standing as close as possible to their set of doors. When the doors open, these two individuals will be utterly shocked by the proximity of the other. They will then perform an elaborate little dance, like bowerbirds ducking and bobbing in search of a mate, before moving out of the way. You should always stand well back and let people out first.\nWhen you enter a ground-floor lift on your own, there will be an agonisingly long wait for the doors to close. This wait will be prolonged enough that you will assume the lift is broken. Do not do anything. If you try to step out, the doors will start to close and you will curse and step back inside. When they finally start to shut again, someone unseen will put an arm into the gap, causing the doors to open once more. A body will eventually follow. This may well be repeated several times until you want to cry. If you are prone to stress, take the stairs or, if that is not feasible, listen to a meditation app.\nWhen you are catching a lift back down, someone will come out of it on your floor while looking at their phone. They will eventually look up and realise that this is not where they were meant to get out. They will emit a small, high-pitched noise and scurry back into the lift. They will then describe what has just happened, even though you were there. “I thought that was the ground floor,” they will say. When this happens you must laugh in a friendly way. It is an oddly disturbing experience for people to enter another company’s territory without permission, a bit like being parachuted behind enemy lines in error.\nDeciding whether to start a conversation in a lift depends on three factors: familiarity, fullness and floor. If you are in a lift with someone you don’t know, it’s very simple: say nothing, smile thinly and then look fixedly at the ceiling. If you must, say “Good morning”, but nothing more. You cannot network or form friendships in a lift; you can only make strangers fear for their safety.\nIf you get in with someone you work with and know well, chat away. But if there are other people in there, tailor your behaviour to take account of who might be earwigging. Do not say “Isn’t Keith amazingly short?” when Keith’s friends might be in there with you. Or, buried deep among the crowd, Keith.\nIf you get in a lift with someone you know vaguely, you are in very tricky territory. A nod may suffice but you may have to speak to them. You must calibrate conversation to the length of the journey. If you have just two floors of ascent or descent together, do not ask for their views on the Geneva Convention. (Actually, no matter what the circumstances, don’t ask for their views on the Geneva Convention.) Whenever a crowd is entering a lift, the person who has to exit first must stand at the very back. No one knows why this rule exists but it is crucial. So if you are getting out on the second floor, make sure to squeeze right in.\nOffices are tribal places, and so are lifts. Entering a crowded lift on the way down is the equivalent of going into a saloon in a Western. No one is pleased to see you; the air crackles with hostility. Do not take it personally: just get in and take up as little space as possible. By the time someone on the next floor tries to enter, you will be part of the in-group and can glare at them. There are other rules. That mirror is not actually for getting dressed. Reaching across someone to press the buttons requires extreme care. But these will do for starters. Let’s move on to tattoos.\n2024.12.week2 这周有些杂事，故不更新。\n2024.12.week3 单词：\n surreal - 超现实的\nsprawling - 蔓延的，庞大的\nlandmark - 里程碑的\nproclamations - 宣告，公告\nformidable - 艰巨的，令人生畏的\ncaricatured - 讽刺化的\nscions - 后裔，子孙\nkaleidoscope - 万花筒\nentrancing - 使人着迷的\napprehensive - 忧虑的，不安的\nverbatim - 逐字的\nmundane - 平凡的，世俗的\nsensuality - 感官享受\nincest - 乱伦\npaedophilia - 恋童癖\nresonance - 共鸣，回响\n 词组：\n do justice to - 公正对待\nmagical realism - 魔幻现实主义\nfamily tree - 家谱\namber-coloured oil - 琥珀色油\nexistential kind - 存在主义类型\nglobal resonance - 全球共鸣\n 固定搭配：\n opt to - 选择\ncompress into - 压缩成\npoint to - 指向\ntrace the fortunes - 追溯命运\nyield to - 屈服于\ndraw on - 借鉴，利用\nresonate with - 与\u0026hellip;产生共鸣\n Culture | From the shelf（沙发） to the couch（沙发）\nDoes great literature translate into great television?\nNetflix hopes so, with its adaptation（改编本） of Gabriel García Márquez’s “One Hundred Years of Solitude”\nIT WOULD BE hard, Gabriel García Márquez thought, to do justice to the surreal, sprawling（庞大的） tale on screen. By his reckoning（预计）, “One Hundred Years of Solitude”, his landmark novel of 1967, would need a runtime of 100 hours; it would also have to be filmed in Colombia, entirely in Spanish.\nNetflix, with the support of Márquez’s estate（遗产）, has honoured（兑现） two of those three proclamations（公告）. The streamer（流媒体公司） boasts（吹嘘） that its new adaptation of Márquez’s novel—the first on screen—is “one of the most ambitious productions in Latin American history”. (“Ambitious” is also a synonym（同义词） for “expensive”: Netflix will not reveal the budget but claims it is the largest ever for a production in the region.) But keeping in mind how much solitude viewers actually want, it has opted to compress Márquez’s novel into 16 episodes, with the first tranche（一部分） released on December 11th.\nThe book presents a formidable challenge to film-makers for two reasons. One is its status: many think “One Hundred Years of Solitude” was the greatest novel of the 20th century. It helped Márquez to win the Nobel prize in literature in 1982 and has sold some（约） 50m copies worldwide. With affection comes expectation. When the TV show was announced, fans online were quick to express their fears about an oversimplified, “caricatured”（滑稽地描述） retelling.\nThose remarks point to the other test for adaptors, which is the novel’s sheer complexity. Set in around 1850-1950, the book traces the fortunes（发展变化的趋势） of the Buendía family across several generations, from the time José Arcadio and his wife, Úrsula, establish the town of Macondo to the moment their last descendant（后代） dies, with civil war, modernisation, economic prosperity and ruin in between.\nTime, in this tale, is a “turning wheel” that yields “unavoidable repetitions”. Male scions are all called some combination of José, Arcadio or Aureliano. (Readers everywhere are grateful to whoever thought to include a family tree at the front of the book.) There are more unusual occurrences（事件）, too. Characters die, only to return as ghosts. One man is permanently surrounded by a kaleidoscope of yellow butterflies; another cracks his head open, leaking not blood but an “amber-coloured oil that was impregnated（充满） with that secret perfume”.\nOn the page this magical realism, as Márquez’s style came to be known, can be entrancing（着迷）. The risk is that it could look oddly unconvincing on screen. When Netflix approached Alex García López, a director, about the project, he was excited but apprehensive. “I remember the book having very little dialogue. I remember it being a very existential kind of book and jumping all over the place. I just thought: ‘This is just not really doable（可行）, is it?’”\nIt was. José Rivera, one of the screenwriters（电影剧本作家）, decided that the story should proceed chronologically（按时间顺序的） and that it needed a narrator. It quotes from the novel verbatim. “It was a great way of having Gabo’s voice guide us through the story,” Mr Lopez says, and a way to be “faithful to the book…to its execution（制作，表演）, to its style”.\nAs a result, the film-makers have captured the strangeness of the story, in which events are at once（一起，同时） fantastical and mundane[mʌnˈdeɪn]. They have also retained its sensuality. At times this makes for uneasy viewing: the novel recounts（讲述） several incidents of incest and one of paedophilia. “We do not want to rewrite history,” asserts Francisco Ramos, Netflix’s vice president of Latin American content: “That’s the way things happened.” In fact, keeping in Aureliano’s wooing（追求，求爱） of Remedios, a nine-year-old girl, makes the tale more timely. Only last month Colombia passed legislation prohibiting anyone under the age of 18 from getting married.\nTo write “One Hundred Years of Solitude” Márquez drew on（借鉴） his childhood town of Aracataca. The novel “couldn’t be more specific and more grounded…in a very specific part of a huge, huge country,” Mr Ramos says, but “because of the way he tells the story it has global resonance”. Almost 60 years later, Netflix is hoping this is true of its version. Márquez’s book, after all, is about history repeating itself.\n","date":"2024-12-01","permalink":"/posts/other/everyweek-english/","series":[],"tags":[],"title":"每周一篇经济学人"},{"categories":["计算机"],"content":"https://cloud.tencent.com/developer/article/2142074\n一、概述 利用 GNU Autoconf 及 Automake 这两套工具来协助我们自动产生 Makefile文件，并且让开发出来的软件可以像大多数源码包那样，只需\u0026quot;./configure\u0026quot;, \u0026ldquo;make\u0026rdquo;,\u0026ldquo;make install\u0026rdquo; 就可以把程序安装到系统中。\n目前automake支持三种目录层次：flat、shallow和deep：\n  flat指的是所有文件都位于同一个目录中。\n就是所有源文件、头文件以及其他库文件都位于当前目录中，且没有子目录。Termutils就是这一类。\n  shallow指的是主要的源代码都储存在顶层目录，其他各个部分则储存在子目录中。\n就是主要源文件在当前目录中，而其它一些实现各部分功能的源文件位于各自不同的目录。automake本身就是这一类。\n  deep指的是所有源代码都被储存在子目录中；顶层目录主要包含配置信息。\n就是所有源文件及自己写的头文件位于当前目录的一个子目录中，而当前目录里没有任何源文件。\n  二、安装 三、基本使用 1graph TB; 2source[源码root]; 3configure.scan; 4configure.in; 5aclocal.m4; 6configure; 7Makefile.am; 8Makefile.in; 9Makefile; 10start(开始) 11start2(开始) 12 13start2 --编程--\u0026gt;source; 14source --autoscan--\u0026gt; configure.scan; 15configure.scan --手动编辑--\u0026gt; configure.in; 16configure.in --aclocal--\u0026gt; aclocal.m4; 17configure.in --autoconf--\u0026gt; configure; 18aclocal.m4 --autoconf--\u0026gt; configure; 19start --手动创建--\u0026gt; Makefile.am 20Makefile.am --automake--\u0026gt; Makefile.in; 21configure.in --\u0026gt; Makefile.in; 22Makefile.in --\u0026gt; Makefile 23configure --\u0026gt; Makefile; 1.编写C代码文件 1vim app.c 1#include \u0026lt;stdio.h\u0026gt;2#include \u0026lt;stdlib.h\u0026gt;3 4int main(int argc, char **argv){ 5\tint i; 6\tfor(i=0; i\u0026lt;argc; i++){ 7\tprintf(\u0026#34;argv[%d]=%s\\n\u0026#34;, i, argv[i]); 8\t} 9\treturn 0; 10} 2.执行autoscan命令生成configure.scan文件 生成configure.scan文件之后，将文件修改成configure.ac文件，如果没有这个.ac文件，执行aclocal命令的时候会报错。\n1autoscan 2ls 3mv configure.scan configure.ac 3.修改configure.ac文件参数 初始生成的configure.ac：\n1# -*- Autoconf -*- 2# Process this file with autoconf to produce a configure script. 3 4AC_PREREQ([2.71]) 5AC_INIT([FULL-PACKAGE-NAME], [VERSION], [BUG-REPORT-ADDRESS]) 6AC_CONFIG_SRCDIR([app.c]) 7AC_CONFIG_HEADERS([config.h]) 8 9# Checks for programs. 10AC_PROG_CC 11 12# Checks for libraries. 13 14# Checks for header files. 15 16# Checks for typedefs, structures, and compiler characteristics. 17 18# Checks for library functions. 19 20AC_OUTPUT 每个configure.ac文件都是以AC_INIT开头，以AC_OUTPUT结束。\nAC_PROG_RANLIB如果是多线程的程序的话要加入这句话,要不运行automake命令时会出错\n AC_INIT 测试程序 测试函数库 测试头文件 测试类型定义 测试结构 测试编译器特性 测试库函数 测试系统调用 AC_OUTPUT\n 文件解释：\n  AC_PREREQ宏声明本文件要求的autoconf版本，本例使用的版本为2.71。\n  AC_INIT()中分别的是: 软件包的名字，版本，作者的联系方式(一般是Email)\nAC_INIT宏用来定义软件的名称和版本等信息，”FULL-PACKAGE-NAME”为软件包名称，”VERSION”为软件版本号，”BUG-REPORT-ADDRESS”为BUG报告地址（一般为软件作者邮件地址）。\n1AC_INIT([app], [1.1.2], [1126626497@qq.com])   在下面再自己添加一行AM_INIT_AUTOMAKE()，里面填入: 程序名字，版本号。\n1AM_INIT_AUTOMAKE(app,1.1.2)   AC_CONFIG_SRCDIR宏用来侦测所指定的源码文件是否存在，来确定源码目录的有效性。此处为当前目录下的app.c。\n  AC_CONFIG_HEADER宏用于生成config.h文件，以便autoheader使用。\n  AC_PROG_CC用来指定编译器，如果不指定，选用默认gcc。 比如: AC_PROG_CC(gcc)\n  AC_OUTPUT用来设定 configure 所要产生的文件，如果是makefile，configure会把它检查出来的结果带入makefile.in文件产生合适的makefile。使用Automake时，还需要一些其他的参数，这些额外的宏用aclocal工具产生。（如上流程图）\n最后AC_OUTPUT()填写生成的文件名称。\n1AC_OUTPUT(Makefile)   修改之后的configure.ac：\n1# -*- Autoconf -*- 2# Process this file with autoconf to produce a configure script. 3 4AC_PREREQ([2.71]) 5AC_INIT([app], [1.1.2], [bnaod1@qq.com]) 6AM_INIT_AUTOMAKE(app,1.1.2) 7AC_CONFIG_SRCDIR([app.c]) 8AC_CONFIG_HEADERS([config.h]) 9 10# Checks for programs. 11AC_PROG_CC 12 13# Checks for libraries. 14 15# Checks for header files. 16 17# Checks for typedefs, structures, and compiler characteristics. 18 19# Checks for library functions. 20 21AC_OUTPUT(Makefile) 4.执行aclocal命令生成aclocal.m4文件 1aclocal 2ls 5.使用autoconf工具生成configure文件 1autoconf 2ls 6.使用autoheader生成config.h.in文件 1autoheader 7.手工编辑Makefile.am文件 Makefile.am是一种比Makefile更高层次的规则。只需指定要生成什么目标，它由什么源文件生成，要安装到什么目录等构成。\nAutomake工具会根据config.in中的参量把Makefile.am转换成Makefile.in文件。在使用Automake之前，要先手动建立Makefile.am文件。\n文件创建之后，需要写三项代码：\n  第一项：软件规范，有三个候选项：foreign(国外),gnu(GNU),gnits\n如果使用foreign等级，它只检测必须的文件\n  第二项：生成的可执行文件名\n  第三项：生成可执行文件所需的原始文件，有多个文件时用空格隔开。\n  1touch Makefile.am 2vim Makefile.am 1AUTOMAKE_OPTIONS=foreign 2bin_PROGRAMS=app 3app_SOURCES=app.c 8.使用automake命令生成Makefile.in文件 添加选项\u0026ndash;add-missing 可以让automake工具自动添加必要的脚本文件\n注意: 不能在共享目录下执行，因为共享目录下是windows文件系统(FA32/NTFS),不支持link操作。\n1automake 9.运行configure配置生成最终的Makefile文件 configure脚本为了让一个程序能够在各种不同类型的机器上运行而设计的。在使用make编译源代码之前，configure会根据自己所依赖的库而在目标机器上进行匹配。\n约定俗成的，所有的configure脚本都把脚本文件名起为configure，一般来讲都是shell脚本，根据所在的系统环境生成makefile文件。\nconfigure脚本运行时扫描当前环境，生成一个名为config.status的子脚本。子脚本将Makefile.in文件转换为适应于当前系统环境的Makefile文件。\n1$./configure 2checking for a BSD-compatible install... /usr/bin/install -c 3checking whether build environment is sane... yes 4checking for a race-free mkdir -p... /usr/bin/mkdir -p 5checking for gawk... gawk 6checking whether make sets $(MAKE)... yes 7checking whether make supports nested variables... yes 8checking for gcc... gcc 9checking whether the C compiler works... yes 10checking for C compiler default output file name... a.out 11checking for suffix of executables... 12checking whether we are cross compiling... no 13checking for suffix of object files... o 14checking whether the compiler supports GNU C... yes 15checking whether gcc accepts -g... yes 16checking for gcc option to enable C11 features... none needed 17checking whether gcc understands -c and -o together... yes 18checking whether make supports the include directive... yes (GNU style) 19checking dependency style of gcc... gcc3 20checking that generated files are newer than configure... done 21configure: creating ./config.status 22config.status: creating Makefile 23config.status: creating config.h 24config.status: executing depfiles commands 10.使用Makefile编译，运行程序 1$make 2make all-am 3make[1]: 进入目录“/home/zhaoxiaoqi/code/c/test-automake” 4gcc -DHAVE_CONFIG_H -I. -g -O2 -MT app.o -MD -MP -MF .deps/app.Tpo -c -o app.o app.c 5mv -f .deps/app.Tpo .deps/app.Po 6gcc -g -O2 -o app app.o 7make[1]: 离开目录“/home/zhaoxiaoqi/code/c/test-automake” 8 9$./app 1 2 3 10argv[0]=./app 11argv[1]=1 12argv[2]=2 13argv[3]=3 11.Make支持的其他命令 1#清除目标文件 2make clean 3#将源文件打包 4make dist 5#编译源文件生成目标文件 6make 7#将目标文件拷贝到指定目录下 8make install 四、configure文件详解 五、多个文件生成Makefile示例(同级目录) 现在目录下有main.c， print.c， sum.c三个c文件，config.h，sum.h两个头文件\n修改Makefile.am内容：\n1AUTOMAKE_OPTIONS=foreign 2bin_PROGRAMS=app 3app_SOURCES=main.c print.c sum.c 六、Makefile.am格式详解 Makefile.am中可用的全局变量    变量 含义     INCLUDES 链接所需要的头文件   LDADD 链接所需要的库文件   LDFLAGS 链接所需要的库文件选项标志   EXTRA_DIST 配置打包时需要打包的其他文件   SUBDIRS 设置处理本目录之前需要递归处理的子目录    例：\n1SUBDIRS=src/lib src/ModuleA/apple/shell src/ModuleA/apple/core 2CURRENTPATH=$(shell /bin/pwd) 3INCLUDES=-I $(CURRENTPATH)/src/include -I $(CURRENTPATH)/src/ModuleA/apple/include 4export INCLUDES Makefile.am中可用的路径变量 在Makefile.am中尽量使用相对路径，系统预定义了两个基本路径：\n   路径变量 含义     $(top_srcdir) 工程最顶层目录，用于引用源程序   $(top_builddir) 定义了生成目标文件最上层目录，用于引用.o 等一些编译出来的目标文件   $(prefix) 定义了软件的安装的路径      automake标准安装路径\n默认安装路径为：$(prefix) = /usr/local，可以通过./configure \u0026ndash;prefix=\u0026lt;new_path\u0026gt;的方法来覆盖。\n其它的预定义目录还包括：bindir = (prefix)/bin,libdir=(prefix)/lib, datadir = (prefix)/share,sysconfdir=(prefix)/etc等等。\n  定义一个新的安装路径\n比如test, 可定义testdir = (prefix)/test,然后test_DATA=test1 test2，则test1，test2会作为数据文件安装到(prefix)/ /test目录下。\n  例:\n1devicedir = ${prefix}/dev 2device_DATA = package 3#package文件会作为数据文件安装到dev目录之下，这相当于定义了一种安装类型：devicedir，所以想怎么安装就怎么安装，后面的XXXXXdir，dir是固定不变的 Makefile.am一般格式 PROGRAMS。表示可执行文件\nLIBRARIES。表示静态库文件\nLTLIBRARIES。表示动态库文件，前面的LT表示libtool。\nHEADERS。头文件。\nSCRIPTS。脚本文件，这个可以被用于执行。如：example_SCRIPTS，如果用这样的话，需要我们自己定义安装目录下的example目录\nDATA。数据文件，不能执行。\n   文件类型 书写格式 示例     软件规范 AUTOMAKE_OPTIONS=foreign 有三个候选项： foreign(国外),gnu(GNU),gnits 如果使用foreign等级，它只检测必须的文   可执行文件 bin_PROGRAMS=foo foo_SOURCES=xxx.c foo_LDADD= foo_LDFLAGS= foo_DEPENDENCIES= bin_PROGRAMS=foo （设置可执行文件的名称） 如果可执行文件的名称为foo,后面的代码前缀，都需要填foo   静态库 lib_LIBRARIES=libfoo.a foo_a_SOURCES= foo_a_LDADD= foo_a_LIBADD= foo_a_LDFLAGS= 如果程序里使用了静态库编译,需要在configure.ac文件里增加以下宏定义代码 AC_PROG_RANLIB   动态库 lib_LTLIBRARIES=libfoo.la foo_la_SOURCES= foo_la_LDADD= foo_la_LIBADD=\nfoo_la_LDFLAGS= 如果程序里使用了动态库编译,需要在configure.ac文件里增加以下宏定义代码 AC_PROG_LIBTOOL 表示利用libtool 来自动生成动态库 编译共享库前,需要运行以下命令: libtoolize -f -c   头文件 include_HEADERS=xx.h xx.h xx.h 软件发布时需要的头文件 make install之后，会将头文件放到安装目录下的include目录里。   数据文件 data_DATA=data1 xxx2 xxx3     对于可执行文件和静态库类型，如果只想编译，不想安装到系统中，可以用noinst_PROGRAMS代替bin_PROGRAMS，noinst_LIBRARIES代替lib_LIBRARIES。\n如果有帮助文档，不需要编译，但是需要随着软件发布一起发布，可以按下面格式进行定义:\n1EXTRA_DIST=led/led.h key/key.h 七、auotomake多级目录生成Makefile(不发布静态库) 多级目录结构的软件，一般是单个程序、库文件或模块放在各自的目录中。automake要求每个目录都有自己的Makefile.am文件来编译各自目录 下的代码。在顶级的目录中，有一个Makefile.am文件，该文件通过SUBDIRS指明了这个目录下有多少个直接下级目录的代码需要编译。下级目录的Makefile.am也指明自己需要编译的下级目录。通过这样的层层递归i，从而完成多级目录结构的编译。\n1.创建待编译的源码(模拟真实项目环境) 1$tree -C 2. 3├── main 4│ └── main.c 5├── print 6│ ├── print.c 7│ └── print.h 8└── sum 9 ├── sum.c 10 └── sum.h 顶层目录是project，在project目录下分别是main\\print\\sum目录。 main目录里的main.c是包含main函数的主程序，分别调用了sum和print目录下.c文件里的函数。\n2.project顶层目录下的操作过程   执行autoscan命令生成configure.scan文件\n1autoscan   将configure.scan改名成configure.in (早期in, 现在常用.ac)\n1mv configure.scan configure.in   修改configure.in\n1[wbyq@wbyq project]$ cat configure.in 2# -*- Autoconf -*- 3# Process this file with autoconf to produce a configure script. 4 5AC_PREREQ([2.63]) 6AC_INIT([app], [1.2.3], [112626497@qq.com]) 7AC_CONFIG_SRCDIR([main/main.c]) 8AC_CONFIG_HEADERS([config.h]) 9AM_INIT_AUTOMAKE(app,1.2.3) 10AC_PROG_RANLIB #使用了静态库编译,需要此宏定义 11 12# Checks for programs. AC_PROG_CC 13 14# Checks for libraries. 15 16# Checks for header files. 17 18# Checks for typedefs, structures, and compiler characteristics. 19 20# Checks for library functions. 21 22 23AC_OUTPUT(Makefile 24 main/Makefile 25 sum/Makefile 26 print/Makefile)   分别执行aclocal、autoconf、autoheader命令\n1ls 2aclocal 3ls 4autoconf 5ls   创建Makefile.am文件\n1touch Makefile.am 1AUTOMAKE_OPTIONS=foreign 2SUBDIRS= print sum main #表示本目录的直接下级目录需要编译 #注意：顺序不能反，按照调用顺序来写。 如果有帮助文档，不需要编译，但是需要随着软件发布一起发布，可以按下面格式进行定义:\n1EXTRA_DIST=doc/help.txt doc/help.txt不需要编译，但要发布该文件。如果有多个文件，则用空格分开。\n  3.main目录下创建Makefile.am文件 在main目录下建立Makefile.am文件。\n1AUTOMAKE_OPTIONS=foreign 2bin_PROGRAMS=app #本目录的文件编译成可执行文件app 3app_SOURCES=main.c 4app_LDADD=$(top_srcdir)/sum/libsum.a $(top_srcdir)/print/libprint.a 5INCLUDES=-I$(top_srcdir)/print/ -I$(top_srcdir)/sum app_LDADD 指定需要的库文件\nINCLUDES 指定需要的头文件\n4.print目录下创建Makefile.am文件 1[wbyq@wbyq project]$ cat print/Makefile.am 2AUTOMAKE_OPTIONS=foreign 3noinst_LIBRARIES=libprint.a 4libprint_a_SOURCES=print.h print.c 5INCLUDES=-I$(top_srcdir)/sum 5.sum目录下创建Makefile.am文件 1[wbyq@wbyq project]$ cat sum/Makefile.am 2AUTOMAKE_OPTIONS=foreign 3noinst_LIBRARIES=libsum.a 4libsum_a_SOURCES=sum.h sum.c 6.编译 1[wbyq@wbyq project]$ automake --add-missing 2[wbyq@wbyq project]$./configure --prefix=$PWD/_install 3[wbyq@wbyq project]$ make 4[wbyq@wbyq project]$ make install 八、auotomake多级目录生成Makefile(发布静态库) 目录结构 在main.里调用了led.c和key.c里的函数。\n1$tree -C 2. 3├── key 4│ ├── key.c 5│ ├── key.h 6│ └── Makefile.am 7├── led 8│ ├── led.c 9│ ├── led.h 10│ └── Makefile.am 11├── Makefile.am 12└── user 13 ├── main.c 14 └── Makefile.am main.c：\n1#include \u0026lt;stdio.h\u0026gt; 2#include \u0026#34;key.h\u0026#34; 3#include \u0026#34;led.h\u0026#34; 4 5int main(char argc,char **argv) { 6\tled_init(); key_init(); 7\treturn 0; 8} led.c:\n1 #include \u0026#34;led.h\u0026#34; 2 3 void led_init(void) { 4 printf(\u0026#34;led_init\\n\u0026#34;); 5 } led.h:\n1#ifndef LED_H 2#define LED_H 3 4#include \u0026lt;stdio.h\u0026gt; 5void led_init(void); 6 7#endif key.c:\n1#include \u0026#34;key.h\u0026#34; 2#include \u0026#34;led.h\u0026#34; 3 4void key_init(void) { 5\tled_init(); 6\tprintf(\u0026#34;key_init\\n\u0026#34;); 7} key.h:\n1#ifndef KEY_H 2#define KEY_H 3#include \u0026lt;stdio.h\u0026gt; 4void key_init(void); 5#endif 调用关系图：\n1graph LR; 2main.c --\u0026gt; led.c \u0026amp; key.c; 3key.c --\u0026gt; led.c; 4 顶层Makefile.am文件代码（自己创建） 1AUTOMAKE_OPTIONS=foreign #软件规范 2SUBDIRS=led key user #执行本目录前，需要递归执行make的目录 user/Makefile.am文件代码（自己创建） 1AUTOMAKE_OPTIONS=foreign #软件规范 2bin_PROGRAMS=app #可执行文件名称 3app_SOURCES=main.c #可执行需要的源文件 4app_LDADD=$(top_srcdir)/led/libled.a $(top_srcdir)/key/libkey.a #可执行文件需要的库文件 5INCLUDES=-I$(top_srcdir)/led -I$(top_srcdir)/key #编译需要的头文件 EXTRA_DIST=$(top_srcdir)/led/led.h $(top_srcdir)/key/key.h #打包时需要额外添加的文件 6#make dist打包命令 key/Makefile.am文件代码（自己创建） 1AUTOMAKE_OPTIONS=foreign #软件规范 2lib_LIBRARIES=libkey.a #生成的静态库文件 3libkey_a_SOURCES=key.c key.h #生成静态库需要的源文件。 格式：libkey_a_SOURCES --将原来的.换成_ 4key_a_LDADD=$(top_srcdir)/led/libled.a 5INCLUDES=-I$(top_srcdir)/led led/Makefile.am文件代码（自己创建） 1AUTOMAKE_OPTIONS=foreign #软件规范 2lib_LIBRARIES=libled.a #生成的静态库文件(lib开头表示执行make installs时会一起发布，加noinst就不会一起发布) 3libled_a_SOURCES=led.c led.h #生成静态库需要的源文件。 格式：libkey_a_SOURCES --将原来的.换成_ 顶层目录下的configure.ac 文件代码   执行autoscan 命令生成configure.scan 文件\n  修改configure.scan 文件后缀为.ac或者.in\n  修改configure.ac 文件参数\n  configure.ac文件代码如下:\n1# -*- Autoconf -*- 2# Process this file with autoconf to produce a configure script. 3 4AC_PREREQ([2.63]) 5AC_INIT([app], [1.2.3], [112662497@qq.com]) 6AC_CONFIG_SRCDIR([user/main.c]) 7AC_CONFIG_HEADERS([config.h]) 8AM_INIT_AUTOMAKE(app,1.2.3) 9AC_PROG_RANLIB #表示使用静态库 10# Checks for programs. 11AC_PROG_CC 12# Checks for library functions. 13AC_OUTPUT(Makefile user/Makefile led/Makefile key/Makefile)   aclocal\n  autoconf\n  autoheader\n  automake \u0026ndash;add-missing\n  ./configure \u0026ndash;prefix=$PWD/_install\n  make \u0026amp;\u0026amp; make install\n  tree _install/ -C\n1_install/ 2├── bin 3│ └── app 4└── lib 5 ├── libkey.a 6 └── libled.a 7 83 directories, 3 files   九、auotomake多级目录生成Makefile(发布动态库+静态库) 目录结构 与八的一模一样。\n顶层Makefile.am文件代码（自己创建） 1AUTOMAKE_OPTIONS=foreign #软件规范 2SUBDIRS=led key user #执行本目录前，需要递归执行make的目录 user/Makefile.am文件代码（自己创建） 和八对比文件名有所变化。从.a变成了.la。\n1AUTOMAKE_OPTIONS=foreign #软件规范 2bin_PROGRAMS=app #可执行文件名称 3app_SOURCES=main.c #可执行需要的源文件 4app_LDADD=$(top_srcdir)/led/libled.la $(top_srcdir)/key/libkey.la #可执行文件需要的动态库文件 INCLUDES=-I$(top_srcdir)/led -I$(top_srcdir)/key #编译需要的头文件 EXTRA_DIST=$(top_srcdir)/led/led.h $(top_srcdir)/key/key.h #打包时需要额外添加的文件 make dist打包命令 key/Makefile.am文件代码（自己创建） 1AUTOMAKE_OPTIONS=foreign #软件规范 2lib_LTLIBRARIES=libkey.la #生成的动态库文件 3libkey_la_SOURCES =key.c key.h #生成静态库需要的源文件。 格式：libkey_la_SOURCES --将原来的.换成_ 4key_a_LDADD=$(top_srcdir)/led/libled.la 5INCLUDES=-I$(top_srcdir)/led led/Makefile.am文件代码（自己创建） 1AUTOMAKE_OPTIONS=foreign #软件规范 2lib_ LTLIBRARIES =libled.la #生成的动态库文件(lib开头表示执行make installs时会一起发布，加noinst就不会一起发布) 3libled_la_SOURCES=led.c led.h #生成静态库需要的源文件。 格式：libkey_la_SOURCES --将原来的.换成_ 顶层目录下的configure.ac 文件代码   autoscan\n  mv configure.scan configure.ac\n  vim configure.ac\n八使用的是AC_PROG_RANLIB #表示使用静态库\n1# -*- Autoconf -*- 2# Process this file with autoconf to produce a configure script. 3AC_PREREQ([2.63]) 4AC_INIT([app], [1.2.3], [112662497@qq.com]) 5AC_CONFIG_SRCDIR([user/main.c]) 6AC_CONFIG_HEADERS([config.h]) 7AM_INIT_AUTOMAKE(app,1.2.3) 8AC_PROG_LIBTOOL#使用动态库 9 10# Checks for programs. 11AC_PROG_CC 12# Checks for library functions. 13AC_OUTPUT(Makefile user/Makefile led/Makefile key/Makefile)   aclocal\\autoconf\\autoheader\n  libtoolize -f -c #共享库必须要执行\n  automake \u0026ndash;add-missing\n  ./configure \u0026ndash;prefix=$PWD/_install\n  make \u0026amp;\u0026amp; make install\n  tree -C\n1   十、自定义安装目录示例(make install) 1wbyqdir=$(prefix)/wbyq_666 2wbyq_DATA=$(top_srcdir)/666.c $(top_srcdir)/888.c wbyq：表示是新的路径类型。\nwbyq_666：表示在安装路径下创建的目录名称。\n666.c、888.c ：是执行make install 拷贝到wbyq_666目录下的文件。\n十一、多级目录与函数的嵌套调用生成Makefile C文件及调用关系图 main/main.c:\n1#include \u0026lt;stdio.h\u0026gt; 2#include \u0026#34;print.h\u0026#34; 3 4int main() { 5\tint a=123; 6\tint b=456; 7\tprint(a,b); 8} sum/sum.h:\n1#ifndef _SUM_H 2#define _SUM_H 3int sum(int,int); 4#endif sum/sum.c:\n1#include \u0026#34;sum.h\u0026#34; 2 3int sum(int a,int b) { 4\tint c; 5\tc=a+b; 6\treturn c; 7} print/print.h:\n1#ifndef _PRINT_H 2#define _PRINT_H 3#include \u0026#34;sum.h\u0026#34; 4#include \u0026lt;stdio.h\u0026gt; 5void print(int,int); 6#endif print/print.c:\n1#include \u0026#34;print.h\u0026#34; 2 3void print(int a,int b) { 4\tint c; 5\tc=sum(a,b); 6\tprintf(\u0026#34;%d\\n\u0026#34;,c); 7} 1graph LR; 2\tmain.c --\u0026gt; print.c; 3\tprint.c --\u0026gt; sum.c; automake操作   autoscan\n  mv configure.scan configure.ac\n  vim configure.ac\n  cat configure.ac\n1AC_PREREQ([2.63]) 2AC_INIT([app], [1.2.3], [112662497@qq.com]) 3AC_CONFIG_SRCDIR([main/main.c]) 4AC_CONFIG_HEADERS([config.h]) 5AM_INIT_AUTOMAKE(app,1.2.3) 6AC_PROG_RANLIB #使用了静态库编译,需要此宏定义 7AC_PROG_CC AC_OUTPUT(Makefile 8 main/Makefile 9 print/Makefile 10 sum/Makefile)   aclocal\n  autoconf\n  autoheader\n  vim Makefile.am\n  cat Makefile.am\n1AUTOMAKE_OPTIONS=foreign 2SUBDIRS= sum print main #顺序   vim main/Makefile.am\n  cat main/Makefile.am\n1AUTOMAKE_OPTIONS=foreign 2bin_PROGRAMS=app 3app_SOURCES=main.c 4app_LDADD=$(top_srcdir)/print/libprint.a $(top_srcdir)/sum/libsum.a #顺序很重要 5INCLUDES=-I$(top_srcdir)/print/ -I$(top_srcdir)/sum/   vim sum/Makefile.am\n  cat sum/Makefile.am\n1AUTOMAKE_OPTIONS=foreign 2lib_LIBRARIES=libsum.a 3libsum_a_SOURCES=sum.h sum.c   vim print/Makefile.am\n  cat print/Makefile.am\n1AUTOMAKE_OPTIONS=foreign 2noinst_LIBRARIES=libprint.a 3libprint_a_SOURCES=print.h print.c 4#重要 5print_a_LDADD=$(top_srcdir)/sum/libsum.a 6INCLUDES=-I$(top_srcdir)/sum   automake \u0026ndash;add-misiing\n  ./configure \u0026ndash;prefix=$PWD/_install\n  make \u0026amp;\u0026amp; make install\n  tree _install\n1├── bin │ 2 └── app 3└── lib 4\t├── libprint.a 5\t└── libsum.a  ","date":"2024-11-29","permalink":"/posts/tech/media-automake/","series":["媒体开发"],"tags":["","",""],"title":"automake构建工具使用"},{"categories":["计算机"],"content":"搁置\n这是书籍的笔记, 这本书我选择记录我做的课后习题, 并改错.\n第1章 引论 书本内容 这一章讲述的确确实实是引论, 方便为以后引申出算法, 时间复杂度, 递归等概念. 没有特别值得注意的地方.\n练习 1.1  1.1 编写一个程序解决选择问题. 令k=N/2. 画出表格显示你的程序对于N为不同值的运行时间.\n选择问题: 有N个数, 求出第k大的数是多少.\n 思路一:\n 当k=1时, 即是求最小值. 这种情况一次遍历即可得出结果, 拿一个位置存放当前最小值, 与遍历值对比. 当k=2时, 可以按照之前的思路, 设定一个2个空间的数组, 里面装着第一小和第二小的数据. 筛选标准是大于第一个, 同时小于第二个的话就存进去, 小于第一个直接替换第一个. 也是一次遍历. \u0026hellip;. 依照这种思路, 只需要预先设定一个[N/2]大小的数组即可. 这当然是教程中列举的一种思路.  目前想不到教材列举的1秒的算法, 所以就把上面这个思路实现一下就行了.\n实现:\n1#include \u0026lt;stdio.h\u0026gt;2#define MAX_NUMBER 1000 3 4int findKthMax(const int* array, int size, int k); 5void findPlace(int* replace, int k, int target); 6void initPlace(int* replace, int k); 7 8int main(void) { 9 int array[10] = {2,1,7,8,5,4,9,10,3,6}; 10 const int* p = array; 11 printf(\u0026#34;%d\u0026#34;, findKthMax(p, 10, 10/2)); 12 return 0; 13} 14 15int findKthMax(const int* array, int size, int k){ 16 int replace[k]; 17 initPlace(replace, k); 18 for (int i = 0; i \u0026lt; size; ++i) { 19 if (*(array + i) \u0026lt; replace[k-1]) { 20 findPlace(replace, k, *(array+i)); 21 } 22 } 23 24 return replace[k-1]; 25} 26 27void findPlace(int* replace, int k, int target){ 28 for (int i = 0; i \u0026lt; k; ++i) { 29 if(target \u0026lt; *(replace+i)){ 30 //挪动 31 for (int j = k-1; j \u0026gt; i; --j) { 32 *(replace+j) = *(replace+j-1); 33 } 34 *(replace+i) = target; 35 return; 36 } 37 } 38} 39 40void initPlace(int* replace, int k){ 41 for (int i = 0; i \u0026lt; k; ++i) { 42 *(replace+i) = MAX_NUMBER; 43 } 44} 45 1.2  1.2 编写一个程序求解字谜游戏问题\n输入是由一些字母和单词的二维数组组成的, 目标是要找出字谜中的单词, 这些单词可能是水平, 垂直或沿对角线以任何方向放置的.\n 思考: 准备一个单词本(字符串数组), 先从第一个字母开始找, 这样一个一个匹配, 匹配到第一个字符就尝试从任意方向上去找, 看看能不能继续匹配. 由于一般来说是单词本大, 题目范围相对小, 故由字谜开始寻找单词匹配.\n实现: (大概就这样吧, 还可以封装一下, 算了)\n1// 2// Created by bnaod1 on 2024/11/29. 3// 4 5#include \u0026#34;stdio.h\u0026#34;6#include \u0026#34;stdlib.h\u0026#34;7#include \u0026#34;string.h\u0026#34;8 9void printStrInDict(char* str); 10void initStrAndPara(char* str, int* now_i, int* now_j, int* size); 11 12//谜题及字典 13const char word_puzzle[4][4] = { 14 \u0026#39;t\u0026#39;, \u0026#39;h\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;s\u0026#39;, 15 \u0026#39;w\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;t\u0026#39;, \u0026#39;s\u0026#39;, 16 \u0026#39;o\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;h\u0026#39;, \u0026#39;g\u0026#39;, 17 \u0026#39;f\u0026#39;, \u0026#39;g\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;t\u0026#39; 18}; 19 20const char* dict[4] = { 21 \u0026#34;this\u0026#34;, 22 \u0026#34;two\u0026#34;, 23 \u0026#34;fat\u0026#34;, 24 \u0026#34;that\u0026#34; 25}; 26 27int main(int argc, char **argv){ 28 for (int i = 0; i \u0026lt; 4; ++i) { 29 for (int j = 0; j \u0026lt; 4; ++j) { 30 //最后一个字母的位置 31 int now_j = j; 32 int now_i = i; 33 int k = 0; //str赋值下标 34 char* str = malloc(sizeof(char)*16); 35 memset(str, 0, sizeof(char)*16); 36 *str = word_puzzle[i][j]; 37 38 //只寻找字母大于等于3个的单词 39 //1.上方 40 if (i \u0026gt; 1){ 41 while(now_i \u0026gt;= 0){ 42 *(str+k) = word_puzzle[now_i--][j]; 43 k++; 44 } 45 printStrInDict(str); 46 } 47 //2.下方 48 k = 0; 49 now_i = i; 50 memset(str, 0, sizeof(char)*16); 51 if (i \u0026lt; 2){ 52 while(now_i \u0026lt; 4){ 53 *(str+k) = word_puzzle[now_i++][j]; 54 k++; 55 } 56 printStrInDict(str); 57 } 58 59 //3. 左边 60 61 62 63 //最后释放内存 64 free(str); 65 66 } 67 } 68 return 0; 69} 70 71 72void printStrInDict(char* str){ 73 for (int i = 0; i \u0026lt; 4; ++i) { 74 for (int j = 0; j \u0026lt; 4; ++j) { 75 //下一个字母不同就退出 76 if (*(str+j) != *(dict[i]+j)){ 77 break; 78 } 79 80 //3个字母及以上的单词 81 if (j \u0026gt; 1){ 82 printf(\u0026#34;find pattern:\u0026#34;); 83 for (int k = 0; k \u0026lt;= j; ++k) { 84 printf(\u0026#34;%c\u0026#34;, *(str+k)); 85 } 86 printf(\u0026#34;\\n\u0026#34;); 87 } 88 } 89 } 90} 91 1.3  1.3 只使用处理I/O的PrintDigit函数, 编写一个过程以输出任意实数(可以是负的)\n 教材中提供的PrintDigit函数:\n1void PrintOut(unsigned int N){ 2\tif(N \u0026gt;= 10){ 3\tPrintOut(N / 10); 4\t} 5\tPrintOut(N % 10); 6} 说实话不太明白这道题什么意思, 所以着重实现后面的需求.\n实现: (感觉有点敷衍了)\n1// 2// Created by bnaod1 on 2024/11/30. 3// 4 5#include \u0026#34;stdio.h\u0026#34;6 7void PrintDigit(long long num); 8long long abs_m(long long x); 9 10int main(){ 11 PrintDigit(-100000000000000000); 12} 13 14void PrintDigit(long long num){ 15 if (num \u0026lt; 0) printf(\u0026#34;-\u0026#34;); 16 17 num = abs_m(num); 18 19 printf(\u0026#34;%lld\u0026#34;, num); 20 21 22} 23 24 25 26long long abs_m(long long x){ 27 if (x \u0026gt;= 0) { 28 return x; 29 } else { 30 return -x; 31 } 32} 33 1.4  1.4 #include filename读入文件filename将其插入到include语句处. 编写一个程序, 使它读入被include语句修饰的文件并且输出这个文件\n 在我的理解里, 这就是一个递归.\n实现: (反正大概就这样了, 没有进行测试, 同时也没有处理\u0026lt;\u0026gt;的情况)\n1// 2// Created by bnaod1 on 2024/11/30. 3// 4 5#include \u0026#34;stdio.h\u0026#34;6#include \u0026#34;stdlib.h\u0026#34;7#include \u0026#34;string.h\u0026#34;8 9int main4(){ 10 11} 12 13void read_file(char* file_name){ 14 FILE* file = NULL; 15 char buff[255]; 16 file = fopen(file_name, \u0026#34;r\u0026#34;); 17 18 if (file == NULL){ 19 perror(\u0026#34;open file failed\u0026#34;); 20 exit(1); 21 } 22 23 while (fgets(buff, 255, file) != NULL){ 24 char pattern[] = \u0026#34;#include\u0026#34;; 25 if (strstr(buff, pattern) != NULL){ 26 //寻找文件名 27 char* include_file = malloc(sizeof(char)*16); 28 memset(include_file, 0, sizeof(char)*16); 29 int k = 0; 30 char* begin = strchr(buff, \u0026#39;\u0026#34;\u0026#39;); 31 if (*begin != \u0026#39;\u0026#34;\u0026#39;){ 32 *(include_file+k) = *(begin+k); 33 k++; 34 } 35 36 read_file(include_file); 37 38 free(include_file); 39 } 40 41 printf(\u0026#34;%s\u0026#34;, buff); 42 } 43} 1.8  $2^{100}(mod 5)$是多少.\n 2%5=2; 4%5=4; 8%5=3; 16%5=1; 32%5=2; 64%5=4; 128%5=3; \u0026hellip;\n余数结果只与个位数有关, 而2的次方的个位数是有规律的: 2, 4, 8, 6, 2, 4, 8, 6\u0026hellip;.\n所以$2^{100}(mod 5) = 6$\n第2章 算法分析 书本内容 概念:\n 大O: T(N)=O(f(N)), T的增长率小于等于f的增长率(上界) omega: T(N)=omega(f(N)), T的增长率大于等于f的增长率(下界) theta: T(N)=theta(f(N)), T的增长率等于f的增长率 小o: T(N)=o(f(N)), T的增长率小于f的增长率  法则:\n T1 + T2 = max(O(f), O(g)) T1 * T2 = O(f * g) T是k次多项式, 则T(N) = theta(N^k) (logN)^k=O(N)  另外关于最大子序列的问题, 后面这两个算法是非常精彩的.\n算法1: 分治, 从局部最优得到全局优, 而且局部优的情况是简单的.\n1static int MaxSubSum( int A[], int Left, int Right) 2\t{ 3\tint MaxLeftSum,MaxRightSum; 4\tint MaxLeftBorderSum,MaxRightBorderSum; 5\tint LeftBorderSum,RightBorderSum; 6\tint Center,i; 7\t8\tif(Left == Right) 9\t{ 10\tif(A[Left] \u0026gt; 0) 11\treturn A[Left]; 12\telse 13\treturn 0; 14\t} 15\t16\tCenter = (Left + Right)/2; 17\tMaxLeftSum = MaxSubSum(A,Left,Center); 18\tMaxRightSum = MaxSubSum(A,Center+1,Right); 19\t20\tMaxLeftBorderSum = 0; 21\tLeftBorderSum = 0; 22\tfor(i = Center;i \u0026gt;= Left;i--) 23\t{ 24\tLeftBorderSum += A[i]; 25\tif(LeftBorderSum \u0026gt; MaxLeftBorderSum) 26\tMaxLeftBorderSum = LeftBorderSum; 27\t} 28\t29\tMaxRightBorderSum = 0; 30\tRightBorderSum = 0; 31\tfor(i = Center+1;i \u0026lt;= Right;i++) 32\t{ 33\tRightBorderSum += A[i]; 34\tif(RightBorderSum \u0026gt; MaxRightBorderSum) 35\tMaxRightBorderSum = RightBorderSum; 36\t} 37\t38\treturn Max(MaxLeftSum,MaxRightSum,MaxLeftBorderSum + MaxRightBorderSum); 39\t} 算法分析: T(N) = 2*T(N/2) + O(N), 将T(N/2)继续减小可以得到最终结果T(N) = NlogN. 可以通过假设$N=2^k$简化推理.\n算法2: 神奇的算法(这个算法真的是人想出来的?)\n1int MaxSubSequence(const int A[], int N) 2\t{ 3\tint ThisSum,MaxSum,j; 4\t5\tThisSum = MaxSum =0; 6\tfor(j = 0;j \u0026lt; N;j++) 7\t{ 8\tThisSum += A[j]; 9\t10\tif(ThisSum \u0026gt; MaxSum) 11\tMaxSum = ThisSum; 12\telse if(ThisSum \u0026lt; 0) 13\tThisSum = 0; 14\t} 15\treturn MaxSum; 16\t} 要点:\n  else if(ThisSum \u0026lt; 0) .当ThisSum没有了增速的同时小于0了(这个子序列对最大序列的贡献为负), ThisSum立刻置为0, 开始重新寻找下一个子序列.\n  当然由于初始化和重新赋值都为0, 算法自动排除掉开头为负数的存在\n  由于上面两点的存在, 保证了下一个可能的最大子序列一定不在前一个最大子序列中间开始.\n  练习 2.1 数学题, 就log几个麻烦点.\n$\\frac{2}{N} \u0026lt; 37 \u0026lt; \\sqrt{N} \u0026lt; N \u0026lt; N\\log_{}{N}\u0026lt;N\\log_{}{N^2}\u0026lt;N\\log_{}{\\log_{}{N}}\u0026lt;N\\log^2_{}{N}\u0026lt;N^{1.5}\u0026lt;N^2\u0026lt;N^2\\log_{}{N}\u0026lt;n^3\u0026lt;2^{\\frac{N}{2}}=2^N$\n2.2 a\n2.3 做不到.\n2.4 洛必达+归纳法即可.\n2.5 想不出.\n2.9 $O(N)$, $O(logN)$\n2.10 很久之前的印象，这个算法是中国人发现的，秦邵九貌似是。\nc. $O(N)$\n2.11 有序查找，就用二分法。所以是$O(logN)$\n2.12  求最小子序列和\n 借用大神的算法：\n1int MinSubSequence(const int A[], int N) 2\t{ 3\tint ThisSum,MinSum,j; 4\t5\tThisSum = MinSum =0; 6\tfor(j = 0;j \u0026lt; N;j++) 7\t{ 8\tThisSum += A[j]; 9\t10\tif(ThisSum \u0026lt; MinSum) 11\tMinSum = ThisSum; 12\telse if(ThisSum \u0026gt; 0) 13\tThisSum = 0; 14\t} 15\treturn MinSum; 16\t}  求最小的正子序列和\n 还是借助一下大神的算法，稍微进行了修改：\n1int MinPositiveSubSequence(const int A[], int N) 2\t{ 3\tint ThisSum,MinPSum,j; 4\t5\tThisSum = 0; 6 MinPSum = MAX_BOUND; 7\tfor(j = 0;j \u0026lt; N;j++) 8\t{ 9\tThisSum += A[j]; 10\t11\tif(ThisSum \u0026lt; MinPSum \u0026amp;\u0026amp; ThisSum \u0026gt; 0) 12\tMinPSum = ThisSum; 13\telse if(ThisSum \u0026gt; MinPSum || ThisSum \u0026lt; 0) 14\tThisSum = A[j]; 15\t} 16\treturn MinPSum; 17\t}  求最大子序列乘积\n 考虑这样的序列：\n1-2, 2 ,3, 6, 8, 9 2-2, -3, 6, 0, 3, 21, -1 30,0,0,0,0,1 这道题就不是那么简单了。当然暴力遍历我也会。\n我觉得应该存两个值，一个是最大正值，还有一个是最大负值（它有可能成为最大正值）。当然遇到0了就重新找下一个序列。最后比较返回即可。还有一种特殊情况：全0.\n测试了一下，基本是没问题的，也就不深究了。\n1// 2// Created by bnaod1 on 2024/12/7. 3// 4#include \u0026#34;stdio.h\u0026#34;5 6int MaxProdSubSequence(const int A[], int N); 7 8 9int main(){ 10// const int A[] = {-2, 2 ,3, 6, 8, 9}; 11// const int A[] = {-2, -3, 6, 0, 3, 21, -1}; 12 const int A[] = {0,1,1,0,0,0}; 13 int result = MaxProdSubSequence(A, 6); 14 printf(\u0026#34;%d\u0026#34;,result); 15 return 0; 16} 17 18 19int MaxProdSubSequence(const int A[], int N) 20{ 21 int ThisProd,MaxProd,psbMaxProd,zeroflag,j; 22 23 ThisProd = psbMaxProd = MaxProd = 1; 24 zeroflag = 0; 25 for (j = 0;j \u0026lt; N;j++) 26 { 27 if (zeroflag == 0 \u0026amp;\u0026amp; A[j] != 0){ 28 zeroflag = 1; 29 } 30 31 ThisProd *= A[j]; 32 psbMaxProd *= A[j]; 33 34 //ThisProd只存放当下最大的 35 if (ThisProd \u0026lt; 0) 36 ThisProd = 1; 37 //psbMaxProd是从头到尾一直乘的，有可能很小，但是再遇到负数即可超越 38 else if (psbMaxProd \u0026gt; ThisProd) 39 ThisProd = psbMaxProd; 40 else if (ThisProd \u0026gt; MaxProd) 41 MaxProd = ThisProd; 42 //遇到0，表示前面这段子序列该结束了 43 else if (ThisProd == 0) 44 ThisProd = psbMaxProd = 1; 45 } 46 47 //全0 48 if (zeroflag == 0) 49 return 0; 50 else 51 return MaxProd; 52} 2.16  不用递归，写出快速求幂的程序\n 可以参考递归的写法，我们就正向写即可。\n对于求解目标$X^N$，实际上是$X^N = X^{N/2} * X^{N/2} * X^{N % 2}$。正向求解最麻烦的是何时多乘个X，可以先计算出乘X的时机。我想二进制也可以做到。\n1// 2// Created by bnaod1 on 2024/12/7. 3// 4#include \u0026#34;stdio.h\u0026#34;5#include \u0026#34;stdlib.h\u0026#34;6#include \u0026#34;stdbool.h\u0026#34;7 8long int Pow(long int X, unsigned int N); 9 10int main(){ 11 printf(\u0026#34;%ld\u0026#34;, Pow(2,5)); 12 return 0; 13} 14 15long int Pow(long int X, unsigned int N){ 16 int i = 0; 17 long int result = X; 18 unsigned int *prodX = NULL; 19 prodX = malloc(sizeof(unsigned int) * 32); 20 21 while (true){ 22 if (N == 1) 23 break; 24 *(prodX+i) = N - (N/2)*2; 25 i++; 26 N = N / 2; 27 } 28 29 for (int j = i-1; j \u0026gt;= 0; --j) { 30 result = result * result; 31 if (*(prodX+j) == 1) 32 result *= X; 33 } 34 35 36 free(prodX); 37 38 return result; 39} 40 41 2.17  给出用于快速取幂运算中的乘法次数的精确计算。（提示可以考虑N的二进制表示）\n 其实N的二进制如果是1，那么就要多一次乘法；如果是0，乘法只有一次。当然需要排除掉最后一个1（最高位的1）。N的求二进制过程与我们快速求幂的过程一一对应，这也是我上一个题的写法。\n举例来说，16的二进制为10000，则需要4次乘法（0000）；31的二进制为11111，则需要8次乘法（1111）；32的二进制为100000，则需要5次乘法（00000）。所以只需要取除最高位的二进制位即可。怎么取呢？首先将N与1进行位与运算，这样高位全被置为0，低位是什么就是什么，然后右移；一直重复直到N==0，这样我们有可能是多算了一个1。\n为了练习二进制位运算相关运算，我还是写一下。\n1// 2// Created by bnaod1 on 2024/12/9. 3// 4#include \u0026#34;stdio.h\u0026#34;5int prod_count(unsigned int N); 6 7int main(){ 8 printf(\u0026#34;%d\u0026#34;, prod_count(31)); 9 return 0; 10} 11 12int prod_count(unsigned int N){ 13 int res = 0; 14 while (N \u0026gt;\u0026gt; 1 != 0){ 15 unsigned int sign = N \u0026amp; 1; 16 17 if (sign == 1) 18 res += 2; 19 else 20 res += 1; 21 22 N = N \u0026gt;\u0026gt; 1; 23 } 24 25 return res; 26} 27 2.19 a.当数组中只剩一个元素或者是空数组\nb.N是奇数的话，将最后一个和前一个，最后一个和第一个比较\nc.循环\nd.\n第3章 表、栈和队列 书本内容   ADT：抽象数据类型是一些操作的集合。\n  表ADT，数组实现，链表实现。这个是入门的东西，很经典，但知识量不大。\n  多项式ADT。和超大数+×有点类似。\n  基数排序。基数排序是由桶排序演化来的。\n桶排序：N个整数，范围1到M；那么就准备M个桶，有个整数来了就将第N个桶增1；最后顺序输出桶的序号。复杂度$O(M+N)$。\n如果10个数，范围是0~1000之内；那么我们选择10个桶（装位数），并进行3趟最低位优先的桶排序就可以排完了。前面各趟排序保证了几个数进入一个桶时，它们是顺序的。\n基数排序就是多趟桶排序。桶的个数为数的位数表示个数，趟数为位数。时间复杂度$O(P(N+B))$，P是趟数，N是元素个数，B是桶数。\n  链表的游标实现\n  ","date":"2024-11-28","permalink":"/posts/tech/media-datastructure/","series":["媒体开发"],"tags":["","",""],"title":"《数据结构与算法分析: C语言描述》"},{"categories":["计算机"],"content":"说明 company内部项目，故不贴出源代码，只记录学习到的知识。\n这次学习深深知道了阅读文档和源码的重要性，以及C语言的精密性，多多学习！\n基础知识 首先1字节(Byte)是8位(bit)。一般网络，文件编程都是以字节为单位。\n在Linux中，一些类型的存储大小如下：（uname -m查看）\n   类型 Linux i686(32位) Linux x86_64(64位) Windows     char 1字节 1字节 1字节   unsigned char 1 1 1   short 2 2 2   unsigned short 2 2 2   int 4 4 4   unsigned int 4 4 4   long 4 8 4   unsigned long 4 8 4   float 4 4 4   double 8 8 8   long int 4 8 4   long long 8 8 8   long double 12 16 8    C语言为了方便精确编程定义了很多类型：\n uint16_t：unsigned short，无符号16位整数 uint32_t：unsigned int，无符号32位整数 socklen_t：unsigned int， 无符号32位整数， 用于表示socket地址结构长度的数据类型。 size_t： unsigned long， 是一种用于表示内存大小的数据类型， 说明说Linux 64位系统中内存大小是8字节。 ssize_t: long.  函数说明 \u0026lt;string.h\u0026gt; 1.memcpy 1void *memcpy(void dest[restrict .n], const void src[restrict .n], size_t n); 针对内存块进行的拷贝。\n  函数memcpy从source的位置开始向后复制num个字节的数据到destination指向的内存位置（右边的数据拷贝到左边来）\n  函数遇到'\\0\u0026rsquo;不会停下来\n  如果source和destination有任何的重叠，复制的结果都是未定义的\n  返回值：memcpy拷贝结束后，返回的是目标空间的起始地址,而且是void*类型（实现各种类型数据的拷贝）\n  使用该函数，需要引用头文件：string.h0\n  2.memset 1void *memset(void s[.n], int c, size_t n); 初始化函数，作用是将某一块内存中的全部设置为指定的值。\n s指向要填充的内存块。 c是要被设置的值。 n是要被设置该值的字符数。 返回类型是一个指向存储区s的指针。  memset函数是按照字节对内存块进行初始化，其实c的实际范围应该在0~255，因为memset函数只能取c的后八位给所输入范围的每个字节。也就是说无论c多大只有后八位二进制是有效的。\nsys/socket.h 1.socket 1int socket(int domain, int type, int protocol); 建立一个协议族为domain、协议类型为type、协议编号为protocol的套接字文件描述符\n如果函数调用成功，会返回一个标识这个套接字的文件描述符，失败的时候返回-1。\n函数参数：\n  domain:\n函数socket()的参数domain用于设置网络通信的域，函数socket()根据这个参数选择通信协议的族。通信协议族在文件sys/socket.h中定义。\n  type:\n函数socket()的参数type用于设置套接字通信的类型，主要有SOCKET_STREAM（流式套接字）、SOCK_DGRAM（数据包套接字）等。\n  protocol:\n函数socket()的第3个参数protocol用于制定某个协议的特定类型，即type类型中的某个类型。通常某协议中只有一种特定类型，这样protocol参数仅能设置为0；但是有些协议有多种特定的类型，就需要设置这个参数来选择特定的类型。\n  2.bind 1int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); 函数参数：\n  sockfd 表示socket函数创建的通信文件描述符\n  addrlen 表示所指定的结构体变量的大小\n  addr 表示struct sockaddr的地址，用于设定要绑定的ip和端口\n1struct sockaddr { 2 sa_family_t sa_family; 3 char sa_data[14]; 4} 5 6//sa_family 用于指定AF_***表示使用什么协议族的ip 7//sa_data 存放ip和端口 8 9//这里有一个问题，直接向sa_data中写入ip和端口号有点麻烦，内核提供struct sockaddr_in结构体进行写入,通过/usr/include/linux/in.h可以看到结构体原型 10//使用该结构体时需要包含\u0026lt;netinet/in.h\u0026gt;头文件，且sockaddr_in结构体是专门为tcp/ip协议族使用，其他协议族需要使用其对应的转换结构体,比如“域通信协议族” 使用的是sockaddr_un结构体   例：\n1struct sockaddr_in addr; 2addr.sin_family = AF_INET; //设置tcp协议族 3addr.sin_port = htons(6789); //设置端口号 4addr.sin_addr.s_addr = inet_addr(\u0026#34;192.168.1.105\u0026#34;); //设置ip地址 5 6ret = bind(skfd, (struct sockaddr*)\u0026amp;addr, sizeof(addr)); 3.sendto 1ssize_t sendto(int sockfd, const void buf[.len], size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen); 参数：前面三个参数分别表示：套接字描述符，指向写出缓冲区的指针和写字节数。 dest_addr：指向一个含有数据报接收者的协议地址（如IP地址和端口号）的套接字地址结构（上面所说的sockaddr_in），其大小由addrlen参数指定。\n4.recvfrom 1ssize_t recvfrom(int sockfd, void buf[restrict .len], size_t len, 2 int flags, 3 struct sockaddr *_Nullable restrict src_addr, 4 socklen_t *_Nullable restrict addrlen); 参数：\n sockfd：要接收数据的套接字文件描述符。 buf：存储数据的缓冲区。 len：缓冲区的大小。 flags：指定接收数据时的行为标志，通常设置为0。 src_addr：（可选）用于接收发送方地址信息的结构体。 addrlen：（可选）指向src_addr结构体的长度。  返回值：\n如果成功接收到数据，返回接收到的字节数。\n如果发生错误，返回-1，并设置errno以指示错误的类型。\n请注意，recvfrom函数通常与sendto函数配对使用，用于在网络编程中进行双向通信。\nnetinet/in.h 1.inet_addr 1in_addr_t inet_addr(const char *cp); 它将参数cp所指向的字符串形式的IP地址(“192.168.1.11”)转换为二进制的网络字节序的IP地址形式。\n该函数的缺点是：如果IP地址是255.255.255.255。那么调用inet_addr()函数后将返回-1(因为-1的补码形式是0xFFFFFFFF)。所以不建议使用inet_addr()函数，而是使用inet_aton()函数。\n2.htons 1uint16_t htons(uint16_t hostshort); htons 是把你机器上的整数转换成“网络字节序”， 网络字节序是 big-endian，也就是整数的高位字节存放在内存的低地址处。 而我们常用的 x86 CPU (intel, AMD) 电脑是 little-endian,也就是整数的低位字节放在内存的低字节处。\n通信规范 C语言中的RTP 对于通信协议规范，应该使用位域来定义，且变量的类型需要更加严格。\n在构造数据包时，注意rtp协议中的变长部分（csrc），并且基于变长部分的大小赋值后面的负载。\nC语言中的UDP 使用socket编程的对应参数即可，内部已经封装了UDP头。注意网络最大传输单元是1500字节，除去各种协议的头部剩下的才是负载用的空间。\n编程技巧   编程时可以用枚举定义统一的错误返回值，这样比较规范也容易找到错误，同时要注意分类。\n  在使用位域时，可以在定义位域的上下加上编译器对齐参数，这样会使位域定义的更严密：\n1//编译器参数， 保存原来的对齐方式，并设新的对齐方式设置为一个字节对齐 2#pragma pack(push, 1) 3 4struct { 5\tint a:1; 6\tint b:2; 7\tchar c:1; 8}sample; 9 10//还原为原来的对齐方式 11#pragma pack(pop)   拷贝消息可使用memcpy，这是基于内存的拷贝，适用于任何数据类型的拷贝。速度较块。\n  结构体初始化使用memset。\n  想要对于一个指针操作，可以在函数内部创建另一个指针变量，使用别名的方式操作：\n1char* implict_name; 2implict_name=\u0026amp;string;   错误退出可以使用perror+exit\n  程序流程图 发送数据：\n1graph LR; 2 start(开始) --\u0026gt; rtp_stream[rtp流初始化-socket,地址]; 3 start --\u0026gt; rtp_message[rtp消息初始化-版本,ssrc]; 4 start --\u0026gt; read_file[打开传输文件]; 5 read_file --\u0026gt; payload1 6 read_file --\u0026gt; payload2 7 read_file --\u0026gt; payload3[...] 8 rtp_message --\u0026gt; rtp_packet_create[生成rtp包] 9 payload1 --\u0026gt; rtp_packet_create 10 payload2 --\u0026gt; rtp_packet_create 11 payload3 --\u0026gt; rtp_packet_create 12 rtp_packet_create --\u0026gt; sendto; 13 rtp_stream --\u0026gt; sendto; 14 sendto[sendto函数] --\u0026gt; rtp_send(发送消息); 15 16 subgraph UDP相关 17 rtp_stream 18 end 19 20 subgraph rtp相关 21 rtp_message 22 end 23 24 subgraph 文件 25 payload1 26 payload2 27 payload3 28 end 接受数据过程差不多，基本上是反过来，就不写了。\nMakefile   可以在开头定义很多出现很多次的东西，如\n 编译器 创建静态库的工具 参数 库目录 包含目录 目标文件 结果文件  使用名称 := 字符串即可定义变量\n  ar 命令是一个用于创建、修改和提取归档文件的工具，通常用于创建静态库（静态链接库）。这些静态库可以包含多个目标文件（.o 文件），并在链接时将这些目标文件打包成一个单一的库文件（通常以 .a 结尾）。\n 参数c：创建归档文件。如果归档文件存在，则不提示。 参数r：添加或替换文件到归档文件中。如果归档文件不存在，则创建一个新的归档文件。 参数u：只替换比当前归档内容更新的文件    Makefile函数\n wildcard可以使变量定义时，括号里的通配符仍然生效 notdir：去掉路径，只保留文件名 patsubst \u0026lt;模式\u0026gt;,\u0026lt;替换后的模式\u0026gt;,\u0026lt;要替换的文本\u0026gt;    伪目标：\n是这样一个目标：它不代表一个真正的文件名，在执行make时可以指定这个目标来执行所在规则定义的命令，有时也可以将一个伪目标称为标签。伪目标通过PHONY来指明。PHONY定义伪目标的命令一定会被执行\n无论当前目录下是否存在“clean”这个文件，输入“make clean”后，命令都会被执行。\n1.PHONY : clean 2clean: 3\trm -rf $(OBJS)  ","date":"2024-11-27","permalink":"/posts/tech/media-lightrtp/","series":["媒体开发"],"tags":["","",""],"title":"lightrtp项目学习"},{"categories":["计算机"],"content":"https://blog.csdn.net/cindylx422/article/details/7515795\n我目前还不能理解，有些地方很抽象。这东西比计网的很多东西还要抽象。\n1. 引言 RTP在多点传送（多播）或单点传送（单播）的网络服务上，提供端对端的网络传输功能，适合应用程序传输实时数据，如：音频，视频或者仿真数据。\nRTP没有为实时服务提供资源预留的功能，也不能保证QoS（服务质量）。数据传输功能由一个控制协议（RTCP）来扩展，通过扩展，可以用一种方式对数据传输进行监测控制。RTCP被设计成和下面的传输层和网络层无关。RTP控制协议RTCP，用于监控服务质量和传送会议中一个参与者的信息。后者对“宽松控制”的会议可能已经足够，但是并没有必要去支持一个应用所有的控制需求。控制功能可能完全或部分地包含于一个单独的会议控制协议（如SIP等）\nRTP被设计为可扩展的，用来提供一个专门的应用程序需要的信息，并经常地集成到应用程序处理中，而不是作为一个单独的层被实现。RTP是一个故意不完成的协议框架。\n2. RTP使用场景 2.1 简单多播音频会议（Simple Multicast Audio Conference） 使用Internet的IP多播服务来进行语音通讯。通过一些分配机制，工作组主持人获得一个多播的组地址和一对端口。一个端口用于音频数据，另一个端口用于控制（RTCP）数据包。该地址和端口信息发布给预定的参与者。如果有私密性要求，则可用章节9.1中说明的方法，对数据和控制包进行加密。\n每个与会者所使用的音频会议应用程序，都以small chunk形式（比方说20毫秒一段）来发送音频数据。每个音频数据块都前缀RTP报头；RTP报头和数据然后包含在UDP包中。RTP报头指明了各个包里音频编码的类型（如PCM, ADPCM,LPC），这样发送方可以在会议过程中改变编码格式，例如，为了要适应一个低带宽的参与者，或是要应付网络拥塞。\n为了应对偶而会丢失和重排包或造成时长不等的延迟，RTP报头里包含时间戳和序列号，这样就允许接收方重构 源的时间轴。\n为了知道实际参与者和接受到的数据的好坏情况， 会议中每个音频应用程序，都周期性地多播一个附加着用户名的接收报告到RTCP端口。接收报告指明了当前说话者被收听到的状况，可用于控制自适应性的编码。除了用户名外，可以包含其他标识信息，只要符合控制带宽限制。一个参与者在离开会议时发送RTCP BYE包。\n2.2 音频和视频会议（Audio and Video Conference） 一个会议如果同时使用音频和视频媒体，则二者传输时使用不同的RTP会话。也就是说，两种媒体中RTP包和RTCP包的传输，是使用两个不同的UDP端口对和（或）多播地址。在RTP层次，音频和视频会话没有直接的耦合；一个同时参加两个会话的参与者，在两个会话的RTCP包中，SHOULD 使用相同的规范名，这样两个会话就发生关联（耦合）了。\n这样分割的其中一个目的是允许一些会议参与者只接受自己选择的某一个媒体（或者音频，或者视频）。更进一步的说明在章节5.2给出。尽管两种媒体区分开来了，但通过两个会话RTCP包内载有的计时信息，同源的音频与视频还是能够同步回放。\n2.3 混频器和转换器（Mixers and Translators） 场景一：一个地方的参与者只能低速接入会议，而其他大部分参与者都能享受高速连接：\n在只能低速接入的地方，放置一个减质量音频编码的RTP层次的中继（称作混频器）。混频器将重新同步输入的音频包，重建发送方产生的20ms固定间隔，混频已重建过的音频流为单一的流，转换音频编码为低带宽格式，最后通过低带宽连接转发数据包流（package stream)。RTP报头为混频器提供了一种方法，使其能辨识出对混频后的包有用的源，从而保证提供给接收方正确的说话者指示。\n场景二：，一些预定参与者尽管有高带宽连接，但不能通过IP多播直接接入会议（位于一个不允许任何IP包通过的应用层防火墙后面）：\n需要另一种称为转换器的RTP层次中继。可以在防火墙两侧分别安装一个转换器，外侧转换器将所有多播包通过安全连接转入内侧转换器，内侧转换器再转发给内部网的一个多播组（multicast group)。\n2.4 分层编码（Layered Encodings） 为了匹配接收方的能力（容量）以及适应网络拥塞，多媒体应用程序应当能够调整其传输速率。许多应用实现把调适传输速率的责任放在源端。这种做法在多播传输中并不好，因为不同接收方对带宽存在着冲突性需求。这经常导致最小公分母的场景，网格中最小的管道支配了全部实况多媒体“广播”的质量和保真度。\n相反地，可以把分层编码和分层传输系统组合起来，从而把调适速率的责任放在接收端。在IP多播之上的RTP上下文中，对一个横跨多个RTP会话（每个会话在独自多播组上开展）的分级表示信号(a hierarchically represented signal)，源能够把它的分层（layers)分割成条。 接收方仅需合并适当的多播组子集，就能适应异种网络和控制接收带宽。\n3.定义（definitions)    概念 定义     RTP payload 通过RTP传输的包中的数据，例如，音频样本或压缩好的视频数据。   RTP packet 一种数据包，其组成部分有：一个固定RTP报头，一个可能为空的作用源（contributing sources）列表（见下文），以及负载数据。一些下层协议可能要求对RTP包的封装进行定义。一般地，下层协议的一个包包含一个RTP包，但若封装方法允许，也可包含数个RTP包（见章节11）。   RTCP packet 一种控制包，其组成部分有：一个类似RTP包的固定报头，后跟一个结构化的部分，该部分具体元素依不同RTCP包的类型而定。格式的定义见章节６。一般地，多个RTCP包将在一个下层协议的包中以合成RTCP包的形式传输；这依靠RTCP包的固定报头中的长度字段来实现。   Port 传输协议用来在同一主机中区分不同目的地的一种抽象。TCP/IP协议使用正整数来标识不同端口。[12]　OSI传输层使用的传输选择器（TSEL,the transport selectors）等同于这里的端口。RTP需依靠低层协议提供的多种机制，如“端口”用以多路复用会话中的RTP和RTCP包。   Transport address 是网络地址与端口的结合，用来标识一个传输层次的终端，例如一个IP地址与一个UDP端口。包是从源传输地址发送到目的传输地址。   RTP media type 一个RTP媒体类型是一个单独RTP会话所载有的负载类型的集合。RTP配置文件把RTP媒体类型指派给RTP负载类型。   Multimedia session 在一个参与者公共组中，并发的RTP会话的集合。例如，一个视频会议（为多媒体会话）可能包含一个音频RTP会话和一个视频RTP会话。   RTP session 一群参与者通过RTP进行通信时所产生的关联。一个参与者可能同时参与多个RTP会话。在一个多媒体会话中，除非编码方式把多种媒体多路复用到一个单一数据流中，否则每种媒体都将使用各自的RTCP包，通过单独的RTP会话来传送。通过使用不同的目的传输地址对（一个网络地址加上一对分别用于RTP和RTCP的端口，构成了一个传输地址对）来接收不同的会话，参与者能把多个RTP会话区隔开来。单个RTP会话中的所有参与者，可能共享一个公用目的传输地址对，比如IP多播的情况；也可能各自使用不同的目的传输地址对，比如个体单播网络地址加上一个端口对。对于单播的情况，参与者可能使用相同端口对来收听其他所有参与者，也可能对来其他每个参与者使用不同的端口对来收听。  RTP会话间相互区别的特征，在于每个RTP会话都维护一个用于SSRC标识符的独立完整的空间。RTP会话所包含的参与者组，由能接收SSRC标识符的参与者组成，这些SSRC标识符由RTP（同步源或作用源）或RTCP中的任意参与者传递。例如，考虑下述情况，用单播UDP实现的三方会议，每方都用不同的端口对来收听其他两方。如果收到一方的数据，就只把RTCP反馈发送给那一方，则会议就相当于由三个单独的点到点RTP会话构成；如果收到一方的数据，却把RTCP反馈发送另两方，则会议就是由一个多方（multi-party)RTP会话构成。后者模拟了三方间进行IP多播通信时的行为。  RTP框架允许上述规定发生变化，但一个特定的控制协议或者应用程序在设计时常常对变化作出约束。   Synchronization source (SSRC) RTP包流的源，用RTP报头中32位数值的SSRC标识符进行标识，使其不依赖于网络地址。一个同步源的所有包构成了相同计时和序列号空间的一部分，这样接收方就可以把一个同步源的包放在一起，来进行重放。举些同步源的例子，像来自同一信号源的包流的发送方，如麦克风、摄影机、RTP混频器（见下文）就是同步源。一个同步源可能随着时间变化而改变其数据格式，如音频编码。SSRC标识符是一个随机选取的值，它在特定的RTP会话中是全局唯一（globally unique）的（见章节8）。参与者并不需要在一个多媒体会议的所有RTP会话中，使用相同的SSRC标识符；SSRC标识符的绑定通过RTCP（见章节6.5.1）。如果参与者在一个RTP会话中生成了多个流，例如来自多个摄影机，则每个摄影机都必须标识成单独的同步源。   Contributing source (CSRC) 若一个RTP包流的源，对由RTP混频器生成的组合流起了作用，则它就是一个作用源。对特定包的生成起作用的源，其SSRC标识符组成的列表，被混频器插入到包的RTP报头中。这个列表叫做CSRC表。相关应用的例子如，在音频会议中，混频器向所有的说话人（talker)指出，谁的话语（speech)将被组合到即将发出的包中，即便所有的包都包含在同一个（混频器的）SSRC标识符中，也可让听者（接收者）可以清楚谁是当前说话人。   End system 一种应用程序，它产生发送出的RTP包中内容，或者使用接收到的RTP包中内容。在一个特定的RTP会话中，一个终端系统可以扮演一个或多个同步源角色，但通常是一个。  混频器（Mixer)：一种中间系统，它从一个或多个源中接收RTP包，可能改变其数据格式，再按某种方式把这些包组合成一个新的包，然后转发出去。由于多个输入源的计时一般不会同步，所以混频器会对各个流的计时作出调整，并为组合流生成一个新的计时。因此，混频器将被标识成它所产生所有数据包的同步源。   Translator 一种中间系统，它转发RTP包而不改变各包的同步源标识符。转换器的例子如下：不作混频地转变编码的设备，把多播复制到单播的重复装置，以及防火墙里应用层次的过滤器。   Monitor 一种应用程序，它接收RTP会话参与者所发送的RTCP包，特别是接收报告（reception report)，而且对当前服务质量进行评估，评估结果用于分配监视任务，故障诊断和长期统计。监视器常常被内建到参与会话的应用程序中，但也可以是一个的独立的应用程序——不参加会话、也不发送或接收RTP数据包（因为它们在不同的端口上）。这些被称作第三方监视器。还有一种情况也是可以接受的，第三方监视器只接收但不发送数据包，或者另外地算入到会话中。   Non-RTP means 为提供一个可用的服务，可能还需要其他的协议和机制。特别地，对多媒体会议来说，一个控制协议可以发布多播地址，发布加密密钥，协商所用的加密算法，以及为没有预定义负载类型值的格式，建立负载类型值和其所代表的负载格式之间的动态映射。其他协议的例子如下：会话初始化协议（SIRFC3261[13]），ITU推荐的H.323[14]，还有使用SDP(RFC2327[15])的应用程序，如RTSP(RFC 2326[16]). 对于简单的应用程序，电子邮件或者会议数据库也可能用到。    4. 字节序,对齐和时间格式 5. RTP数据传输协议 5.1 RTP固定头中的各字段 RTP头有以下格式:\nReal Time Transport Protocol\n1 0 1 2 3 2 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 3 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 4 |V=2|P|X| CC |M| PT | sequence number | 5 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 6 | timestamp | 7 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 8 | synchronization source (SSRC) identifier | 9 +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+ 10 | contributing source (CSRC) identifiers | 11 | .... | 12 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 前12个字节出现在每个RTP包中，仅仅在被混合器插入时，才出现CSRC识别符列表。这些域有以下意义：\n  **version (V)：**2 bits\n此域定义了RTP的版本。此协议定义的版本是2。(值1被RTP草案版本使用，值0用在最初\u0026quot;vat\u0026quot;语音工具使用的协议中。)\n  **padding (P)：**1 bit\n若设置了padding位，则该packet在尾端包含一到多个padding octets，padding octets 不算作负载的一部分。padding的最后一个字节指明可以忽略多少个 padding octets（包括它自己）。padding可能在某些要求固定块大小的加密算法中需要，或者用于在底层数据单元中传输多个RTP包。\n  **extension (X)：**1 bits\n若设置extension位，固定头后面MUST跟随一个（且仅一个）头扩展，头扩展的格式定义与Section 5.3.1。\n  **CSRC count (CC)：**4 bits\nCSRC计数包含了跟在固定头后面CSRC识别符的数目。\n  **marker (M)：**1 bit\n标志的解释由具体profile规定。它用来允许在比特流中标记重要的事件，如帧边界。\n  **payload type (PT)：**7bits\n此域定义了负载的格式，由具体应用决定其解释。协议可以规定负载类型码和负载格式之间一个默认的匹配。其他的负载类型码可以通过非RTP方法动态定义。RTP发送端在任意给定时间发出一个单独的RTP负载类型；此域不用来复用不同的媒体流。\n  sequence number:16 bits\n每发送一个RTP数据包，序列号加1，接收端可以据此检测丢包和重建包序列。序列号的初始值是随机的(不可预测)，以使即便在源本身不加密时(有时包要通过翻译器，它会这样做)，对加密算法泛知的普通文本攻击也会更加困难。\n  timestamp: 32 bits\n时间戳反映了RTP数据包中第一个字节的采样时间。（采样时钟必须来源于一个及时的单调、线性递增时钟，以便允许同步和去除网络引起的数据包抖动（见章节6.4.1）。该时钟的分辨率必须满足期望的同步精度和测量数据包到来时的抖动的需要（一种典型的时钟分辨率不满足情况是每个视频帧仅一个时钟周期）时钟频率依赖于负载数据的格式，并在描述文件（profile）中或者是在负载格式描述中（payload format specification）进行静态描述。也可以通过非RTP方法（non-RTP means）对负载格式动态描述。 如果RTP包是周期性产生的，那么将使用由采样时钟决定的名义上的采样时刻，而不是读取系统时间。例如，对一个固定速率的音频，采样时钟（时间戳时钟）将在每个周期内增加1。如果一个音频从输入设备中读取含有160个采样周期的块，那么对每个块，时间戳的值增加160，而不考虑该块是否用一个包传递或是被丢弃。 时间戳的初始值应当是随机的，就像序号一样。几个连续的RTP包如果（逻辑上）是同时产生的，如：属于同一个视频帧的RTP包，将有相同的时间戳。如果数据并不是以它采样的顺序进行传输，那么连续的RTP包可以包含不是单调递增（或递减）的时间戳（RTP包的序列号仍然是单调变化的）。 不同媒体流的RTP时间戳可能以不同的速率增长。而且会有独立的随机偏移量。因此，虽然这些时间戳足以重构一个单独的流的时序，但直接比较不同的媒体流的时间戳不能有效的进行同步。对于每一个媒体，我们把与采样时刻相关联的RTP时间戳与来自于参考时钟上的时间戳（NTP）相关联（相反，对于每一种媒体，RTP时间戳通过与一个参考时间戳wallclock配对的方法来与采样时刻联系起来。）。参考时钟的时间戳表示了（对应于RTP时间戳的）数据的采样时刻。（即：RTP时间戳可用来实现不同媒体流的同步，NTP时间戳解决了RTP时间戳有随机偏移量的问题。）参考时钟用于同步所有媒体的共同时间（参考时间戳为所有媒体所公用，以此来实现同步）。这一时间戳对（RTP时间戳和NTP时间戳），用于判断RTP时间戳和NTP时间戳的对应关系，以进行媒体流的同步。它们不是在每一个数据包中都被发送，而在发送速率更低的RTCP的SR（发送者报告）中。即RTP时间戳记录当前是第几个采样数据，NTP时间戳记录当前数据包相对于参考时钟（1900年1月1日0点算起，当前时间相对于该时刻所经过的秒数）的绝对时间。 选取采样时间作为RTP时间戳的参考点是因为它可以被传输的终节点获知，而且对所有媒体内容有一个相同的定义，再者是它不受编码延迟或其它数据处理的约束。目的是为了对所有在同一时刻采样的媒体进行同步。 如果传输的数据是存贮好的，而不是实时采样等到的，那么会使用从参考时钟得到的虚的表示时间线（virtual presentation timeline虚拟表示时间表）以确定存贮数据中的每个媒体下一帧或下一个单元应该呈现的时间（还是时刻？？？）。此种情况下RTP时间戳反映了每一个单元应当回放的时间（时刻？？？）。这就是说，每个单元的RTP时间戳将会和参考时钟相关。真正的回放将由接收者决定。\n为事先录制的视频插播实时音频旁白的例子阐述了选择采样时刻作为参考点的重要性。在这种情况下，视频会在“本地”播放给解说员观看，同时会通过RTP向外界传输。RTP传输的一个视频帧的“采样时刻”将会被建立，建立的方法是将RTP包的时间戳与该视频帧播放给旁白者的时刻（参考时钟）相比较（即当前的采样序号结合绝对时间得出“采样时刻”）。包含有解说员解说的的音频RTP包，它的采样时刻将会在音频被采样的时刻，通过与同一参考时钟相比较而建立。音频和视频甚至可以被不同的主机传输只要这两个主机的参考时钟通过比如NTP之类的途径实现了同步。接受者能够使用RTCP SR包中的时间戳对从而将音频和视频同步。\n  **SSRC：**32 bits\n用以识别同步源。标识符应该被随机生成，以使在同一个RTP会话期中没有任何两个同步源有相同的SSRC识别符。一个用于创造随机标示符的示例算法在A.6第六章讲述。尽管多个源选择同一个SSRC识别符的概率很低，所有RTP实现工具都必须准备检测和解决冲突。第8章讲述了冲突的可能性及其解决机制。若一个源改变本身的源传输地址，必须选择新的SSRC识别符，以避免被当作一个环路源(see Section 8.2)。\n  **CSRC列表：**0到15项，每项32bits\nCSRC列表指出了对此包中负载内容的所有贡献源。识别符的数目在CC域中给定。若有贡献源多于15个，仅识别15个。CSRC识别符由混合器插入(see Section 7.1)，并列出所有贡献源的SSRC识别符。例如语音包，混合产生新包的所有源的SSRC标识符都被列出，以在接收端处正确指示参与者。\n  5.2 复用RTP会话 省略第一段\n独立的音频和视频流不应该在一个RTP会话中传输然后根据负载的类型或SSRC来解除复用。包含不同RTP媒体类型的交错包，并且这些包使用同一SSRC将会引起下面一系列问题。\n 假设，两个共用相同RTP会话和相同SSRC标识的音频流，其中一个改变了编码，由此需要一个不同的负载类型。这时就没有办法来识别究竟是哪个音频流改变了编码。 SSRC标示符是被定义用来确定一个单一的时序和序列号空间。如果媒体的时钟频率不同，那么交错的多种媒体负载类型需要不同的时序空间和不同的序列号空间，由此来指出哪种负载类型发生了数据包丢失。 RTCP发送方和接受方报告只能对每一个SSRC标示符表述一种时序和序列号空间，并且不能加载负载类型域。 RTP混合器不能够将不兼容的交叉流合并到一种数据流中。  为每一种媒体采用一个不同的SSRC标示符，但是仍然将他们放在一个RTP会话中传输可以避免前两个问题，但无法避免最后两个。 另一方面，复用同一媒体的有联系的源于一个使用不同SSRC标示符的RTP会话中是关于多播会话的规范。上述的问题不适用于：比如说，一个RTP混合器能够合并多种音源，并且同样的待遇适用于所有的音源。在最后两个问题不会发生的其他情况下，同一媒体的数据流复用（这些数据流使用不同的SSRC）也可以是适当的。\n5.3 对于RTP包头特性说明的修改 已经存在的RTP数据包包头被认为已经满足通常所有应用类型的需要。然而，为了符合ALF设计原则，该包头可以通过修改或作一些定义在特性说明中的增加的方法实现个性定制。同时，仍然允许与特性独立的显示和记录工具产生作用。\n 标示位和负载类型域携带profile-specific信息，但是它们被存储在固定的包头中，因为很多应用程序被预计需要它们，否则可能需要增加另外32位来存储它们。包含这些域的八位字节可能被一个profile重新定义，从而适应于不同的需求，例如增加和减少标示位。但是只要有标示位，都必须有一个在该字节的msb；以让特性独立的(profile-independent)监视器能够观察到包丢失模式和标示位之间的相互关系。 ​ Additional information that is required for a particular payload format, such as a video encoding, should be carried in the payload section of the packet. This might be in a header that is always present at the start of the payload section, or might be indicated by a reserved value in the data pattern. 如果一种特殊的应用需要独立于负载类型的附加功能，那么这些应用执行的profile应该定义附加的固定域，这些固定域应该紧跟着SSRC域。这些应用能够快捷地访问这些附加域，而这时那些profile-independent监视器和记录器仍然能够通过解释前12个字节来处理RTP数据包。  如果事实证明一种附加的功能在所有文件中被普遍需求，那时，就需要定义一个新版本的RTP包头。\n5.3.1 RTP头扩展 RTP提供扩展机制以允许实现个性化：某些新的与负载格式独立的功能要求的附加信息在RTP数据包头中传输。设计此扩展机制可以使其它没有扩展的交互忽略此头扩展。RTP头扩展的格式如下图所示。 注意特殊负载类型需要的附加信息不能使用这种头扩展，而是应该被存贮在数据包的负载部分中。\n1 0 1 2 3 2 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 3+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 4| defined by profile | length | 5+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 6| header extension | 7| .... | 若RTP头中的扩展比特位置1，则一个长度可变的头扩展部分被加到RTP固定头之后。头扩展包含16比特的长度域，指示扩展项中32比特字的个数，不包括4个字节扩展头(因此零是有效值)。RTP固定头之后只允许有一个头扩展。为允许多个互操作实现独立生成不同的头扩展，或某种特定实现有多种不同的头扩展，扩展项的前16比特用以识别标识符或参数。这16比特的格式由具体实现的上层协议定义。基本的RTP说明并不定义任何头扩展本身。\n6. RTP控制协议RTCP 6.1 RTCP包格式 这部分定义了几个RTCP包类型，可以传送不同的控制信息：\n SR： 发送者报告，描述当前发送者的的发送和接收统计； **RR：**接收者报告，描述非当前发送者的接收统计； **SDES：**源描述项，其中包括规范名(CNAME)； **BYE：**表明参与者将结束会话； **APP：**应用特定功能。  每个RTCP包以与RTP数据包类似的固定头部起始，接着是根据RTCP包类型而可能长度不同的结构化元素，但是必须结尾于32位边界（即该RTCP包的总位数可以被32整除）。对齐要求和每个包固定头部中的长度域使RTCP包\u0026quot;可堆叠\u0026quot;，即可以将多个RTCP包形成一个复合RTCP包，在底层协议(如UDP)中，通常都是将复合包作为一个包传输的。 在RTCP复合包中不明确指定有多少个RTCP包，而是依靠底层协议提供(该复合包的)总长度来决定该复合包的结束（UDP在头部包含一个field，指定其长度）。\n复合包中的每个RTCP包可以单独处理，而无需考虑包复合的顺序。然而，为了实现RTCP协议的某些功能，添加以下限制：\n 接收统计信息(在SR或RR中)只要带宽允许应该尽可能经常的发送，以达到统计的最大分辨率。因此每个周期发送的RTCP复合包必须包含一个报告包。 新的参与者需要尽快接收一个源的规范名以识别数据源并开始关联媒体以实现唇形同步。因此，每个包中必须包含SDES CNAME，除非复合包被分割以进行部分加密（见9.1节的描述）。 必须限制首次在复合包中出现的包类型的数目，以增加在第一个字中常数比特的数目，这样可以增加RTCP包的有效性，以区分误传的RTP包和其他无关的包。  因此，所有RTCP包必须以复合包的形式发送。复合包中至少有两个RTCP包。具有以下格式：\n **加密前缀：**当且仅当复合包被加密时，对每个RTCP复合包前缀一个32位随机数。如果加密需要padding，必须添加到复合包的最后一个封包中。 **SR或RR：**复合包中的第一个RTCP包必须是一个报告包，以利于附录A.2中描述的头部验证。即使还没有数据发送和接收，该限制也是适用的。此时必须发送一个空的RR包，同样必须在复合包中搭配一个其他的RTCP包，即使是BYE。 **额外的RR：**若被报告的接收统计源数目超过SR/RR包中最大允许的31个，附加的RR必须跟在最初的报告包后面。 **SDES：**除了9.1节描述的情况外，每个RTCP复合包都必须包含一个SDES包。 **BYE或APP：**其他RTCP包类型（非SR/RR/SDES packet），包括那些尚未定义的，可以遵循任何顺序，除了BYE必须是最后一个封包(每个BYE包都包含一个给定的SSRC/CSRC)。  每个RTP参与者在一个报告间隔内应只发送一个RTCP复合包，以便正确估计每个参与者的RTCP带宽。除非像9.1节描述的情况——把一个RTCP复合包分割以进行加密。如果数据源的个数太多，以至于不能把RR包都放到同一个RTCP复合包中而不超过路径MTU，那么可在每个间隔中发送RR包的子集。在多个发送间隔中，所有的RR包应该被等概率的选中，这样就可以报告所有数据源的接收数据的情况。\n为了分摊the packet overhead，推荐Translators and Mixers在可行的时候，把来自多个source的各自的RTCP packet综合到一个复合包。如果一个RTCP复合包的长度超过了路径MTU，则它应当被分割为多个更短的复合包来传输（以什么规则segment？）。这不会影响对RTCP带宽的估计，因为每一个复合包至少代表了一个参与者。要注意的是每个RTCP复合包必须以SR或RR包开头。\n应该忽略那些未知类型的输入RTCP包。\n1 if encrypted: random 32-bit integer 2 | 3 |[--------- packet --------][---------- packet ----------][-packet-] 4 | 5 | receiver chunk chunk 6 V reports item item item item 7 -------------------------------------------------------------------- 8 R[SR #sendinfo #site1#site2][SDES #CNAME PHONE #CNAME LOC][BYE##why] 9 -------------------------------------------------------------------- 10 | | 11 |\u0026lt;----------------------- compound packet -----------------------\u0026gt;| 12 |\u0026lt;-------------------------- UDP packet -------------------------\u0026gt;| 13 14 #: SSRC/CSRC identifier 6.2 RTCP传输时间间隔 RTP被设计为自动适应不同的规模的会话――从几个参与者到几千个参与者的会话。例如，在一个音频会议中，data traffic is inherently self-limiting（速率是自我限制的），因为同时只会有一个或两个人说话；因此在组播分发的情况下，任何link上的data rate都保持相对固定，不管有多少个参与者。尽管如此，control traffic却不是self-limiting。如果来自每个参与者的接收报告以恒定速率发送，则控制流量将随着参与者数量的增加而线性增长。因此，必须通过动态计算RTCP分组传输之间的间隔来降低速率。\n对每一个会话，我们假定数据传输受到一个上限――会话带宽的限制。会话带宽分配给所有的参与者。这个带宽会被预留，并由网络所限制。如果没有预留，基于环境的其他约束将会确定合理的最大带宽供会话使用，这就是会话带宽。会话带宽在一定程度上独立于媒体编码，但媒体编码却依赖于会话带宽。\n在涉及媒体应用时，会话带宽参数最好由一个会话控制应用提供。但媒体应用可能设置一个默认参数。此参数由单个发送者选择的编码方式的数据带宽算出。会话管理可能会基于多播范围的规则或其他标准确定带宽限制。所有的参与者应使用相同的会话带宽值以保证计算出相同的RTCP间隔。 控制传输带宽应当是会话带宽的一小部分，这部分所占总的会话带宽的百分比应是已知的。一小部分：传输协议的首要功能是传输数据；已知：控制传输带宽可以被放进带宽描述中提供给资源预留协议，并且使每个参与者都可以独立的计算出他所占有的带宽份额。\n控制传输带宽作为额外的一部分加入到会话带宽中。建议RTCP控制传输带宽为RTCP会话带宽的5%。其中的1/4分配给发送者；当发送者的比例超过所有参与者的1/4时，其RTCP控制带宽相应增加。所有的会话参与者必须使用相同的常数（以上提到的百分比），以便计算出相同的发送时间间隔。这些常数应在一个特殊的描述文件中确定。\n计算出的RTCP复合包的发送时间间隔应该有一个下限，以免参与者数量较少时大量发送RTCP包。这也使网络暂时断开时，发送间隔不会太小。在应用开始时，一个延迟应加到第一个的TCP复合包发送之前，以便从其他参与者接收RTCP复合包。这样，发送时间间隔能更快的收敛到正确的值。这个延迟可以设为最小时间间隔的一半。固定的时间间隔建议为5秒。\n一个实现可能使RTCP最小发送时间间隔与会话带宽参数成比例。则应满足下列约束：\n 对多播会话，只有活动的数据发送者使用减小的最小化的值计算RTCP复合包的发送时间间隔。 对单播会话，减小的值也可能被不是活动的数据发送者使用，发送初始的RTCP复合包之前的延迟可能是0。 对所有会话，在计算参与者的离开时间时，这个固定最小值会被用到。因此，不使用减小的值进行RTCP包的发送，就不会被其他参与者提前宣布超时。 减小的最小时间间隔建议为：360/sb(秒)，其中sb：会话带宽（千字节/秒）。当sb\u0026gt;72kb/s时，最小时间间隔将小于5s。 6.3节所描述的算法和附录A.7将实现本节列出的目标： ○计算出的RTCP包的时间间隔与组中参与者的人数成正比。（参与者越多，发送时间间隔越长，每个参与者占有的RTCP带宽越小）。 RTCP包的（真实）时间间隔是计算出的时间间隔的0.5～1.5倍之间某个随机的值，以避免所有的参与者意外的同步。 RTCP复合包的平均大小将会被动态估计，包括所有发送的包和接收的包。以自动适应携带的控制信息数量的变化。 由于计算出的时间间隔依赖于组中的人数。因此，当一个的用户加入一个已经存在的会话或者大量的用户几乎同时加入一个新的会话时，就会有意外的初始化效应。这些新用户将在开始时错误的估计组中的人数（估计太小）。因此他们的RTCP包的发送时间间隔就会太短。如果许多用户同时加入一个会话，这个问题就很重要了。为了处理这处问题考虑了一种叫“时间重估”的算法。这个算法使得组中人数增加时，用户能够支持RTCP包的传输。 当有用户离开会话，不管是发送BYE包还是超时，组中的人数会减少。计算出的时间间隔也应当减少。因此，应用“逆向重估”算法，使组中的成员更快的减少他们的时间间隔，以对组中的人数减少做出响应。 BYE包的处理和其他RTCP包的处理不同。BYE包的发送用到一个“放弃支持”算法。以避免大量的BYE包同时发送，使大量参与者同时离开会话。 这个算法适用于所有参与者都允许RTCP包的情况。此时，会话带宽＝每个发送者的带宽×会话中参与者的总人数。详细算法见随后小节，附录A.7给出了算法的一个实现。  6.2.1 维持会话成员的人数 当侦听到新的站点的时候，应当把他们加入计数。每一个登录都应在表中创建一条记录，并以SSRC或CSRC进行索引。新的登录直到接收到含有SSRC的包或含有与此SSRC相联系的规范名的SDES包才视为有效（见附录A.1）。当一个与SSRC标识符相对RTCP　BYE包收到时，登录会被从表中删除。除非一个“掉队”的数据包到达，使登录重新创建。 如果在几个RTCP报告时间间隔内没有RTP或RTCP包收到，一个参与者可能标记另外一个站点静止，并删除它。这是针对丢包提供的一个很强健的机制。所有站点对这个超时时间间隔乘子应大体相同，以使这种超时机制正常工作。因此这个乘子应在特别的描述文件中确定。 对于一个有大量参与者的会话，维持并存贮一个有所有参与者的SSRC及各项信息的表几乎是不可能的。因此，只可以只存贮SSRC。其他算法类似。关键的问题就是，任何算法都不应当低估组的规模，虽然它有可能被高估。\n6.3 RTCP包的发送和接收规则 下面列出了如何发送RTCP包，当接收到的TCP包时该干什么的规则。 为执行规则，一个会话参与者就维持下列变量： tp:　RTCP包发送的最后时间。 tc: 当前时间。 tn: 估计的下一个RTCP包要发送的时间。 pmembers: tn最后被重新计算时，会计的会话成员的人数。 members: 会话成员人数的当前估计。 senders: 会话成员中发送者人数的估计。 rtcp_bw: 目标RTCP带宽。例如用于会话中所有成员的RTCP带宽。单位bit/s。这将是程序开始时，指定给“会话带宽”参数的一部分。 we_sent: 自当前第二个前面的RTCP发送后，应用程序又发送了数据，则此项为true。 avg_rtcp_size: 此参与者收到的和发送的RTCP复合包的平均大小。单位：bit。按6.2节，此大小包括底层传输层和网络层协议头。 initial: 如果应用程序还未发送RTCP包，则标记为true。 许多规则都用到了RTCP包传输的“计算时间间隔”。此时间间隔将在随后的小节描述。\n6.3.1 计算RTCP传输时间间隔","date":"2024-11-27","permalink":"/posts/tech/media-rtp/","series":["媒体开发"],"tags":["","",""],"title":"RTP协议学习"},{"categories":["计算机"],"content":"https://blog.csdn.net/weixin_43925427/article/details/140907523\nhttps://blog.csdn.net/qq_62821433/article/details/139480927\n概念 协程（Coroutines） 是一种程序组件，允许不同的执行线程或路径在单个进程中共享同一个执行环境。与线程相比，协程是轻量级的，因为它们共享相同的进程空间并具有较小的上下文切换开销。主要特点包括：\n 非阻塞执行：协程可以在等待 I/O 操作或其他长时间执行的任务时让出 CPU，允许其他协程运行。 协作式多任务处理：协程的切换是显式的，由程序员或协程库控制，不是由操作系统的调度器控制。 高效的并发：协程可以在单个线程中实现高效的并发执行，适用于处理大量并发连接和请求。  在网络应用中，协程可用于优化 I/O 操作，尤其是在高并发环境下。使用协程可以避免为每个客户端连接创建一个线程的高成本，从而减少资源消耗和提高性能。\n与进程，线程的区别   进程\n 1.程序的一次执行过程；\n2.系统资源分配的单位，具有独立的虚拟内存，PCB控制块，代码，数据，堆栈，文件资源等；\n3.进程上下文切换开销大（主要问题）\n   线程\n 1.系统调度的单位；\n2.共享进程的资源空间；具有自己的栈，寄存器\n3.并发性好，同一进程内的线程切换不会导致进程的上下文切换，所以线程切换开销小；\n4.共享进程资源，多线程会发生冲突，需要进行同步。\n   协程\n 1.可以理解为线程中的线程；\n2.具有自己的上下文；\n3.协程切换不会引起线程的上下文（更轻量）\n4.一个线程同一时刻只有一个协程执行；\n5.协程执行任意时刻都可以退出，下次可以继续执行（与函数的区别，函数一条路走到黑）\n6.高并发场景下性能很好，并且不需要同步\n   产生原因 协程效率高并不是根本原因。\n在高并发场景下，两个原因：\n1.用同步代码逻辑简单，并发性差强人意\n同步阻塞：阻塞等待业务处理，期间不能做其他事情\n同步非阻塞：不断轮询，忙等待占用cpu，\n2.用异步，并发性好，代码逻辑又很复杂\n基于以上就产生了协程，协程可以做到用同步的代码逻辑达到异步的效果\n优缺点 优点：\n1.用同步的思想编写出异步的效果，\n2.并发性好，性能高\n缺点：\n单线程中同时只能执行一个协程，无法利用多核功能，还是得结合多线程\n协程库  Boost.Coroutine2：这是Boost库中的⼀个模块，提供了⼀组灵活的协程实现，包括对称协程和⾮对称协程。它提供了⼀些强⼤的特性，如⽀持多个栈和⾃定义栈⼤⼩。 libco：腾讯微信团队开源的⼀个C/C++协程库，据说微信后台⼤量在使⽤这个库，通过⼏个简单的接⼝就能实现协程的创建/调度，同时基于epoll/kqueue实现了⼀个事件反应堆，再加上sys_call（系统调⽤）hook技术，以此给开发者提供同步/异步的开发⽅法 libgo ：是⼀个使⽤ C++ 编写的协作式调度的stackful有栈协程库, 同时也是⼀个强⼤的并⾏编程库。⽀持linux平台，MacOS和windows平台，在c++11以上的环境中都能⽤。  ucontext库 概念 在 C 语言中，ucontext 库提供了一套功能丰富的 API，用于管理程序的执行上下文。这些功能主要用于实现用户空间的轻量级线程（协程），允许程序在多个执行流之间进行显式的上下文切换。\n 上下文（Context）：表示程序在某一时间点的运行状态，包括程序计数器、寄存器集合和堆栈等。 协程（Coroutine）：是一种比线程更轻量的执行单元，它允许进行非抢占式的任务切换，即在用户空间进行切换而无需内核介入。  核心函数   getcontext(ucontext_t \\*ucp): 获取当前执行流的上下文，并保存在 ucp 指向的 ucontext_t 结构体中。（初始化）\n  setcontext(const ucontext_t \\*ucp): 切换到 ucp 指定的上下文执行。调用此函数后，程序的控制流会转移到新的上下文继续执行，当前函数不会返回。\n  makecontext(ucontext_t \\*ucp, void (\\*func)(), int argc, ...): 修改 ucp 指定的上下文，设置它的执行函数和函数参数。func 应是一个不返回值的函数，因为从该函数返回将导致程序终止。（第一次swap到ctx时，就开始执行func；后面swap回来时，继续执行func）\n  swapcontext(ucontext_t \\*oucp, const ucontext_t \\*ucp): 保存当前上下文到 oucp 并切换到 ucp 指向的上下文。通常用于实现协程之间的切换。\n  ucontext_t 结构体 ucontext_t 结构体是管理上下文的核心，它包括以下几个部分：\n  uc_link:\n当前上下文结束后，程序执行将继续的上下文的指针。\n  uc_stack: 描述当前上下文使用的堆栈的信息，包括堆栈的位置、大小和标志。\n  uc_mcontext: 保存特定于机器的执行上下文信息（如寄存器），这部分是系统特定的。\n  uc_sigmask: 上下文执行时的信号屏蔽集，用于控制哪些信号在此上下文中被阻塞。\n  代码示例： 1#include \u0026lt;stdio.h\u0026gt;2#include \u0026lt;ucontext.h\u0026gt;3 4ucontext_t ctx[3]; // 创建三个上下文对象，对应三个协程 5ucontext_t main_ctx; // 主上下文，用于协程之间的调度 6 7int count = 0; // 全局变量，用于控制打印次数和协程切换 8 9// coroutine1 10void func1(void) { 11 // 当 count 小于 30 时持续执行 12\twhile (count ++ \u0026lt; 30) { 13\tprintf(\u0026#34;1\\n\u0026#34;); // 打印标识符1 14\tswapcontext(\u0026amp;ctx[0], \u0026amp;main_ctx); // 从协程1切换到主上下文 15\tprintf(\u0026#34;4\\n\u0026#34;); // 当协程1再次获得控制时，打印标识符4 16\t} 17} 18 19// coroutine2 20void func2(void) { 21 // 当 count 小于 30 时持续执行 22\twhile (count ++ \u0026lt; 30) { 23\tprintf(\u0026#34;2\\n\u0026#34;); // 打印标识符2 24\tswapcontext(\u0026amp;ctx[1], \u0026amp;main_ctx); // 从协程2切换到主上下文 25\tprintf(\u0026#34;5\\n\u0026#34;); // 当协程2再次获得控制时，打印标识符5 26\t} 27} 28 29// coroutine3 30void func3(void) { 31 // 当 count 小于 30 时持续执行 32\twhile (count ++ \u0026lt; 30) { 33\tprintf(\u0026#34;3\\n\u0026#34;); // 打印标识符3 34\tswapcontext(\u0026amp;ctx[2], \u0026amp;main_ctx); // 从协程3切换到主上下文 35\tprintf(\u0026#34;6\\n\u0026#34;); // 当协程3再次获得控制时，打印标识符6 36\t} 37} 38 39// schedule 40int main() { 41 // 分配堆栈空间 42\tchar stack1[2048] = {0}; 43\tchar stack2[2048] = {0}; 44\tchar stack3[2048] = {0}; 45 46 // 初始化协程1的上下文，并设置堆栈和链接 47\tgetcontext(\u0026amp;ctx[0]); 48\tctx[0].uc_stack.ss_sp = stack1; 49\tctx[0].uc_stack.ss_size = sizeof(stack1); 50\tctx[0].uc_link = \u0026amp;main_ctx; 51\tmakecontext(\u0026amp;ctx[0], func1, 0); 52 53 // 初始化协程2的上下文，并设置堆栈和链接 54\tgetcontext(\u0026amp;ctx[1]); 55\tctx[1].uc_stack.ss_sp = stack2; 56\tctx[1].uc_stack.ss_size = sizeof(stack2); 57\tctx[1].uc_link = \u0026amp;main_ctx; 58\tmakecontext(\u0026amp;ctx[1], func2, 0); 59 60 // 初始化协程3的上下文，并设置堆栈和链接 61\tgetcontext(\u0026amp;ctx[2]); 62\tctx[2].uc_stack.ss_sp = stack3; 63\tctx[2].uc_stack.ss_size = sizeof(stack3); 64\tctx[2].uc_link = \u0026amp;main_ctx; 65\tmakecontext(\u0026amp;ctx[2], func3, 0); 66 67 // 开始从主上下文切换到协程 68\tprintf(\u0026#34;swapcontext\\n\u0026#34;); 69\twhile (count \u0026lt;= 30) { // 调度器，循环切换到各个协程 70\tswapcontext(\u0026amp;main_ctx, \u0026amp;ctx[count % 3]); // 循环切换到三个协程 71\t} 72 73\tprintf(\u0026#34;\\n\u0026#34;); 74} 关键点：\n 初始化上下文：为每个协程分配堆栈并设置其执行的函数。 协程调度：主函数中的 while 循环实现简单的轮转调度（Round-Robin），根据 count 的值循环切换到三个协程的上下文。 swapcontext()：保存当前上下文并激活新的上下文。在每个协程中，它将控制权交回给主上下文，而主上下文则根据调度逻辑选择下一个要运行的协程。  运行结果：\n11 22 33 44 51 65 72 86 93 104 111 125 132 146 153 164 171 185 192 206 213 224 231 245 252 266 273 284 291 305 312 326 333 344 351 365 372 386 393 404 411 425 432 446 453 464 471 485 492 506 513 524 531 545 552 566 573 584 伪代码框架解析 1struct coroutine{ 2 int fd; // 文件描述符，用于网络 I/O 3 ucontext_t ctx; // 上下文信息，用于协程切换 4 void *arg; // 函数参数 5 queue_node(coroutine, ) ready_queue; // 准备就绪的协程队列 6 rbtree_node(coroutine, ) wait_rb; // 等待中的协程红黑树 7 rbtree_node(coroutine, ) sleep_rb; // 睡眠中的协程红黑树 8}; 这里，每个协程包括一个文件描述符、上下文信息、函数参数以及三种状态的管理节点：就绪、等待和睡眠。\n1void func(void){ 2} 3typedef void *(*coroutine_entry)(void *) 4int create_coroutine(co_id, coroutine_entry entry, void *arg){ 5 struct coroutine *co = malloc(sizeof(struct coroutine)); 6 co-\u0026gt;ss_sp = 7 makecontext(\u0026amp;co-\u0026gt;ctx, func, 0); 8} 在这段代码中，create_coroutine 函数用于初始化一个协程。它分配内存，设置栈空间，并使用 makecontext 准备上下文切换。func 是协程将要执行的函数。\n1// 调度器 2struct scheduler{ 3 int epfd; // epoll 文件描述符 4 struct epoll_event events[]; // 事件数组 5 6 queue_node(coroutine, ) ready_head; // 就绪队列头 7 rbtree_root(coroutine, ) wait; // 等待红黑树 8 rbtree_root(coroutine, ) sleep; // 睡眠红黑树 9} 调度器负责管理所有协程的生命周期和状态转换。它使用 epoll 监听事件，根据 I/O 事件调度协程。就绪、等待和睡眠队列/树用于管理不同状态的协程。\n通过使用协程，你可以高效地管理数以万计的并发连接，每个连接使用非常少的内存，同时避免多线程编程中常见的同步和竞争状态问题。\nhook实践 基本概念 Hook 是一种编程技术，用于拦截和修改函数或方法的调用。通过 hook，程序员可以在函数调用前后插入自定义逻辑，从而改变程序的行为。Hook 常用于以下几个场景：\n 调试：插入调试代码来监控函数调用及其参数和返回值。 监控：监控系统或应用程序的行为，例如记录日志。 扩展功能：在不修改原始代码的情况下添加新的功能。 安全性：拦截和修改系统调用以增强安全性。  Hook 的实现方式有多种，常见的包括：\n 动态链接库插桩：使用动态链接库 (DLL) 的加载机制来替换或扩展现有函数。 代码注入：将自定义代码注入到目标进程中。 函数指针替换：修改函数指针，使其指向自定义的函数。 虚函数表 (VTable) 替换：在 C++ 中，通过替换对象的虚函数表条目来实现 hook。  代码实践 定义函数指针类型和变量\n1typedef ssize_t (*read_t)(int fd, void *buf, size_t count); 2read_t read_f = NULL; 3 4typedef ssize_t (*write_t)(int fd, const void *buf, size_t count); 5write_t write_f = NULL; 定义了两个函数指针类型 read_t 和 write_t，并声明了两个全局变量 read_f 和 write_f。这些变量将用于保存原始的 read 和 write 函数地址。 Hook 函数实现\n1ssize_t read(int fd, void *buf, size_t count) { 2 struct pollfd fds[1] = {0}; 3 4 fds[0].fd = fd; 5 fds[0].events = POLLIN; 6 7 int res = poll(fds, 1, 0); 8 if (res \u0026lt;= 0) { 9 getcontext(\u0026amp;main_ctx); 10 swapcontext(\u0026amp;main_ctx, \u0026amp;read_ctx); // fd --\u0026gt; ctx 11 } 12 13 ssize_t ret = read_f(fd, buf, count); 14 printf(\u0026#34;read: %s\\n\u0026#34;, (char *)buf); 15 return ret; 16} 这是自定义的 read 函数，它会拦截所有对 read 函数的调用，并在调用原始 read 函数之前执行一些逻辑。\n poll 调用：使用 poll 检查文件描述符 fd 是否有数据可读。 上下文切换：如果没有数据可读，保存当前上下文并切换到 read_ctx。 调用原始 read：调用保存的原始 read 函数 read_f。 打印读取的数据：将读取的数据打印出来。  另一个 Hook 函数\n1ssize_t write(int fd, const void *buf, size_t count) { 2 printf(\u0026#34;write: %s\\n\u0026#34;, (const char *)buf); 3 return write_f(fd, buf, count); 4} 自定义的 write 函数会拦截所有对 write 函数的调用，打印写入的数据，并调用原始 write 函数。 初始化 Hook\n1void init_hook(void) { 2 if (!read_f) { 3 read_f = dlsym(RTLD_NEXT, \u0026#34;read\u0026#34;); 4 } 5 if (!write_f) { 6 write_f = dlsym(RTLD_NEXT, \u0026#34;write\u0026#34;); 7 } 8} init_hook 函数用于初始化 read_f 和 write_f，它们分别指向原始的 read 和 write 函数。dlsym 函数从共享库中查找符号的地址，这里查找的是 read 和 write 函数。 主函数\n1int main() { 2 init_hook(); 3 4 // 初始化 read_ctx 上下文 5 getcontext(\u0026amp;read_ctx); 6 read_ctx.uc_link = \u0026amp;main_ctx; 7 read_ctx.uc_stack.ss_sp = malloc(SIGSTKSZ); 8 read_ctx.uc_stack.ss_size = SIGSTKSZ; 9 makecontext(\u0026amp;read_ctx, (void (*)(void))read, 0); 10 11 int sockfd = socket(AF_INET, SOCK_STREAM, 0); 12 13 struct sockaddr_in serveraddr; 14 memset(\u0026amp;serveraddr, 0, sizeof(struct sockaddr_in)); 15 16 serveraddr.sin_family = AF_INET; 17 serveraddr.sin_addr.s_addr = htonl(INADDR_ANY); 18 serveraddr.sin_port = htons(2048); 19 20 if (-1 == bind(sockfd, (struct sockaddr*)\u0026amp;serveraddr, sizeof(struct sockaddr))) { 21 perror(\u0026#34;bind\u0026#34;); 22 return -1; 23 } 24 25 listen(sockfd, 10); 26 27 struct sockaddr_in clientaddr; 28 socklen_t len = sizeof(clientaddr); 29 int clientfd = accept(sockfd, (struct sockaddr*)\u0026amp;clientaddr, \u0026amp;len); 30 printf(\u0026#34;accept\\n\u0026#34;); 31 32 while (1) { 33 char buffer[128] = {0}; 34 int count = read(clientfd, buffer, 128); 35 if (count == 0) { 36 break; 37 } 38 write(clientfd, buffer, count); 39 printf(\u0026#34;sockfd: %d, clientfd: %d, count: %d, buffer: %s\\n\u0026#34;, sockfd, clientfd, count, buffer); 40 } 41 42 free(read_ctx.uc_stack.ss_sp); 43 44 return 0; 45} 在主函数中，首先调用 init_hook 初始化 read_f 和 write_f。然后初始化 read_ctx 上下文，并使用 makecontext 函数设置上下文的执行函数为 read。\n接下来，创建一个套接字，并绑定到本地地址，开始监听连接。接受一个客户端连接后，进入循环，读取客户端发送的数据，并将数据回写给客户端。\n通过这种方式，read 和 write 的行为被拦截，并增加了自定义逻辑。\n完整代码 1 2 3#define _GNU_SOURCE 4 5#include \u0026lt;dlfcn.h\u0026gt;6 7#include \u0026lt;stdio.h\u0026gt;8#include \u0026lt;ucontext.h\u0026gt;9#include \u0026lt;string.h\u0026gt;10#include \u0026lt;unistd.h\u0026gt;11#include \u0026lt;fcntl.h\u0026gt;12 13#include \u0026lt;sys/socket.h\u0026gt;14#include \u0026lt;errno.h\u0026gt;15#include \u0026lt;netinet/in.h\u0026gt;16 17#include \u0026lt;pthread.h\u0026gt;18#include \u0026lt;sys/poll.h\u0026gt;19#include \u0026lt;sys/epoll.h\u0026gt;20 21#if 1 22// hook 23typedef ssize_t (*read_t)(int fd, void *buf, size_t count); 24read_t read_f = NULL; 25 26typedef ssize_t (*write_t)(int fd, const void *buf, size_t count); 27write_t write_f = NULL; 28 29ssize_t read(int fd, void *buf, size_t count) 30{ 31 32\tstruct pollfd fds[1] = {0}; 33 34\tfds[0].fd = fd; 35\tfds[0].events = POLLIN; 36 37\tint res = poll(fds, 1, 0); 38\tif (res \u0026lt;= 0) 39\t{ // 40 41\t// fd --\u0026gt; epoll_ctl(); 42 43\tswapcontext(); // fd --\u0026gt; ctx 44\t} 45\t// io 46 47\tssize_t ret = read_f(fd, buf, count); 48\tprintf(\u0026#34;read: %s\\n\u0026#34;, (char *)buf); 49\treturn ret; 50} 51 52ssize_t write(int fd, const void *buf, size_t count) 53{ 54 55\tprintf(\u0026#34;write: %s\\n\u0026#34;, (const char *)buf); 56 57\treturn write_f(fd, buf, count); 58} 59 60void init_hook(void) 61{ 62 63\tif (!read_f) 64\t{ 65\tread_f = dlsym(RTLD_NEXT, \u0026#34;read\u0026#34;); 66\t} 67 68\tif (!write_f) 69\t{ 70\twrite_f = dlsym(RTLD_NEXT, \u0026#34;write\u0026#34;); 71\t} 72} 73 74#endif 75 76int main() 77{ 78 79\tinit_hook(); 80 81\tint sockfd = socket(AF_INET, SOCK_STREAM, 0); 82 83\tstruct sockaddr_in serveraddr; 84\tmemset(\u0026amp;serveraddr, 0, sizeof(struct sockaddr_in)); 85 86\tserveraddr.sin_family = AF_INET; 87\tserveraddr.sin_addr.s_addr = htonl(INADDR_ANY); 88\tserveraddr.sin_port = htons(2048); 89 90\tif (-1 == bind(sockfd, (struct sockaddr *)\u0026amp;serveraddr, sizeof(struct sockaddr))) 91\t{ 92\tperror(\u0026#34;bind\u0026#34;); 93\treturn -1; 94\t} 95 96\tlisten(sockfd, 10); 97 98\tstruct sockaddr_in clientaddr; 99\tsocklen_t len = sizeof(clientaddr); 100\tint clientfd = accept(sockfd, (struct sockaddr *)\u0026amp;clientaddr, \u0026amp;len); 101\tprintf(\u0026#34;accept\\n\u0026#34;); 102 103\twhile (1) 104\t{ 105 106\tchar buffer[128] = {0}; 107\tint count = read(clientfd, buffer, 128); 108\tif (count == 0) 109\t{ 110\tbreak; 111\t} 112\twrite(clientfd, buffer, count); 113\tprintf(\u0026#34;sockfd: %d, clientfd: %d, count: %d, buffer: %s\\n\u0026#34;, sockfd, clientfd, count, buffer); 114\t} 115 116\treturn 0; 117} 通过 hook 技术，可以拦截系统函数的调用，并在调用之前或之后执行自定义逻辑。这在调试、监视和修改函数行为时非常有用。在代码中，hook 技术用于拦截 read 和 write 函数的调用，打印读取和写入的数据，并实现上下文切换的逻辑。\n","date":"2024-11-27","permalink":"/posts/tech/media-coroutine-begin/","series":["媒体开发"],"tags":["","",""],"title":"协程"},{"categories":["计算机"],"content":"1.流程图：graph 1graph 方向描述 2 图表中其他语句 1.1 方向    用词 含义     TB top -\u0026gt; bottom   BT bottom -\u0026gt; top   RL right -\u0026gt; left   LR left -\u0026gt; right    例：\n1graph LR; 2 A \u0026amp; B--\u0026gt;C; 3 B--\u0026gt;A; 4 C--\u0026gt;D; 1graph LR; 2 A--\u0026gt;C; 3 B--\u0026gt;C; 4 B--\u0026gt;A; 5 C--\u0026gt;D; 1.2 符号及含义 1.2.1 节点形状    表述 说明 含义     id[文字] 矩形节点        过程       id(文字) 圆形矩形节点 开始/结束   id((文字)) 圆形节点 链接   id{文字} 菱形节点 判断   id\u0026gt;文字] 右向旗帜状节点     [单向箭头线段]表示流程方向 「id」为节点的唯一标识，「括号」内为节点显示名称\n1graph TB 2 A 3 B[矩形节点] 4 C(圆形矩形节点) 5 D((圆形节点)) 6 E{菱形节点} 7 F\u0026gt;旗帜形状节点] 1graph TB 2 A 3 B[矩形节点] 4 C(圆形矩形节点) 5 D((圆形节点)) 6 E{菱形节点} 7 F\u0026gt;旗帜形状节点] 1.2.2 连线样式 1graph TB 2 A1---B1 3 A2--\u0026gt;B2 4 A3--text---B3 5 A4--text--\u0026gt;B4 6 A5-.-B5 7 A6-.-\u0026gt;B6 8 A7-.text.-B7 9 A8-.text.-\u0026gt;B8 10 A9===B9 11 A10==\u0026gt;B10 12 A11==text===B11 13 A12==text==\u0026gt;B12 1graph TB 2 A1---B1 3 A2--\u0026gt;B2 4 A3--text---B3 5 A4--text--\u0026gt;B4 6 A5-.-B5 7 A6-.-\u0026gt;B6 8 A7-.text.-B7 9 A8-.text.-\u0026gt;B8 10 A9===B9 11 A10==\u0026gt;B10 12 A11==text===B11 13 A12==text==\u0026gt;B12 1.3 简化写法 1graph LR 2 开始(买炸鸡流程开始)--\u0026gt;节点(买炸鸡) 3 节点--\u0026gt;判断(是否有炸鸡) 4 判断--YES--\u0026gt;开心--\u0026gt;回家(回家) 5 判断--NO--\u0026gt;伤心--\u0026gt;回家 6 7简化写法流程如下-.- 8 A1(购买炸鸡流程开始)--\u0026gt;买炸鸡--\u0026gt;B1(判断是否油炸)--是--\u0026gt;高兴--\u0026gt;A2(回家) 9 B1--没有--\u0026gt;不高兴--\u0026gt;A2 1graph LR 2 开始(买炸鸡流程开始)--\u0026gt;节点(买炸鸡) 3 节点--\u0026gt;判断(是否有炸鸡) 4 判断--YES--\u0026gt;开心--\u0026gt;回家(回家) 5 判断--NO--\u0026gt;伤心--\u0026gt;回家 6 7简化写法流程如下-.- 8 A1(购买炸鸡流程开始)--\u0026gt;买炸鸡--\u0026gt;B1(判断是否油炸)--是--\u0026gt;高兴--\u0026gt;A2(回家) 9 B1--没有--\u0026gt;不高兴--\u0026gt;A2 2.子图表 1subgraph 2 写入子图表中的描述内容 3end 例：\n1graph RL 2 c1--\u0026gt;a2 3 subgraph one 4 a1--\u0026gt;a2 5 end 6 subgraph two 7 b1--\u0026gt;b2 8 end 9 subgraph three 10 c1--\u0026gt;c2 11 end 12 one--\u0026gt;two 13 three--\u0026gt;two 14 two--\u0026gt;c2 1graph RL 2 c1--\u0026gt;a2 3 subgraph one 4 a1--\u0026gt;a2 5 end 6 subgraph two 7 b1--\u0026gt;b2 8 end 9 subgraph three 10 c1--\u0026gt;c2 11 end 12 one--\u0026gt;two 13 three--\u0026gt;two 14 two--\u0026gt;c2 3. 序列图 3.1 概述 sequenceDiagram 是每一个时序图的固定开头\n3.2 参与者 1sequenceDiagram 2 participant 参与者A 3 participant 参与者B 4 ... 5 participant 简称 as 参与者C #该语法可在接下来的描述中使用简称来代替参与者3 3.3 连线样式 1sequenceDiagram 2 participant A 3 participant B 4 participant C 5 A-\u0026gt;B: 不带箭头的实线 6 B-\u0026gt;\u0026gt;A: 带箭头的实线 7 loop 循环标题 8 C-\u0026gt;\u0026gt;C: 循环内容 9 end 10 B--\u0026gt;C: 不带箭头的虚线 11 C--\u0026gt;\u0026gt;B: 带箭头的虚线 1sequenceDiagram 2 participant A 3 participant B 4 participant C 5 A-\u0026gt;B: 不带箭头的实线 6 B-\u0026gt;\u0026gt;A: 带箭头的实线 7 loop 循环标题 8 C-\u0026gt;\u0026gt;C: 循环内容 9 end 10 B--\u0026gt;C: 不带箭头的虚线 11 C--\u0026gt;\u0026gt;B: 带箭头的虚线 ","date":"2024-11-26","permalink":"/posts/tech/media-mermaid/","series":["媒体开发"],"tags":["","",""],"title":"Mermaid"},{"categories":["计算机"],"content":"实现特定SDP报文转化为C结构 一、根据SDP规范定义C结构体 下面是一个sdp报文：\n1v=0 2o=HWPSS 3427743244 1084119141 IN IP4 127.0.0.1 3s=test1.mp4 // test1.mp4：媒体文件名 4c=IN IP4 0.0.0.0 5t=0 0 6a=control:* 7a=range:npt=0-44.000000 8m=video 0 RTP/AVP 96 // 96：track-\u0026gt;payload_type 视频：96音频：97 9a=control:trackID=101 // 101：轨道ID。 视频：101，102， 103 音频： 201，202， 203，204， 205 10a=rtpmap:96 MP4V-ES/90000 11a=fmtp:96 profile-level-id=2;config=000001b0020; 12m=audio 0 RTP/AVP 97 13a=control:trackID=201 14a=rtpmap:97 mpeg4-generic/24000/1 15a=fmtp:97 streamtype=5;profile-level-id=15; mode=AAC-hbr; config=1308; SizeLength=13; IndexLength=3;IndexDeltaLength=3; Profile=1; 需要注意的地方：\n 媒体数目， 媒体内的a字段数目都是不固定的。如果用C语言结构体装的话，可能需要内存分配和指针等东西。（目前想法是可以通过柔性数组处理实现） 单个字段内的数据组成也是不定的，可以先暂时取出文本域，再将文本域通过空格分为数组，至于之后的具体是什么内容，可以另写函数处理。  目前暂时就定义这个报文里面有的东西。\n二、文件流模拟输入 读文件demo feof函数判断文件结尾，fgets读取一行，遇到换行停止（会读取换行符）。\n1#include \u0026lt;stdio.h\u0026gt;2 3int main(){ 4\tFILE *file = NULL; 5\tchar buff[255]; 6\t7\tfile = fopen(\u0026#34;sdp.txt\u0026#34;, \u0026#34;r\u0026#34;); 8\tif(file == NULL){ 9\tprintf(\u0026#34;Error opening file\u0026#34;); 10\treturn 1; 11\t} 12\t13\twhile(!feof(file)){ 14\tfgets(buff, 255, (FILE*)file); 15\tprintf(\u0026#34;%s\u0026#34;, buff); 16\t} 17 18\t19\tfclose(file); 20\treturn 0; 21} 22 三、字符处理转化结构体 核心思想：\n 先初始分配一个默认的内存， 存放1个媒体， 且a行只有1个。 先扫描一遍文本，记录会话a行， 媒体个数， 各个媒体的a行个数。 如果在上面的过程中遇到了多个a，多个m，使用字段记录变动的字段，再立刻使用realloc进行动态拓展。  遇到的问题：\n 多维数组指针索引遍历问题， 这个去翻C Primer Plus的302页即可。（已解决） 结构体中的柔性数组内存分配。（以解决） 字符打印始终是乱码，乱码出现在柔性数组那里，会话部分有些乱码有些没有，且每次乱码的位置都是固定的。但是后面的柔性数组没有乱码。 好像malloc的内存自动会释放，如果自己再调用free的话会报free(): double free detected in tcache 2（已解决） 不额外写printf的话会报malloc(): corrupted top size的错误， 非常奇怪。  头文件sdp_handle.h：\n1#ifndef SDP_HANDLE_H 2#define SDP_HANDLE_H 3#define STR_LENGTH 64 4#define DEFAULT_MEDIA_ATTRIBUTE 2 5#define DEFAULT_SESSION_ATTRIBUTE 2 6 7typedef struct _media { 8\tchar information[STR_LENGTH]; //m 9\tint a_count; //记录一个媒体的a行个数 10\tchar attribute[][STR_LENGTH]; //a 11} Media; 12 13typedef struct _session { 14\tchar version; //v 15\tchar originator[STR_LENGTH]; //o 16\tchar name[STR_LENGTH]; //s 17\tchar connection_information[STR_LENGTH]; //c 18\tint time_active[2]; //t 19\tint media_count; //记录一次会话的媒体个数 20\tMedia* media[5]; //m,由于变长数组只能有一个，暂时写死 21\tint a_count; //记录会话的a属性个数 22\tchar attribute[][STR_LENGTH]; //a 23} Session; 24 25 26//字符串处理为结构体 27void handle_line_to_struct(Session* session, FILE* file); 28//打印会话信息到控制台 29void print_session(Session session); 30//将会话信息持久化到文件 31void save_session(Session session, char* file_name); 32//创建会话内存 33Session* malloc_session(Session* session); 34//清理会话内存 35void destory_session(Session* session); 36//创建媒体内存 37Media* malloc_media(Media* media); 38//清理媒体内存 39void destory_media(Media* media); 40//字符串指针复制函数 41void strcpy_p(char* from, char* dest, char stopsign); 42 43 44#endif 函数文件sdp_handle.c：\n1#include \u0026lt;stdio.h\u0026gt;2#include \u0026lt;string.h\u0026gt;3#include \u0026lt;stdlib.h\u0026gt;4#include \u0026lt;stdbool.h\u0026gt;5#include \u0026#34;sdp_handle.h\u0026#34;6 7 8//----------------------处理字符函数---------------- 9//处理字符串为结构体 10void handle_line_to_struct(Session* session, FILE* file){ 11\tchar buff[255]; //缓冲区 12\tint handled_a = 0; //记录已经处理的会话a行数 13\tint handled_a_m = 0; //记录单个媒体已经处理的a行数 14 15\t//1.读取文件 16\t//TODO 定义安全检查函数 17\t//TODO 错误处理 18\twhile(true){ 19\tfgets(buff, 255, (FILE*)file); 20\tchar* str = buff; 21 22\t//报文末尾判断 23\tif(feof(file)){ 24\tbreak; 25\t} 26\t27\t//2.对每行进行parse 28\t//char* seperate = strchr(str, \u0026#39;=\u0026#39;); //显式地区分类别和文本 29\tchar type = *str; //字段类别头 30\tchar* begin = str+2; //文本的开始 31\t//printf(\u0026#34;%c\\n\u0026#34;, type); 32\tswitch(type){ 33\t//TODO 覆盖一般SDP报文的内容 34\tcase \u0026#39;v\u0026#39;: 35\t//暂时假设v字段只有1位 36\tsession-\u0026gt;version = *begin; 37\tbreak; 38\tcase \u0026#39;o\u0026#39;: 39\tstrcpy_p(begin, session-\u0026gt;originator, \u0026#39;\\n\u0026#39;); 40\tbreak; 41\tcase \u0026#39;s\u0026#39;: 42\tstrcpy_p(begin, session-\u0026gt;name, \u0026#39;\\n\u0026#39;); 43\tbreak; 44\tcase \u0026#39;c\u0026#39;: 45\tstrcpy_p(begin, session-\u0026gt;connection_information, \u0026#39;\\n\u0026#39;); 46\tbreak; 47\tcase \u0026#39;t\u0026#39;: 48\t//由于时间有可能是长位的，采用atoi函数 49\tchar* devide = strchr(begin, \u0026#39; \u0026#39;); 50\tdevide++; 51\tchar start_time[20]; 52\tchar stop_time[20]; 53\tstrcpy_p(begin, start_time, \u0026#39; \u0026#39;); 54\tstrcpy_p(devide, stop_time, \u0026#39;\\n\u0026#39;); 55\tsession-\u0026gt;time_active[0] = atoi(start_time); 56\tsession-\u0026gt;time_active[1] = atoi(stop_time); 57\tbreak; 58\tcase \u0026#39;m\u0026#39;: 59\t//创建媒体 60\tMedia* media; 61\tmedia = malloc_media(NULL); 62\thandled_a_m = 0; //计数器清零 63\tstrcpy_p(begin, media-\u0026gt;information, \u0026#39;\\n\u0026#39;); 64\t*(session-\u0026gt;media + session-\u0026gt;media_count)= media; //赋值给对应的媒体段 65\tsession-\u0026gt;media_count++; 66\tmedia = NULL; 67\tbreak; 68\tcase \u0026#39;a\u0026#39;: 69\t//判断a行的归属 70\tif(session-\u0026gt;media_count == 0){ 71\t//1.处理session的a 72\t//如果a段的内存不够，进行扩容 73\tif(handled_a \u0026gt;= session-\u0026gt;a_count){ 74\tsession-\u0026gt;a_count += 1; //一次扩容1行 75\tsession = malloc_session(session); 76\t} 77\t//对应位置进行复制字符串 78\tstrcpy_p(begin, *(session-\u0026gt;attribute+handled_a), \u0026#39;\\n\u0026#39;); 79\thandled_a++; 80\t}else{ 81\t//2.处理media的a 82\t//还是先检查内存是否足够 83\tMedia* media_now; 84\tmedia_now = *(session-\u0026gt;media+(session-\u0026gt;media_count-1)); 85\tif(handled_a_m \u0026gt;= media_now-\u0026gt;a_count){ 86\tmedia_now-\u0026gt;a_count += 1; //一次扩容1行 87\tmedia_now = malloc_media(media_now); 88\t} 89\t//对应位置进行复制 90\tstrcpy_p(begin, *(media_now-\u0026gt;attribute+handled_a_m), \u0026#39;\\n\u0026#39;); 91\thandled_a_m++; 92\t} 93\tbreak;\t94\tdefault: 95\tprintf(\u0026#34;Unkown Type:%c\\n\u0026#34;, type); 96\t} 97\t} 98\t99} 100 101//复制字符串函数 102void strcpy_p(char* from, char* dest, char stopsign){ 103\t//复制 104\tfor(; *from != stopsign; from++, dest++){ 105\t*dest = *from; 106\t} 107\t//最后面加\u0026#39;\\0\u0026#39; 108\t*dest = \u0026#39;\\0\u0026#39;; 109} 110 111 112//-----------------输出函数----------------- 113 114//打印会话信息到控制台 115void print_session(Session session){ 116\t//printf(\u0026#34;\\n\u0026#34;); 117\tprintf(\u0026#34;Session Information:\\n\u0026#34;); 118\tprintf(\u0026#34;------------------------------\\n\u0026#34;); 119\tprintf(\u0026#34;version:%c\\n\u0026#34;, session.version); 120\tprintf(\u0026#34;originator:%s\\n\u0026#34;, session.originator); 121\tprintf(\u0026#34;name:%s\\n\u0026#34;, session.name); 122\tprintf(\u0026#34;connection information:%s\\n\u0026#34;, session.connection_information); 123\tprintf(\u0026#34;time_active, start:%d, end:%d\\n\u0026#34;, session.time_active[0], session.time_active[1]); 124\tprintf(\u0026#34;attribute:\\n\u0026#34;); 125\tfor(int i = 0; i \u0026lt; session.a_count; i++){ 126\tprintf(\u0026#34;%s\\n\u0026#34;, (*(session.attribute+i))); 127\t} 128\tprintf(\u0026#34;\\n\u0026#34;); 129\tprintf(\u0026#34;\\n\u0026#34;); 130 131\tif(session.media_count == 0){ 132\tprintf(\u0026#34;No Media Information!\\n\u0026#34;); 133\t}else{ 134\tprintf(\u0026#34;Media Information:\\n\u0026#34;); 135\tprintf(\u0026#34;------------------------------\\n\u0026#34;); 136\tfor(int i = 0; i \u0026lt; session.media_count; i++){ 137\tMedia* media_now = *(session.media+i); 138\tprintf(\u0026#34;Media %d:\\n\u0026#34;, (i+1)); 139\tprintf(\u0026#34;information:%s\\n\u0026#34;, media_now-\u0026gt;information); 140\tprintf(\u0026#34;attribute:\\n\u0026#34;); 141\tfor(int j = 0; j \u0026lt; media_now-\u0026gt;a_count; j++){ 142\tprintf(\u0026#34;%s\\n\u0026#34;, *(media_now-\u0026gt;attribute + j)); 143\t} 144\tprintf(\u0026#34;\\n\u0026#34;); 145\t} 146\t} 147} 148 149 150 151//会话持久化到rst文件 152void save_session(Session session, char* file_name){ 153\t//1.创建文件 154\tFILE* write_file = fopen(file_name, \u0026#34;w+\u0026#34;); 155 156\t//2.写入文件 157\tfprintf(write_file, \u0026#34;Session Information:\\n\u0026#34;); 158\tfprintf(write_file, \u0026#34;------------------------------\\n\u0026#34;); 159 160\tfprintf(write_file, \u0026#34;#. \u0026#34;); 161\tfprintf(write_file, \u0026#34;version: \u0026#34;); 162\tfputc(session.version, write_file); 163\tfprintf(write_file, \u0026#34;\\n\\n\u0026#34;); 164 165\tfprintf(write_file, \u0026#34;#. \u0026#34;); 166\tfprintf(write_file, \u0026#34;originator: \u0026#34;); 167\tfprintf(write_file, \u0026#34;%s\\n\\n\u0026#34;, session.originator); 168 169 170\tfprintf(write_file, \u0026#34;#. \u0026#34;); 171\tfprintf(write_file, \u0026#34;name: \u0026#34;); 172\tfprintf(write_file, \u0026#34;%s\\n\\n\u0026#34;, session.name); 173 174\tfprintf(write_file, \u0026#34;#. \u0026#34;); 175\tfprintf(write_file, \u0026#34;connection information: \u0026#34;); 176\tfprintf(write_file, \u0026#34;%s\\n\\n\u0026#34;, session.connection_information); 177 178\tfprintf(write_file, \u0026#34;#. \u0026#34;); 179\tfprintf(write_file, \u0026#34;time_active, start: \u0026#34;); 180\tfprintf(write_file, \u0026#34;%d\u0026#34;, session.time_active[0]); 181\tfprintf(write_file, \u0026#34;, end: \u0026#34;); 182\tfprintf(write_file, \u0026#34;%d\\n\\n\u0026#34;, session.time_active[1]); 183 184\tfprintf(write_file, \u0026#34;#. \u0026#34;); 185\tfprintf(write_file, \u0026#34;attribute: \\n\u0026#34;); 186\tfor(int i = 0; i \u0026lt; session.a_count; i++){ 187\tfprintf(write_file, \u0026#34;\t- %s\\n\u0026#34;, (*(session.attribute+i))); 188\t} 189\tfprintf(write_file, \u0026#34;\\n\\n\u0026#34;); 190 191\tif(session.media_count == 0){ 192\tfprintf(write_file, \u0026#34;No Media Information!\\n\\n\u0026#34;); 193\t}else{ 194\tfprintf(write_file, \u0026#34;Media Information:\\n\u0026#34;); 195\tfprintf(write_file, \u0026#34;------------------------------\\n\u0026#34;); 196\tfor(int i = 0; i \u0026lt; session.media_count; i++){ 197\tMedia* media_now = *(session.media+i); 198 199\tfprintf(write_file, \u0026#34;Media %d:\\n\\n\u0026#34;, (i+1)); 200 201\tfprintf(write_file, \u0026#34;information:\u0026#34;); 202\tfprintf(write_file, \u0026#34;%s\\n\\n\u0026#34;, media_now-\u0026gt;information); 203 204\tfprintf(write_file, \u0026#34;attribute:\\n\\n\u0026#34;); 205\tfor(int j = 0; j \u0026lt; media_now-\u0026gt;a_count; j++){ 206\tfprintf(write_file, \u0026#34;#. \u0026#34;); 207\tfprintf(write_file, \u0026#34;%s\\n\\n\u0026#34;, *(media_now-\u0026gt;attribute + j)); 208\t} 209\t} 210\t} 211 212\t//3.关闭文件 213\tfclose(write_file); 214 215} 216 217 218 219 220//----------------处理内存------------------- 221 222//分配会话内存 223Session* malloc_session(Session* session){ 224\tSession* session_new = NULL; 225\tif(session == NULL){ 226\t//初始化 227\tprintf(\u0026#34;Initial session memory:%ld\\n\u0026#34;, sizeof(Session) + DEFAULT_SESSION_ATTRIBUTE * STR_LENGTH * sizeof(char)); 228\tsession_new = (Session*)malloc(sizeof(Session) + DEFAULT_SESSION_ATTRIBUTE * STR_LENGTH * sizeof(char)); 229\tsession_new-\u0026gt;a_count=DEFAULT_SESSION_ATTRIBUTE; 230\tsession_new-\u0026gt;media_count = 0; 231\t}else{ 232\t//根据a_count动态分配内存 233\tprintf(\u0026#34;Realloc session memory:%ld\\n\u0026#34;, sizeof(Session) + session-\u0026gt;a_count * STR_LENGTH * sizeof(char)); 234\tsession_new = (Session*)realloc(session, sizeof(Session) + session-\u0026gt;a_count * STR_LENGTH * sizeof(char)); 235\t} 236 237\t//判断内存是否分配成功 238\tif(session_new == NULL){ 239\tprintf(\u0026#34;No aviliable memory for session!\\n\u0026#34;); 240\t} 241 242\treturn session_new; 243} 244 245//清理会话内存 246void destory_session(Session* session){ 247\tprintf(\u0026#34;Clear session memory\\n\u0026#34;); 248\tfor(int i = 0; i \u0026lt; session-\u0026gt;media_count; i++){ 249\tdestory_media(*(session-\u0026gt;media+i)); 250\t} 251\tfree(session); 252\tsession = NULL; 253} 254 255//分配媒体内存 256Media* malloc_media(Media* media){ 257\tMedia* media_new = NULL; 258\t//初始化判断 259\tif(media == NULL){ 260\t//新分配内存 261\tprintf(\u0026#34;Malloc new media memory\\n\u0026#34;); 262\tmedia_new = (Media*)malloc(sizeof(Media) + DEFAULT_MEDIA_ATTRIBUTE*sizeof(char)*STR_LENGTH); 263\tmedia_new-\u0026gt;a_count = DEFAULT_MEDIA_ATTRIBUTE; 264\t}else{\t265\t//动态根据参数a_count分配内存 266\tprintf(\u0026#34;Realloc media memory\\n\u0026#34;); 267\tmedia_new = realloc(media, sizeof(Media)+media-\u0026gt;a_count*sizeof(char)*STR_LENGTH); 268\t} 269\t270\t//内存分配失败检验 271\tif(media_new == NULL){ 272\tprintf(\u0026#34;No memory aviliable for media\\n\u0026#34;); 273\t} 274\t275\treturn media_new; 276} 277 278//清理媒体内存 279void destory_media(Media* media){ 280\tprintf(\u0026#34;Clear media memory\\n\u0026#34;); 281\tfree(media); 282\tmedia == NULL; 283} 284 四、文件流模拟输出\u0026amp;格式化打印结构体 对应函数在上面那节已经给出。\nmain.c文件：\n1#include \u0026lt;stdio.h\u0026gt;2#include \u0026lt;string.h\u0026gt;3#include \u0026#34;sdp_handle.h\u0026#34;4 5//TODO 修复不打印额外字符会出现：malloc(): corrupted top size的bug 6//命令行参数1作读取的sdp报文文件 7int main(int argc, char *argv[]){ 8\t//文件指针 9\tFILE *file = NULL; 10\t//会话结构体 11\tSession* session = NULL; 12 13\t//合法性检验 14\tfile = fopen(\u0026#34;sdp.txt\u0026#34;, \u0026#34;r\u0026#34;); 15\tif(file == NULL){ 16\tprintf(\u0026#34;Error opening file\u0026#34;); 17\treturn 1; 18\t} 19\t//printf(\u0026#34;Open file success\\n\u0026#34;); 20 21\t//创建新会话 22\tsession = malloc_session(session); 23 24\t//解析sdp.txt文件 25\thandle_line_to_struct(session, file); 26\t//关闭文件 27\tfclose(file); 28 29\t//打印结构体到控制台 30\tprint_session(*session); 31 32\t//保存结构体为rst文件 33\tsave_session(*session, argv[1]); 34 35\t//回收内存 36\tdestory_session(session); 37 38\treturn 0; 39} Makefile：\n1out: main.o sdp_handle.o 2\tgcc -o out main.o sdp_handle.o 3 4sdp_handle.o:sdp_handle.c 5\tgcc -c sdp_handle.c 6 7main.o: main.c 8\tgcc -c main.c 9 10 11clean: 12\trm main.o sdp_handle.o out 13 14run: 15\t./out sdp.rst 命令行输出测试：\n1./out sdp.rst 2Initial session memory:384 3Malloc new media memory 4Malloc new media memory 5Realloc media memory 6Session Information: 7------------------------------ 8version:0 9originator:HWPSS 3427743244 1084119141 IN IP4 127.0.0.1 10name:test1.mp4 11connection information:IN IP4 0.0.0.0 12time_active, start:0, end:0 13attribute: 14cont��{� 15*p 16 17 18Media Information: 19------------------------------ 20Media 1: 21information:video 0 RTP/AVP 96 22attribute: 23control:trackID=101 24fmtp:96 profile-level-id=2;config=000001b0020; 25 26Media 2: 27information:audio 0 RTP/AVP 97 28attribute: 29control:trackID=201 30rtpmap:97 mpeg4-generic/24000/1 31fmtp:97 streamtype=5;profile-level-id=15; mode=AAC-hbr; config=1308; SizeLength=13; IndexLength=3;IndexDeltaLength=3; Profile=1; 32 33Clear session memory 34Clear media memory 35Clear media memory 写文件输出测试：\n1Session Information: 2------------------------------ 3#. version: 0 4 5#. originator: HWPSS 3427743244 1084119141 IN IP4 127.0.0.1 6 7#. name: test1.mp4 8 9#. connection information: IN IP4 0.0.0.0 10 11#. time_active, start: 0, end: 0 12 13#. attribute: 14\t- contx�s� 15\t- � 16 17 18Media Information: 19------------------------------ 20Media 1: 21 22information:video 0 RTP/AVP 96 23 24attribute: 25 26#. control:trackID=101 27 28#. fmtp:96 profile-level-id=2;config=000001b0020; 29 30Media 2: 31 32information:audio 0 RTP/AVP 97 33 34attribute: 35 36#. control:trackID=201 37 38#. rtpmap:97 mpeg4-generic/24000/1 39 40#. fmtp:97 streamtype=5;profile-level-id=15; mode=AAC-hbr; config=1308; SizeLength=13; IndexLength=3;IndexDeltaLength=3; Profile=1; 可见还是存在些许问题的，有些字段始终是乱码的， 但是找不到原因。\n实现解析任意SDP报文 尚未解决问题：\n 各结构体需定义完善，覆盖所有可能的字段 session段规定的一些字段是media段的默认值 有些字段如果media段规定，session段不需要规定 optional字段需要注意 文本域里面的文本解析分离 需要判断报文的可用性，判断格式是否符合规范  暂时不考虑。\n参考 下面是做这次小软件参考的链接：\nC语言中的结构体指针_结构体指针c语言-CSDN博客 C 结构体 | 菜鸟教程 如何使用fgets防止缓冲区溢出？_如何防止fgets在缓冲区溢出时多次运行？_防止缓冲区溢出 - 腾讯云开发者社区 - 腾讯云 C语言基础—文件读写 - 知乎 vim 配置c/c++开发环境_vim配置c++开发环境 deepin-CSDN博客 (84 封私信 / 10 条消息) 如何在 Linux 下利用 Vim 搭建 C/C++ 开发环境? - 知乎 结构体嵌套问题的常见错误_c语言 结构体里嵌套结构体数组-CSDN博客 【转载】在linux下使用gcc/g++编译多个.h .c 文件_arm-linux-gnueabi-gcc编译多个。c 。h文件-CSDN博客 C语言动态内存分配_使用realloc重新分配内存后,务必要将原有地址使用free释放,否则会出现内存泄-CSDN博客 「C系列」C 错误处理_c语言错误处理-CSDN博客 realloc(): invalid next size: C语言报错-CSDN博客 C\u0026gt; fgets读取文件最后一行重复问题 - 明明1109 - 博客园 C语言打印输出字符串的几种方法_c语言输出字符串-CSDN博客 C++结构体中变长数组的使用问题分解刨析_C 语言_脚本之家 C语言——指针（数组，函数）_数组指针-CSDN博客 ","date":"2024-11-25","permalink":"/posts/tech/media-sdptoc/","series":["媒体开发"],"tags":["","",""],"title":"SDP协议解析C结构体"},{"categories":["计算机"],"content":"搁置\n1. 两数之和 暴力枚举 1#include \u0026lt;stdio.h\u0026gt;2#include \u0026lt;stdlib.h\u0026gt;3 4int* twoSumNormal(int* nums, int numsSize, int target, int* returnSize); 5 6 7int main(){ 8 int nums[4] = [2,7,11,15]; 9 int target = 9; 10 int* returnSize = 0; 11 int* res = twoSumNormal(nums, 4, target, returnSize); 12 free(res); 13 return 0; 14} 15 16 17//示例 1： 18// 19//输入：nums = [2,7,11,15], target = 9 20//输出：[0,1] 21//解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 22//示例 2： 23// 24//输入：nums = [3,2,4], target = 6 25//输出：[1,2] 26//示例 3： 27// 28//输入：nums = [3,3], target = 6 29//输出：[0,1] 30 31/** 32* Note: The returned array must be malloced, assume caller calls free(). 33*/ 34int* twoSumNormal(int* nums, int numsSize, int target, int* returnSize) { 35 for (int i = 0; i \u0026lt; numsSize; i++) { 36 for (int j = i + 1; j \u0026lt; numsSize; ++j) { 37 if(nums[i] + nums[j] == target){ 38 int* res = malloc(sizeof(int) * 2); 39 res[0] = i; 40 res[1] = j; 41 *returnSize = 2; 42 return res; 43 } 44 } 45 } 46 47 *returnSize = 0; 48 return NULL; 49} 50 哈希表 关于uthash.h 1#include \u0026#34;stdio.h\u0026#34;2#include \u0026#34;stdlib.h\u0026#34;3#include \u0026#34;uthash.h\u0026#34;4 5//单个节点 6struct hashTable { 7 int key; 8 int val; 9 UT_hash_handle hh; 10}; 11 12 13struct hashTable* find(int ikey); 14void insert(int ikey, int ival); 15int* twoSum(int* nums, int numsSize, int target, int* returnSize); 16 17 18//节点群 19static struct hashTable* hashtable; 20 21 22int main(){ 23 return 0; 24} 25 26 27//从节点群中找到符合条件的单个节点, 如果找不到, 返回空 28struct hashTable* find(int ikey) { 29 struct hashTable* tmp; 30 HASH_FIND_INT(hashtable, \u0026amp;ikey, tmp); 31 return tmp; 32} 33 34void insert(int ikey, int ival) { 35 //检查是否是重复元素 36 struct hashTable* it = find(ikey); 37 if (it == NULL) { 38 struct hashTable* tmp = malloc(sizeof(struct hashTable)); 39 tmp-\u0026gt;key = ikey, tmp-\u0026gt;val = ival; 40 HASH_ADD_INT(hashtable, ikey, tmp); 41 } else { 42 it-\u0026gt;val = ival; 43 } 44} 45 46int* twoSum(int* nums, int numsSize, int target, int* returnSize) { 47 hashtable = NULL; 48 for (int i = 0; i \u0026lt; numsSize; i++) { 49 struct hashTable* it = find(target - nums[i]); 50 if (it != NULL) { 51 int* ret = malloc(sizeof(int) * 2); 52 ret[0] = it-\u0026gt;val, ret[1] = i; 53 *returnSize = 2; 54 return ret; 55 } 56 insert(nums[i], i); 57 } 58 *returnSize = 0; 59 return NULL; 60} 61 ","date":"2024-11-23","permalink":"/posts/tech/media-algorithm-c/","series":["媒体开发"],"tags":["","",""],"title":"Leetcode C语言算法刷题"},{"categories":["计算机"],"content":"搁置\n第零章 计算器概论 0.1 计算机：辅助人脑的好工具 0.1.2 一切设计的起点： CPU 的架构   精简指令集精简指令集 (Reduced Instruction Set Computer, RISC):\n微指令集较为精简，每个指令的运行时间都很短，完成的动作也很单纯，指令的执行效能较佳； 但是若要做复杂的事情，就要由多个指令来完成。常见的 RISC 微指令集 CPU 主要例如甲骨文 (Oracle) 公司的 SPARC 系列、 IBM 公司的 Power Architecture (包括 PowerPC) 系列、与安谋公司 (ARM Holdings) 的 ARM CPU 系列等。\n  复杂指令集复杂指令集(Complex Instruction Set Computer, CISC):\nCISC 在微指令集的每个小指令可以执行一些较低阶的硬件操作，指令数目多而且复杂， 每条指令的长度并不相同。因为指令执行较为复杂所以每条指令花费的时间较长， 但每条个别指令可以处理的工作较为丰富。常见的 CISC 微指令集 CPU 主要有 AMD、Intel、VIA 等的 x86架构的 CPU。\n  0.2 个人计算机架构与相关设备组件 0.2.1 执行脑袋运算与判断的 CPU   CPU 的工作频率：外频与倍频\n频率就是 CPU 每秒钟可以进行的工作次数。\n早期的 CPU 架构主要透过北桥来链接系统最重要的 CPU、主存储器与显示适配器装置。因为所有的设备都得掉透过北桥来连结，因此每个设备的工作频率应该要相同。 于是就有所谓的前端总线 (FSB) 这个东西的产生。但因为 CPU 的指令周期比其他的设备都要来的快，又为了要满足 FSB 的频率，因此厂商就在 CPU 内部再进行加速， 于是就有所谓的外频与倍频了。\n如此一来所有的数据都被北桥卡死了，北桥又不可能比 CPU 更快，因此这家伙常常是系统效能的瓶颈。为了解决这个问题，新的 CPU 设计中， 已经将内存控制器整合到 CPU 内部，而链接 CPU 与内存、显示适配器的控制器的设计，在 Intel 部份使用 QPI (Quick Path Interconnect) 与 DMI技术，而 AMD 部份则使用 Hyper Transport 了，这些技术都可以让 CPU 直接与主存储器、显示适配等设备分别进行沟通，而不需要透过外部的链接芯片了。\n ","date":"2024-11-23","permalink":"/posts/tech/media-niaoge-linux/","series":["媒体开发"],"tags":["","",""],"title":"《鸟哥Linux私房菜基础篇》"},{"categories":["计算机"],"content":"不想看了.\nSDP（rfc-4566）原文件阅读 rfc-4566， SDP(Session Description Protocol 会话描述协议) 协议原文件解读。由于是第一次阅读RFC，所以会比较详尽，以后的RFC文档只抓关键，其他的需要时查阅。\n参考：\nhttps://www.rfc-editor.org/info/rfc4566\n中文的翻译部分参考:\nhttps://blog.csdn.net/jisuanji111111/article/details/120956930\nhttps://zhuanlan.zhihu.com/p/429477119\n这里我只贴出英文和必要的和一些没有翻译的中文， 全中文查阅上面的链接。\n SDP is intended for describing multimedia sessions for the purposes of session announcement, session invitation, and other forms of multimedia session initiation.\n1.Introduction 场景：When initiating multimedia teleconferences, voice-over-IP calls, streaming video, or other sessions,\n需求：there is a requirement to convey media details, transport addresses, and other session description metadata to the participants.\n简单描述： SDP provides a standard representation for such information, irrespective of how that information is transported. SDP is purely a format for session description \u0026ndash; it does not incorporate a transport protocol, and it is intended to use different transport protocols as appropriate（单纯的会话描述格式， 不包括传输协议，灵活运用）。It is not intended to support negotiation of session content or media encodings\n2.Glossary of Terms 三个重要术语：会议、会话、会话描述\n  Conference: A multimedia conference is a set of two or more communicating users along with the software they are using to communicate.\n  Session: A multimedia session is a set of multimedia senders and receivers and the data streams flowing from senders to receivers. A multimedia conference is an example of a multimedia session.\n  Session Description: A well-defined format for conveying sufficient information to discover and participate in a multimedia session.\n  RFC通用关键字：\nThe key words \u0026ldquo;MUST\u0026rdquo;, \u0026ldquo;MUST NOT\u0026rdquo;, \u0026ldquo;REQUIRED\u0026rdquo;, \u0026ldquo;SHALL\u0026rdquo;, \u0026ldquo;SHALL NOT\u0026rdquo;, \u0026ldquo;SHOULD\u0026rdquo;, \u0026ldquo;SHOULD NOT\u0026rdquo;, \u0026ldquo;RECOMMENDED\u0026rdquo;, \u0026ldquo;MAY\u0026rdquo;, and \u0026ldquo;OPTIONAL\u0026rdquo; in this document are to be interpreted as described in RFC 2119 [3].\n3.Examples of SDP Usage  用于SIP协议中的session descriptions信息。 用于部分RTSP服务器和客户端关于parameters for media delivery的沟通 用于携带电子邮件和www的会话信息描述， 它没有传输可靠的性质 用作会话目录用于多播会话场景  4.Requirements and Recommendations 目的：Thus far, multicast-based sessions on the Internet have differed from many other forms of conferencing in that anyone receiving the traffic can join the session (unless the session traffic is encrypted). In such an environment, SDP serves two primary purposes. It is a means to communicate the existence of a session, and it is a means to convey sufficient information to enable joining and participating in the session. In a unicast environment, only the latter purpose is likely to be relevant.\nSDP session decription包括：\n Session name and purpose Time(s) the session is active The media comprising the session Information needed to receive those media (addresses, ports, formats, etc.)  其他可能信息：\n Information about the bandwidth to be used by the session Contact information for the person responsible for the session  SDP用途：In general, SDP must convey sufficient information to enable applications to join a session (with the possible exception of encryption keys) and to announce the resources to be used to any non-participants that may need to know. (This latter feature is primarily useful when SDP is used with a multicast session announcement protocol.)\n4.1. Media and Transport Information SDP应携带的关于媒体和传输的信息\nAn SDP session description includes the following media information:\n The type of media (video, audio, etc.) The transport protocol (RTP/UDP/IP, H.320, etc.) The format of the media (H.261 video, MPEG video, etc.)  In addition to media format and transport protocol, SDP conveys address and port details. For an IP multicast session, these comprise:\n  The multicast group address for media\n  The transport port for media\n  This address and port are the destination address and destination port of the multicast stream, whether being sent, received, or both.\nFor unicast IP sessions, the following are conveyed:\n  The remote address for media\n  The remote transport port for media\n  The semantics of this address and port depend on the media and transport protocol defined. By default, this SHOULD be the remote address and remote port to which data is sent. Some media types may redefine this behaviour, but this is NOT RECOMMENDED since it complicates implementations (including middleboxes that must parse the addresses to open Network Address Translation (NAT) or firewall pinholes).\n4.2. Timing Information 时间信息， 应该是有界的。\nSessions may be either bounded or unbounded in time. Whether or not they are bounded, they may be only active at specific times. SDP can convey:\n  An arbitrary list of start and stop times bounding the session\n  For each bound, repeat times such as \u0026ldquo;every Wednesday at 10am for one hour\u0026rdquo;\n  This timing information is globally consistent, irrespective of local time zone or daylight saving time (see Section 5.9). （关于时间全球一致的：）\n4.3. Private Sessions 可以通过加密session description实现私有会话， 可以通过private announcement传递加密密钥和加密方案\nprivate sessions are typically conveyed by encrypting the session description during distribution. The details of how encryption is performed are dependent on the mechanism used to convey SDP; mechanisms are currently defined for SDP transported using SAP [14] and SIP [15]\nIf a session announcement is private, it is possible to use that private announcement to convey encryption keys necessary to decode each of the media in a conference, including enough information to know which encryption scheme is used for each media.\n4.4. Obtaining Further Information about a Session 应携带足够的足以参与会话的信息\nA session description should convey enough information to decide whether or not to participate in a session. SDP may include additional pointers in the form of Uniform Resource Identifiers(URIs) for more information about the session.\n4.5. Categorisation 过滤会话描述， 通过属性a。\nWhen many session descriptions are being distributed by SAP, or any other advertisement mechanism, it may be desirable to filter session announcements that are of interest from those that are not. SDP supports a categorisation mechanism for sessions that is capable of being automated (the \u0026ldquo;a=cat:\u0026rdquo; attribute; see Section 6).\n4.6. Internationalisation 国际化。要求UTF8编码的ISO 10646字符集应用于部分字段， 为了压缩可以在其他字段使用其他字符集。\nThe SDP specification recommends the use of the ISO 10646 character sets in the UTF-8 encoding [5] to allow many different languages to be represented. However, to assist in compact representations, SDP also allows other character sets such as ISO 8859-1 to be used when desired. Internationalisation only applies to free-text fields (session name and background information), and not to SDP as a whole.\n5. SDP Specification 规范。一些字符规定， 一些格式规定，一些行为规定及其原因\n An SDP session description is entirely textual using the ISO 10646 character set in UTF-8 encoding. SDP field names and attribute names use only the US-ASCII subset of UTF-8, but textual fields and attribute values MAY use the full ISO 10646 character set. Field and attribute values that use the full UTF-8 character set are never directly compared, hence there is no requirement for UTF-8 normalisation. The textual form, as opposed to a binary encoding such as ASN.1 or XDR, was chosen to enhance portability, to enable a variety of transports to be used, and to allow flexible, text-based toolkits to be used to generate and process session descriptions. However, since SDP may be used in environments where the maximum permissible size of a session description is limited, the encoding is deliberately compact. Also, since announcements may be transported via very unreliable means or damaged by an intermediate caching server, the encoding was designed with strict order and formatting rules so that most errors would result in malformed session announcements that could be detected easily and discarded. This also allows rapid discarding of encrypted session announcements for which a receiver does not have the correct key.  SDP会话描述综述。会话层，媒体层，可选项。\nAn SDP session description consists of a number of lines of text of the form:\n1\u0026lt;type\u0026gt;=\u0026lt;value\u0026gt; where \u0026lt;type\u0026gt; MUST be exactly one case-significant character and \u0026lt;value\u0026gt; is structured text whose format depends on \u0026lt;type\u0026gt;. In general, \u0026lt;value\u0026gt; is either a number of fields delimited by a single space character or a free format string, and is case-significant unless a specific field defines otherwise. Whitespace MUST NOT be used on either side of the \u0026ldquo;=\u0026rdquo; sign.\nAn SDP session description consists of a session-level section followed by zero or more media-level sections. The session-level part starts with a \u0026ldquo;v=\u0026rdquo; line and continues to the first media-level section. Each media-level section starts with an \u0026ldquo;m=\u0026rdquo; line and continues to the next media-level section or end of the whole session description. In general, session-level values are the default for all media unless overridden by an equivalent media-level value.\nSome lines in each description are REQUIRED and some are OPTIONAL, but all MUST appear in exactly the order given here (the fixed order greatly enhances error detection and allows for a simple parser). OPTIONAL items are marked with a \u0026ldquo;*\u0026rdquo;.\n1Session description 2\tv= (protocol version)(协议版本) 3\to= (originator and session identifier)(创建者和会话标识符) 4\ts= (session name)(会话名称) 5\ti=* (session information)(会话信息) 6\tu=* (URI of description)(描述的URI) 7\te=* (email address)(邮箱地址) 8\tp=* (phone number)(电话) 9\tc=* (connection information -- not required if included in all media)(连接信息 - 如果包\t含在媒体信息中，则不需要该字段) 10\tb=* (zero or more bandwidth information lines)(零行或多行带宽信息) 11\tOne or more time descriptions (\u0026#34;t=\u0026#34; and \u0026#34;r=\u0026#34; lines; see below) 12\tz=* (time zone adjustments)(时区调整) 13\tk=* (encryption key)(加密密钥) 14\ta=* (zero or more session attribute lines)(零行或多行会话属性) 15\tZero or more media descriptions 16\t17Time description 18\tt= (time the session is active)(会话活跃时间) 19\tr=* (zero or more repeat times)(零次或多次会话重复次数) 20\t21Media description, if present 22\tm= (media name and transport address)(媒体名称和传输地址) 23\ti=* (media title)(媒体标题) 24\tc=* (connection information -- optional if included at 25\tsession level)(连接信息 - 如果包含在会话信息中，则不需要该字段) 26\tb=* (zero or more bandwidth information lines)(零行或多行带宽信息) 27\tk=* (encryption key)(加密密钥) 28\ta=* (zero or more media attribute lines)(零行或多行媒体属性)   The set of type letters is deliberately small and not intended to be extensible \u0026ndash; an SDP parser MUST completely ignore any session description that contains a type letter that it does not understand.\n  a属性用作扩展：The attribute mechanism (\u0026ldquo;a=\u0026rdquo; described below) is the primary means for extending SDP and tailoring it to particular applications or media.\n  Some attributes (the ones listed in Section 6 of this memo) have a defined meaning, but others may be added on an application-, media-, or session-specific basis.\n  忽略没有规范的内容：An SDP parser MUST ignore any attribute it doesn’t understand.\n  外部引用：An SDP session description may contain URIs that reference external content in the \u0026ldquo;u=\u0026rdquo;, \u0026ldquo;k=\u0026rdquo;, and \u0026ldquo;a=\u0026rdquo; lines. These URIs may be dereferenced in some cases, making the session description non-self- contained.\n  所有媒体的默认属性：The connection (\u0026ldquo;c=\u0026quot;) and attribute (\u0026ldquo;a=\u0026quot;) information in the session-level section applies to all the media of that session unless overridden by connection information or an attribute of the same name in the media description. For instance, in the example below, each media behaves as if it were given a \u0026ldquo;recvonly\u0026rdquo; attribute.\n1v=0 2o=jdoe 2890844526 2890842807 IN IP4 10.47.16.5 3s=SDP Seminar 4i=A Seminar on the session description protocol 5u=http://www.example.com/seminars/sdp.pdf 6e=j.doe@example.com (Jane Doe) 7c=IN IP4 224.2.17.12/127 8t=2873397496 2873404696 9a=recvonly 10m=audio 49170 RTP/AVP 0 11m=video 51372 RTP/AVP 99 12a=rtpmap:99 h263-1998/90000   文本域的一些特殊字符：Text fields such as the session name and information are octet（八位字节） strings that may contain any octet with the exceptions of 0x00 (Nul), 0x0a (ASCII newline), and 0x0d (ASCII carriage return).\n  协议结尾：The sequence CRLF (0x0d0a) is used to end a record, although parsers SHOULD be tolerant and also accept records terminated with a single newline character.\n  如何解析：If the \u0026ldquo;a=charset\u0026rdquo; attribute is not present, these octet strings MUST be interpreted as containing ISO-10646 characters in UTF-8 encoding (the presence of the \u0026ldquo;a=charset\u0026rdquo; attribute may force some fields to be interpreted differently).\n  包含域名的使用：A session description can contain domain names in the \u0026ldquo;o=\u0026rdquo;, \u0026ldquo;u=\u0026rdquo;, \u0026ldquo;e=\u0026rdquo;, \u0026ldquo;c=\u0026rdquo;, and \u0026ldquo;a=\u0026rdquo; lines. Any domain name used in SDP MUST comply with [1], [2].\n  域名的编码：Internationalised domain names (IDNs) MUST be represented using the ASCII Compatible Encoding (ACE) form defined in [11] and MUST NOT be directly represented in UTF-8 or any other encoding (this requirement is for compatibility with RFC 2327 and other SDP-related standards, which predate the development of internationalised domain names).\n  5.1. Protocol Version (\u0026ldquo;v=\u0026quot;) 目前只有版本0\n1v=0 The \u0026ldquo;v=\u0026rdquo; field gives the version of the Session Description Protocol. This memo defines version 0. There is no minor version number.\n5.2. Origin (\u0026ldquo;o=\u0026quot;) 会话组织者，会话标识符，版本号\n1o=\u0026lt;username\u0026gt; \u0026lt;sess-id\u0026gt; \u0026lt;sess-version\u0026gt; \u0026lt;nettype\u0026gt; \u0026lt;addrtype\u0026gt; \u0026lt;unicast-address\u0026gt; The \u0026ldquo;o=\u0026rdquo; field gives the originator of the session (her username and the address of the user’s host) plus a session identifier and version number:\n \u0026lt;username\u0026gt;（不能有空格） is the user’s login on the originating host, or it is \u0026ldquo;-\u0026rdquo; if the originating host does not support the concept of user IDs. The \u0026lt;username\u0026gt; MUST NOT contain spaces. \u0026lt;sess-id\u0026gt; （基于这个字段的所有属性通过工具生成）is a numeric string such that the tuple of \u0026lt;username\u0026gt;, \u0026lt;sess-id\u0026gt;, \u0026lt;nettype\u0026gt;, \u0026lt;addrtype\u0026gt;, and \u0026lt;unicast-address\u0026gt; forms a globally unique identifier for the session. The method of \u0026lt;sess-id\u0026gt; allocation is up to the creating tool, but it has been suggested that a Network Time Protocol (NTP) format timestamp be used to ensure uniqueness [13]. \u0026lt;sess-version\u0026gt;（版本信息，通过工具生成） is a version number for this session description. Its usage is up to the creating tool, so long as（只要） \u0026lt;sess-version\u0026gt; is increased when a modification is made to the session data. Again, it is RECOMMENDED that an NTP format timestamp is used. \u0026lt;nettype\u0026gt;（网络类型。一般就是IN了） is a text string giving the type of network. Initially \u0026ldquo;IN\u0026rdquo; is defined to have the meaning \u0026ldquo;Internet\u0026rdquo;, but other values MAY be registered in the future (see Section 8). \u0026lt;addrtype\u0026gt;（地址类型） is a text string giving the type of the address that follows. Initially \u0026ldquo;IP4\u0026rdquo; and \u0026ldquo;IP6\u0026rdquo; are defined, but other values MAY be registered in the future (see Section 8). \u0026lt;unicast-address\u0026gt;（创建会话者的地址，最好使用域名，不要使用内网地址） is the address of the machine from which the session was created. For an address type of IP4, this is either the fully qualified domain name of the machine or the dotted- decimal representation of the IP version 4 address of the machine. For an address type of IP6, this is either the fully qualified domain name of the machine or the compressed textual representation of the IP version 6 address of the machine. For both IP4 and IP6, the fully qualified domain name is the form that SHOULD be given unless this is unavailable, in which case the globally unique address MAY be substituted. A local IP address MUST NOT be used in any context where the SDP description might leave the scope in which the address is meaningful (for example, a local address MUST NOT be included in an application-level referral that might leave the scope).  综述：In general, the \u0026ldquo;o=\u0026rdquo; field serves as a globally unique identifier for this version of this session description, and the subfields excepting the version taken together identify the session irrespective of any modifications.\n安全考虑可以随意填充username和unicast：For privacy reasons, it is sometimes desirable to obfuscate（混淆） the username and IP address of the session originator. If this is a concern, an arbitrary \u0026lt;username\u0026gt; and private \u0026lt;unicast-address\u0026gt; MAY be chosen to populate（填充） the \u0026ldquo;o=\u0026rdquo; field, provided that these are selected in a manner that does not affect the global uniqueness of the field.\n5.3. Session Name (\u0026ldquo;s=\u0026quot;) 文字会话名。\n1s=\u0026lt;session name\u0026gt; The \u0026ldquo;s=\u0026rdquo; field is the textual session name. There MUST be one and only one \u0026ldquo;s=\u0026rdquo; field per session description. The \u0026ldquo;s=\u0026rdquo; field MUST NOT be empty and SHOULD contain ISO 10646 characters (but see also the \u0026ldquo;a=charset\u0026rdquo; attribute). If a session has no meaningful name, the value \u0026ldquo;s= \u0026quot; SHOULD be used (i.e., a single space as the session name).\n5.4. Session Information (\u0026ldquo;i=\u0026quot;) 会话的一些描述信息。用作媒体域时是分类标签各个媒体\n1i=\u0026lt;session description\u0026gt; 作为会话的描述信息：The \u0026ldquo;i=\u0026rdquo; field provides textual information about the session. There MUST be at most one session-level \u0026ldquo;i=\u0026rdquo; field per session description, and at most one \u0026ldquo;i=\u0026rdquo; field per media. If the \u0026ldquo;a=charset\u0026rdquo; attribute is present, it specifies the character set used in the \u0026ldquo;i=\u0026rdquo; field. If the \u0026ldquo;a=charset\u0026rdquo; attribute is not present, the \u0026ldquo;i=\u0026rdquo; field MUST contain ISO 10646 characters in UTF-8 encoding.\n区分同一会话下同一类型的媒体：A single \u0026ldquo;i=\u0026rdquo; field MAY also be used for each media definition. In media definitions, \u0026ldquo;i=\u0026rdquo; fields are primarily intended for labelling media streams. As such, they are most likely to be useful when a single session has more than one distinct media stream of the same media type. An example would be two different whiteboards, one for slides and one for feedback and questions.\nThe \u0026ldquo;i=\u0026rdquo; field is intended to provide a free-form human-readable description of the session or the purpose of a media stream. It is not suitable for parsing by automata（自动机）.\n5.5. URI (\u0026ldquo;u=\u0026quot;) 关于会话其他信息的uri。\n1u=\u0026lt;uri\u0026gt; A URI is a Uniform Resource Identifier as used by WWW clients [7]. The URI should be a pointer to additional information about the session. This field is OPTIONAL, but if it is present it MUST be specified before the first media field. No more than one URI field is allowed per session description.\n5.6. Email Address and Phone Number (\u0026ldquo;e=\u0026rdquo; and \u0026ldquo;p=\u0026quot;) 会议负责人的联系方式。\n1e=\u0026lt;email-address\u0026gt; 2p=\u0026lt;phone-number\u0026gt; The \u0026ldquo;e=\u0026rdquo; and \u0026ldquo;p=\u0026rdquo; lines specify contact information for the person responsible for the conference. This is not necessarily the same person that created the conference announcement.\nInclusion of an email address or phone number is OPTIONAL. Note that the previous version of SDP specified that either an email field or a phone field MUST be specified, but this was widely ignored. The change brings the specification into line with common usage.\nIf an email address or phone number is present, it MUST be specified before the first media field. More than one email or phone field can be given for a session description.\nPhone numbers SHOULD be given in the form of an international public telecommunication number (see ITU-T Recommendation E.164) preceded by a \u0026ldquo;+\u0026rdquo;. Spaces and hyphens may be used to split up a phone field to aid readability if desired. For example:\n1p=+1 617 555-6011 Both email addresses and phone numbers can have an OPTIONAL free text string associated with them, normally giving the name of the person who may be contacted. This MUST be enclosed in parentheses if it is present. For example:\n1e=j.doe@example.com (Jane Doe) The alternative RFC 2822 [29] name quoting convention is also allowed for both email addresses and phone numbers. For example:\n1e=Jane Doe \u0026lt;j.doe@example.com\u0026gt; The free text string SHOULD be in the ISO-10646 character set with UTF-8 encoding, or alternatively in ISO-8859-1 or other encodings if the appropriate session-level \u0026ldquo;a=charset\u0026rdquo; attribute is set.\n5.7. Connection Data (\u0026ldquo;c=\u0026quot;) 连接数据。\n1c=\u0026lt;nettype\u0026gt; \u0026lt;addrtype\u0026gt; \u0026lt;connection-address\u0026gt; The \u0026ldquo;c=\u0026rdquo; field contains connection data.\nA session description MUST contain either at least one \u0026ldquo;c=\u0026rdquo; field in each media description or a single \u0026ldquo;c=\u0026rdquo; field at the session level. It MAY contain a single session-level \u0026ldquo;c=\u0026rdquo; field and additional \u0026ldquo;c=\u0026rdquo; field(s) per media description, in which case the per-media values override the session-level settings for the respective media.\nThe first sub-field (\u0026quot;\u0026lt;nettype\u0026gt;\u0026quot;) is the network type, which is a text string giving the type of network. Initially, \u0026ldquo;IN\u0026rdquo; is defined to have the meaning \u0026ldquo;Internet\u0026rdquo;, but other values MAY be registered in the future (see Section 8).\nThe second sub-field (\u0026quot;\u0026lt;addrtype\u0026gt;\u0026quot;) is the address type. This allows SDP to be used for sessions that are not IP based. This memo only defines IP4 and IP6, but other values MAY be registered in the future (see Section 8).\nThe third sub-field (\u0026quot;\u0026lt;connection-address\u0026gt;\u0026quot;) is the connection address. OPTIONAL sub-fields MAY be added after the connection address depending on the value of the \u0026lt;addrtype\u0026gt; field.\nWhen the \u0026lt;addrtype\u0026gt; is IP4 and IP6, the connection address is defined as follows:\n 多播场景：If the session is multicast, the connection address will be an IP multicast group address. If the session is not multicast, then the connection address contains the unicast IP address of the expected data source or data relay or data sink as determined by additional attribute fields. It is not expected that unicast addresses will be given in a session description that is communicated by a multicast announcement, though this is not prohibited. Sessions using an IPv4 multicast connection address MUST also have a time to live (TTL) value present in addition to the multicast address. The TTL and the address together define the scope with which multicast packets sent in this conference will be sent. TTL values MUST be in the range 0-255. Although the TTL MUST be specified, its use to scope multicast traffic is deprecated（不赞同使用TTL限制多播流量）; applications SHOULD use an administratively scoped address instead.  The TTL for the session is appended to the address using a slash as a separator. An example is:\n1c=IN IP4 224.2.36.42/127 IPv6 multicast does not use TTL scoping, and hence the TTL value MUST NOT be present for IPv6 multicast. It is expected that IPv6 scoped addresses will be used to limit the scope of conferences.\n","date":"2024-11-19","permalink":"/posts/tech/media-sdp/","series":["媒体开发"],"tags":["","",""],"title":"SDP协议学习"},{"categories":["计算机"],"content":"BNF 巴科斯范式(BNF: Backus-Naur Form 的缩写)是由 John Backus 和 Peter Naur 首先引入的用来描述计算机语言语法的符号集。现在，几乎每一位新编程语言书籍的作者都使用巴科斯范式来定义编程语言的语法规则。\n在BNF中，双引号中的字(\u0026ldquo;word\u0026rdquo;)代表着这些字符本身。而double_quote用来代表双引号。\n在双引号外的字（有可能有下划线）代表着语法部分。\n1\u0026lt; \u0026gt; : 内包含的为必选项。 2[ ] : 内包含的为可选项。 3{ } : 内包含的为可重复0至无数次的项。 4| : 表示在其左右两边任选一项，相当于\u0026#34;OR\u0026#34;的意思。 5::= : 是“被定义为”的意思 6\u0026#34;...\u0026#34; : 术语符号 7[...] : 选项，最多出现一次 8{...} : 重复项，任意次数，包括 0 次 9(...) : 分组 10| : 并列选项，只能选一个 11斜体字: 参数，在其它地方有解释 下面是是用BNF来定义的Java语言中的For语句的实例：\n1FOR_STATEMENT ::= 2 \u0026#34;for\u0026#34; \u0026#34;(\u0026#34; ( variable_declaration | 3 ( expression \u0026#34;;\u0026#34; ) | \u0026#34;;\u0026#34; ) 4 [ expression ] \u0026#34;;\u0026#34; 5 [ expression ] \u0026#34;;\u0026#34; 6 \u0026#34;)\u0026#34; statement ABNF RFC2234 定义了扩展的巴科斯范式(ABNF)。近年来在Internet的定义中 ABNF 被广泛使用。ABNF 做了更多的改进。扩充巴科斯-瑙尔范式(ABNF)基于了巴科斯-瑙尔范式(BNF)，但由它自己的语法和推导规则构成。这种元语言的发起原则是描述作为通信协议(双向规范)的语言的形式系统。它建档于 RFC 4234 中通常充当 IETF 通信协议的定义语言。\nABNF 规定是一组推导规则，写为：\n1规则 = 定义 ; 注释 CR LF 这里的规则是大小写敏感的非终止符，定义由定义这个规则的符号序列，一个文档注释组成，并结束于回车换行。\n规则名字是大小写不敏感的: \u0026lt;rulename\u0026gt;, \u0026lt;Rulename\u0026gt;, \u0026lt;RULENAME\u0026gt; 和 \u0026lt;rUlENamE\u0026gt; 都提及同一个规则。规则名字由开始于一个字母的字母、数字和连字符组成。不要求用尖括号(“\u0026lt;”, “\u0026gt;”) (如 BNF 那样)包围规则名字。但是它们可以用来界定规则名字，比如在冗文中识别出规则名字的时候。\nABNF 使用 7-位 ASCII 编码，在 8-位域中把高位置零。\n终结符由一个或多个数值字符指定。数值字符可以指定为跟随着基数(b = 二进制, d = 十进制, x = 十六进制)的一个百分号“%”，随后是这个数值，或数值的串联(用“.” 来指示)。例如回车可以指定为十进制的 %d13 或十六进制的 %x0D。回车换行可以指定为 %d13.10。\n文字正文通过使用包围在引号(\u0026quot;)中字符串来指定。这些字符串是大小写不敏感的，使用的字符集是 US-ASCII。所以字符串“abc”将匹配“abc”, “Abc”, “aBc”, “abC”, “ABc”, “AbC”, “aBC” 和 “ABC”。对于大小写敏感匹配，必须定义明确的字符: 要匹配 “aBc” 定义将是 %d97 %d66 %d99。\n操作符 空白被用来分隔定义的各个元素: 要使空格被识别为分割符则必须明确的包含它。\n串联 1规则1 规则2 规则可以通过列出一序列的规则名字来定义。\n要匹配字符串“aba”可以使用下列规则:\n1fu = %x61; a 2bar = %x62; b 3mumble = fu bar fu 选择 1规则1 / 规则2 规则可以通过用反斜杠(“/”)分隔的多选一规则来定义。\n要接受规则 \u0026lt;fu\u0026gt; 或规则 \u0026lt;bar\u0026gt; 可构造如下规则：\n1fubar = fu / bar 递增选择 1规则1 =/ 规则2 可以通过使用在规则名字和定义之间的“=/”来向一个规则增加补充选择。\n规则\n1ruleset = alt1 / alt2 / alt3 / alt4 / alt5 等价于\n1ruleset = alt1 / alt2 2ruleset =/ alt3 3ruleset =/ alt4 / alt5 值范围 1%c##-## 数值范围可以通过使用连字符(“-”)来指定。\n规则\n1OCTAL = \u0026#34;0\u0026#34; / \u0026#34;1\u0026#34; / \u0026#34;2\u0026#34; / \u0026#34;3\u0026#34; / \u0026#34;4\u0026#34; / \u0026#34;5\u0026#34; / \u0026#34;6\u0026#34; / \u0026#34;7\u0026#34; 等价于\n1OCTAL = %x30-37 序列分组 1(规则1 规则2) 元素可以放置在圆括号中来组合定义中的规则。\n要匹配“elem fubar snafu”或“elem tarfu snafu”可以构造下列规则：\n1group = elem (fubar / tarfu) snafu 要匹配“elem fubar”或“tarfu snafu”可以构造下列规则：\n1group = elem fubar / tarfu snafu 2group = (elem fubar) / (tarfu snafu) 可变重复 1n*n规则 要指示一个元素的重复可以使用形式 \u0026lt;a\u0026gt;*\u0026lt;b\u0026gt; 元素。可选的 \u0026lt;a\u0026gt; 给出要包括的元素的最小数目，缺省为 0。可选的 \u0026lt;b\u0026gt; 给出要包括的元素的最大数目，缺省为无穷。\n对零或多个元素使用 *元素，对一或多个元素使用 1*元素，对二或三个元素使用 2*3元素。\n特定重复 1n规则 要指示明确数目的元素可使用形式 \u0026lt;a\u0026gt; 元素，它等价于 \u0026lt;a\u0026gt;*\u0026lt;a\u0026gt;元素。\n使用 2DIGIT 得到两个数字，使用 3DIGIT 得到三个数字。(DIGIT 在下面的核心规则中定义)。\n可选序列 1[规则] 要指示可选元素下列构造是等价的：\n1[fubar snafu] 2*1(fubar snafu) 30*1(fubar snafu) 注释 1; 注释 分号(“;”)开始一个注释并持续到此行的结束。\n操作符优先级 上述操作符有从最紧绑定(binding)到最松绑定的给定优先级:\n 字符串，名字形成(formation) 注释 值范围 重复 分组，可选 串联 选择  与串联一起使用选择操作符可以造成混淆，建议使用分组来做明确串联分组。\n核心规则 核心规则定义于 ABNF 标准中。\n   规则 形式定义 意义     ALPHA %x41-5A / %x61-7A 大写和小写 ASCII 字母 (A-Z a-z)   DIGIT %x30-39 数字 (0-9)   HEXDIG DIGIT / \u0026ldquo;A\u0026rdquo; / \u0026ldquo;B\u0026rdquo; / \u0026ldquo;C\u0026rdquo; / \u0026ldquo;D\u0026rdquo; / \u0026ldquo;E\u0026rdquo; / \u0026ldquo;F\u0026rdquo; 十六进制数字 (0-9 A-F a-f)   DQUOTE %x22 双引号   SP %x20 空格   HTAB %x09 水平tab   WSP SP / HTAB 空格和水平tab   LWSP *(WSP / CRLF WSP) 线性空白(晚于换行)   VCHAR %x21-7E 可见(打印)字符   CHAR %x01-7F 任何 7-位 US-ASCII 字符，不包括 NUL   OCTET %x00-FF 8 位数据   CTL %x00-1F / %x7F 控制字符   CR %x0D 回车   LF %x0A 换行   CRLF CR LF 互联网标准换行   BIT \u0026ldquo;0\u0026rdquo; / \u0026ldquo;1\u0026rdquo;     例子 在巴科斯范式(BNF)条目中的邮政地址的例子可以被指定为：\n1postal-address = name-part street zip-part 2 3name-part = *(personal-part SP) last-name [SP suffix] CRLF 4name-part = / personal-part CRLF 5 6personal-part = first-name / (initial \u0026#34;.\u0026#34;) 7first-name = *ALPHA 8initial = ALPHA 9last-name = *ALPHA 10suffix = (\u0026#34;Jr.\u0026#34; / \u0026#34;Sr.\u0026#34; / 1*(\u0026#34;I\u0026#34; / \u0026#34;V\u0026#34; / \u0026#34;X\u0026#34;)) 11 12street = [apt SP] house-num SP street-name CRLF 13apt = 1*4DIGIT 14house-num = 1*8（DIGIT / ALPHA） 15street-name = 1*VCHAR 16 17zip-part = town-name \u0026#34;,\u0026#34; SP state 1*2SP zip-code CRLF 18town-name = 1*(ALPHA / SP) 19state = 2ALPHA 20zip-code = 5DIGIT [\u0026#34;-\u0026#34; 4DIGIT] ","date":"2024-11-18","permalink":"/posts/tech/media-abnf/","series":["媒体开发"],"tags":["","",""],"title":"ABNF范式"},{"categories":["计算机"],"content":"搁置\n编译原理， 媒体处理一天都在和字符，二进制位操作， 操作系统这些底层打交道， 学这个获益极大。\n笔记大体上就是概括大意,细致的东西以后的自己翻书或者搜索吧~\n第1章 引论 1.1 语言处理器 编译器是一个将源语言翻译为目标语言的程序， 如果目标程序是一个可执行的机器语言程序， 它就可以被用户调用。解释器不通过翻译的方式生成目标程序， 它直接利用用户提供的输入执行源程序的操作。\n把用户输入映射为输出的过程中，由编译器产生的机器语言目标程序比解释器快很多， 但解释器的错误诊断效果通常比编译器更好。\n例如：Java语言处理器结合了编译和解释过程，java源程序首先被编译成字节码， 由虚拟机对字节码加以解释执行。\n语言处理系统：\n 预处理器将程序的多个模块聚合在一起，它还负责把宏的缩写形式转换为源语言的语句 编译器受到预处理的源程序可能产生一个汇编语言程序， 因为汇编语言比较容易输出和调试 汇编器处理这个汇编程序生成可重定位的机器代码 由于一个文件中的代码可能指向另一个文件的位置， 链接器解决外部内存地址的问题 加载器把所有的可执行目标文件放到内存执行  1.2 一个编译器的结构 编译器将源程序映射为目标程序， 这个映射过程由两部分组成：分析部分（前端）和综合部分（后端）\n分析部分将源程序分解为多个组成要素， 在这些要素上加上语法结构， 使用这个结构创建源程序的一个中间表示。如果分析部分检查出源程序没有按照正确的语法构成或者语义不一致就会提供有用信息使得用户按此改正。分析部分还会收集源程序的信息将其存放在一个符号表的数据结构。符号表和中间表示形式一起传送给综合部分。、\n综合部分根据中间表示形式和符号表中的信息来构造目标程序。\n编译过程步骤：字符流 \u0026mdash;(词法分析器)\u0026mdash;\u0026gt; 符号流 \u0026mdash;(语法分析)\u0026ndash;\u0026gt;语法分析\u0026mdash;(语义分析)\u0026ndash;\u0026gt;语法树 \u0026mdash;(中间代码生成器)\u0026ndash;\u0026gt; 中间表示形式 \u0026mdash;(机器无关代码优化器)\u0026ndash;\u0026gt; 中间表示形式\u0026mdash;(代码生成器)\u0026ndash;\u0026gt;目标机器语言 \u0026mdash;(机器相关代码优化器)\u0026ndash;\u0026gt; 目标机器语言\n 优化是可选的。\n 1.2.1 词法分析 编译器的第1个步骤为词法分析/扫描。\n词法分析读入源程序的字符流， 将它们组织为词素的序列。对于每个词素产生形如\u0026lt;token-name, attribute-value\u0026gt;的词法单元作为输出。其中token-name是由下一步语法分析使用的抽象符号。 attribute-value指向符号表中关于这个词法单元的条目。\n例如： 语句position = initial + rate * 60\n position: 被映射为词法单元\u0026lt;id, 1\u0026gt; ，（id是表示标识符的抽象符号， 1是符号表中position的下标， 存放着标识符的名字和类型等信息） =: \u0026lt; = \u0026gt; ，这个词法单元不需要属性值于是省略， 但也可以使用assign抽象符号作为词法单元的名字。 initial: \u0026lt; id, 2 \u0026gt;  +: \u0026lt; + \u0026gt;  rate: \u0026lt; id , 3\u0026gt;  *: \u0026lt; * \u0026gt;  60: \u0026lt; 60 \u0026gt; ，按理应是\u0026lt;number , 4 \u0026gt; ， 具体阅读第2， 3章  于是position = initial + rate * 60 \u0026mdash;词法分析\u0026ndash;\u0026gt; \u0026lt;id,1\u0026gt;\u0026lt;=\u0026gt;\u0026lt;id,2\u0026gt;\u0026lt;+\u0026gt;\u0026lt;id,3\u0026gt;\u0026lt;*\u0026gt;\u0026lt;60\u0026gt;\n1.2.2 语法分析 编译器的第2个步骤称为语法分析/解析。\n语法分析器使用词法分析器生成的各词法单元的第一个分量来创建树形的中间表示， 它给出了词法单元分析的语法结构。一个常用的表示方法是语法树， 树中每一个内部节点表示一个运算， 该节点的子结点表示运算的分量。\n这颗树显示了语句position = initial + rate * 60的运算执行顺序：\n1\t= 2 / \\ 3\u0026lt;id,1\u0026gt; + 4\t/ \\ 5 \u0026lt;id,2\u0026gt; * 6 / \\ 7 \u0026lt;id,3\u0026gt; 60 运算顺序和通常的算术规则相同。\n1.2.3 语义分析 语义分析器使用语法树和符号表检查源程序是否和语言定义的语义一致， 同时也收集信息存放在语法树和符号表中以便后续中间代码过程使用。\n语义分析还执行类型检查， 检查每个运算符是否具有匹配的运算分量。如果类型错误将报告错误。\n如果程序设计语言允许自动类型转换， 那么语义分析将进行自动类型转换。\n例如：\u0026lt;id,1\u0026gt;，\u0026lt;id,2\u0026gt;，\u0026lt;id,3\u0026gt;为浮点数， 那么60在这种情况下需要转化为浮点数才能相，这时语义分析器输出一个关于运算符inttofloat的额外结点。inttofloat明确地将整数参数转化为浮点数。\n1\t= 2 / \\ 3\u0026lt;id,1\u0026gt; + 4\t/ \\ 5 \u0026lt;id,2\u0026gt; * 6 / \\ 7 \u0026lt;id,3\u0026gt; | 8 inttofloat 9 | 10 60 1.2.4 中间代码生成 在语法分析和语义分析完成后， 编译器生成一个低级的类机器语言的中间表示，这种语言具有两个性质：它易于生成，能够轻松地翻译为目标机器上的语言。\n第6章会介绍一种叫三地址代码的中间表示形式， 它类似于汇编指令， 每个指令具有三个运算分量， 每个运算分量类似于寄存器。\n1t1 = inttofloat(60) 2t2 = id3 * t1 3t3 = id2 + t2 4id1 = t3 关于三地址指令：\n 每个三地址赋值指令的右部最多只有一个运算符 编译器应该生成一个临时名字存放三地址指令计算得到的值 有些三地址指令运算分量少于三个  1.2.5 代码优化 机器无关的代码优化生成更好的代码， 通常意味着更快， 也可以是更短或者能耗更低。\n不同编译器代码优化的工作量相差很大， 有的优化工作做得很多会在优化阶段花相当多的时间；有些优化简单可以极大提高程序运行效率且不会降低很多编译速度。\n例如：优化器得出结论，把60转化为浮点数的运算可以在编译时刻一劳永逸地完成， 于是使用浮点数60.0替代整数60可以消除inttofloat运算；t3仅被使用一次， 可以把它的值传递给id1\n1t1 = id3 * 60.0 2id1 = id2 + t1 1.2.6 代码生成 代码生成器以中间表示形式输入映射为目标语言， 如果目标语言是机器代码， 它将为程序使用的每个变量选择寄存器或内存位置，然后中间指令被翻译成为机器指令序列。\n例如使用寄存器R1和R2：\n1#将地址id3的内容加载到寄存器R2中 2LDF R2, id3 3 4#‘#’表示60.0作为一个立即数处理。将60.0乘R2中的内容 5MULF R2, R2, #60.0 6 7LDF R1, id2 8 9#将存放在R2的值加到R1上 10ADDF R1, R1, R2 11 12#将寄存器R1中的值存放到id1中 13STF id1, R1 1.2.7 符号表管理 符号表为每个变量创建条目, 记录名字的各个属性如类型,作用域; 对于过程名字还包括参数数量和类型, 每个参数的传递方法和返回类型.\n1.2.8 将多个步骤组合成趟 多个步骤组合成一趟. 我们可以把不同前端和某个目标机的后端结合为不同源语言建立目标机上的编译器; 同样也可以将同一个前端和不同目标机后端结合建立不同目标机的编译器. 这一切通过前端和后端的中间表示形式连接.\n1.2.9 编译器构造工具 工具实现编译器的不同阶段, 它们生成的组件易于和编译器的其他部分相集成, 如语法分析器的生成器, 扫描器的生成器, 语法制导的翻译引擎, 代码生成器的生成器, 数据流分析引擎, 编译器构造工具集.\n1.3 程序设计语言的发展历程 1.3.1 走向高级程序设计语言 按照代分类:\n 第一代语言:机器语言 第二代语言: 汇编语言 第三代语言: 高级程序设计语言(Fortran, Cobol, Lisp, C, C++, C#, Java) 第四代语言: 为特定应用设计的语言(NOMAD, SQL, Postscript) 第五代语言: 基于逻辑和约束的语言(Prolog, OPS5)  另一种分类方式:\n 强制式语言:指明如何完成一个计算任务的语言 声明式语言: 指明要进行哪些运算的语言.  冯诺依曼语言: 以冯诺依曼计算机体系结构为计算模型的程序设计语言\n面向对象语言, 脚本语言\u0026hellip;\n1.3.2 对编译器的影响  编译器设计者必须设计算法和表示方式来翻译和支持新的语言特征. 通过降低用高级语言程序的执行开销, 编译器还可以推动这些高级语言的使用. 编译器必须能够正确翻译用源语言书写的所有程序, 但为源程序生成最佳代码的问题一般是不可判定的, 编译器设计者需要折中处理, 以解决高效代码生成问题.  1.4 构建一个编译器的相关科学 1.4.1 编译器设计和实现中的建模 如何设计正确的数学模型和选择正确算法的研究, 在过程中需考虑通用性, 功能, 简单性, 有效性之间的平衡. 如:\n 有穷状态自动机和正则表达式用来描述程序的词法单位(关键字, 标识符等)以及描述被编译器用来识别这些单位的算法 上下文无关法用于描述程序设计语言的语法结构 树形结构表示程序结构以及程序到目标代码的翻译方法  1.4.2 代码优化的科学 处理器体系结构更加复杂, 这让编译器有了更多改进代码执行方式的机会.\n编译器设计目标:\n  优化必须是正确的(不改变编译程序的含义)\n  优化必须能够改善很多程序的性能.\n性能通常意味着执行速度, 也希望降低生成代码的大小, 降低代码能耗. 另外错误报告和调试等可用性也很重要.\n  优化所需的时间必须保持在合理范围内\n开启优化有时候会暴露源程序中的新问题, 需要对经过优化的代码再次进行测试.\n  所需要的工程方面的工作必须是可管理的\n  1.5 编译技术的应用","date":"2024-11-15","permalink":"/posts/tech/media-compilersprinciples/","series":["媒体开发"],"tags":["","",""],"title":"《编译原理》"},{"categories":["普通类"],"content":" 笔记要记录的只是重复性容易忘记的内容, 或者是新学的生疏的且有结构性要求的内容. 如果是不能记录笔记的书籍, 可以采用读后感的形式记录读过的书. 记笔记应以一小部分为单位，切忌看一段记笔记一段。这个“一小部分“应根据具体知识内容的知识密度来，知识容量不能太大了，不然笔记记不全。 只做工具性知识记录，不做计划和规划。 笔记应满足“易查阅”，“简单明了结构清晰”，保留原理性内容，不留理解性内容的要求。 一种可能的做笔记方式：先过一遍大体地分类，然后将以后工作经常用到的，容易忘记的东西进行笔记强化和细化。 记住“自己是来学东西的，不是来准备考试的。” 注意笔记中的“无意义”部分，也就是即便记录了也永远不会再看第二遍的东西。从而改善笔记方式。 但凡是可以轻松通过网络查到的东西，笔记都不应该记录 做笔记时一定要明白自己学的到底是什么，学习不是去记忆。学习应当学的是思维和思路，练习的才是机械式的技术。两者都是重要的东西，但是练习是不可被笔记化的。笔记中的别人的样例实际上是为练习服务的所以笔记应当作的是思路，思维，原理，理论，样例。 只需要做好一点，在理解完全之后再摘抄，而不是边理解边摘抄 ","date":"2024-11-14","permalink":"/posts/other/note-rule/","series":[""],"tags":["","",""],"title":"笔记规范"},{"categories":["计算机"],"content":"运行shell脚本的方法 1.作为可执行程序\n1chmod +x ./test.sh #使脚本具有执行权限 2./test.sh #执行脚本 2.作为解释器参数\n1/bin/sh test.sh 2/bin/php test.php 变量 定义变量 变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。同时，变量名的命名须遵循如下规则：\n 只包含字母、数字和下划线：** 变量名可以包含字母（大小写敏感）、数字和下划线 _，不能包含其他特殊字符。 不能以数字开头： 变量名不能以数字开头，但可以包含数字。 避免使用 Shell 关键字： 不要使用Shell的关键字（例如 if、then、else、fi、for、while 等）作为变量名，以免引起混淆。 使用大写字母表示常量：习惯上，常量的变量名通常使用大写字母，例如 PI=3.14。 避免使用特殊符号： 尽量避免在变量名中使用特殊符号，因为它们可能与 Shell 的语法产生冲突。 避免使用空格： 变量名中不应该包含空格，因为空格通常用于分隔命令和参数。  有效的 Shell 变量名示例如下：\n1RUNOOB=\u0026#34;www.runoob.com\u0026#34; 2LD_LIBRARY_PATH=\u0026#34;/bin/\u0026#34; 3_var=\u0026#34;123\u0026#34; 4var2=\u0026#34;abc\u0026#34; 除了显式地直接赋值，还可以用语句给变量赋值，如：\n1for file in `ls /etc` 2 或 3for file in $(ls /etc) 以上语句将 /etc 下目录的文件名循环出来。\n使用变量 使用一个定义过的变量，只要在变量名前面加美元符号即可，如：\n1your_name=\u0026#34;qinjx\u0026#34; 2 echo $your_name 3 echo ${your_name} 变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况：\n1for skill in Ada Coffe Action Java; do 2 echo \u0026#34;I am good at ${skill}Script\u0026#34; 3done 如果不给skill变量加花括号，写成echo \u0026ldquo;I am good at $skillScript\u0026rdquo;，解释器就会把$skillScript当成一个变量（其值为空），代码执行结果就不是我们期望的样子了。\n推荐给所有变量加上花括号，这是个好的编程习惯。\n只读变量 使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。\n1#!/bin/bash 2 3myUrl=\u0026#34;https://www.google.com\u0026#34; 4readonly myUrl 5myUrl=\u0026#34;https://www.runoob.com\u0026#34; 6 7#/bin/sh: NAME: This variable is read only. 删除变量 使用 unset 命令可以删除变量。语法：\n1unset variable_name 变量被删除后不能再次使用。unset 命令不能删除只读变量。\n变量类型   字符串变量： 使用单引号 ' 或双引号 \u0026quot; 来定义字符串\n  整数变量： 可以使用 declare 或 typeset 命令来声明整数变量。\n1declare -i my_integer=42 这样的声明告诉 Shell 将 my_integer 视为整数，如果尝试将非整数值赋给它，Shell会尝试将其转换为整数。\n  数组变量：\n  Shell 也支持数组，允许你在一个变量中存储多个值。数组可以是整数索引数组或关联数组\n  1#整数索引数组 2my_array=(1 2 3 4 5) 3 4#关联数组 5declare -A associative_array 6associative_array[\u0026#34;name\u0026#34;]=\u0026#34;John\u0026#34; 7associative_array[\u0026#34;age\u0026#34;]=30   环境变量：这些是由操作系统或用户设置的特殊变量，用于配置 Shell 的行为和影响其执行环境。例如，PATH 变量包含了操作系统搜索可执行文件的路径\n  特殊变量：有一些特殊变量在 Shell 中具有特殊含义，例如 $0 表示脚本的名称，$1, $2, 等表示脚本的参数。\n$#表示传递给脚本的参数数量，$? 表示上一个命令的退出状态等。\n  字符串 字符串可以用单引号，也可以用双引号，也可以不用引号。\n1.单引号字符串的限制：\n 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的； 单引号字符串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。  2.双引号的优点：\n 双引号里可以有变量 双引号里可以出现转义字符  1your_name=\u0026#34;runoob\u0026#34; 2str=\u0026#34;Hello, I know you are \\\u0026#34;$your_name\\\u0026#34;! \\n\u0026#34; 3echo -e $str 3.字符串拼接：\n 可以使用双引号或者单引号包裹变量 单引号中包裹变量只能使用单引号  1your_name=\u0026#34;runoob\u0026#34; 2# 使用双引号拼接 3greeting=\u0026#34;hello, \u0026#34;$your_name\u0026#34; !\u0026#34; 4greeting_1=\u0026#34;hello, ${your_name}!\u0026#34; 5echo $greeting $greeting_1 6#hello, runoob ! hello, runoob ! 7 8# 使用单引号拼接 9greeting_2=\u0026#39;hello, \u0026#39;$your_name\u0026#39; !\u0026#39; 10greeting_3=\u0026#39;hello, ${your_name} !\u0026#39; 11echo $greeting_2 $greeting_3 12#hello, runoob ! hello, ${your_name} ! 4.获取字符串长度\n${#string}\n变量为字符串时，${#string} 等价于 ${#string[0]}:\n1string=\u0026#34;abcd\u0026#34; 2echo ${#string} # 输出 4 3 4string=\u0026#34;abcd\u0026#34; 5echo ${#string[0]} # 输出 4 5.提取子字符串\n${string:开始下标：总共截取长度}\n从字符串第 2 个字符开始截取 4 个字符：\n1string=\u0026#34;runoob is a great site\u0026#34; 2echo ${string:1:4} # 输出 unoo 应用shell特殊符号截取：\n假设有变量 var=http://www.aaa.com/123.htm\n # 号截取，删除左边字符，保留右边字符。  1echo ${var#*//} 其中 var 是变量名，# 号是运算符，*// 表示从左边开始删除第一个 // 号及左边的所有字符\n即删除 http://\n结果是 ：www.aaa.com/123.htm\n## 号截取，删除左边字符，保留右边字符。  1echo ${var##*/} ##*/ 表示从左边开始删除最后（最右边）一个 / 号及左边的所有字符\n即删除 http://www.aaa.com/\n结果是 123.htm\n%号截取，删除右边字符，保留左边字符  1echo ${var%/*} %/* 表示从右边开始，删除第一个 / 号及右边的字符\n结果是：http://www.aaa.com\n%% 号截取，删除右边字符，保留左边字符  1echo ${var%%/*} %%/* 表示从右边开始，删除最后（最左边）一个 / 号及右边的字符\n结果是：http:\n从左边第几个字符开始，及字符的个数  1echo ${var:0:5} 其中的 0 表示左边第一个字符开始，5 表示字符的总个数。\n结果是：http:\n从左边第几个字符开始，一直到结束。  1echo ${var:7} 其中的 7 表示左边第8个字符开始，一直到结束。\n结果是 ：www.aaa.com/123.htm\n从右边第几个字符开始，及字符的个数  1echo ${var:0-7:3} 其中的 0-7 表示右边算起第七个字符开始，3 表示字符的个数。\n结果是：123\n从右边第几个字符开始，一直到结束。  1echo ${var:0-7} 表示从右边第七个字符开始，一直到结束。\n结果是：123.htm\n注：（左边的第一个字符是用 0 表示，右边的第一个字符用 0-1 表示）\n#、## 表示从左边开始删除。一个 # 表示从左边删除到第一个指定的字符；两个 # 表示从左边删除到最后一个指定的字符。\n%、%% 表示从右边开始删除。一个 % 表示从右边删除到第一个指定的字符；两个 % 表示从左边删除到最后一个指定的字符。\n删除包括了指定的字符本身。\n6.查找子字符串\nexpr index \u0026quot;$string\u0026quot; 子串\n查找字符 i 或 o 的位置(哪个字母先出现就计算哪个)：\n1string=\u0026#34;runoob is a great site\u0026#34; 2echo `expr index \u0026#34;$string\u0026#34; io` # 输出 4 用反引号括起来， 不然echo直接打印后面的字符。\n数组 bash支持一维数组（不支持多维数组），并且没有限定数组的大小。类似于 C 语言，数组元素的下标由 0 开始编号。获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于 0。\n定义数组 数组名=(值1 值2 ... 值n)\n定义示例：\n可以不使用连续的下标，而且下标的范围没有限制。\n1array_name=(value0 value1 value2 value3) 2 3array_name=( 4value0 5value1 6value2 7value3 8) 9 10array_name[0]=value0 11array_name[1]=value1 12array_name[n]=valuen 读取数组 ${数组名[下标]}\n使用 @ 符号可以获取数组中的所有元素\n1valuen=${array_name[n]} 2 3echo ${array_name[@]} 获取数组的长度 和字符串一样\n1# 取得数组元素的个数 2length=${#array_name[@]} 3# 或者 4length=${#array_name[*]} 5 6# 取得数组单个元素的长度 7length=${#array_name[n]} 注释 单行注释 以 # 开头的行就是注释，会被解释器忽略。通过每一行加一个 # 号设置多行注释\n如果在开发过程中，遇到大段的代码需要临时注释起来，过一会儿又取消注释，怎么办呢？\n每一行加个#符号太费力了，可以把这一段要注释的代码用一对花括号括起来，定义成一个函数，没有地方调用这个函数，这块代码就不会执行，达到了和注释一样的效果。\n多行注释 1#语法 2:\u0026lt;\u0026lt;EOF 3注释内容... 4注释内容... 5注释内容... 6EOF 7 8#示例 9: \u0026lt;\u0026lt;\u0026#39;COMMENT\u0026#39; 10这是注释的部分。 11可以有多行内容。 12COMMENT 13 14:\u0026lt;\u0026lt;\u0026#39; 15注释内容... 16注释内容... 17注释内容... 18\u0026#39; 19 20:\u0026lt;\u0026lt;! 21注释内容... 22注释内容... 23注释内容... 24! 或者使用：号\n: + 空格 + 单引号\n1: \u0026#39; 2这是注释的部分。 3可以有多行内容。 4\u0026#39; 传递参数 我们可以在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为 $n，n 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数。\n例如可以使用 $1、$2 等来引用传递给脚本的参数，其中 $1 表示第一个参数，$2 表示第二个参数，依此类推。\n例：\n1#!/bin/bash 2# author:菜鸟教程 3# url:www.runoob.com 4 5echo \u0026#34;Shell 传递参数实例！\u0026#34;; 6echo \u0026#34;执行的文件名：$0\u0026#34;; 7echo \u0026#34;第一个参数为：$1\u0026#34;; 8echo \u0026#34;第二个参数为：$2\u0026#34;; 9echo \u0026#34;第三个参数为：$3\u0026#34;; 10 11 12--------------- 13 14 15$ chmod +x test.sh 16$ ./test.sh 1 2 3 17Shell 传递参数实例！ 18执行的文件名：./test.sh 19第一个参数为：1 20第二个参数为：2 21第三个参数为：3 特殊字符：\n   参数处理 说明     $# 传递到脚本的参数个数   $* 以一个单字符串显示所有向脚本传递的参数。 如\u0026quot;$*\u0026ldquo;用「\u0026quot;」括起来的情况、以\u0026rdquo;$1 $2 … $n\u0026quot;的形式输出所有参数。   $$ 脚本运行的当前进程ID号   $! 后台运行的最后一个进程的ID号   $@ 与$*相同，但是使用时加引号，并在引号中返回每个参数。 如\u0026quot;$@\u0026ldquo;用「\u0026quot;」括起来的情况、以\u0026rdquo;$1\u0026quot; \u0026ldquo;$2\u0026rdquo; … \u0026ldquo;$n\u0026rdquo; 的形式输出所有参数。   $- 显示Shell使用的当前选项，与set命令 功能相同。   $? 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。    例：\n1#!/bin/bash 2# author:菜鸟教程 3# url:www.runoob.com 4 5echo \u0026#34;Shell 传递参数实例！\u0026#34;; 6echo \u0026#34;第一个参数为：$1\u0026#34;; 7 8echo \u0026#34;参数个数为：$#\u0026#34;; 9echo \u0026#34;传递的参数作为一个字符串显示：$*\u0026#34;; 10 11 12--------------- 13 14$ chmod +x test.sh 15$ ./test.sh 1 2 3 16Shell 传递参数实例！ 17第一个参数为：1 18参数个数为：3 19传递的参数作为一个字符串显示：1 2 3 20 $* 与 $@ 区别：\n 相同点：都是引用所有参数。 不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，则 \u0026quot; * \u0026quot; 等价于 \u0026ldquo;1 2 3\u0026rdquo;（传递了一个参数），而 \u0026ldquo;@\u0026rdquo; 等价于 \u0026ldquo;1\u0026rdquo; \u0026ldquo;2\u0026rdquo; \u0026ldquo;3\u0026rdquo;（传递了三个参数）。  1#!/bin/bash 2# author:菜鸟教程 3# url:www.runoob.com 4 5echo \u0026#34;-- \\$* 演示 ---\u0026#34; 6for i in \u0026#34;$*\u0026#34;; do 7 echo $i 8done 9 10echo \u0026#34;-- \\$@ 演示 ---\u0026#34; 11for i in \u0026#34;$@\u0026#34;; do 12 echo $i 13done 14 15 16--------------- 17 18$ chmod +x test.sh 19$ ./test.sh 1 2 3 20-- $* 演示 --- 211 2 3 22-- $@ 演示 --- 231 242 253 数组 基础在上面\n关联数组 定义：declare -A array_name\n其实也就是java中的字典。\n1declare -A site=([\u0026#34;google\u0026#34;]=\u0026#34;www.google.com\u0026#34; [\u0026#34;runoob\u0026#34;]=\u0026#34;www.runoob.com\u0026#34; [\u0026#34;taobao\u0026#34;]=\u0026#34;www.taobao.com\u0026#34;) 2 3#先声明一个关联数组，然后再设置键和值 4declare -A site 5site[\u0026#34;google\u0026#34;]=\u0026#34;www.google.com\u0026#34; 6site[\u0026#34;runoob\u0026#34;]=\u0026#34;www.runoob.com\u0026#34; 7site[\u0026#34;taobao\u0026#34;]=\u0026#34;www.taobao.com\u0026#34; 访问：array_name[\u0026quot;index\u0026quot;]\n1declare -A site 2site[\u0026#34;google\u0026#34;]=\u0026#34;www.google.com\u0026#34; 3site[\u0026#34;runoob\u0026#34;]=\u0026#34;www.runoob.com\u0026#34; 4site[\u0026#34;taobao\u0026#34;]=\u0026#34;www.taobao.com\u0026#34; 5 6echo ${site[\u0026#34;runoob\u0026#34;]} 获取数组所有元素 使用 @ 或 * 可以获取数组中的所有元素\n1#!/bin/bash 2# author:菜鸟教程 3# url:www.runoob.com 4 5my_array[0]=A 6my_array[1]=B 7my_array[2]=C 8my_array[3]=D 9 10echo \u0026#34;数组的元素为: ${my_array[*]}\u0026#34; 11echo \u0026#34;数组的元素为: ${my_array[@]}\u0026#34; 12 13------------- 14 15$ chmod +x test.sh 16$ ./test.sh 17数组的元素为: A B C D 18数组的元素为: A B C D 19 1declare -A site 2site[\u0026#34;google\u0026#34;]=\u0026#34;www.google.com\u0026#34; 3site[\u0026#34;runoob\u0026#34;]=\u0026#34;www.runoob.com\u0026#34; 4site[\u0026#34;taobao\u0026#34;]=\u0026#34;www.taobao.com\u0026#34; 5 6echo \u0026#34;数组的元素为: ${site[*]}\u0026#34; 7echo \u0026#34;数组的元素为: ${site[@]}\u0026#34; 8 9--------------- 10 11$ chmod +x test.sh 12$ ./test.sh 13数组的元素为: www.google.com www.runoob.com www.taobao.com 14数组的元素为: www.google.com www.runoob.com www.taobao.com 在数组前加一个感叹号 ! 可以获取数组的所有键\n1declare -A site 2site[\u0026#34;google\u0026#34;]=\u0026#34;www.google.com\u0026#34; 3site[\u0026#34;runoob\u0026#34;]=\u0026#34;www.runoob.com\u0026#34; 4site[\u0026#34;taobao\u0026#34;]=\u0026#34;www.taobao.com\u0026#34; 5 6echo \u0026#34;数组的键为: ${!site[*]}\u0026#34; 7echo \u0026#34;数组的键为: ${!site[@]}\u0026#34; 8 9------------- 10 11数组的键为: google runoob taobao 12数组的键为: google runoob taobao 获取数组的长度 获取数组长度的方法与获取字符串长度的方法相同\n1#!/bin/bash 2# author:菜鸟教程 3# url:www.runoob.com 4 5my_array[0]=A 6my_array[1]=B 7my_array[2]=C 8my_array[3]=D 9 10echo \u0026#34;数组元素个数为: ${#my_array[*]}\u0026#34; 11echo \u0026#34;数组元素个数为: ${#my_array[@]}\u0026#34; Tips 数组的值也可以写入变量。\n1A=1 2my_array=($A B C D) 3echo \u0026#34;第一个元素为: ${my_array[0]}\u0026#34; 4echo \u0026#34;第二个元素为: ${my_array[1]}\u0026#34; 5echo \u0026#34;第三个元素为: ${my_array[2]}\u0026#34; 6echo \u0026#34;第四个元素为: ${my_array[3]}\u0026#34; 根据数组元素索引获取该数组元素值时，数组下标可为变量。\n1arr=(a b c d) 2i=2 3echo ${arr[i]} 运算符 原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。\nexpr 是一款表达式计算工具，使用它能完成表达式的求值操作。\n 表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。 完整的表达式要被   包含，注意这个字符不是常用的单引号，在 Esc 键下边。  1#!/bin/bash 2 3val=`expr 2 + 2` 4echo \u0026#34;两数之和为 : $val\u0026#34; 算术运算符 表列出了常用的算术运算符，假定变量 a 为 10，变量 b 为 20：\n   运算符 说明 举例     + 加法 expr $a + $b 结果为 30。   - 减法 expr $a - $b 结果为 -10。   * 乘法 expr $a \\* $b 结果为 200。   / 除法 expr $b / $a 结果为 2。   % 取余 expr $b % $a 结果为 0。   = 赋值 a=$b 把变量 b 的值赋给 a。   == 相等。用于比较两个数字，相同则返回 true。 [ $a == $b ] 返回 false。   != 不相等。用于比较两个数字，不相同则返回 true。 [ $a != $b ] 返回 true。    条件表达式要放在方括号之间，并且要有空格，例如: [$a==$b] 是错误的，必须写成 [ $a == $b ]。\n关系运算符 假定变量 a 为 10，变量 b 为 20：\n   运算符 说明 举例     -eq 检测两个数是否相等，相等返回 true。 [ $a -eq $b ] 返回 false。   -ne 测两个数是否不相等，不相等返回 true。 [ $a -ne $b ] 返回 true。   -gt 检测左边的数是否大于右边的，如果是，则返回 true。 [ $a -gt $b ] 返回 false。   -lt 检测左边的数是否小于右边的，如果是，则返回 true。 [ $a -lt $b ] 返回 true。   -ge 检测左边的数是否大于等于右边的，如果是，则返回 true。 [ $a -ge $b ] 返回 false。   -le 检测左边的数是否小于等于右边的，如果是，则返回 true。 [ $a -le $b ] 返回 true。    布尔运算符 假定变量 a 为 10，变量 b 为 20：\n   运算符 说明 举例     ! 非运算，表达式为 true 则返回 false，否则返回 true。 [ ! false ] 返回 true。   -o 或运算，有一个表达式为 true 则返回 true。 [ $a -lt 20 -o $b -gt 100 ] 返回 true。   -a 与运算，两个表达式都为 true 才返回 true。 [ $a -lt 20 -a $b -gt 100 ] 返回 false。    逻辑运算符 假定变量 a 为 10，变量 b 为 20:\n   运算符 说明 举例     \u0026amp;\u0026amp; 逻辑的 AND [[ $a -lt 100 \u0026amp;\u0026amp; $b -gt 100 ]] 返回 false   || 逻辑的 OR [[ $a -lt 100 || $b -gt 100 ]] 返回 true    字符串运算符 假定变量 a 为 \u0026ldquo;abc\u0026rdquo;，变量 b 为 \u0026ldquo;efg\u0026rdquo;：\n   运算符 说明 举例     = 检测两个字符串是否相等，相等返回 true。 [ $a = $b ] 返回 false。   != 检测两个字符串是否不相等，不相等返回 true。 [ $a != $b ] 返回 true。   -z 检测字符串长度是否为0，为0返回 true。 [ -z $a ] 返回 false。   -n 检测字符串长度是否不为 0，不为 0 返回 true。 [ -n \u0026ldquo;$a\u0026rdquo; ] 返回 true。   $ 检测字符串是否不为空，不为空返回 true。 [ $a ] 返回 true。    文件测试运算符 文件测试运算符用于检测 Unix 文件的各种属性。\n属性检测描述如下：\n   操作符 说明 举例     -b file 检测文件是否是块设备文件，如果是，则返回 true。 [ -b $file ] 返回 false。   -c file 检测文件是否是字符设备文件，如果是，则返回 true。 [ -c $file ] 返回 false。   -d file 检测文件是否是目录，如果是，则返回 true。 [ -d $file ] 返回 false。   -f file 检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。 [ -f $file ] 返回 true。   -g file 检测文件是否设置了 SGID 位，如果是，则返回 true。 [ -g $file ] 返回 false。   -k file 检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。 [ -k $file ] 返回 false。   -p file 检测文件是否是有名管道，如果是，则返回 true。 [ -p $file ] 返回 false。   -u file 检测文件是否设置了 SUID 位，如果是，则返回 true。 [ -u $file ] 返回 false。   -r file 检测文件是否可读，如果是，则返回 true。 [ -r $file ] 返回 true。   -w file 检测文件是否可写，如果是，则返回 true。 [ -w $file ] 返回 true。   -x file 检测文件是否可执行，如果是，则返回 true。 [ -x $file ] 返回 true。   -s file 检测文件是否为空（文件大小是否大于0），不为空返回 true。 [ -s $file ] 返回 true。   -e file 检测文件（包括目录）是否存在，如果是，则返回 true。 [ -e $file ] 返回 true。    其他检查符：\n -S: 判断某文件是否 socket。 -L: 检测文件是否存在并且是一个符号链接。  1#!/bin/bash 2# author:菜鸟教程 3# url:www.runoob.com 4 5file=\u0026#34;/var/www/runoob/test.sh\u0026#34; 6if [ -r $file ] 7then 8 echo \u0026#34;文件可读\u0026#34; 9else 10 echo \u0026#34;文件不可读\u0026#34; 11fi 12if [ -w $file ] 13then 14 echo \u0026#34;文件可写\u0026#34; 15else 16 echo \u0026#34;文件不可写\u0026#34; 17fi 18if [ -x $file ] 19then 20 echo \u0026#34;文件可执行\u0026#34; 21else 22 echo \u0026#34;文件不可执行\u0026#34; 23fi 24if [ -f $file ] 25then 26 echo \u0026#34;文件为普通文件\u0026#34; 27else 28 echo \u0026#34;文件为特殊文件\u0026#34; 29fi 30if [ -d $file ] 31then 32 echo \u0026#34;文件是个目录\u0026#34; 33else 34 echo \u0026#34;文件不是个目录\u0026#34; 35fi 36if [ -s $file ] 37then 38 echo \u0026#34;文件不为空\u0026#34; 39else 40 echo \u0026#34;文件为空\u0026#34; 41fi 42if [ -e $file ] 43then 44 echo \u0026#34;文件存在\u0026#34; 45else 46 echo \u0026#34;文件不存在\u0026#34; 47fi 自增和自减操作符 尽管 Shell 本身没有像 C、C++ 或 Java 那样的 ++ 和 \u0026ndash; 操作符，但可以通过其他方式实现相同的功能。以下是一些常见的方法：\nlet命令 1#!/bin/bash 2 3# 初始化变量 4num=5 5 6# 自增 7let num++ 8 9# 自减 10let num-- 11 12echo $num $(()) 1#!/bin/bash 2 3# 初始化变量 4num=5 5 6# 自增 7num=$((num + 1)) 8 9# 自减 10num=$((num - 1)) 11 12echo $num expr 1#!/bin/bash 2 3# 初始化变量 4num=5 5 6# 自增 7num=$(expr $num + 1) 8 9# 自减 10num=$(expr $num - 1) 11 12echo $num (()) 1#!/bin/bash 2 3# 初始化变量 4num=5 5 6# 自增 7((num++)) 8 9# 自减 10((num--)) 11 12echo $num echo命令 停止 自己只需要过一过就行， 忘记了自己去查， 故不再更新。\n","date":"2024-11-14","permalink":"/posts/tech/media-misc-shell/","series":["媒体开发"],"tags":["","",""],"title":"菜鸟教程Shell"},{"categories":["计算机"],"content":"  在线rst编辑器：\nhttp://rst.ninjs.org/\nhttps://notex.ch/editor\n  英文文档：https://docutils.sourceforge.io/docs/ref/rst/restructuredtext.html\n  国内资料： reStructuredText(.rst)语法规则快速入门 1, reStructuredText(.rst)语法规则快速入门2   简单总结：\n  标题： ! \u0026quot; # $ % \u0026amp; ' ( ) * + , - . / : ; \u0026lt; = \u0026gt; ? @ [ \\ ] ^ _ ` { | } ~ 连续几个分为几级标题\n  段落： 空行为一段， 缩进变成引用段落\n  列表\n无序列表：* + - • ‣ ⁃\n有序列表：\n1arabic numerals: 1, 2, 3, ... (no upper limit). 2uppercase alphabet characters: A, B, C, ..., Z. 3lower-case alphabet characters: a, b, c, ..., z. 4uppercase Roman numerals: I, II, III, IV, ..., MMMMCMXCIX (4999). 5lowercase Roman numerals: i, ii, iii, iv, ..., mmmmcmxcix (4999). 如果你不想使用这些，在你标明第一个条目的序号字符后，第二个开始你还可以使用”#”号来让reStructuredText自动生成需要的序号。\n定义列表\n字段列表\n选项列表\n  表格：\n网格表： - = | +\n-” 用来分隔行， “=“ 用来分隔表头和表体行，”|” 用来分隔列，而”+”用来表示行和列相交的节点\n简单表格: = -\n1 2基本形式 3======== 4 5`下面这种是最简单的表格形式，当然你也可以去掉表头展示。`6 7===== ===== =======8 A B A and B9===== ===== =======10False False False11True False False12False True False13True True True14===== ===== =======15 16表内嵌入 17======== 18 19`下面这种简单表内有列表`20 21===== =====22col 1 col 223===== =====241 Second column of row 1.252 Second column of row 2.26 Second line of paragraph.273 - Second column of row 3.28 29 - Second item in bullet30 list (row 3, column 2).31\\ Row 4; column 1 will be empty.32===== =====  块：\n文字块： 前面两冒号+空行， 块内内容要有缩进。\n  样式：\n1.. Strong Emphasis 2 3This is **Strong Text**. HTML tag is strong.粗体 4 5.. Italic, Emphasis 6 7This is *Emphasis* Text.这个HTML使用em， 斜体 8 9.. Interpreted Text 10 11This is `Interpreted Text`. 注意，这个HTML一般用\u0026lt;cite\u0026gt;表示 12 13.. Inline Literals 14 15This is ``Inline Literals``. HTML tag is \u0026lt;tt\u0026gt;. 等宽字体. 16 17 18 19我这里是一个 链接_. 20 21.. _链接: http://blog.useasp.net 22 23这里同样是一个 `链接\u0026lt;http://blog.useasp.net\u0026gt;`_，不需要特别设置。  ","date":"2024-11-13","permalink":"/posts/tech/media-misc-rst/","series":["媒体开发"],"tags":["","",""],"title":"rst语法"},{"categories":["计算机"],"content":"git 1.创建repository仓库\n1git --version 2mkdir my-cool-website 3cd my-cool-website 4git status #在不知道怎么办时获取一些信息 5git init #初始化仓库 6git status 2.设置用户信息\n1## global 全局配置 2git config --global user.name \u0026#34;Valenti Despa\u0026#34; 3git config --global user.email \u0026#34;valenti@example.com\u0026#34; 3.第一次commit提交\n1git commit #无文件提交(文件没有变化) 2vim readme.md #:x保存退出 3git status #出现未跟踪文件 4git add readme.md #添加追踪文件（暂存区） 5git status #出现要提交的变更 6git commit -m \u0026#34;My first commit\u0026#34; 4.一次提交多个文件\n1vim index.html 2vim readme.md 3git status #出现未跟踪的文件以及待提交的变更 4#一个一个添加 5#git add readme.md index.html 6git add . #全部添加 5.取消暂存区的文件的变更\n这样做不意味着原文件的变更取消了\n1git reset HEAD readme.md 2git status 3git commit -m \u0026#34;Added first page\u0026#34; 4 5git add . 6git status 7git commit -m \u0026#34;Improve readme\u0026#34; 8git status 9 6.查看变更\n1git log 2git log --patch #查看更详细的变更 7.提交文件夹\n1mkdir temp 2git status #git不跟踪文件夹 3#插入空文件 4touch temp/.gitkeep 5git status 6git add . 7git commit -m \u0026#34;Added temp folder\u0026#34; 8.删除文件\n1#未跟踪文件 2touch newfile.txt 3git status #未跟踪文件 4rm newfile.txt 5 6#在跟踪文件 7rm -rf -- temp #删除在跟踪目录 8git status 9git add . #暂存区删除目录 10git commit -m \u0026#34;Removed temp folder\u0026#34; 9..gitignore文件\n有些文件在目录中但是不想让他们在仓库中，使用gitignore排除他们。\n1mkdir config 2touch config/private.txt 3git status 4vim .gitignore 5 6config 7 8git status 9git add . 10git commit -m \u0026#34;Added gitignore configuration\u0026#34; 10.创建分支\n创建实验性的东西， 开发新功能等。这样不会影响主分支\n1git checkout -b feature/new-table #创建新分支并切换 2git status 3vim index.html 4git add . 5git commit -m \u0026#34;Added table\u0026#34; 6 7git checkout master #回到主分支 8cat index.html #没有变化 9 10git checkout feature/new-table 11.合并分支\n这里只是出现简单合并。\n1git branch -d featrue/new-table #删除分支出现error 2 3git checkout master 4git merge feature/new-table 5git log 6 7#合并模式为fastforward， 这只会在当master没有出现更改情况下的合并 8git branch -d featrue/new-table 12.高级分支场景\n1git checkout -b bugfix/table 2vim index.html 3git add . 4git status 5git commit -m \u0026#34;Added table cell\u0026#34; 6 7git checkout master 8vim readme.md 9git add . 10git commit -m \u0026#34;Learning branching\u0026#34; 11 12#这时出现了双分支。两分支无共同父 13git merge bugfix/table 14#这时使用的是recursive 递归策略 15 13.获取另一个分支的修改\n这样可以使得两个分支在一些文件保持一直， 可以进行快速合并\n1git checkout -b bugfix/table-2 2vim index.html 3git add . 4git commit -m \u0026#34;Added 2nd cell\u0026#34; 5 6git checkout master 7vim readme.md 8git add . 9git commit -m \u0026#34;Learning rebaseing\u0026#34; 10 11#不能进行快速合并 12 13git checkout bugfix/table-2 14#bugfix/table-2获取，master的修改 15git rebase master 16 17git log 18git checkout master 19#快速合并 20git merge bugfix/table-2 14.解决合并冲突\n合并冲突通常是两次提交修改到了同一文件甚至三同一行\n1#准备 2git checkout -b bugfix/table-3 3vim index.html 4git add . 5git commit -m \u0026#34;Rename cell\u0026#34; 6 7git checkout master 8vim index.html #修改同一行 9git add . 10git commit -m \u0026#34;Renamed in My cell\u0026#34; 11 12#冲突 13git merge bugfix/table-3 #冲突 14git status #both modified: index.html 15git merge --abort #停止合并 16git status #一切都好 17 18git checkout bugfix/table-3 19git rebase master #冲突 20git rebase --abort #停止同步 21 22#解决 23git merge bugfix/table-3 #冲突 24git status #both modified: index.html 25vim index.html #出现HEAD， 分支等信息， 告诉你那里冲突了 26#解决冲突， 可以使用ide打开更好解决。 27 28#告诉git已经处理好冲突 29git add index.html 30git commit -m \u0026#34;Resolve conflict\u0026#34; 31git status 15.在远程仓库开发\n  创建新的项目\n  创建新仓库或者推送已有仓库\n1git init 2 3#origin是后面链接的别名 4git remote add origin git@gitlab.---.team:---/my-cool-website.git 5 6git remote -v #显示所有远程库   推送变化\n1#注意如果没有sshkey需要生成并上传到代码平台 2ssh-keygem -t rsa -C \u0026#34;...\u0026#34; 3 4#只推送master 5git push origin master   Gitlab 1.gitlab web界面\n可以查看提交commit看看那些内容发生了变化\n可以master旁边添加分支\n可以快速改变文件内容而不需要在本地改变\n2.web界面中commit\n直接edit文件，然后commit就行\n3.从远程拉取变化到本地\n1git pull 2git pull origin master 4.解决冲突\n本地commit之后， web那里也收到了同一文件的commit, 这是本地不能push\n1#方法一： 2#先把远程的冲突pull过来 3git pull origin master 4 5#进行冲突处理。merge commit 6 7#方法二： 8#直接同步为远端的master 9git reset --hard origin/master 10 11#或者rebase， 解决冲突/自动合并 12git pull origin master --rebase 5.克隆远端仓库\nclone按钮有连接\n1git clone 链接 6.将分支合并到master\n1git pull 更新 2git checkout -b feature/cool-table 3git add . 4git commit -m \u0026#34;Text change\u0026#34; 5#推送远端分支 6git push origin feature/cool-table 7#进行merge request， 请求合并到主分支 8访问连接， 或者gitlab上merge‘ 9 10vim index.html 11git add . 12git commit -m \u0026#34;fix\u0026#34; 13git push origin feature/cool-table 14这样再次更改也会反映在merge中。 15squash commit可以合并多个commit， 保持历史记录整洁 ","date":"2024-11-12","permalink":"/posts/tech/media-git/","series":["媒体开发"],"tags":["","",""],"title":"git\u0026gitlab"},{"categories":["计算机"],"content":"一、Linux系统启动过程 1.内核引导 当计算机打开电源后，首先是BIOS开机自检，按照BIOS中设置的启动设备（通常是硬盘）来启动。\n操作系统接管硬件以后，首先读入 /boot 目录下的内核文件。\n2.运行init init 进程是系统所有进程的起点，你可以把它比拟成系统所有进程的老祖宗，没有这个进程，系统中任何进程都不会启动。\ninit 程序首先是需要读取配置文件 /etc/inittab。\n3.运行级别 许多程序需要开机启动。它们在Windows叫做\u0026quot;服务\u0026quot;（service），在Linux就叫做\u0026quot;守护进程\u0026quot;（daemon）。\ninit进程的一大任务，就是去运行这些开机启动的程序。\n但是，不同的场合需要启动不同的程序，比如用作服务器时，需要启动Apache，用作桌面就不需要。\nLinux允许为不同的场合，分配不同的开机启动程序，这就叫做\u0026quot;运行级别\u0026quot;（runlevel）。也就是说，启动时根据\u0026quot;运行级别\u0026quot;，确定要运行哪些程序。\nLinux系统有7个运行级别(runlevel)：\n 运行级别0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动 运行级别1：单用户工作状态，root权限，用于系统维护，禁止远程登录 运行级别2：多用户状态(没有NFS) 运行级别3：完全的多用户状态(有NFS)，登录后进入控制台命令行模式 运行级别4：系统未使用，保留 运行级别5：X11控制台，登录后进入图形GUI模式 运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动  4.系统初始化 在init的配置文件中有这么一行： si::sysinit:/etc/rc.d/rc.sysinit　它调用执行了/etc/rc.d/rc.sysinit，而rc.sysinit是一个bash shell的脚本，它主要是完成一些系统初始化的工作，rc.sysinit是每一个运行级别都要首先运行的重要脚本。\n它主要完成的工作有：激活交换分区，检查磁盘，加载硬件模块以及其它一些需要优先执行任务。\n1l5:5:wait:/etc/rc.d/rc 5 这一行表示以5为参数运行/etc/rc.d/rc，/etc/rc.d/rc是一个Shell脚本，它接受5作为参数，去执行/etc/rc.d/rc5.d/目录下的所有的rc启动脚本，/etc/rc.d/rc5.d/目录中的这些启动脚本实际上都是一些连接文件，而不是真正的rc启动脚本，真正的rc启动脚本实际上都是放在/etc/rc.d/init.d/目录下。\n而这些rc启动脚本有着类似的用法，它们一般能接受start、stop、restart、status等参数。\n/etc/rc.d/rc5.d/中的rc启动脚本通常是K或S开头的连接文件，对于以 S 开头的启动脚本，将以start参数来运行。\n而如果发现存在相应的脚本也存在K打头的连接，而且已经处于运行态了(以/var/lock/subsys/下的文件作为标志)，则将首先以stop为参数停止这些已经启动了的守护进程，然后再重新运行。\n这样做是为了保证是当init改变运行级别时，所有相关的守护进程都将重启。\n至于在每个运行级中将运行哪些守护进程，用户可以通过chkconfig或setup中的\u0026quot;System Services\u0026quot;来自行设定。\n5.建立终端 rc执行完毕后，返回init。这时基本系统环境已经设置好了，各种守护进程也已经启动了。\ninit接下来会打开6个终端，以便用户登录系统。在inittab中的以下6行就是定义了6个终端：\n11:2345:respawn:/sbin/mingetty tty1 22:2345:respawn:/sbin/mingetty tty2 33:2345:respawn:/sbin/mingetty tty3 44:2345:respawn:/sbin/mingetty tty4 55:2345:respawn:/sbin/mingetty tty5 66:2345:respawn:/sbin/mingetty tty6 从上面可以看出在2、3、4、5的运行级别中都将以respawn方式运行mingetty程序，mingetty程序能打开终端、设置模式。\n同时它会显示一个文本登录界面，这个界面就是我们经常看到的登录界面，在这个登录界面中会提示用户输入用户名，而用户输入的用户将作为参数传给login程序来验证用户的身份。\n6.用户登录系统 一般来说，用户的登录方式有三种：\n （1）命令行登录 （2）ssh登录 （3）图形界面登录  对于运行级别为5的图形方式用户来说，他们的登录是通过一个图形化的登录界面。登录成功后可以直接进入 KDE、Gnome 等窗口管理器。\n而本文主要讲的还是文本方式登录的情况：当我们看到mingetty的登录界面时，我们就可以输入用户名和密码来登录系统了。\nLinux 的账号验证程序是 login，login 会接收 mingetty 传来的用户名作为用户名参数。\n然后 login 会对用户名进行分析：如果用户名不是 root，且存在 /etc/nologin 文件，login 将输出 nologin 文件的内容，然后退出。\n这通常用来系统维护时防止非root用户登录。只有/etc/securetty中登记了的终端才允许 root 用户登录，如果不存在这个文件，则 root 用户可以在任何终端上登录。\n/etc/usertty文件用于对用户作出附加访问限制，如果不存在这个文件，则没有其他限制。\n7.图形模式与文字模式的切换方式 Linux预设提供了六个命令窗口终端机让我们来登录。\n默认我们登录的就是第一个窗口，也就是tty1，这个六个窗口分别为tty1,tty2 … tty6，你可以按下Ctrl + Alt + F1 ~ F6 来切换它们。\n如果你安装了图形界面，默认情况下是进入图形界面的，此时你就可以按Ctrl + Alt + F1 ~ F6来进入其中一个命令窗口界面。\n当你进入命令窗口界面后再返回图形界面只要按下Ctrl + Alt + F7 就回来了。\n8.Linux关机 正确的关机流程为：sync \u0026gt; shutdown \u0026gt; reboot \u0026gt; halt\n关机指令为：shutdown ，你可以man shutdown 来看一下帮助文档。\n例如你可以运行如下命令关机：\n1sync 将数据由内存同步到硬盘中。 2 3shutdown 关机指令，你可以man shutdown 来看一下帮助文档。例如你可以运行如下命令关机： 4 5shutdown –h 10 ‘This server will shutdown after 10 mins’ 这个命令告诉大家，计算机将在10分钟后关机，并且会显示在登陆用户的当前屏幕中。 6 7shutdown –h now 立马关机 8 9shutdown –h 20:25 系统会在今天20:25关机 10 11shutdown –h +10 十分钟后关机 12 13shutdown –r now 系统立马重启 14 15shutdown –r +10 系统十分钟后重启 16 17reboot 就是重启，等同于 shutdown –r now 18 19halt 关闭系统，等同于shutdown –h now 和 poweroff 最后总结一下，不管是重启系统还是关闭系统，首先要运行 sync 命令，把内存中的数据写到磁盘中。\n关机的命令有 shutdown –h now halt poweroff 和 init 0 , 重启系统的命令有 shutdown –r now reboot init 6。\nhalt 命令通知硬件来停止所有的 CPU 功能，但是仍然保持通电。你可以用它使系统处于低层维护状态。注意在有些情况会它会完全关闭系统。\n1# halt ### 停止机器 2# halt -p ### 关闭机器、关闭电源 3# halt --reboot ### 重启机器 poweroff 会发送一个 ACPI 信号来通知系统关机。\n1# poweroff ### 关闭机器、关闭电源 2# poweroff --halt ### 停止机器 3# poweroff --reboot ### 重启机器 reboot 命令 reboot 通知系统重启。\n1# reboot ### 重启机器 2# reboot --halt ### 停止机器 3# reboot -p ### 关闭机器 二、Linux系统目录结构 在 Linux 或 Unix 操作系统中，所有的文件和目录都被组织成以一个根节点开始的倒置的树状结构。\n文件系统的最顶层是由根目录开始的，系统使用 / 来表示根目录。在根目录之下的既可以是目录，也可以是文件，而每一个目录中又可以包含子目录文件。如此反复就可以构成一个庞大的文件系统。\n在Linux文件系统中有两个特殊的目录，一个用户所在的工作目录，也叫当前目录，可以使用一个点 . 来表示；另一个是当前目录的上一级目录，也叫父目录，可以使用两个点 .. 来表示。\n树状目录结构：\n  /bin： bin 是 Binaries (二进制文件) 的缩写, 这个目录存放着最经常使用的命令。\n  /boot： 这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。\n  /dev ： dev 是 Device(设备) 的缩写, 该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。\n  /etc： etc 是 Etcetera(等等) 的缩写,这个目录用来存放所有的系统管理所需要的配置文件和子目录。\n  /home： 用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的，如上图中的 alice、bob 和 eve。\n  /lib： lib 是 Library(库) 的缩写这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。\n  /lost+found： 这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。\n  /media： linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。\n  /mnt： 系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 /mnt/ 上，然后进入该目录就可以查看光驱里的内容了。\n  /opt： opt 是 optional(可选) 的缩写，这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。\n  /proc： proc 是 Processes(进程) 的缩写，/proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。 这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器：\n1echo 1 \u0026gt; /proc/sys/net/ipv4/icmp_echo_ignore_all   /root： 该目录为系统管理员，也称作超级权限者的用户主目录。\n  /sbin： s 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序。\n  /selinux： 这个目录是 Redhat/CentOS 所特有的目录，Selinux 是一个安全机制，类似于 windows 的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。\n  /srv： 该目录存放一些服务启动之后需要提取的数据。\n  /sys：\n这是 Linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs 。\nsysfs 文件系统集成了下面3种文件系统的信息：针对进程信息的 proc 文件系统、针对设备的 devfs 文件系统以及针对伪终端的 devpts 文件系统。\n该文件系统是内核设备树的一个直观反映。\n当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。\n  /tmp： tmp 是 temporary(临时) 的缩写这个目录是用来存放一些临时文件的。\n  /usr： usr 是 unix system resources(unix 系统资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。\n  /usr/bin： 系统用户使用的应用程序。\n  /usr/sbin： 超级用户使用的比较高级的管理程序和系统守护程序。\n  /usr/src： 内核源代码默认的放置目录。\n  /var： var 是 variable(变量) 的缩写，这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。\n  /run： 是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。\n  三、Linux 远程登录 登陆到自己的Linux上 密钥对已经生成了。你可以给你的密钥输入一个密码，（在Key Passphrase那里）也可以留空。然后点 Save public key 保存公钥，点 Save private Key 保存私钥。笔者建议你放到一个比较安全的地方，一来防止别人偷窥，二来防止误删除。接下来就该到远程 linux 主机上设置了。\n1）创建目录 /root/.ssh 并设置权限\n[root@localhost ~]# mkdir /root/.ssh mkdir 命令用来创建目录，以后会详细介绍，暂时只了解即可。\n[root@localhost ~]# chmod 700 /root/.ssh chmod 命令是用来修改文件属性权限的，以后会详细介绍。\n2）创建文件 / root/.ssh/authorized_keys\n[root@localhost ~]# vim /root/.ssh/authorized_keys vim 命令是编辑一个文本文件的命令，同样在后续章节详细介绍。\n3）打开刚才生成的public key 文件，建议使用写字板打开，这样看着舒服一些，复制从AAAA开头至 \u0026ldquo;\u0026mdash;- END SSH2 PUBLIC KEY \u0026mdash;-\u0026rdquo; 该行上的所有内容，粘贴到/root/.ssh/authorized_keys 文件中，要保证所有字符在一行。\n设置putty选项，点窗口左侧的SSh –\u0026gt; Auth ，单击窗口右侧的Browse… 选择刚刚生成的私钥， 再点Open ，此时输入root，就不用输入密码就能登录了。\n利用ssh登录远程服务器 启动ssh：\n1service sshd start 登录远程服务器：\n1ssh -p 50022 my@127.0.0.1 2输入密码： 3my@127.0.0.1: -p 后面是端口\nmy 是服务器用户名\n127.0.0.1 是服务器 ip\n回车输入密码即可登录\n四、Linux文件基本属性 为了保护系统的安全性，Linux 系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。不同的用户处于不同的地位，拥有不同的权限。\n在 Linux 中我们通常使用以下两个命令来修改文件或目录的所属用户与权限：\n chown (change owner) ： 修改所属用户与组。 chmod (change mode) ： 修改用户的权限。  在 Linux 中我们可以使用 ll 或者 ls –l 命令来显示一个文件的属性以及文件所属的用户和组\n在 Linux 中第一个字符代表这个文件是目录、文件或链接文件等等。\n 当为 d 则是目录 当为 - 则是文件； 若是 l 则表示为链接文档(link file)； 若是 b 则表示为装置文件里面的可供储存的接口设备(可随机存取装置)； 若是 c 则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。  接下来的字符中，以三个为一组，且均为 rwx 的三个参数的组合。其中， r 代表可读(read)、 w 代表可写(write)、 x 代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号 - 而已。\n所以每个文件的属性由左边第一部分的 10 个字符来确定：\n从左至右用 0-9 这些数字来表示。\n第 0 位确定文件类型，第 1-3 位确定属主（该文件的所有者）拥有该文件的权限。第4-6位确定属组（所有者的同组用户）拥有该文件的权限，第7-9位确定其他用户拥有该文件的权限。\n其中，第 1、4、7 位表示读权限，如果用 r 字符表示，则有读权限；第 2、5、8 位表示写权限，如果用 w 字符表示，则有写权限，；第 3、6、9 位表示可执行权限，如果用 x 字符表示，则有执行权限。\nLinux文件属主和属组 对于文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户。\n同时，在Linux系统中，用户是按组分类的，一个用户属于一个或多个组。\n文件所有者以外的用户又可以分为文件所属组的同组用户和其他用户。\n因此，Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。\n对于 root 用户来说，一般情况下，文件的权限对其不起作用。\n更改文件属性 chgrp：更改文件属组 语法：\n1chgrp [-R] 属组名 文件名 参数选项\n -R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上 -R 的参数，那么该目录下的所有文件的属组都会更改。  chown：更改文件所有者（owner），也可以同时更改文件所属组。 语法：\n1chown [–R] 所有者 文件名 2chown [-R] 所有者:属组名 文件名 进入 /root 目录（~）将install.log的拥有者改为bin这个账号：\n1[root@www ~] cd ~ 2[root@www ~]# chown bin install.log 3[root@www ~]# ls -l 4-rw-r--r-- 1 bin users 68495 Jun 25 08:53 install.log 将install.log的拥有者与群组改回为root：\n1[root@www ~]# chown root:root install.log 2[root@www ~]# ls -l 3-rw-r--r-- 1 root root 68495 Jun 25 08:53 install.log chmod：更改文件9个属性 Linux文件属性有两种设置方法，一种是数字，一种是符号。\nLinux 文件的基本权限就有九个，分别是 owner/group/others(拥有者/组/其他) 三种身份各有自己的 read/write/execute 权限。\n数字版： 文件的权限字符为： -rwxrwxrwx ， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下：\n r:4 w:2 x:1  选项与参数：\n xyz : 就是刚刚提到的数字类型的权限属性，为 rwx 属性数值的相加。 -R : 进行递归(recursive)的持续变更，以及连同次目录下的所有文件都会变更  符号版： 以使用 u, g, o 来代表三种身份的权限。\n外， a 则代表 all，即全部的身份。读写的权限可以写成 r, w, x，也就是可以使用下表的方式来看：\n   chmod u g o a +(加入) -(除去) =(设定) r w x 文件或目录    如果我们需要将文件权限设置为 -rwxr-xr\u0026ndash; ，可以使用 chmod u=rwx,g=rx,o=r 文件名 来设定\n五、Linux文件与目录管理 处理目录的常用命令  ls（英文全拼：list files）: 列出目录及文件名 cd（英文全拼：change directory）：切换目录 pwd（英文全拼：print work directory）：显示目前的目录 mkdir（英文全拼：make directory）：创建一个新的目录 rmdir（英文全拼：remove directory）：删除一个空的目录 cp（英文全拼：copy file）: 复制文件或目录 rm（英文全拼：remove）: 删除文件或目录 mv（英文全拼：move file）: 移动文件与目录，或修改文件与目录的名称  你可以使用 man [命令] 来查看各个命令的使用文档，如 ：man cp。\nls 选项与参数：\n -a ：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来(常用) -d ：仅列出目录本身，而不是列出目录内的文件数据(常用) -l ：长数据串列出，包含文件的属性与权限等等数据；(常用)  将目录下的所有文件列出来(含属性与隐藏档)\n1[root@www ~]# ls -al ~ cd pwd 选项与参数：\n -P ：显示出确实的路径，而非使用链接 (link) 路径。  实例：单纯显示出目前的工作目录：\n1[root@www ~]# pwd 2/root \u0026lt;== 显示出目录啦～ 实例显示出实际的工作目录，而非链接档本身的目录名而已。\n1[root@www ~]# cd /var/mail \u0026lt;==注意，/var/mail是一个链接档 2[root@www mail]# pwd 3/var/mail \u0026lt;==列出目前的工作目录 4[root@www mail]# pwd -P 5/var/spool/mail \u0026lt;==怎么回事？有没有加 -P 差很多～ 6[root@www mail]# ls -ld /var/mail 7lrwxrwxrwx 1 root root 10 Sep 4 17:54 /var/mail -\u0026gt; spool/mail 8# 看到这里应该知道为啥了吧？因为 /var/mail 是链接档，链接到 /var/spool/mail 9# 所以，加上 pwd -P 的选项后，会不以链接档的数据显示，而是显示正确的完整路径啊！ mkdir 语法：\n1mkdir [-mp] 目录名称 选项与参数：\n -m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～ -p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！  实例：请到/tmp底下尝试创建数个新目录看看：\n1[root@www ~]# cd /tmp 2[root@www tmp]# mkdir test \u0026lt;==创建一名为 test 的新目录 3[root@www tmp]# mkdir test1/test2/test3/test4 4mkdir: cannot create directory `test1/test2/test3/test4\u0026#39;: 5No such file or directory \u0026lt;== 没办法直接创建此目录啊！ 6[root@www tmp]# mkdir -p test1/test2/test3/test4 加了这个 -p 的选项，可以自行帮你创建多层目录！\n实例：创建权限为 rwx\u0026ndash;x\u0026ndash;x 的目录。\n1[root@www tmp]# mkdir -m 711 test2 2[root@www tmp]# ls -l 3drwxr-xr-x 3 root root 4096 Jul 18 12:50 test 4drwxr-xr-x 3 root root 4096 Jul 18 12:53 test1 5drwx--x--x 2 root root 4096 Jul 18 12:54 test2 上面的权限部分，如果没有加上 -m 来强制配置属性，系统会使用默认属性。\n如果我们使用 -m ，如上例我们给予 -m 711 来给予新的目录 drwx\u0026ndash;x\u0026ndash;x 的权限。\nrmdir 语法：\n1 rmdir [-p] 目录名称 选项与参数：\n **-p ：**从该目录起，一次删除多级空目录  删除 runoob 目录\n1[root@www tmp]# rmdir runoob/ 将 mkdir 实例中创建的目录(/tmp 底下)删除掉！\n1[root@www tmp]# ls -l \u0026lt;==看看有多少目录存在？ 2drwxr-xr-x 3 root root 4096 Jul 18 12:50 test 3drwxr-xr-x 3 root root 4096 Jul 18 12:53 test1 4drwx--x--x 2 root root 4096 Jul 18 12:54 test2 5[root@www tmp]# rmdir test \u0026lt;==可直接删除掉，没问题 6[root@www tmp]# rmdir test1 \u0026lt;==因为尚有内容，所以无法删除！ 7rmdir: `test1\u0026#39;: Directory not empty 8[root@www tmp]# rmdir -p test1/test2/test3/test4 9[root@www tmp]# ls -l \u0026lt;==您看看，底下的输出中test与test1不见了！ 10drwx--x--x 2 root root 4096 Jul 18 12:54 test2 利用 -p 这个选项，立刻就可以将 test1/test2/test3/test4 一次删除。\n不过要注意的是，这个 rmdir 仅能删除空的目录，你可以使用 rm 命令来删除非空目录。\ncp 语法:\n1[root@www ~]# cp [-adfilprsu] 来源档(source) 目标档(destination) 2[root@www ~]# cp [options] source1 source2 source3 .... directory 选项与参数：\n **-a：**相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用) **-d：**若来源档为链接档的属性(link file)，则复制链接档属性而非文件本身； **-f：**为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次； **-i：**若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用) **-l：**进行硬式链接(hard link)的链接档创建，而非复制文件本身； **-p：**连同文件的属性一起复制过去，而非使用默认属性(备份常用)； **-r：**递归持续复制，用於目录的复制行为；(常用) **-s：**复制成为符号链接档 (symbolic link)，亦即『捷径』文件； **-u：**若 destination 比 source 旧才升级 destination ！  用 root 身份，将 root 目录下的 .bashrc 复制到 /tmp 下，并命名为 bashrc\n1[root@www ~]# cp ~/.bashrc /tmp/bashrc 2[root@www ~]# cp -i ~/.bashrc /tmp/bashrc 3cp: overwrite `/tmp/bashrc\u0026#39;? n \u0026lt;==n不覆盖，y为覆盖 rm 语法：\n1 rm [-fir] 文件或目录 选项与参数：\n -f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息； -i ：互动模式，在删除前会询问使用者是否动作 -r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！  mv 语法：\n1[root@www ~]# mv [-fiu] source destination 2[root@www ~]# mv [options] source1 source2 source3 .... directory 选项与参数：\n -f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖； -i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！ -u ：若目标文件已经存在，且 source 比较新，才会升级 (update)  Linux文件内容查看  cat 由第一行开始显示文件内容 tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！ nl 显示的时候，顺道输出行号！ more 一页一页的显示文件内容 less 与 more 类似，但是比 more 更好的是，他可以往前翻页！ head 只看头几行 tail 只看尾巴几行  cat 语法：\n1cat [-AbEnTv] 选项与参数：\n -A ：相当於 -vET 的整合选项，可列出一些特殊字符而不是空白而已； -b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！ -E ：将结尾的断行字节 $ 显示出来； -n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同； -T ：将 [tab] 按键以 ^I 显示出来； -v ：列出一些看不出来的特殊字符  tac tac与cat命令刚好相反，文件内容从最后一行开始显示，可以看出 tac 是 cat 的倒着写！\nnl 显示行号\n语法：\n1nl [-bnw] 文件 选项与参数：\n -b ：指定行号指定的方式，主要有两种： -b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)； -b t ：如果有空行，空的那一行不要列出行号(默认值)； -n ：列出行号表示的方法，主要有三种： -n ln ：行号在荧幕的最左方显示； -n rn ：行号在自己栏位的最右方显示，且不加 0 ； -n rz ：行号在自己栏位的最右方显示，且加 0 ； -w ：行号栏位的占用的位数。  more 一页一页翻动\n在 more 这个程序的运行过程中，你有几个按键可以按的：\n 空白键 (space)：代表向下翻一页； Enter ：代表向下翻『一行』； /字串 ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字； :f ：立刻显示出档名以及目前显示的行数； q ：代表立刻离开 more ，不再显示该文件内容。 b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。  less less运行时可以输入的命令有：\n 空白键 ：向下翻动一页； [pagedown]：向下翻动一页； [pageup] ：向上翻动一页； /字串 ：向下搜寻『字串』的功能； ?字串 ：向上搜寻『字串』的功能； n ：重复前一个搜寻 (与 / 或 ? 有关！) N ：反向的重复前一个搜寻 (与 / 或 ? 有关！) q ：离开 less 这个程序；  head 语法：\n1head [-n number] 文件 选项与参数：\n -n ：后面接数字，代表显示几行的意思  1[root@www ~]# head /etc/man.config 默认的情况中，显示前面 10 行！若要显示前 20 行，就得要这样：\n1[root@www ~]# head -n 20 /etc/man.config tail 取出文件后面几行\n语法：\n1tail [-n number] 文件 选项与参数：\n -n ：后面接数字，代表显示几行的意思 -f ：表示持续侦测后面所接的档名，要等到按下[ctrl]-c才会结束tail的侦测  Linux链接概念 Linux 链接分两种，一种被称为硬链接（Hard Link），另一种被称为符号链接（Symbolic Link）。默认情况下，ln 命令产生硬链接。\n硬连接 硬连接指通过索引节点来进行连接。在 Linux 的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在 Linux 中，多个文件名指向同一索引节点是存在的。比如：A 是 B 的硬链接（A 和 B 都是文件名），则 A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号相同，即一个 inode 节点对应两个不同的文件名，两个文件名指向同一个文件，A 和 B 对文件系统来说是完全平等的。删除其中任何一个都不会影响另外一个的访问。\n硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，**只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。**也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。\n软连接 另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有类似于 Windows 的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。比如：A 是 B 的软链接（A 和 B 都是文件名），A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号不相同，A 和 B 指向的是两个不同的 inode，继而指向两块不同的数据块。但是 A 的数据块中存放的只是 B 的路径名（可以根据这个找到 B 的目录项）。A 和 B 之间是“主从”关系，如果 B 被删除了，A 仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。\n1[oracle@Linux]$ touch f1 #创建一个测试文件f1 2[oracle@Linux]$ ln f1 f2 #创建f1的一个硬连接文件f2 3[oracle@Linux]$ ln -s f1 f3 #创建f1的一个符号连接文件f3 4[oracle@Linux]$ ls -li # -i参数显示文件的inode节点信息 5total 0 69797648 -rw-r--r-- 2 oracle oinstall 0 Apr 21 08:11 f1 79797648 -rw-r--r-- 2 oracle oinstall 0 Apr 21 08:11 f2 89797649 lrwxrwxrwx 1 oracle oinstall 2 Apr 21 08:11 f3 -\u0026gt; f1 从上面的结果中可以看出，硬连接文件 f2 与原文件 f1 的 inode 节点相同，均为 9797648，然而符号连接文件的 inode 节点不同。\n1[oracle@Linux]$ echo \u0026#34;I am f1 file\u0026#34; \u0026gt;\u0026gt;f1 2[oracle@Linux]$ cat f1 3I am f1 file 4[oracle@Linux]$ cat f2 5I am f1 file 6[oracle@Linux]$ cat f3 7I am f1 file 8[oracle@Linux]$ rm -f f1 9[oracle@Linux]$ cat f2 10I am f1 file 11[oracle@Linux]$ cat f3 12cat: f3: No such file or directory 通过上面的测试可以看出：当删除原始文件 f1 后，硬连接 f2 不受影响，但是符号连接 f3 文件无效\n依此您可以做一些相关的测试，可以得到以下全部结论：\n 1).删除符号连接f3,对f1,f2无影响； 2).删除硬连接f2，对f1,f3也无影响； 3).删除原文件f1，对硬连接f2没有影响，导致符号连接f3失效； 4).同时删除原文件f1,硬连接f2，整个文件会真正的被删除。  六、Linux用户和用户组管理 Linux系统用户账号的管理 添加账号 1 参数说明：\n  选项:\n -c comment 指定一段注释性描述。 -d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。 -g 用户组 指定用户所属的用户组。 -G 用户组，用户组 指定用户所属的附加组。 -s Shell文件 指定用户的登录Shell。 -u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。    用户名:\n指定新账号的登录名。\n  1# useradd -s /bin/sh -g group –G adm,root gem 此命令新建了一个用户gem，该用户的登录Shell是 /bin/sh，它属于group用户组，同时又属于adm和root用户组，其中group用户组是其主组。\n这里可能新建组：#groupadd group及groupadd adm\n增加用户账号就是在/etc/passwd文件中为新用户增加一条记录，同时更新其他系统文件如/etc/shadow, /etc/group等。\nLinux提供了集成的系统管理工具userconf，它可以用来对用户账号进行统一管理。\n删除帐号 删除用户账号就是要将/etc/passwd等系统文件中的该用户记录删除，必要时还删除用户的主目录。\n删除一个已有的用户账号使用userdel命令，其格式如下：\n1userdel 选项 用户名 常用的选项是 -r，它的作用是把用户的主目录一起删除。\n例如：\n1# userdel -r sam 此命令删除用户sam在系统文件中（主要是/etc/passwd, /etc/shadow, /etc/group等）的记录，同时删除用户的主目录。\n修改帐号 1usermod 选项 用户名 常用的选项包括-c, -d, -m, -g, -G, -s, -u以及-o等，这些选项的意义与useradd命令中的选项一样，可以为用户指定新的资源值。\n另外，有些系统可以使用选项：-l 新用户名\n这个选项指定一个新的账号，即将原来的用户名改为新的用户名。\n1# usermod -s /bin/ksh -d /home/z –g developer sam 此命令将用户sam的登录Shell修改为ksh，主目录改为/home/z，用户组改为developer。\n用户口令的管理 用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。\n指定和修改用户口令的Shell命令是passwd。超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令。命令的格式为：\n1passwd 选项 用户名 可使用的选项：\n -l 锁定口令，即禁用账号。 -u 口令解锁。 -d 使账号无口令。 -f 强迫用户下次登录时修改口令。  如果默认用户名，则修改当前用户的口令。\nLinux系统用户组的管理 不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。\n用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的更新。\n增加一个新的用户组 1groupadd 选项 用户组 可以使用的选项有：\n -g GID 指定新用户组的组标识号（GID）。 -o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。  删除一个已有的用户组 1groupdel 用户组 修改用户组的属性 1groupmod 选项 用户组 常用的选项有：\n -g GID 为用户组指定新的组标识号。 -o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。 -n新用户组 将用户组的名字改为新名字  切换到其他用户组 用户可以在登录后，使用命令newgrp切换到其他用户组，这个命令的参数就是目的用户组。例如：\n1$ newgrp root 这条命令将当前用户切换到root用户组，前提条件是root用户组确实是该用户的主组或附加组。类似于用户账号的管理，用户组的管理也可以通过集成的系统管理工具来完成。\n与用户账号有关的系统文件 完成用户管理的工作有许多种方法，但是每一种方法实际上都是对有关的系统文件进行修改。\n与用户和用户组相关的信息都存放在一些系统文件中，这些文件包括/etc/passwd, /etc/shadow, /etc/group等。\n/etc/passwd Linux系统中的每个用户都在/etc/passwd文件中有一个对应的记录行，它记录了这个用户的一些基本属性。\n这个文件对所有用户都是可读的。\n1root❌0:0:Superuser:/: 2daemon❌1:1:System daemons:/etc: 3bin❌2:2:Owner of system commands:/bin: 4sys❌3:3:Owner of system files:/usr/sys: 5adm❌4:4:System accounting:/usr/adm: 6uucp❌5:5:UUCP administrator:/usr/lib/uucp: 7auth❌7:21:Authentication administrator:/tcb/files/auth: 8cron❌9:16:Cron daemon:/usr/spool/cron: 9listen❌37:4:Network daemon:/usr/net/nls: 10lp❌71:18:Printer administrator:/usr/spool/lp: 11sam❌200:50:Sam san:/home/sam:/bin/sh 从上面的例子我们可以看到，/etc/passwd中一行记录对应着一个用户，每行记录又被冒号(:)分隔为7个字段，其格式和具体含义如下：\n1用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell 系统中有一类用户称为伪用户（pseudo users）。\n这些用户在/etc/passwd文件中也占有一条记录，但是不能登录，因为它们的登录Shell为空。它们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求。\n常见的伪用户如下所示：\n1伪 用 户 含 义 2bin 拥有可执行的用户命令文件 3sys 拥有系统文件 4adm 拥有帐户文件 5uucp UUCP使用 6lp lp或lpd子系统使用 7nobody NFS使用 /etc/shadow 由于/etc/passwd文件是所有用户都可读的，如果用户的密码太简单或规律比较明显的话，一台普通的计算机就能够很容易地将它破解，因此对安全性要求较高的Linux系统都把加密后的口令字分离出来，单独存放在一个文件中，这个文件是/etc/shadow文件。 有超级用户才拥有该文件读权限，这就保证了用户密码的安全性。\n它的文件格式与/etc/passwd类似，由若干个字段组成，字段之间用\u0026quot;:\u0026ldquo;隔开。这些字段是：\n1登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志  \u0026ldquo;登录名\u0026quot;是与/etc/passwd文件中的登录名相一致的用户账号 \u0026ldquo;口令\u0026quot;字段存放的是加密后的用户口令字，长度为13个字符。如果为空，则对应用户没有口令，登录时不需要口令；如果含有不属于集合 { ./0-9A-Za-z }中的字符，则对应的用户不能登录。 \u0026ldquo;最后一次修改时间\u0026quot;表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。例如在SCO Linux 中，这个时间起点是1970年1月1日。 \u0026ldquo;最小时间间隔\u0026quot;指的是两次修改口令之间所需的最小天数。 \u0026ldquo;最大时间间隔\u0026quot;指的是口令保持有效的最大天数。 \u0026ldquo;警告时间\u0026quot;字段表示的是从系统开始警告用户到用户密码正式失效之间的天数。 \u0026ldquo;不活动时间\u0026quot;表示的是用户没有登录活动但账号仍能保持有效的最大天数。 \u0026ldquo;失效时间\u0026quot;字段给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了。  /etc/group 当一个用户同时是多个组中的成员时，在/etc/passwd文件中记录的是用户所属的主组，也就是登录时所属的默认组，而其他组称为附加组。\n用户要访问属于附加组的文件时，必须首先使用newgrp命令使自己成为所要访问的组中的成员。\n用户组的所有信息都存放在/etc/group文件中。此文件的格式也类似于/etc/passwd文件，由冒号(:)隔开若干个字段，这些字段有：\n1组名:口令:组标识号:组内用户列表  \u0026ldquo;组名\u0026quot;是用户组的名称，由字母或数字构成。与/etc/passwd中的登录名一样，组名不应重复。 \u0026ldquo;口令\u0026quot;字段存放的是用户组加密后的口令字。一般Linux 系统的用户组都没有口令，即这个字段一般为空，或者是*。 \u0026ldquo;组标识号\u0026quot;与用户标识号类似，也是一个整数，被系统内部用来标识组。 \u0026ldquo;组内用户列表\u0026quot;是属于这个组的所有用户的列表，不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组。  七、磁盘管理 df 检查文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。\n1df [-ahikHTm] [目录或文件名] 选项与参数：\n -h：以人类可读的方式显示输出结果（例如，使用 KB、MB、GB 等单位）。 -T：显示文件系统的类型。 -t \u0026lt;文件系统类型\u0026gt;：只显示指定类型的文件系统。 -i：显示 inode 使用情况。 -H：该参数是 -h 的变体，但是使用 1000 字节作为基本单位而不是 1024 字节。这意味着它会以 SI（国际单位制）单位（例如 MB、GB）而不是二进制单位（例如 MiB、GiB）来显示磁盘使用情况。 -k：这个选项会以 KB 作为单位显示磁盘空间使用情况。 -a：该参数将显示所有的文件系统，包括虚拟文件系统，例如 proc、sysfs 等。如果没有使用该选项，默认情况下，df 命令不会显示虚拟文件系统。  du Linux du 命令也是查看使用空间的，但是与 df 命令不同的是 Linux du 命令是对文件和目录磁盘使用的空间的查看\n语法：\n1du [-ahskm] 文件或目录名称 选项与参数：\n -a ：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。 -h ：以人们较易读的容量格式 (G/M) 显示； -s ：仅显示指定目录或文件的总大小，而不显示其子目录的大小。 -S ：包括子目录下的总计，与 -s 有点差别。 -k ：以 KBytes 列出容量显示； -m ：以 MBytes 列出容量显示；  fdisk fdisk 是 Linux 的磁盘分区表操作工具。\n语法：\n1fdisk [-l] 装置名称 选项与参数：\n -l ：输出后面接的装置所有的分区内容。若仅有 fdisk -l 时， 则系统将会把整个系统内能够搜寻到的装置的分区均列出来。  列出所有分区信息\n1[root@AY120919111755c246621 tmp]# fdisk -l 出你系统中的根目录所在磁盘，并查阅该硬盘内的相关信息\n1[root@www ~]# df / \u0026lt;==注意：重点在找出磁盘文件名而已 2Filesystem 1K-blocks Used Available Use% Mounted on 3/dev/hdc2 9920624 3823168 5585388 41% / 4 5[root@www ~]# fdisk /dev/hdc \u0026lt;==仔细看，不要加上数字喔！ 6The number of cylinders for this disk is set to 5005. 7There is nothing wrong with that, but this is larger than 1024, 8and could in certain setups cause problems with: 91) software that runs at boot time (e.g., old versions of LILO) 102) booting and partitioning software from other OSs 11 (e.g., DOS FDISK, OS/2 FDISK) 12 13Command (m for help): \u0026lt;==等待你的输入！ 输入 m 后，就会看到底下这些命令介绍\n1Command (m for help): m \u0026lt;== 输入 m 后，就会看到底下这些命令介绍 2Command action 3 a toggle a bootable flag 4 b edit bsd disklabel 5 c toggle the dos compatibility flag 6 d delete a partition \u0026lt;==删除一个partition 7 l list known partition types 8 m print this menu 9 n add a new partition \u0026lt;==新增一个partition 10 o create a new empty DOS partition table 11 p print the partition table \u0026lt;==在屏幕上显示分割表 12 q quit without saving changes \u0026lt;==不储存离开fdisk程序 13 s create a new empty Sun disklabel 14 t change a partition\u0026#39;s system id 15 u change display/entry units 16 v verify the partition table 17 w write table to disk and exit \u0026lt;==将刚刚的动作写入分割表 18 x extra functionality (experts only) 离开 fdisk 时按下 q，那么所有的动作都不会生效！相反的， 按下w就是动作生效的意思。\n磁盘格式化 磁盘分割完毕后自然就是要进行文件系统的格式化，格式化的命令非常的简单，使用 mkfs（make filesystem） 命令。\n语法：\n1mkfs [-t 文件系统格式] 装置文件名 选项与参数：\n -t ：可以接文件系统格式，例如 ext3, ext2, vfat 等(系统有支持才会生效)  看 mkfs 支持的文件格式\n1[root@www ~]# mkfs[tab][tab] 2mkfs mkfs.cramfs mkfs.ext2 mkfs.ext3 mkfs.msdos mkfs.vfat 将分区 /dev/hdc6（可指定你自己的分区） 格式化为 ext3 文件系统：\n1[root@www ~]# mkfs -t ext3 /dev/hdc6 2mke2fs 1.39 (29-May-2006) 3Filesystem label= \u0026lt;==这里指的是分割槽的名称(label) 4OS type: Linux 5Block size=4096 (log=2) \u0026lt;==block 的大小配置为 4K 6Fragment size=4096 (log=2) 7251392 inodes, 502023 blocks \u0026lt;==由此配置决定的inode/block数量 825101 blocks (5.00%) reserved for the super user 9First data block=0 10Maximum filesystem blocks=515899392 1116 block groups 1232768 blocks per group, 32768 fragments per group 1315712 inodes per group 14Superblock backups stored on blocks: 15 32768, 98304, 163840, 229376, 294912 16 17Writing inode tables: done 18Creating journal (8192 blocks): done \u0026lt;==有日志记录 19Writing superblocks and filesystem accounting information: done 20 21This filesystem will be automatically checked every 34 mounts or 22180 days, whichever comes first. Use tune2fs -c or -i to override. 23# 这样就创建起来我们所需要的 Ext3 文件系统了！简单明了！ 磁盘检验 fsck（file system check）用来检查和维护不一致的文件系统。\n若系统掉电或磁盘发生问题，可利用fsck命令对文件系统进行检查。\n语法：\n1fsck [-t 文件系统] [-ACay] 装置名称 选项与参数：\n -t : 给定档案系统的型式，若在 /etc/fstab 中已有定义或 kernel 本身已支援的则不需加上此参数 -s : 依序一个一个地执行 fsck 的指令来检查 -A : 对/etc/fstab 中所有列出来的 分区（partition）做检查 -C : 显示完整的检查进度 -d : 打印出 e2fsck 的 debug 结果 -p : 同时有 -A 条件时，同时有多个 fsck 的检查一起执行 -R : 同时有 -A 条件时，省略 / 不检查 -V : 详细显示模式 -a : 如果检查有错则自动修复 -r : 如果检查有错则由使用者回答是否修复 -y : 选项指定检测每个文件是自动输入yes，在不确定那些是不正常的时候，可以执行 # fsck -y 全部检查修复。  查看系统有多少文件系统支持的 fsck 命令：\n1[root@www ~]# fsck[tab][tab] 2fsck fsck.cramfs fsck.ext2 fsck.ext3 fsck.msdos fsck.vfat 强制检测 /dev/hdc6 分区:\n1[root@www ~]# fsck -C -f -t ext3 /dev/hdc6 2fsck 1.39 (29-May-2006) 3e2fsck 1.39 (29-May-2006) 4Pass 1: Checking inodes, blocks, and sizes 5Pass 2: Checking directory structure 6Pass 3: Checking directory connectivity 7Pass 4: Checking reference counts 8Pass 5: Checking group summary information 9vbird_logical: 11/251968 files (9.1% non-contiguous), 36926/1004046 blocks 如果没有加上 -f 的选项，则由于这个文件系统不曾出现问题，检查的经过非常快速！若加上 -f 强制检查，才会一项一项的显示过程。\n磁盘挂载与卸除 Linux 的磁盘挂载使用 mount 命令，卸载使用 umount 命令。\n磁盘挂载语法：\n1mount [-t 文件系统] [-L Label名] [-o 额外选项] [-n] 装置文件名 挂载点 用默认的方式，将刚刚创建的 /dev/hdc6 挂载到 /mnt/hdc6 上面！\n1[root@www ~]# mkdir /mnt/hdc6 2[root@www ~]# mount /dev/hdc6 /mnt/hdc6 磁盘卸载命令 umount 语法：\n1umount [-fn] 装置文件名或挂载点 选项与参数：\n -f ：强制卸除！可用在类似网络文件系统 (NFS) 无法读取到的情况下； -n ：不升级 /etc/mtab 情况下卸除。  卸载/dev/hdc6\n1[root@www ~]# umount /dev/hdc6 八、vi/vim 基本上 vi/vim 共分为三种模式，命令模式（Command Mode）、输入模式（Insert Mode）和命令行模式（Command-Line Mode）。\n第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等    移动光标的方法      h 或 向左箭头键(←) 光标向左移动一个字符   j 或 向下箭头键(↓) 光标向下移动一个字符   k 或 向上箭头键(↑) 光标向上移动一个字符   l 或 向右箭头键(→) 光标向右移动一个字符   如果想要进行多次移动的话，例如向下移动 30 行，可以使用 \u0026ldquo;30j\u0026rdquo; 或 \u0026ldquo;30↓\u0026rdquo; 的组合按键    [Ctrl] + [f] 屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)   [Ctrl] + [b] 屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)   [Ctrl] + [d] 屏幕『向下』移动半页   [Ctrl] + [u] 屏幕『向上』移动半页   + 光标移动到非空格符的下一行   - 光标移动到非空格符的上一行   n 那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20 则光标会向后面移动 20 个字符距离。   0 或功能键[Home] 这是数字『 0 』：移动到这一行的最前面字符处 (常用)   $ 或功能键[End] 移动到这一行的最后面字符处(常用)   H 光标移动到这个屏幕的最上方那一行的第一个字符   M 光标移动到这个屏幕的中央那一行的第一个字符   L 光标移动到这个屏幕的最下方那一行的第一个字符   G 移动到这个档案的最后一行(常用)   nG n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)   gg 移动到这个档案的第一行，相当于 1G 啊！ (常用)   n n 为数字。光标向下移动 n 行(常用)   搜索替换    /word 向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！ (常用)   ?word 向光标之上寻找一个字符串名称为 word 的字符串。   n 这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！   N 这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。   使用 /word 配合 n 及 N 是非常有帮助的！可以让你重复的找到一些你搜寻的关键词！    :n1,n2s/word1/word2/g n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则： 『:100,200s/vbird/VBIRD/g』。(常用)   :1,$s/word1/word2/g 或 :%s/word1/word2/g 从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用)   :1,$s/word1/word2/gc 或 :%s/word1/word2/gc 从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用)   删除、复制与贴上    x, X 在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)   nx n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。   dd 剪切游标所在的那一整行(常用)，用 p/P 可以粘贴。   ndd n 为数字。剪切光标所在的向下 n 行，例如 20dd 则是剪切 20 行(常用)，用 p/P 可以粘贴。   d1G 删除光标所在到第一行的所有数据   dG 删除光标所在到最后一行的所有数据   d$ 删除游标所在处，到该行的最后一个字符   d0 那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符   yy 复制游标所在的那一行(常用)   nyy n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)   y1G 复制游标所在行到第一行的所有数据   yG 复制游标所在行到最后一行的所有数据   y0 复制光标所在的那个字符到该行行首的所有数据   y$ 复制光标所在的那个字符到该行行尾的所有数据   p, P p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用)   J 将光标所在行与下一行的数据结合成同一行   c 重复删除多个数据，例如向下删除 10 行，[ 10cj ]   u 复原前一个动作。(常用)   [Ctrl]+r 重做上一个动作。(常用)   这个 u 与 [Ctrl]+r 是很常用的指令！一个是复原，另一个则是重做一次～ 利用这两个功能按键，你的编辑，嘿嘿！很快乐的啦！    . 不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用)    第二部分：一般模式切换到编辑模式的可用的按钮说明    进入输入或取代的编辑模式      i, I 进入输入模式(Insert mode)： i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。 (常用)   a, A 进入输入模式(Insert mode)： a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用)   o, O 进入输入模式(Insert mode)： 这是英文字母 o 的大小写。o 为在目前光标所在的下一行处输入新的一行； O 为在目前光标所在的上一行处输入新的一行！(常用)   r, R 进入取代模式(Replace mode)： r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)   上面这些按键中，在 vi 画面的左下角处会出现『\u0026ndash;INSERT\u0026ndash;』或『\u0026ndash;REPLACE\u0026ndash;』的字样。 由名称就知道该动作了吧！！特别注意的是，我们上面也提过了，你想要在档案里面输入字符时， 一定要在左下角处看到 INSERT 或 REPLACE 才能输入喔！    [Esc] 退出编辑模式，回到一般模式中(常用)    第三部分：一般模式切换到指令行模式的可用的按钮说明    指令行的储存、离开等指令      :w 将编辑的数据写入硬盘档案中(常用)   :w! 若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！   :q 离开 vi (常用)   :q! 若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。   注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～    :wq 储存后离开，若为 :wq! 则为强制储存后离开 (常用)   ZZ 这是大写的 Z 喔！如果修改过，保存当前文件，然后退出！效果等同于(保存并退出)   ZQ 不保存，强制退出。效果等同于 :q!。   :w [filename] 将编辑的数据储存成另一个档案（类似另存新档）   :r [filename] 在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面   :n1,n2 w [filename] 将 n1 到 n2 的内容储存成 filename 这个档案。   :! command 暂时离开 vi 到指令行模式下执行 command 的显示结果！例如 『:! ls /home』即可在 vi 当中察看 /home 底下以 ls 输出的档案信息！   vim 环境的变更    :set nu 显示行号，设定之后，会在每一行的前缀显示该行的行号   :set nonu 与 set nu 相反，为取消行号！   ","date":"2024-11-11","permalink":"/posts/tech/media-runnoob-linux/","series":["媒体开发"],"tags":["","",""],"title":"菜鸟教程Linux教程"},{"categories":["计算机"],"content":"快速回顾一下, 简单的就不记了.\n1.常量 作用：用于记录程序中不可更改的数据\nC++定义常量两种方式\n  #define 宏常量： #define 常量名 常量值\n 通常在文件上方定义，表示一个常量    const修饰的变量 const 数据类型 常量名 = 常量值\n 通常在变量定义前加关键字const，修饰该变量为常量，不可修改    1//1、宏常量 2#define day 7 3 4int main() { 5 6\tcout \u0026lt;\u0026lt; \u0026#34;一周里总共有 \u0026#34; \u0026lt;\u0026lt; day \u0026lt;\u0026lt; \u0026#34; 天\u0026#34; \u0026lt;\u0026lt; endl; 7\t//day = 8; //报错，宏常量不可以修改 8 9\t//2、const修饰变量 10\tconst int month = 12; 11\tcout \u0026lt;\u0026lt; \u0026#34;一年里总共有 \u0026#34; \u0026lt;\u0026lt; month \u0026lt;\u0026lt; \u0026#34; 个月份\u0026#34; \u0026lt;\u0026lt; endl; 12\t//month = 24; //报错，常量是不可以修改的 13\t14\t15\tsystem(\u0026#34;pause\u0026#34;); 16 17\treturn 0; 18} 2.数据类型 整型 C++中能够表示整型的类型有以下几种方式，区别在于所占内存空间不同：\n   数据类型 占用空间 取值范围     short(短整型) 2字节 (-2^15 ~ 2^15-1)   int(整型) 4字节 (-2^31 ~ 2^31-1)   long(长整形) Windows为4字节，Linux为4字节(32位)，8字节(64位) (-2^31 ~ 2^31-1)   long long(长长整形) 8字节 (-2^63 ~ 2^63-1)    sizeof关键字: 利用sizeof关键字可以统计数据类型所占内存大小\nsizeof( 数据类型 / 变量)\n浮点型 浮点型变量分为两种：\n 单精度float 双精度double  两者的区别在于表示的有效数字范围不同。\n   数据类型 占用空间 有效数字范围     float 4字节 7位有效数字   double 8字节 15～16位有效数字    字符型 字符型变量用于显示单个字符\nchar ch = 'a';\n 注意1：在显示字符型变量时，用单引号将字符括起来，不要用双引号\n  注意2：单引号内只能有一个字符，不可以是字符串\n  C和C++中字符型变量只占用1个字节。 字符型变量并不是把字符本身放到内存中存储，而是将对应的ASCII编码放入到存储单元  字符串 两种风格\n C风格字符串： char 变量名[] = \u0026quot;字符串值\u0026quot;   注意：C风格的字符串要用双引号括起来\n  C++风格字符串： string 变量名 = \u0026quot;字符串值\u0026quot;   注意：C++风格字符串，需要加入头文件==#include\u0026lt;string\u0026gt;==\n 布尔值 bool类型只有两个值：\n true \u0026mdash; 真（本质是1） false \u0026mdash; 假（本质是0）  bool类型占==1个字节==大小\n数据的输入: cin \u0026gt;\u0026gt; 变量 \n3.运算符 算术运算符    运算符 术语 示例 结果     + 正号 +3 3   - 负号 -3 -3   + 加 10 + 5 15   - 减 10 - 5 5   * 乘 10 * 5 50   / 除 10 / 5 2   % 取模(取余) 10 % 3 1   ++ 前置递增 a=2; b=++a; a=3; b=3;   ++ 后置递增 a=2; b=a++; a=3; b=2;   \u0026ndash; 前置递减 a=2; b=\u0026ndash;a; a=1; b=1;   \u0026ndash; 后置递减 a=2; b=a\u0026ndash;; a=1; b=2;    赋值运算符    运算符 术语 示例 结果     = 赋值 a=2; b=3; a=2; b=3;   += 加等于 a=0; a+=2; a=2;   -= 减等于 a=5; a-=3; a=2;   *= 乘等于 a=2; a*=2; a=4;   /= 除等于 a=4; a/=2; a=2;   %= 模等于 a=3; a%2; a=1;    比较运算符    运算符 术语 示例 结果     == 相等于 4 == 3 0   != 不等于 4 != 3 1   \u0026lt; 小于 4 \u0026lt; 3 0   \u0026gt; 大于 4 \u0026gt; 3 1   \u0026lt;= 小于等于 4 \u0026lt;= 3 0   \u0026gt;= 大于等于 4 \u0026gt;= 1 1    逻辑运算符    运算符 术语 示例 结果     ! 非 !a 如果a为假，则!a为真； 如果a为真，则!a为假。   \u0026amp;\u0026amp; 与 a \u0026amp;\u0026amp; b 如果a和b都为真，则结果为真，否则为假。   || 或 a || b 如果a和b有一个为真，则结果为真，二者都为假时，结果为假。    4.程序流程结构 if 三元运算符 switch 语法：\n1switch(表达式) 2 3{ 4 5\tcase 结果1：执行语句;break; 6 7\tcase 结果2：执行语句;break; 8 9\t... 10 11\tdefault:执行语句;break; 12 13} 14 示例\n1int main() { 2 3\t//请给电影评分 4\t//10 ~ 9 经典 5\t// 8 ~ 7 非常好 6\t// 6 ~ 5 一般 7\t// 5分以下 烂片 8 9\tint score = 0; 10\tcout \u0026lt;\u0026lt; \u0026#34;请给电影打分\u0026#34; \u0026lt;\u0026lt; endl; 11\tcin \u0026gt;\u0026gt; score; 12 13\tswitch (score) 14\t{ 15\tcase 10: 16\tcase 9: 17\tcout \u0026lt;\u0026lt; \u0026#34;经典\u0026#34; \u0026lt;\u0026lt; endl; 18\tbreak; 19\tcase 8: 20\tcout \u0026lt;\u0026lt; \u0026#34;非常好\u0026#34; \u0026lt;\u0026lt; endl; 21\tbreak; 22\tcase 7: 23\tcase 6: 24\tcout \u0026lt;\u0026lt; \u0026#34;一般\u0026#34; \u0026lt;\u0026lt; endl; 25\tbreak; 26\tdefault: 27\tcout \u0026lt;\u0026lt; \u0026#34;烂片\u0026#34; \u0026lt;\u0026lt; endl; 28\tbreak; 29\t} 30 31\tsystem(\u0026#34;pause\u0026#34;); 32 33\treturn 0; 34}  注意1：switch语句中表达式类型只能是整型或者字符型\n  注意2：case里如果没有break，那么程序会一直向下执行\n  总结：与if语句比，对于多条件判断时，switch的结构清晰，执行效率高，缺点是switch不可以判断区间\n while do\u0026hellip;while for 跳转语句 break 作用: 用于跳出==选择结构==或者==循环结构==\nbreak使用的时机：\n 出现在switch条件语句中，作用是终止case并跳出switch 出现在循环语句中，作用是跳出当前的循环语句 出现在嵌套循环中，跳出最近的内层循环语句  continue **作用：**在==循环语句==中，跳过本次循环中余下尚未执行的语句，继续执行下一次循环\ngoto **作用：**可以无条件跳转语句\n语法： goto 标记;\n**解释：**如果标记的名称存在，执行到goto语句时，会跳转到标记的位置\n示例：\n1int main() { 2 3\tcout \u0026lt;\u0026lt; \u0026#34;1\u0026#34; \u0026lt;\u0026lt; endl; 4 5\tgoto FLAG; 6 7\tcout \u0026lt;\u0026lt; \u0026#34;2\u0026#34; \u0026lt;\u0026lt; endl; 8\tcout \u0026lt;\u0026lt; \u0026#34;3\u0026#34; \u0026lt;\u0026lt; endl; 9\tcout \u0026lt;\u0026lt; \u0026#34;4\u0026#34; \u0026lt;\u0026lt; endl; 10 11\tFLAG: 12 13\tcout \u0026lt;\u0026lt; \u0026#34;5\u0026#34; \u0026lt;\u0026lt; endl; 14\t15\tsystem(\u0026#34;pause\u0026#34;); 16 17\treturn 0; 18}  注意：在程序中不建议使用goto语句，以免造成程序流程混乱\n 5.数组 一维数组 一维数组定义的三种方式：\n 数据类型 数组名[ 数组长度 ]; 数据类型 数组名[ 数组长度 ] = { 值1，值2 ...}; (如果{}内不足10个数据，剩余数据用0补全) 数据类型 数组名[ ] = { 值1，值2 ...};  一维数组名称的用途：\n 可以统计整个数组在内存中的长度 可以获取数组在内存中的首地址  示例：\n1int main() { 2 3\t//数组名用途 4\t//1、可以获取整个数组占用内存空间大小 5\tint arr[10] = { 1,2,3,4,5,6,7,8,9,10 }; 6 7\tcout \u0026lt;\u0026lt; \u0026#34;整个数组所占内存空间为： \u0026#34; \u0026lt;\u0026lt; sizeof(arr) \u0026lt;\u0026lt; endl; 8\tcout \u0026lt;\u0026lt; \u0026#34;每个元素所占内存空间为： \u0026#34; \u0026lt;\u0026lt; sizeof(arr[0]) \u0026lt;\u0026lt; endl; 9\tcout \u0026lt;\u0026lt; \u0026#34;数组的元素个数为： \u0026#34; \u0026lt;\u0026lt; sizeof(arr) / sizeof(arr[0]) \u0026lt;\u0026lt; endl; 10 11\t//2、可以通过数组名获取到数组首地址 12\tcout \u0026lt;\u0026lt; \u0026#34;数组首地址为： \u0026#34; \u0026lt;\u0026lt; (int)arr \u0026lt;\u0026lt; endl; 13\tcout \u0026lt;\u0026lt; \u0026#34;数组中第一个元素地址为： \u0026#34; \u0026lt;\u0026lt; (int)\u0026amp;arr[0] \u0026lt;\u0026lt; endl; 14\tcout \u0026lt;\u0026lt; \u0026#34;数组中第二个元素地址为： \u0026#34; \u0026lt;\u0026lt; (int)\u0026amp;arr[1] \u0026lt;\u0026lt; endl; 15 16\t//arr = 100; 错误，数组名是常量，因此不可以赋值 17 18 19\tsystem(\u0026#34;pause\u0026#34;); 20 21\treturn 0; 22}  注意：数组名是常量，不可以赋值\n  总结1：直接打印数组名，可以查看数组所占内存的首地址\n  总结2：对数组名进行sizeof，可以获取整个数组占内存空间的大小\n 二维数组 二维数组定义的四种方式：\n 数据类型 数组名[ 行数 ][ 列数 ]; 数据类型 数组名[ 行数 ][ 列数 ] = { {数据1，数据2 } ，{数据3，数据4 } }; 数据类型 数组名[ 行数 ][ 列数 ] = { 数据1，数据2，数据3，数据4};  数据类型 数组名[ ][ 列数 ] = { 数据1，数据2，数据3，数据4};  二维数组数组名:\n 查看二维数组所占内存空间 获取二维数组首地址  示例：\n1int main() { 2 3\t//二维数组数组名 4\tint arr[2][3] = 5\t{ 6\t{1,2,3}, 7\t{4,5,6} 8\t}; 9 10\tcout \u0026lt;\u0026lt; \u0026#34;二维数组大小： \u0026#34; \u0026lt;\u0026lt; sizeof(arr) \u0026lt;\u0026lt; endl; 11\tcout \u0026lt;\u0026lt; \u0026#34;二维数组一行大小： \u0026#34; \u0026lt;\u0026lt; sizeof(arr[0]) \u0026lt;\u0026lt; endl; 12\tcout \u0026lt;\u0026lt; \u0026#34;二维数组元素大小： \u0026#34; \u0026lt;\u0026lt; sizeof(arr[0][0]) \u0026lt;\u0026lt; endl; 13 14\tcout \u0026lt;\u0026lt; \u0026#34;二维数组行数： \u0026#34; \u0026lt;\u0026lt; sizeof(arr) / sizeof(arr[0]) \u0026lt;\u0026lt; endl; 15\tcout \u0026lt;\u0026lt; \u0026#34;二维数组列数： \u0026#34; \u0026lt;\u0026lt; sizeof(arr[0]) / sizeof(arr[0][0]) \u0026lt;\u0026lt; endl; 16 17\t//地址 18\tcout \u0026lt;\u0026lt; \u0026#34;二维数组首地址：\u0026#34; \u0026lt;\u0026lt; arr \u0026lt;\u0026lt; endl; 19\tcout \u0026lt;\u0026lt; \u0026#34;二维数组第一行地址：\u0026#34; \u0026lt;\u0026lt; arr[0] \u0026lt;\u0026lt; endl; 20\tcout \u0026lt;\u0026lt; \u0026#34;二维数组第二行地址：\u0026#34; \u0026lt;\u0026lt; arr[1] \u0026lt;\u0026lt; endl; 21 22\tcout \u0026lt;\u0026lt; \u0026#34;二维数组第一个元素地址：\u0026#34; \u0026lt;\u0026lt; \u0026amp;arr[0][0] \u0026lt;\u0026lt; endl; 23\tcout \u0026lt;\u0026lt; \u0026#34;二维数组第二个元素地址：\u0026#34; \u0026lt;\u0026lt; \u0026amp;arr[0][1] \u0026lt;\u0026lt; endl; 24 25\tsystem(\u0026#34;pause\u0026#34;); 26 27\treturn 0; 28}  总结1：二维数组名就是这个数组的首地址\n  总结2：对二维数组名进行sizeof时，可以获取整个二维数组占用的内存空间大小\n 6.函数 函数的定义 语法：\n1返回值类型 函数名 （参数列表） 2{ 3 4 函数体语句 5 6 return表达式 7 8} 函数的调用 值传递  所谓值传递，就是函数调用时实参将数值传入给形参 值传递时，如果形参发生，并不会影响实参  函数的常见样式 函数的声明 作用： 告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。\n 函数的声明可以多次，但是函数的定义只能有一次  函数的分文件编写 函数分文件编写一般有4个步骤\n 创建后缀名为.h的头文件 创建后缀名为.cpp的源文件 在头文件中写函数的声明 在源文件中写函数的定义  示例：\n1//swap.h文件 2#include\u0026lt;iostream\u0026gt;3using namespace std; 4 5//实现两个数字交换的函数声明 6void swap(int a, int b); 7 1//swap.cpp文件 2#include \u0026#34;swap.h\u0026#34;3 4void swap(int a, int b) 5{ 6\tint temp = a; 7\ta = b; 8\tb = temp; 9 10\tcout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; 11\tcout \u0026lt;\u0026lt; \u0026#34;b = \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; 12} 1//main函数文件 2#include \u0026#34;swap.h\u0026#34;3int main() { 4 5\tint a = 100; 6\tint b = 200; 7\tswap(a, b); 8 9\tsystem(\u0026#34;pause\u0026#34;); 10 11\treturn 0; 12} 13 7.指针 指针变量定义语法： 数据类型 * 变量名；\n示例：\n1int main() { 2 3\t//1、指针的定义 4\tint a = 10; //定义整型变量a 5\t6\t//指针定义语法： 数据类型 * 变量名 ; 7\tint * p; 8 9\t//指针变量赋值 10\tp = \u0026amp;a; //指针指向变量a的地址 11\tcout \u0026lt;\u0026lt; \u0026amp;a \u0026lt;\u0026lt; endl; //打印数据a的地址 12\tcout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; //打印指针变量p 13 14\t//2、指针的使用 15\t//通过*操作指针变量指向的内存 16\tcout \u0026lt;\u0026lt; \u0026#34;*p = \u0026#34; \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; 17 18\tsystem(\u0026#34;pause\u0026#34;); 19 20\treturn 0; 21} 指针变量和普通变量的区别\n 普通变量存放的是数据,指针变量存放的是地址 指针变量可以通过\u0026quot; * \u0026ldquo;操作符，操作指针变量指向的内存空间，这个过程称为解引用   总结1： 我们可以通过 \u0026amp; 符号 获取变量的地址\n  总结2：利用指针可以记录地址\n  总结3：对指针变量解引用，可以操作指针指向的内存\n 指针所占内存空间 所有指针类型在32位操作系统下是4个字节\n空指针和野指针 空指针：指针变量指向内存中编号为0的空间\n**注意：**空指针指向的内存是不可以访问的\n示例1：空指针\n1int main() { 2 3\t//指针变量p指向内存地址编号为0的空间 4\tint * p = NULL; 5 6\t//访问空指针报错 7\t//内存编号0 ~255为系统占用内存，不允许用户访问 8\tcout \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; 9 10\tsystem(\u0026#34;pause\u0026#34;); 11 12\treturn 0; 13} 野指针：指针变量指向非法的内存空间\n示例2：野指针\n1int main() { 2 3\t//指针变量p指向内存地址编号为0x1100的空间 4\tint * p = (int *)0x1100; 5 6\t//访问野指针报错 7\tcout \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; 8 9\tsystem(\u0026#34;pause\u0026#34;); 10 11\treturn 0; 12}  总结：空指针和野指针都不是我们申请的空间，因此不要访问。\n const修饰指针 const修饰指针有三种情况\n const修饰指针 \u0026mdash; 常量指针 const int * p1 = \u0026amp;a; const修饰常量 \u0026mdash; 指针常量 int * const p2 = \u0026amp;a; const即修饰指针，又修饰常量 const int * const p3 = \u0026amp;a;  **示例： **\n1int main() { 2 3\tint a = 10; 4\tint b = 10; 5 6\t//const修饰的是指针，指针指向可以改，指针指向的值不可以更改 7\tconst int * p1 = \u0026amp;a; 8\tp1 = \u0026amp;b; //正确 9\t//*p1 = 100; 报错 10\t11 12\t//const修饰的是常量，指针指向不可以改，指针指向的值可以更改 13\tint * const p2 = \u0026amp;a; 14\t//p2 = \u0026amp;b; //错误 15\t*p2 = 100; //正确 16 17 //const既修饰指针又修饰常量 18\tconst int * const p3 = \u0026amp;a; 19\t//p3 = \u0026amp;b; //错误 20\t//*p3 = 100; //错误 21 22\tsystem(\u0026#34;pause\u0026#34;); 23 24\treturn 0; 25}  技巧：看const右侧紧跟着的是指针还是常量, 是指针就是常量指针，是常量就是指针常量\n 指针和数组 当数组名传入到函数作为参数时，被退化为指向首元素的指针\n示例：\n1int main() { 2 3\tint arr[] = { 1,2,3,4,5,6,7,8,9,10 }; 4 5\tint * p = arr; //指向数组的指针 6 7\tcout \u0026lt;\u0026lt; \u0026#34;第一个元素： \u0026#34; \u0026lt;\u0026lt; arr[0] \u0026lt;\u0026lt; endl; 8\tcout \u0026lt;\u0026lt; \u0026#34;指针访问第一个元素： \u0026#34; \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; 9 10\tfor (int i = 0; i \u0026lt; 10; i++) 11\t{ 12\t//利用指针遍历数组 13\tcout \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; 14\tp++; 15\t} 16 17\tsystem(\u0026#34;pause\u0026#34;); 18 19\treturn 0; 20} 指针和函数 利用指针作函数参数，可以修改实参的值\n1//地址传递 2void swap2(int * p1, int *p2) 3{ 4\tint temp = *p1; 5\t*p1 = *p2; 6\t*p2 = temp; 7} 如果不想修改实参，就用值传递，如果想修改实参，就用地址传递\n8.结构体 结构体定义和使用 语法：struct 结构体名 { 结构体成员列表 }；\n通过结构体创建变量的方式有三种：\n struct 结构体名 变量名 struct 结构体名 变量名 = { 成员1值 ， 成员2值\u0026hellip;} 定义结构体时顺便创建变量  示例：\n1//结构体定义 2struct student 3{ 4\t//成员列表 5\tstring name; //姓名 6\tint age; //年龄 7\tint score; //分数 8}stu3; //结构体变量创建方式3 9 10 11int main() { 12 13\t//结构体变量创建方式1 14\tstruct student stu1; //struct 关键字可以省略 15 16\tstu1.name = \u0026#34;张三\u0026#34;; 17\tstu1.age = 18; 18\tstu1.score = 100; 19\t20\tcout \u0026lt;\u0026lt; \u0026#34;姓名：\u0026#34; \u0026lt;\u0026lt; stu1.name \u0026lt;\u0026lt; \u0026#34; 年龄：\u0026#34; \u0026lt;\u0026lt; stu1.age \u0026lt;\u0026lt; \u0026#34; 分数：\u0026#34; \u0026lt;\u0026lt; stu1.score \u0026lt;\u0026lt; endl; 21 22\t//结构体变量创建方式2 23\tstruct student stu2 = { \u0026#34;李四\u0026#34;,19,60 }; 24 25\tcout \u0026lt;\u0026lt; \u0026#34;姓名：\u0026#34; \u0026lt;\u0026lt; stu2.name \u0026lt;\u0026lt; \u0026#34; 年龄：\u0026#34; \u0026lt;\u0026lt; stu2.age \u0026lt;\u0026lt; \u0026#34; 分数：\u0026#34; \u0026lt;\u0026lt; stu2.score \u0026lt;\u0026lt; endl; 26 27 28\tstu3.name = \u0026#34;王五\u0026#34;; 29\tstu3.age = 18; 30\tstu3.score = 80; 31\t32 33\tcout \u0026lt;\u0026lt; \u0026#34;姓名：\u0026#34; \u0026lt;\u0026lt; stu3.name \u0026lt;\u0026lt; \u0026#34; 年龄：\u0026#34; \u0026lt;\u0026lt; stu3.age \u0026lt;\u0026lt; \u0026#34; 分数：\u0026#34; \u0026lt;\u0026lt; stu3.score \u0026lt;\u0026lt; endl; 34 35\tsystem(\u0026#34;pause\u0026#34;); 36 37\treturn 0; 38}  总结1：定义结构体时的关键字是struct，不可省略\n  总结2：创建结构体变量时，关键字struct可以省略\n  总结3：结构体变量利用操作符 \u0026lsquo;\u0026rsquo;.'' 访问成员\n 结构体数组  struct 结构体名 数组名[元素个数] = { {} , {} , ... {} }\n1struct student arr[3]= 2\t{ 3\t{\u0026#34;张三\u0026#34;,18,80 }, 4\t{\u0026#34;李四\u0026#34;,19,60 }, 5\t{\u0026#34;王五\u0026#34;,20,70 } 6\t}; 7 结构体指针 利用操作符 -\u0026gt; 可以通过结构体指针访问结构体属性\n1int main() { 2\t3\tstruct student stu = { \u0026#34;张三\u0026#34;,18,100, }; 4\t5\tstruct student * p = \u0026amp;stu; 6\t7\tp-\u0026gt;score = 80; //指针通过 -\u0026gt; 操作符可以访问成员 8 9\tcout \u0026lt;\u0026lt; \u0026#34;姓名：\u0026#34; \u0026lt;\u0026lt; p-\u0026gt;name \u0026lt;\u0026lt; \u0026#34; 年龄：\u0026#34; \u0026lt;\u0026lt; p-\u0026gt;age \u0026lt;\u0026lt; \u0026#34; 分数：\u0026#34; \u0026lt;\u0026lt; p-\u0026gt;score \u0026lt;\u0026lt; endl; 10\t11\tsystem(\u0026#34;pause\u0026#34;); 12 13\treturn 0; 14} 结构体嵌套结构体 结构体做函数参数 传递方式有两种：\n 值传递 地址传递  1//值传递 2void printStudent(student stu ) 3{ 4\tstu.age = 28; 5\tcout \u0026lt;\u0026lt; \u0026#34;子函数中 姓名：\u0026#34; \u0026lt;\u0026lt; stu.name \u0026lt;\u0026lt; \u0026#34; 年龄： \u0026#34; \u0026lt;\u0026lt; stu.age \u0026lt;\u0026lt; \u0026#34; 分数：\u0026#34; \u0026lt;\u0026lt; stu.score \u0026lt;\u0026lt; endl; 6} 7 8//地址传递 9void printStudent2(student *stu) 10{ 11\tstu-\u0026gt;age = 28; 12\tcout \u0026lt;\u0026lt; \u0026#34;子函数中 姓名：\u0026#34; \u0026lt;\u0026lt; stu-\u0026gt;name \u0026lt;\u0026lt; \u0026#34; 年龄： \u0026#34; \u0026lt;\u0026lt; stu-\u0026gt;age \u0026lt;\u0026lt; \u0026#34; 分数：\u0026#34; \u0026lt;\u0026lt; stu-\u0026gt;score \u0026lt;\u0026lt; endl; 13} 结构体中 const使用场景 用const来防止误操作\n1//const使用场景 2void printStudent(const student *stu) //加const防止函数体中的误操作 3{ 4\t//stu-\u0026gt;age = 100; //操作失败，因为加了const修饰 5\tcout \u0026lt;\u0026lt; \u0026#34;姓名：\u0026#34; \u0026lt;\u0026lt; stu-\u0026gt;name \u0026lt;\u0026lt; \u0026#34; 年龄：\u0026#34; \u0026lt;\u0026lt; stu-\u0026gt;age \u0026lt;\u0026lt; \u0026#34; 分数：\u0026#34; \u0026lt;\u0026lt; stu-\u0026gt;score \u0026lt;\u0026lt; endl; 6 7} 9.内存分区模型 C++程序在执行时，将内存大方向划分为4个区域\n 代码区：存放函数体的二进制代码，由操作系统进行管理的 全局区：存放全局变量和静态变量以及常量 栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等 堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收  不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程\n程序运行前 在程序编译后，生成了exe可执行程序，未执行该程序前分为两个区域\n代码区：\n​\t存放 CPU 执行的机器指令\n​\t代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可\n​\t代码区是只读的，使其只读的原因是防止程序意外地修改了它的指令\n全局区：\n​\t全局变量和静态变量存放在此.\n​\t全局区还包含了常量区, 字符串常量和其他常量也存放在此.\n​\t==该区域的数据在程序结束后由操作系统释放==.\n程序运行后 栈区：\n​\t由编译器自动分配释放, 存放函数的参数值,局部变量等\n​\t注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放\n堆区：\n​\t由程序员分配释放,若程序员不释放,程序结束时由操作系统回收\n​\t在C++中主要利用new在堆区开辟内存\nnew操作符 C++中利用==new==操作符在堆区开辟数据\n​\t堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 ==delete==\n​\t语法： new 数据类型\n​\t利用new创建的数据，会返回该数据对应的类型的指针\n示例1： 基本语法\n1int* func() 2{ 3\tint* a = new int(10); 4\treturn a; 5} 6 7int main() { 8 9\tint *p = func(); 10 11\tcout \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; 12\tcout \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; 13 14\t//利用delete释放堆区数据 15\tdelete p; 16 17\t//cout \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; //报错，释放的空间不可访问 18 19\tsystem(\u0026#34;pause\u0026#34;); 20 21\treturn 0; 22} 示例2：开辟数组\n1//堆区开辟数组 2int main() { 3 4\tint* arr = new int[10]; 5 6\tfor (int i = 0; i \u0026lt; 10; i++) 7\t{ 8\tarr[i] = i + 100; 9\t} 10 11\tfor (int i = 0; i \u0026lt; 10; i++) 12\t{ 13\tcout \u0026lt;\u0026lt; arr[i] \u0026lt;\u0026lt; endl; 14\t} 15\t//释放数组 delete 后加 [] 16\tdelete[] arr; 17 18\tsystem(\u0026#34;pause\u0026#34;); 19 20\treturn 0; 21} 22 10.引用 引用的基本使用 给变量起别名\n数据类型 \u0026amp;别名 = 原名\n引用注意事项  引用必须初始化 引用在初始化后，不可以改变  1int main() { 2 3\tint a = 10; 4\tint b = 20; 5\t//int \u0026amp;c; //错误，引用必须初始化 6\tint \u0026amp;c = a; //一旦初始化后，就不可以更改 7\tc = b; //这是赋值操作，不是更改引用 8 9\tcout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; 10\tcout \u0026lt;\u0026lt; \u0026#34;b = \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; 11\tcout \u0026lt;\u0026lt; \u0026#34;c = \u0026#34; \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl; 12 13\tsystem(\u0026#34;pause\u0026#34;); 14 15\treturn 0; 16} 引用做函数参数 **作用：**函数传参时，可以利用引用的技术让形参修饰实参\n**优点：**可以简化指针修改实参, 通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单\n1//1. 值传递 2void mySwap01(int a, int b) { 3\tint temp = a; 4\ta = b; 5\tb = temp; 6} 7 8//2. 地址传递 9void mySwap02(int* a, int* b) { 10\tint temp = *a; 11\t*a = *b; 12\t*b = temp; 13} 14 15//3. 引用传递 16void mySwap03(int\u0026amp; a, int\u0026amp; b) { 17\tint temp = a; 18\ta = b; 19\tb = temp; 20} 引用做函数返回值 引用是可以作为函数的返回值存在的\n注意：不要返回局部变量引用\n用法：函数调用作为左值\n1//返回局部变量引用 2int\u0026amp; test01() { 3\tint a = 10; //局部变量 4\treturn a; 5} 6 7//返回静态变量引用 8int\u0026amp; test02() { 9\tstatic int a = 20; 10\treturn a; 11} 12 13int main() { 14 15\t//不能返回局部变量的引用 16\tint\u0026amp; ref = test01(); 17\tcout \u0026lt;\u0026lt; \u0026#34;ref = \u0026#34; \u0026lt;\u0026lt; ref \u0026lt;\u0026lt; endl; 18\tcout \u0026lt;\u0026lt; \u0026#34;ref = \u0026#34; \u0026lt;\u0026lt; ref \u0026lt;\u0026lt; endl; 19 20\t//如果函数做左值，那么必须返回引用 21\tint\u0026amp; ref2 = test02(); 22\tcout \u0026lt;\u0026lt; \u0026#34;ref2 = \u0026#34; \u0026lt;\u0026lt; ref2 \u0026lt;\u0026lt; endl; 23\tcout \u0026lt;\u0026lt; \u0026#34;ref2 = \u0026#34; \u0026lt;\u0026lt; ref2 \u0026lt;\u0026lt; endl; 24 25\ttest02() = 1000; 26 27\tcout \u0026lt;\u0026lt; \u0026#34;ref2 = \u0026#34; \u0026lt;\u0026lt; ref2 \u0026lt;\u0026lt; endl; 28\tcout \u0026lt;\u0026lt; \u0026#34;ref2 = \u0026#34; \u0026lt;\u0026lt; ref2 \u0026lt;\u0026lt; endl; 29 30\tsystem(\u0026#34;pause\u0026#34;); 31 32\treturn 0; 33} 引用的本质 引用的本质在c++内部实现是一个指针常量.\nC++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了\n1//发现是引用，转换为 int* const ref = \u0026amp;a; 2void func(int\u0026amp; ref){ 3\tref = 100; // ref是引用，转换为*ref = 100 4} 5int main(){ 6\tint a = 10; 7 8 //自动转换为 int* const ref = \u0026amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改 9\tint\u0026amp; ref = a; 10\tref = 20; //内部发现ref是引用，自动帮我们转换为: *ref = 20; 11 12\tcout \u0026lt;\u0026lt; \u0026#34;a:\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; 13\tcout \u0026lt;\u0026lt; \u0026#34;ref:\u0026#34; \u0026lt;\u0026lt; ref \u0026lt;\u0026lt; endl; 14 15\tfunc(a); 16\treturn 0; 17} 常量引用 常量引用主要用来修饰形参，防止误操作\n1//引用使用的场景，通常用来修饰形参 2void showValue(const int\u0026amp; v) { 3\t//v += 10; 4\tcout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; endl; 5} 6 7int main() { 8 9\t//int\u0026amp; ref = 10; 引用本身需要一个合法的内存空间，因此这行错误 10\t//加入const就可以了，编译器优化代码，int temp = 10; const int\u0026amp; ref = temp; 11\tconst int\u0026amp; ref = 10; 12 13\t//ref = 100; //加入const后不可以修改变量 14\tcout \u0026lt;\u0026lt; ref \u0026lt;\u0026lt; endl; 15 16\t//函数中利用常量引用防止误操作修改实参 17\tint a = 10; 18\tshowValue(a); 19 20\tsystem(\u0026#34;pause\u0026#34;); 21 22\treturn 0; 23} 11.函数提高 函数默认参数 在C++中，函数的形参列表中的形参是可以有默认值的。\n 返回值类型 函数名 （参数= 默认值）{}\n1int func(int a, int b = 10, int c = 10) { 2\treturn a + b + c; 3} 4 5//1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值 6//2. 如果函数声明有默认值，函数实现的时候就不能有默认参数 7int func2(int a = 10, int b = 10); 8int func2(int a, int b) { 9\treturn a + b; 10} 函数占位参数 C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置\n返回值类型 函数名 (数据类型){}\n1//函数占位参数 ，占位参数也可以有默认参数 2void func(int a, int) { 3\tcout \u0026lt;\u0026lt; \u0026#34;this is func\u0026#34; \u0026lt;\u0026lt; endl; 4} 5 6int main() { 7 8\tfunc(10,10); //占位参数必须填补 9 10\tsystem(\u0026#34;pause\u0026#34;); 11 12\treturn 0; 13} 12.函数重载 函数重载概述 函数重载满足条件：\n 同一个作用域下 函数名称相同 函数参数类型不同 或者 个数不同 或者 顺序不同  注意: 函数的返回值不可以作为函数重载的条件\n函数重载注意事项  引用作为重载条件 函数重载碰到函数默认参数  示例：\n1//函数重载注意事项 2//1、引用作为重载条件 3 4void func(int \u0026amp;a) 5{ 6\tcout \u0026lt;\u0026lt; \u0026#34;func (int \u0026amp;a) 调用 \u0026#34; \u0026lt;\u0026lt; endl; 7} 8 9void func(const int \u0026amp;a) 10{ 11\tcout \u0026lt;\u0026lt; \u0026#34;func (const int \u0026amp;a) 调用 \u0026#34; \u0026lt;\u0026lt; endl; 12} 13 14 15//2、函数重载碰到函数默认参数 16 17void func2(int a, int b = 10) 18{ 19\tcout \u0026lt;\u0026lt; \u0026#34;func2(int a, int b = 10) 调用\u0026#34; \u0026lt;\u0026lt; endl; 20} 21 22void func2(int a) 23{ 24\tcout \u0026lt;\u0026lt; \u0026#34;func2(int a) 调用\u0026#34; \u0026lt;\u0026lt; endl; 25} 26 27int main() { 28\t29\tint a = 10; 30\tfunc(a); //调用无const 31\tfunc(10);//调用有const 32 33 34\t//func2(10); //碰到默认参数产生歧义，需要避免 35 36\tsystem(\u0026#34;pause\u0026#34;); 37 38\treturn 0; 39} 13.类和对象 封装 封装的意义：\n 将属性和行为作为一个整体，表现生活中的事物 将属性和行为加以权限控制  class 类名{ 访问权限： 属性 / 行为 };\n访问权限有三种：\n public 公共权限 protected 保护权限 private 私有权限  示例：\n1//三种权限 2//公共权限 public 类内可以访问 类外可以访问 3//保护权限 protected 类内可以访问 类外不可以访问 4//私有权限 private 类内可以访问 类外不可以访问 5 6class Person 7{ 8\t//姓名 公共权限 9public: 10\tstring m_Name; 11 12\t//汽车 保护权限 13protected: 14\tstring m_Car; 15 16\t//银行卡密码 私有权限 17private: 18\tint m_Password; 19 20public: 21\tvoid func() 22\t{ 23\tm_Name = \u0026#34;张三\u0026#34;; 24\tm_Car = \u0026#34;拖拉机\u0026#34;; 25\tm_Password = 123456; 26\t} 27}; 28 29int main() { 30 31\tPerson p; 32\tp.m_Name = \u0026#34;李四\u0026#34;; 33\t//p.m_Car = \u0026#34;奔驰\u0026#34;; //保护权限类外访问不到 34\t//p.m_Password = 123; //私有权限类外访问不到 35 36\tsystem(\u0026#34;pause\u0026#34;); 37 38\treturn 0; 39} struct和class区别 在C++中 struct和class唯一的区别就在于 默认的访问权限不同\n区别：\n struct 默认权限为公共 class 默认权限为私有  1class C1 2{ 3\tint m_A; //默认是私有权限 4}; 5 6struct C2 7{ 8\tint m_A; //默认是公共权限 9}; 10 11int main() { 12 13\tC1 c1; 14\tc1.m_A = 10; //错误，访问权限是私有 15 16\tC2 c2; 17\tc2.m_A = 10; //正确，访问权限是公共 18 19\tsystem(\u0026#34;pause\u0026#34;); 20 21\treturn 0; 22} 成员属性设置为私有 **优点1：**将所有成员属性设置为私有，可以自己控制读写权限\n**优点2：**对于写权限，我们可以检测数据的有效性\n对象的初始化和清理 I 构造函数和析构函数 c++利用了构造函数和析构函数解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。\n对象的初始化和清理工作是编译器强制要我们做的事情，因此如果我们不提供构造和析构，编译器会提供, 编译器提供的构造函数和析构函数是空实现。\n 构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。 析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理工作。  构造函数语法：类名(){}\n 构造函数，没有返回值也不写void 函数名称与类名相同 构造函数可以有参数，因此可以发生重载 程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次  析构函数语法： ~类名(){}\n 析构函数，没有返回值也不写void 函数名称与类名相同,在名称前加上符号 ~ 析构函数不可以有参数，因此不可以发生重载 程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次  II 构造函数的分类及调用 两种分类方式：\n​\t按参数分为： 有参构造和无参构造\n​\t按类型分为： 普通构造和拷贝构造\n三种调用方式：\n​\t括号法\n​\t显示法\n​\t隐式转换法\n1class Person { 2public: 3\t//无参（默认）构造函数 4\tPerson() { 5\tcout \u0026lt;\u0026lt; \u0026#34;无参构造函数!\u0026#34; \u0026lt;\u0026lt; endl; 6\t} 7\t//有参构造函数 8\tPerson(int a) { 9\tage = a; 10\tcout \u0026lt;\u0026lt; \u0026#34;有参构造函数!\u0026#34; \u0026lt;\u0026lt; endl; 11\t} 12\t//拷贝构造函数 13\tPerson(const Person\u0026amp; p) { 14\tage = p.age; 15\tcout \u0026lt;\u0026lt; \u0026#34;拷贝构造函数!\u0026#34; \u0026lt;\u0026lt; endl; 16\t} 17\t//析构函数 18\t~Person() { 19\tcout \u0026lt;\u0026lt; \u0026#34;析构函数!\u0026#34; \u0026lt;\u0026lt; endl; 20\t} 21public: 22\tint age; 23}; 24 25//2、构造函数的调用 26//调用无参构造函数 27void test01() { 28\tPerson p; //调用无参构造函数 29} 30 31//调用有参的构造函数 32void test02() { 33 34\t//2.1 括号法，常用 35\tPerson p1(10); 36\t//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明 37\t//Person p2(); 38 39\t//2.2 显式法 40\tPerson p2 = Person(10); 41\tPerson p3 = Person(p2); 42\t//Person(10)单独写就是匿名对象 当前行结束之后，马上析构 43 44\t//2.3 隐式转换法 45\tPerson p4 = 10; // Person p4 = Person(10); 46\tPerson p5 = p4; // Person p5 = Person(p4); 47 48\t//注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明 49\t//Person p5(p4); 50} 51 52int main() { 53 54\ttest01(); 55\t//test02(); 56 57\tsystem(\u0026#34;pause\u0026#34;); 58 59\treturn 0; 60} III 拷贝构造函数调用时机 C++中拷贝构造函数调用时机通常有三种情况\n 使用一个已经创建完毕的对象来初始化一个新对象 值传递的方式给函数参数传值 以值方式返回局部对象  1class Person { 2public: 3\tPerson() { 4\tcout \u0026lt;\u0026lt; \u0026#34;无参构造函数!\u0026#34; \u0026lt;\u0026lt; endl; 5\tmAge = 0; 6\t} 7\tPerson(int age) { 8\tcout \u0026lt;\u0026lt; \u0026#34;有参构造函数!\u0026#34; \u0026lt;\u0026lt; endl; 9\tmAge = age; 10\t} 11\tPerson(const Person\u0026amp; p) { 12\tcout \u0026lt;\u0026lt; \u0026#34;拷贝构造函数!\u0026#34; \u0026lt;\u0026lt; endl; 13\tmAge = p.mAge; 14\t} 15\t//析构函数在释放内存之前调用 16\t~Person() { 17\tcout \u0026lt;\u0026lt; \u0026#34;析构函数!\u0026#34; \u0026lt;\u0026lt; endl; 18\t} 19public: 20\tint mAge; 21}; 22 23//1. 使用一个已经创建完毕的对象来初始化一个新对象 24void test01() { 25 26\tPerson man(100); //p对象已经创建完毕 27\tPerson newman(man); //调用拷贝构造函数 28\tPerson newman2 = man; //拷贝构造 29 30\t//Person newman3; 31\t//newman3 = man; //不是调用拷贝构造函数，赋值操作 32} 33 34//2. 值传递的方式给函数参数传值 35//相当于Person p1 = p; 36void doWork(Person p1) {} 37void test02() { 38\tPerson p; //无参构造函数 39\tdoWork(p); 40} 41 42//3. 以值方式返回局部对象 43Person doWork2() 44{ 45\tPerson p1; 46\tcout \u0026lt;\u0026lt; (int *)\u0026amp;p1 \u0026lt;\u0026lt; endl; 47\treturn p1; 48} 49 50void test03() 51{ 52\tPerson p = doWork2(); 53\tcout \u0026lt;\u0026lt; (int *)\u0026amp;p \u0026lt;\u0026lt; endl; 54} 55 56 57int main() { 58 59\t//test01(); 60\t//test02(); 61\ttest03(); 62 63\tsystem(\u0026#34;pause\u0026#34;); 64 65\treturn 0; 66} IV 构造函数调用规则 默认情况下，c++编译器至少给一个类添加3个函数\n1．默认构造函数(无参，函数体为空)\n2．默认析构函数(无参，函数体为空)\n3．默认拷贝构造函数，对属性进行值拷贝\n构造函数调用规则如下：\n  如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造\n  如果用户定义拷贝构造函数，c++不会再提供其他构造函数\n  1class Person { 2public: 3\t//无参（默认）构造函数 4\tPerson() { 5\tcout \u0026lt;\u0026lt; \u0026#34;无参构造函数!\u0026#34; \u0026lt;\u0026lt; endl; 6\t} 7\t//有参构造函数 8\tPerson(int a) { 9\tage = a; 10\tcout \u0026lt;\u0026lt; \u0026#34;有参构造函数!\u0026#34; \u0026lt;\u0026lt; endl; 11\t} 12\t//拷贝构造函数 13\tPerson(const Person\u0026amp; p) { 14\tage = p.age; 15\tcout \u0026lt;\u0026lt; \u0026#34;拷贝构造函数!\u0026#34; \u0026lt;\u0026lt; endl; 16\t} 17\t//析构函数 18\t~Person() { 19\tcout \u0026lt;\u0026lt; \u0026#34;析构函数!\u0026#34; \u0026lt;\u0026lt; endl; 20\t} 21public: 22\tint age; 23}; 24 25void test01() 26{ 27\tPerson p1(18); 28\t//如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作 29\tPerson p2(p1); 30 31\tcout \u0026lt;\u0026lt; \u0026#34;p2的年龄为： \u0026#34; \u0026lt;\u0026lt; p2.age \u0026lt;\u0026lt; endl; 32} 33 34void test02() 35{ 36\t//如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造 37\tPerson p1; //此时如果用户自己没有提供默认构造，会出错 38\tPerson p2(10); //用户提供的有参 39\tPerson p3(p2); //此时如果用户没有提供拷贝构造，编译器会提供 40 41\t//如果用户提供拷贝构造，编译器不会提供其他构造函数 42\tPerson p4; //此时如果用户自己没有提供默认构造，会出错 43\tPerson p5(10); //此时如果用户自己没有提供有参，会出错 44\tPerson p6(p5); //用户自己提供拷贝构造 45} 46 47int main() { 48 49\ttest01(); 50 51\tsystem(\u0026#34;pause\u0026#34;); 52 53\treturn 0; 54} V 深拷贝与浅拷贝 浅拷贝：简单的赋值拷贝操作\n深拷贝：在堆区重新申请空间，进行拷贝操作\n如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题\n示例：\n1class Person { 2public: 3\t//无参（默认）构造函数 4\tPerson() { 5\tcout \u0026lt;\u0026lt; \u0026#34;无参构造函数!\u0026#34; \u0026lt;\u0026lt; endl; 6\t} 7\t//有参构造函数 8\tPerson(int age ,int height) { 9\t10\tcout \u0026lt;\u0026lt; \u0026#34;有参构造函数!\u0026#34; \u0026lt;\u0026lt; endl; 11 12\tm_age = age; 13\tm_height = new int(height); 14\t15\t} 16\t//拷贝构造函数 17\tPerson(const Person\u0026amp; p) { 18\tcout \u0026lt;\u0026lt; \u0026#34;拷贝构造函数!\u0026#34; \u0026lt;\u0026lt; endl; 19\t//如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题 20\tm_age = p.m_age; 21\tm_height = new int(*p.m_height); 22\t23\t} 24 25\t//析构函数 26\t~Person() { 27\tcout \u0026lt;\u0026lt; \u0026#34;析构函数!\u0026#34; \u0026lt;\u0026lt; endl; 28\tif (m_height != NULL) 29\t{ 30\tdelete m_height; 31\t} 32\t} 33public: 34\tint m_age; 35\tint* m_height; 36}; VI 初始化列表 C++提供了初始化列表语法，用来初始化属性\n构造函数()：属性1(值1),属性2（值2）... {}\n1\t////传统方式初始化 2\t//Person(int a, int b, int c) { 3\t//\tm_A = a; 4\t//\tm_B = b; 5\t//\tm_C = c; 6\t//} 7 8\t//初始化列表方式初始化 9\tPerson(int a, int b, int c) :m_A(a), m_B(b), m_C(c) {} VII 类对象作为类成员 当类中成员是其他类对象时，我们称该成员为 对象成员\n构造的顺序是 ：先调用对象成员的构造，再调用本类构造\n析构顺序与构造相反\nVIII 静态成员 静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员\n静态成员分为：\n 静态成员变量  所有对象共享同一份数据 在编译阶段分配内存 类内声明，类外初始化   静态成员函数  所有对象共享同一个函数 静态成员函数只能访问静态成员变量    C++对象模型和this指针 成员变量和成员函数分开存储 1class Person { 2public: 3\tPerson() { 4\tmA = 0; 5\t} 6\t//非静态成员变量占对象空间 7\tint mA; 8\t//静态成员变量不占对象空间 9\tstatic int mB; 10\t//函数也不占对象空间，所有函数共享一个函数实例 11\tvoid func() { 12\tcout \u0026lt;\u0026lt; \u0026#34;mA:\u0026#34; \u0026lt;\u0026lt; this-\u0026gt;mA \u0026lt;\u0026lt; endl; 13\t} 14\t//静态成员函数也不占对象空间 15\tstatic void sfunc() { 16\t} 17}; this指针概念 每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码\n那么问题是：这一块代码是如何区分那个对象调用自己的呢？\nc++通过提供特殊的对象指针，this指针，解决上述问题。this指针指向被调用的成员函数所属的对象\nthis指针是隐含每一个非静态成员函数内的一种指针\nthis指针不需要定义，直接使用即可\nthis指针的用途：\n 当形参和成员变量同名时，可用this指针来区分 在类的非静态成员函数中返回对象本身，可使用return *this  1Person(int age) 2\t{ 3\t//1、当形参和成员变量同名时，可用this指针来区分 4\tthis-\u0026gt;age = age; 5\t} 6 7\tPerson\u0026amp; PersonAddPerson(Person p) 8\t{ 9\tthis-\u0026gt;age += p.age; 10\t//返回对象本身 11\treturn *this; 12\t} 空指针访问成员函数 C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针\n如果用到this指针，需要加以判断保证代码的健壮性\n1//空指针访问成员函数 2class Person { 3public: 4 5\tvoid ShowClassName() { 6\tcout \u0026lt;\u0026lt; \u0026#34;我是Person类!\u0026#34; \u0026lt;\u0026lt; endl; 7\t} 8 9\tvoid ShowPerson() { 10\tif (this == NULL) { 11\treturn; 12\t} 13\tcout \u0026lt;\u0026lt; mAge \u0026lt;\u0026lt; endl; 14\t} 15 16public: 17\tint mAge; 18}; 19 20void test01() 21{ 22\tPerson * p = NULL; 23\tp-\u0026gt;ShowClassName(); //空指针，可以调用成员函数 24\tp-\u0026gt;ShowPerson(); //但是如果成员函数中用到了this指针，就不可以了 25} const修饰成员函数 常函数：\n 成员函数后加const后我们称为这个函数为常函数 常函数内不可以修改成员属性 成员属性声明时加关键字mutable后，在常函数中依然可以修改  常对象：\n 声明对象前加const称该对象为常对象 常对象只能调用常函数  示例：\n1class Person { 2public: 3\tPerson() { 4\tm_A = 0; 5\tm_B = 0; 6\t} 7 8\t//this指针的本质是一个指针常量，指针的指向不可修改 9\t//如果想让指针指向的值也不可以修改，需要声明常函数 10\tvoid ShowPerson() const { 11\t//const Type* const pointer; 12\t//this = NULL; //不能修改指针的指向 Person* const this; 13\t//this-\u0026gt;mA = 100; //但是this指针指向的对象的数据是可以修改的 14 15\t//const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量 16\tthis-\u0026gt;m_B = 100; 17\t} 18 19\tvoid MyFunc() const { 20\t//mA = 10000; 21\t} 22 23public: 24\tint m_A; 25\tmutable int m_B; //可修改 可变的 26}; 27 28 29//const修饰对象 常对象 30void test01() { 31 32\tconst Person person; //常量对象 33\tcout \u0026lt;\u0026lt; person.m_A \u0026lt;\u0026lt; endl; 34\t//person.mA = 100; //常对象不能修改成员变量的值,但是可以访问 35\tperson.m_B = 100; //但是常对象可以修改mutable修饰成员变量 36 37\t//常对象访问成员函数 38\tperson.MyFunc(); //常对象不能调用const的函数 39 40} 友元 在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术\n友元的目的就是让一个函数或者类 访问另一个类中私有成员\n友元的关键字为 ==friend==\n友元的三种实现\n 全局函数做友元 类做友元 成员函数做友元  全局函数做友元 1class Building 2{ 3\t//告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容 4\tfriend void goodGay(Building * building); 5 6public: 7 8\tBuilding() 9\t{ 10\tthis-\u0026gt;m_SittingRoom = \u0026#34;客厅\u0026#34;; 11\tthis-\u0026gt;m_BedRoom = \u0026#34;卧室\u0026#34;; 12\t} 13 14 15public: 16\tstring m_SittingRoom; //客厅 17 18private: 19\tstring m_BedRoom; //卧室 20}; 21 22 23void goodGay(Building * building) 24{ 25\tcout \u0026lt;\u0026lt; \u0026#34;好基友正在访问： \u0026#34; \u0026lt;\u0026lt; building-\u0026gt;m_SittingRoom \u0026lt;\u0026lt; endl; 26\tcout \u0026lt;\u0026lt; \u0026#34;好基友正在访问： \u0026#34; \u0026lt;\u0026lt; building-\u0026gt;m_BedRoom \u0026lt;\u0026lt; endl; 27} 28 29 30void test01() 31{ 32\tBuilding b; 33\tgoodGay(\u0026amp;b); 34} 35 类做友元 1class Building; 2class goodGay 3{ 4public: 5 6\tgoodGay(); 7\tvoid visit(); 8 9private: 10\tBuilding *building; 11}; 12 13 14class Building 15{ 16\t//告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容 17\tfriend class goodGay; 18 19public: 20\tBuilding(); 21 22public: 23\tstring m_SittingRoom; //客厅 24private: 25\tstring m_BedRoom;//卧室 26}; 27 28Building::Building() 29{ 30\tthis-\u0026gt;m_SittingRoom = \u0026#34;客厅\u0026#34;; 31\tthis-\u0026gt;m_BedRoom = \u0026#34;卧室\u0026#34;; 32} 33 34goodGay::goodGay() 35{ 36\tbuilding = new Building; 37} 38 39void goodGay::visit() 40{ 41\tcout \u0026lt;\u0026lt; \u0026#34;好基友正在访问\u0026#34; \u0026lt;\u0026lt; building-\u0026gt;m_SittingRoom \u0026lt;\u0026lt; endl; 42\tcout \u0026lt;\u0026lt; \u0026#34;好基友正在访问\u0026#34; \u0026lt;\u0026lt; building-\u0026gt;m_BedRoom \u0026lt;\u0026lt; endl; 43} 44 45void test01() 46{ 47\tgoodGay gg; 48\tgg.visit(); 49 50} 成员函数做友元 1class Building; 2class goodGay 3{ 4public: 5 6\tgoodGay(); 7\tvoid visit(); //只让visit函数作为Building的好朋友，可以发访问Building中私有内容 8\tvoid visit2(); 9 10private: 11\tBuilding *building; 12}; 13 14 15class Building 16{ 17\t//告诉编译器 goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容 18\tfriend void goodGay::visit(); 19 20public: 21\tBuilding(); 22 23public: 24\tstring m_SittingRoom; //客厅 25private: 26\tstring m_BedRoom;//卧室 27}; 28 29Building::Building() 30{ 31\tthis-\u0026gt;m_SittingRoom = \u0026#34;客厅\u0026#34;; 32\tthis-\u0026gt;m_BedRoom = \u0026#34;卧室\u0026#34;; 33} 34 35goodGay::goodGay() 36{ 37\tbuilding = new Building; 38} 39 40void goodGay::visit() 41{ 42\tcout \u0026lt;\u0026lt; \u0026#34;好基友正在访问\u0026#34; \u0026lt;\u0026lt; building-\u0026gt;m_SittingRoom \u0026lt;\u0026lt; endl; 43\tcout \u0026lt;\u0026lt; \u0026#34;好基友正在访问\u0026#34; \u0026lt;\u0026lt; building-\u0026gt;m_BedRoom \u0026lt;\u0026lt; endl; 44} 45 46void goodGay::visit2() 47{ 48\tcout \u0026lt;\u0026lt; \u0026#34;好基友正在访问\u0026#34; \u0026lt;\u0026lt; building-\u0026gt;m_SittingRoom \u0026lt;\u0026lt; endl; 49\t//cout \u0026lt;\u0026lt; \u0026#34;好基友正在访问\u0026#34; \u0026lt;\u0026lt; building-\u0026gt;m_BedRoom \u0026lt;\u0026lt; endl; 50} 51 52void test01() 53{ 54\tgoodGay gg; 55\tgg.visit(); 56 57} 运算符重载 运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型\n加号运算符重载 1class Person { 2public: 3\tPerson() {}; 4\tPerson(int a, int b) 5\t{ 6\tthis-\u0026gt;m_A = a; 7\tthis-\u0026gt;m_B = b; 8\t} 9\t//成员函数实现 + 号运算符重载 10\tPerson operator+(const Person\u0026amp; p) { 11\tPerson temp; 12\ttemp.m_A = this-\u0026gt;m_A + p.m_A; 13\ttemp.m_B = this-\u0026gt;m_B + p.m_B; 14\treturn temp; 15\t} 16 17 18public: 19\tint m_A; 20\tint m_B; 21}; 22 23//全局函数实现 + 号运算符重载 24//Person operator+(const Person\u0026amp; p1, const Person\u0026amp; p2) { 25//\tPerson temp(0, 0); 26//\ttemp.m_A = p1.m_A + p2.m_A; 27//\ttemp.m_B = p1.m_B + p2.m_B; 28//\treturn temp; 29//} 30 31//运算符重载 可以发生函数重载 32Person operator+(const Person\u0026amp; p2, int val) 33{ 34\tPerson temp; 35\ttemp.m_A = p2.m_A + val; 36\ttemp.m_B = p2.m_B + val; 37\treturn temp; 38} 39 40void test() { 41 42\tPerson p1(10, 10); 43\tPerson p2(20, 20); 44 45\t//成员函数方式 46\tPerson p3 = p2 + p1; //相当于 p2.operaor+(p1) 47\tcout \u0026lt;\u0026lt; \u0026#34;mA:\u0026#34; \u0026lt;\u0026lt; p3.m_A \u0026lt;\u0026lt; \u0026#34; mB:\u0026#34; \u0026lt;\u0026lt; p3.m_B \u0026lt;\u0026lt; endl; 48 49 50\tPerson p4 = p3 + 10; //相当于 operator+(p3,10) 51\tcout \u0026lt;\u0026lt; \u0026#34;mA:\u0026#34; \u0026lt;\u0026lt; p4.m_A \u0026lt;\u0026lt; \u0026#34; mB:\u0026#34; \u0026lt;\u0026lt; p4.m_B \u0026lt;\u0026lt; endl; 52 53} 左移运算符重载 重载左移运算符配合友元可以实现输出自定义数据类型\n1class Person { 2\tfriend ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; out, Person\u0026amp; p); 3 4public: 5 6\tPerson(int a, int b) 7\t{ 8\tthis-\u0026gt;m_A = a; 9\tthis-\u0026gt;m_B = b; 10\t} 11 12\t//成员函数 实现不了 p \u0026lt;\u0026lt; cout 不是我们想要的效果 13\t//void operator\u0026lt;\u0026lt;(Person\u0026amp; p){ 14\t//} 15 16private: 17\tint m_A; 18\tint m_B; 19}; 20 21//全局函数实现左移重载 22//ostream对象只能有一个 23ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; out, Person\u0026amp; p) { 24\tout \u0026lt;\u0026lt; \u0026#34;a:\u0026#34; \u0026lt;\u0026lt; p.m_A \u0026lt;\u0026lt; \u0026#34; b:\u0026#34; \u0026lt;\u0026lt; p.m_B; 25\treturn out; 26} 27 28void test() { 29 30\tPerson p1(10, 20); 31 32\tcout \u0026lt;\u0026lt; p1 \u0026lt;\u0026lt; \u0026#34;hello world\u0026#34; \u0026lt;\u0026lt; endl; //链式编程 33} 34 递增运算符重载 前置递增返回引用，后置递增返回值\n1class MyInteger { 2 3\tfriend ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; out, MyInteger myint); 4 5public: 6\tMyInteger() { 7\tm_Num = 0; 8\t} 9\t//前置++ 10\tMyInteger\u0026amp; operator++() { 11\t//先++ 12\tm_Num++; 13\t//再返回 14\treturn *this; 15\t} 16 17\t//后置++ 18\tMyInteger operator++(int) { 19\t//先返回 20\tMyInteger temp = *this; //记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++； 21\tm_Num++; 22\treturn temp; 23\t} 24 25private: 26\tint m_Num; 27}; 28 29 30ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; out, MyInteger myint) { 31\tout \u0026lt;\u0026lt; myint.m_Num; 32\treturn out; 33} 34 35 36//前置++ 先++ 再返回 37void test01() { 38\tMyInteger myInt; 39\tcout \u0026lt;\u0026lt; ++myInt \u0026lt;\u0026lt; endl; 40\tcout \u0026lt;\u0026lt; myInt \u0026lt;\u0026lt; endl; 41} 42 43//后置++ 先返回 再++ 44void test02() { 45 46\tMyInteger myInt; 47\tcout \u0026lt;\u0026lt; myInt++ \u0026lt;\u0026lt; endl; 48\tcout \u0026lt;\u0026lt; myInt \u0026lt;\u0026lt; endl; 49} 赋值运算符重载 c++编译器至少给一个类添加4个函数\n 默认构造函数(无参，函数体为空) 默认析构函数(无参，函数体为空) 默认拷贝构造函数，对属性进行值拷贝 赋值运算符 operator=, 对属性进行值拷贝  如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题\n1class Person 2{ 3public: 4 5\tPerson(int age) 6\t{ 7\t//将年龄数据开辟到堆区 8\tm_Age = new int(age); 9\t} 10 11\t//重载赋值运算符 12\tPerson\u0026amp; operator=(Person \u0026amp;p) 13\t{ 14\tif (m_Age != NULL) 15\t{ 16\tdelete m_Age; 17\tm_Age = NULL; 18\t} 19\t//编译器提供的代码是浅拷贝 20\t//m_Age = p.m_Age; 21 22\t//提供深拷贝 解决浅拷贝的问题 23\tm_Age = new int(*p.m_Age); 24 25\t//返回自身 26\treturn *this; 27\t} 28 29 30\t~Person() 31\t{ 32\tif (m_Age != NULL) 33\t{ 34\tdelete m_Age; 35\tm_Age = NULL; 36\t} 37\t} 38 39\t//年龄的指针 40\tint *m_Age; 41 42}; 43 44 45void test01() 46{ 47\tPerson p1(18); 48 49\tPerson p2(20); 50 51\tPerson p3(30); 52 53\tp3 = p2 = p1; //赋值操作 54 55\tcout \u0026lt;\u0026lt; \u0026#34;p1的年龄为：\u0026#34; \u0026lt;\u0026lt; *p1.m_Age \u0026lt;\u0026lt; endl; 56 57\tcout \u0026lt;\u0026lt; \u0026#34;p2的年龄为：\u0026#34; \u0026lt;\u0026lt; *p2.m_Age \u0026lt;\u0026lt; endl; 58 59\tcout \u0026lt;\u0026lt; \u0026#34;p3的年龄为：\u0026#34; \u0026lt;\u0026lt; *p3.m_Age \u0026lt;\u0026lt; endl; 60} 关系运算符重载 重载关系运算符，可以让两个自定义类型对象进行对比操作\n1class Person 2{ 3public: 4\tPerson(string name, int age) 5\t{ 6\tthis-\u0026gt;m_Name = name; 7\tthis-\u0026gt;m_Age = age; 8\t}; 9 10\tbool operator==(Person \u0026amp; p) 11\t{ 12\tif (this-\u0026gt;m_Name == p.m_Name \u0026amp;\u0026amp; this-\u0026gt;m_Age == p.m_Age) 13\t{ 14\treturn true; 15\t} 16\telse 17\t{ 18\treturn false; 19\t} 20\t} 21 22\tbool operator!=(Person \u0026amp; p) 23\t{ 24\tif (this-\u0026gt;m_Name == p.m_Name \u0026amp;\u0026amp; this-\u0026gt;m_Age == p.m_Age) 25\t{ 26\treturn false; 27\t} 28\telse 29\t{ 30\treturn true; 31\t} 32\t} 33 34\tstring m_Name; 35\tint m_Age; 36}; 函数调用运算符重载  函数调用运算符 () 也可以重载 由于重载后使用的方式非常像函数的调用，因此称为仿函数 仿函数没有固定写法，非常灵活  1class MyPrint 2{ 3public: 4\tvoid operator()(string text) 5\t{ 6\tcout \u0026lt;\u0026lt; text \u0026lt;\u0026lt; endl; 7\t} 8 9}; 10void test01() 11{ 12\t//重载的（）操作符 也称为仿函数 13\tMyPrint myFunc; 14\tmyFunc(\u0026#34;hello world\u0026#34;); 15} 16 17 18class MyAdd 19{ 20public: 21\tint operator()(int v1, int v2) 22\t{ 23\treturn v1 + v2; 24\t} 25}; 26 27void test02() 28{ 29\tMyAdd add; 30\tint ret = add(10, 10); 31\tcout \u0026lt;\u0026lt; \u0026#34;ret = \u0026#34; \u0026lt;\u0026lt; ret \u0026lt;\u0026lt; endl; 32 33\t//匿名对象调用 34\tcout \u0026lt;\u0026lt; \u0026#34;MyAdd()(100,100) = \u0026#34; \u0026lt;\u0026lt; MyAdd()(100, 100) \u0026lt;\u0026lt; endl; 35} 继承 继承的基本语法 class A : public B;\nA 类称为子类 或 派生类\nB 类称为父类 或 基类\n派生类中的成员，包含两大部分：\n一类是从基类继承过来的，一类是自己增加的成员。\n从基类继承过过来的表现其共性，而新增的成员体现了其个性。\n继承方式 继承的语法：class 子类 : 继承方式 父类\n继承方式一共有三种：\n 公共继承 保护继承 私有继承  1class Base1 2{ 3public: 4\tint m_A; 5protected: 6\tint m_B; 7private: 8\tint m_C; 9}; 10 11//公共继承 12class Son1 :public Base1 13{ 14public: 15\tvoid func() 16\t{ 17\tm_A; //可访问 public权限 18\tm_B; //可访问 protected权限 19\t//m_C; //不可访问 20\t} 21}; 22 23void myClass() 24{ 25\tSon1 s1; 26\ts1.m_A; //其他类只能访问到公共权限 27} 28 29//保护继承 30class Base2 31{ 32public: 33\tint m_A; 34protected: 35\tint m_B; 36private: 37\tint m_C; 38}; 39class Son2:protected Base2 40{ 41public: 42\tvoid func() 43\t{ 44\tm_A; //可访问 protected权限 45\tm_B; //可访问 protected权限 46\t//m_C; //不可访问 47\t} 48}; 49void myClass2() 50{ 51\tSon2 s; 52\t//s.m_A; //不可访问 53} 54 55//私有继承 56class Base3 57{ 58public: 59\tint m_A; 60protected: 61\tint m_B; 62private: 63\tint m_C; 64}; 65class Son3:private Base3 66{ 67public: 68\tvoid func() 69\t{ 70\tm_A; //可访问 private权限 71\tm_B; //可访问 private权限 72\t//m_C; //不可访问 73\t} 74}; 75class GrandSon3 :public Son3 76{ 77public: 78\tvoid func() 79\t{ 80\t//Son3是私有继承，所以继承Son3的属性在GrandSon3中都无法访问到 81\t//m_A; 82\t//m_B; 83\t//m_C; 84\t} 85}; 继承中的对象模型 从父类继承过来的成员，哪些属于子类对象中？\n私有成员只是被隐藏了，但是还是会继承下去\n继承中构造和析构顺序 子类继承父类后，当创建子类对象，也会调用父类的构造函数\n继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反\n继承同名成员处理方式 当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？\n 访问子类同名成员 直接访问即可 访问父类同名成员 需要加作用域  1class Base { 2public: 3\tBase() 4\t{ 5\tm_A = 100; 6\t} 7 8\tvoid func() 9\t{ 10\tcout \u0026lt;\u0026lt; \u0026#34;Base - func()调用\u0026#34; \u0026lt;\u0026lt; endl; 11\t} 12 13\tvoid func(int a) 14\t{ 15\tcout \u0026lt;\u0026lt; \u0026#34;Base - func(int a)调用\u0026#34; \u0026lt;\u0026lt; endl; 16\t} 17 18public: 19\tint m_A; 20}; 21 22 23class Son : public Base { 24public: 25\tSon() 26\t{ 27\tm_A = 200; 28\t} 29 30\t//当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数 31\t//如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域 32\tvoid func() 33\t{ 34\tcout \u0026lt;\u0026lt; \u0026#34;Son - func()调用\u0026#34; \u0026lt;\u0026lt; endl; 35\t} 36public: 37\tint m_A; 38}; 39 40void test01() 41{ 42\tSon s; 43 44\tcout \u0026lt;\u0026lt; \u0026#34;Son下的m_A = \u0026#34; \u0026lt;\u0026lt; s.m_A \u0026lt;\u0026lt; endl; 45\tcout \u0026lt;\u0026lt; \u0026#34;Base下的m_A = \u0026#34; \u0026lt;\u0026lt; s.Base::m_A \u0026lt;\u0026lt; endl; 46 47\ts.func(); 48\ts.Base::func(); 49\ts.Base::func(10); 50 51} 继承同名静态成员处理方式 继承中同名的静态成员在子类对象上如何进行访问？\n静态成员和非静态成员出现同名，处理方式一致\n 访问子类同名成员 直接访问即可 访问父类同名成员 需要加作用域   同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）\n 1class Base { 2public: 3\tstatic void func() 4\t{ 5\tcout \u0026lt;\u0026lt; \u0026#34;Base - static void func()\u0026#34; \u0026lt;\u0026lt; endl; 6\t} 7\tstatic void func(int a) 8\t{ 9\tcout \u0026lt;\u0026lt; \u0026#34;Base - static void func(int a)\u0026#34; \u0026lt;\u0026lt; endl; 10\t} 11 12\tstatic int m_A; 13}; 14 15int Base::m_A = 100; 16 17class Son : public Base { 18public: 19\tstatic void func() 20\t{ 21\tcout \u0026lt;\u0026lt; \u0026#34;Son - static void func()\u0026#34; \u0026lt;\u0026lt; endl; 22\t} 23\tstatic int m_A; 24}; 25 26int Son::m_A = 200; 27 28//同名成员属性 29void test01() 30{ 31\t//通过对象访问 32\tcout \u0026lt;\u0026lt; \u0026#34;通过对象访问： \u0026#34; \u0026lt;\u0026lt; endl; 33\tSon s; 34\tcout \u0026lt;\u0026lt; \u0026#34;Son 下 m_A = \u0026#34; \u0026lt;\u0026lt; s.m_A \u0026lt;\u0026lt; endl; 35\tcout \u0026lt;\u0026lt; \u0026#34;Base 下 m_A = \u0026#34; \u0026lt;\u0026lt; s.Base::m_A \u0026lt;\u0026lt; endl; 36 37\t//通过类名访问 38\tcout \u0026lt;\u0026lt; \u0026#34;通过类名访问： \u0026#34; \u0026lt;\u0026lt; endl; 39\tcout \u0026lt;\u0026lt; \u0026#34;Son 下 m_A = \u0026#34; \u0026lt;\u0026lt; Son::m_A \u0026lt;\u0026lt; endl; 40\tcout \u0026lt;\u0026lt; \u0026#34;Base 下 m_A = \u0026#34; \u0026lt;\u0026lt; Son::Base::m_A \u0026lt;\u0026lt; endl; 41} 42 43//同名成员函数 44void test02() 45{ 46\t//通过对象访问 47\tcout \u0026lt;\u0026lt; \u0026#34;通过对象访问： \u0026#34; \u0026lt;\u0026lt; endl; 48\tSon s; 49\ts.func(); 50\ts.Base::func(); 51 52\tcout \u0026lt;\u0026lt; \u0026#34;通过类名访问： \u0026#34; \u0026lt;\u0026lt; endl; 53\tSon::func(); 54\tSon::Base::func(); 55\t//出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问 56\tSon::Base::func(100); 57} 多继承语法 C++允许一个类继承多个类\n语法： class 子类 ：继承方式 父类1 ， 继承方式 父类2...\n多继承可能会引发父类中有同名成员出现，需要加作用域区分\nC++实际开发中不建议用多继承\n1class Base1 { 2public: 3\tBase1() 4\t{ 5\tm_A = 100; 6\t} 7public: 8\tint m_A; 9}; 10 11class Base2 { 12public: 13\tBase2() 14\t{ 15\tm_A = 200; //开始是m_B 不会出问题，但是改为mA就会出现不明确 16\t} 17public: 18\tint m_A; 19}; 20 21//语法：class 子类：继承方式 父类1 ，继承方式 父类2 22class Son : public Base2, public Base1 23{ 24public: 25\tSon() 26\t{ 27\tm_C = 300; 28\tm_D = 400; 29\t} 30public: 31\tint m_C; 32\tint m_D; 33}; 34 35 36//多继承容易产生成员同名的情况 37//通过使用类名作用域可以区分调用哪一个基类的成员 38void test01() 39{ 40\tSon s; 41\tcout \u0026lt;\u0026lt; \u0026#34;sizeof Son = \u0026#34; \u0026lt;\u0026lt; sizeof(s) \u0026lt;\u0026lt; endl; 42\tcout \u0026lt;\u0026lt; s.Base1::m_A \u0026lt;\u0026lt; endl; 43\tcout \u0026lt;\u0026lt; s.Base2::m_A \u0026lt;\u0026lt; endl; 44} 菱形继承 两个派生类继承同一个基类\n又有某个类同时继承者两个派生类\n 菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义 利用虚继承可以解决菱形继承问题  1class Animal 2{ 3public: 4\tint m_Age; 5}; 6 7//继承前加virtual关键字后，变为虚继承 8//此时公共的父类Animal称为虚基类 9class Sheep : virtual public Animal {}; 10class Tuo : virtual public Animal {}; 11class SheepTuo : public Sheep, public Tuo {}; 12 13void test01() 14{ 15\tSheepTuo st; 16\tst.Sheep::m_Age = 100; 17\tst.Tuo::m_Age = 200; 18 19\tcout \u0026lt;\u0026lt; \u0026#34;st.Sheep::m_Age = \u0026#34; \u0026lt;\u0026lt; st.Sheep::m_Age \u0026lt;\u0026lt; endl; 20\tcout \u0026lt;\u0026lt; \u0026#34;st.Tuo::m_Age = \u0026#34; \u0026lt;\u0026lt; st.Tuo::m_Age \u0026lt;\u0026lt; endl; 21\tcout \u0026lt;\u0026lt; \u0026#34;st.m_Age = \u0026#34; \u0026lt;\u0026lt; st.m_Age \u0026lt;\u0026lt; endl; 22} 多态 多态分为两类\n 静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名 动态多态: 派生类和虚函数实现运行时多态  静态多态和动态多态区别：\n 静态多态的函数地址早绑定 - 编译阶段确定函数地址 动态多态的函数地址晚绑定 - 运行阶段确定函数地址  多态满足条件\n 有继承关系 子类重写父类中的虚函数  多态使用条件\n 父类指针或引用指向子类对象  重写：函数返回值类型 函数名 参数列表 完全一致称为重写\n1class Animal 2{ 3public: 4\t//Speak函数就是虚函数 5\t//函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。 6\tvirtual void speak() 7\t{ 8\tcout \u0026lt;\u0026lt; \u0026#34;动物在说话\u0026#34; \u0026lt;\u0026lt; endl; 9\t} 10}; 11 12class Cat :public Animal 13{ 14public: 15\tvoid speak() 16\t{ 17\tcout \u0026lt;\u0026lt; \u0026#34;小猫在说话\u0026#34; \u0026lt;\u0026lt; endl; 18\t} 19}; 20 21class Dog :public Animal 22{ 23public: 24 25\tvoid speak() 26\t{ 27\tcout \u0026lt;\u0026lt; \u0026#34;小狗在说话\u0026#34; \u0026lt;\u0026lt; endl; 28\t} 29 30}; 31//我们希望传入什么对象，那么就调用什么对象的函数 32//如果函数地址在编译阶段就能确定，那么静态联编 33//如果函数地址在运行阶段才能确定，就是动态联编 34 35void DoSpeak(Animal \u0026amp; animal) 36{ 37\tanimal.speak(); 38} 39// 40//多态满足条件： 41//1、有继承关系 42//2、子类重写父类中的虚函数 43//多态使用： 44//父类指针或引用指向子类对象 45 46void test01() 47{ 48\tCat cat; 49\tDoSpeak(cat); 50 51 52\tDog dog; 53\tDoSpeak(dog); 54} 多态案例一-计算器类 1//多态实现 2//抽象计算器类 3//多态优点：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护 4class AbstractCalculator 5{ 6public : 7 8\tvirtual int getResult() 9\t{ 10\treturn 0; 11\t} 12 13\tint m_Num1; 14\tint m_Num2; 15}; 16 17//加法计算器 18class AddCalculator :public AbstractCalculator 19{ 20public: 21\tint getResult() 22\t{ 23\treturn m_Num1 + m_Num2; 24\t} 25}; 26 27//减法计算器 28class SubCalculator :public AbstractCalculator 29{ 30public: 31\tint getResult() 32\t{ 33\treturn m_Num1 - m_Num2; 34\t} 35}; 36 37//乘法计算器 38class MulCalculator :public AbstractCalculator 39{ 40public: 41\tint getResult() 42\t{ 43\treturn m_Num1 * m_Num2; 44\t} 45}; 46 47 48void test02() 49{ 50\t//创建加法计算器 51\tAbstractCalculator *abc = new AddCalculator; 52\tabc-\u0026gt;m_Num1 = 10; 53\tabc-\u0026gt;m_Num2 = 10; 54\tcout \u0026lt;\u0026lt; abc-\u0026gt;m_Num1 \u0026lt;\u0026lt; \u0026#34; + \u0026#34; \u0026lt;\u0026lt; abc-\u0026gt;m_Num2 \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; abc-\u0026gt;getResult() \u0026lt;\u0026lt; endl; 55\tdelete abc; //用完了记得销毁 56 57\t//创建减法计算器 58\tabc = new SubCalculator; 59\tabc-\u0026gt;m_Num1 = 10; 60\tabc-\u0026gt;m_Num2 = 10; 61\tcout \u0026lt;\u0026lt; abc-\u0026gt;m_Num1 \u0026lt;\u0026lt; \u0026#34; - \u0026#34; \u0026lt;\u0026lt; abc-\u0026gt;m_Num2 \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; abc-\u0026gt;getResult() \u0026lt;\u0026lt; endl; 62\tdelete abc; 63 64\t//创建乘法计算器 65\tabc = new MulCalculator; 66\tabc-\u0026gt;m_Num1 = 10; 67\tabc-\u0026gt;m_Num2 = 10; 68\tcout \u0026lt;\u0026lt; abc-\u0026gt;m_Num1 \u0026lt;\u0026lt; \u0026#34; * \u0026#34; \u0026lt;\u0026lt; abc-\u0026gt;m_Num2 \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; abc-\u0026gt;getResult() \u0026lt;\u0026lt; endl; 69\tdelete abc; 70} 71 纯虚函数和抽象类 在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容\n因此可以将虚函数改为纯虚函数\n纯虚函数语法：virtual 返回值类型 函数名 （参数列表）= 0 ;\n当类中有了纯虚函数，这个类也称为抽象类\n抽象类特点：\n 无法实例化对象 子类必须重写抽象类中的纯虚函数，否则也属于抽象类  1class Base 2{ 3public: 4\t//纯虚函数 5\t//类中只要有一个纯虚函数就称为抽象类 6\t//抽象类无法实例化对象 7\t//子类必须重写父类中的纯虚函数，否则也属于抽象类 8\tvirtual void func() = 0; 9}; 10 11class Son :public Base 12{ 13public: 14\tvirtual void func() 15\t{ 16\tcout \u0026lt;\u0026lt; \u0026#34;func调用\u0026#34; \u0026lt;\u0026lt; endl; 17\t}; 18}; 19 20void test01() 21{ 22\tBase * base = NULL; 23\t//base = new Base; // 错误，抽象类无法实例化对象 24\tbase = new Son; 25\tbase-\u0026gt;func(); 26\tdelete base;//记得销毁 27} 多态案例二-制作饮品 1//抽象制作饮品 2class AbstractDrinking { 3public: 4\t//烧水 5\tvirtual void Boil() = 0; 6\t//冲泡 7\tvirtual void Brew() = 0; 8\t//倒入杯中 9\tvirtual void PourInCup() = 0; 10\t//加入辅料 11\tvirtual void PutSomething() = 0; 12\t//规定流程 13\tvoid MakeDrink() { 14\tBoil(); 15\tBrew(); 16\tPourInCup(); 17\tPutSomething(); 18\t} 19}; 20 21//制作咖啡 22class Coffee : public AbstractDrinking { 23public: 24\t//烧水 25\tvirtual void Boil() { 26\tcout \u0026lt;\u0026lt; \u0026#34;煮农夫山泉!\u0026#34; \u0026lt;\u0026lt; endl; 27\t} 28\t//冲泡 29\tvirtual void Brew() { 30\tcout \u0026lt;\u0026lt; \u0026#34;冲泡咖啡!\u0026#34; \u0026lt;\u0026lt; endl; 31\t} 32\t//倒入杯中 33\tvirtual void PourInCup() { 34\tcout \u0026lt;\u0026lt; \u0026#34;将咖啡倒入杯中!\u0026#34; \u0026lt;\u0026lt; endl; 35\t} 36\t//加入辅料 37\tvirtual void PutSomething() { 38\tcout \u0026lt;\u0026lt; \u0026#34;加入牛奶!\u0026#34; \u0026lt;\u0026lt; endl; 39\t} 40}; 41 42//制作茶水 43class Tea : public AbstractDrinking { 44public: 45\t//烧水 46\tvirtual void Boil() { 47\tcout \u0026lt;\u0026lt; \u0026#34;煮自来水!\u0026#34; \u0026lt;\u0026lt; endl; 48\t} 49\t//冲泡 50\tvirtual void Brew() { 51\tcout \u0026lt;\u0026lt; \u0026#34;冲泡茶叶!\u0026#34; \u0026lt;\u0026lt; endl; 52\t} 53\t//倒入杯中 54\tvirtual void PourInCup() { 55\tcout \u0026lt;\u0026lt; \u0026#34;将茶水倒入杯中!\u0026#34; \u0026lt;\u0026lt; endl; 56\t} 57\t//加入辅料 58\tvirtual void PutSomething() { 59\tcout \u0026lt;\u0026lt; \u0026#34;加入枸杞!\u0026#34; \u0026lt;\u0026lt; endl; 60\t} 61}; 62 63//业务函数 64void DoWork(AbstractDrinking* drink) { 65\tdrink-\u0026gt;MakeDrink(); 66\tdelete drink; 67} 68 69void test01() { 70\tDoWork(new Coffee); 71\tcout \u0026lt;\u0026lt; \u0026#34;--------------\u0026#34; \u0026lt;\u0026lt; endl; 72\tDoWork(new Tea); 73} 虚析构和纯虚析构 多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码\n解决方式：将父类中的析构函数改为虚析构或者纯虚析构\n虚析构和纯虚析构共性：\n 可以解决父类指针释放子类对象 都需要有具体的函数实现  虚析构和纯虚析构区别：\n 如果是纯虚析构，该类属于抽象类，无法实例化对象  虚析构语法：\nvirtual ~类名(){}\n纯虚析构语法：\n virtual ~类名() = 0;\n类名::~类名(){}\n​\t1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象\n​\t2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构\n​\t3. 拥有纯虚析构函数的类也属于抽象类\n1class Animal { 2public: 3 4\tAnimal() 5\t{ 6\tcout \u0026lt;\u0026lt; \u0026#34;Animal 构造函数调用！\u0026#34; \u0026lt;\u0026lt; endl; 7\t} 8\tvirtual void Speak() = 0; 9 10\t//析构函数加上virtual关键字，变成虚析构函数 11\t//virtual ~Animal() 12\t//{ 13\t//\tcout \u0026lt;\u0026lt; \u0026#34;Animal虚析构函数调用！\u0026#34; \u0026lt;\u0026lt; endl; 14\t//} 15 16 17\tvirtual ~Animal() = 0; 18}; 19 20Animal::~Animal() 21{ 22\tcout \u0026lt;\u0026lt; \u0026#34;Animal 纯虚析构函数调用！\u0026#34; \u0026lt;\u0026lt; endl; 23} 24 25//和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。 26 27class Cat : public Animal { 28public: 29\tCat(string name) 30\t{ 31\tcout \u0026lt;\u0026lt; \u0026#34;Cat构造函数调用！\u0026#34; \u0026lt;\u0026lt; endl; 32\tm_Name = new string(name); 33\t} 34\tvirtual void Speak() 35\t{ 36\tcout \u0026lt;\u0026lt; *m_Name \u0026lt;\u0026lt; \u0026#34;小猫在说话!\u0026#34; \u0026lt;\u0026lt; endl; 37\t} 38\t~Cat() 39\t{ 40\tcout \u0026lt;\u0026lt; \u0026#34;Cat析构函数调用!\u0026#34; \u0026lt;\u0026lt; endl; 41\tif (this-\u0026gt;m_Name != NULL) { 42\tdelete m_Name; 43\tm_Name = NULL; 44\t} 45\t} 46 47public: 48\tstring *m_Name; 49}; 50 51void test01() 52{ 53\tAnimal *animal = new Cat(\u0026#34;Tom\u0026#34;); 54\tanimal-\u0026gt;Speak(); 55 56\t//通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏 57\t//怎么解决？给基类增加一个虚析构函数 58\t//虚析构函数就是用来解决通过父类指针释放子类对象 59\tdelete animal; 60} 多态案例三-电脑组装 14.文件操作 程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放\n通过文件可以将数据持久化\nC++中对文件操作需要包含头文件 \u0026lt; fstream \u0026gt;\n文件类型分为两种：\n 文本文件 - 文件以文本的ASCII码形式存储在计算机中 二进制文件 - 文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂它们  操作文件的三大类:\n ofstream：写操作 ifstream： 读操作 fstream ： 读写操作  文本文件 写文件 写文件步骤如下：\n  包含头文件\n#include \u0026lt;fstream\u0026gt;\n  创建流对象\nofstream ofs;\n  打开文件\nofs.open(\u0026ldquo;文件路径\u0026rdquo;,打开方式);\n  写数据\nofs \u0026laquo; \u0026ldquo;写入的数据\u0026rdquo;;\n  关闭文件\nofs.close();\n  文件打开方式：\n   打开方式 解释     ios::in 为读文件而打开文件   ios::out 为写文件而打开文件   ios::ate 初始位置：文件尾   ios::app 追加方式写文件   ios::trunc 如果文件存在先删除，再创建   ios::binary 二进制方式    注意： 文件打开方式可以配合使用，利用|操作符\n**例如：**用二进制方式写文件 ios::binary | ios:: out\n示例：\n1#include \u0026lt;fstream\u0026gt;2 3void test01() 4{ 5\tofstream ofs; 6\tofs.open(\u0026#34;test.txt\u0026#34;, ios::out); 7 8\tofs \u0026lt;\u0026lt; \u0026#34;姓名：张三\u0026#34; \u0026lt;\u0026lt; endl; 9\tofs \u0026lt;\u0026lt; \u0026#34;性别：男\u0026#34; \u0026lt;\u0026lt; endl; 10\tofs \u0026lt;\u0026lt; \u0026#34;年龄：18\u0026#34; \u0026lt;\u0026lt; endl; 11 12\tofs.close(); 13} 14 15int main() { 16 17\ttest01(); 18 19\tsystem(\u0026#34;pause\u0026#34;); 20 21\treturn 0; 22} 总结：\n 文件操作必须包含头文件 fstream 读文件可以利用 ofstream ，或者fstream类 打开文件时候需要指定操作文件的路径，以及打开方式 利用\u0026laquo;可以向文件中写数据 操作完毕，要关闭文件  读文件 读文件步骤如下：\n  包含头文件\n#include \u0026lt;fstream\u0026gt;\n  创建流对象\nifstream ifs;\n  打开文件并判断文件是否打开成功\nifs.open(\u0026ldquo;文件路径\u0026rdquo;,打开方式);\n  读数据\n四种方式读取\n  关闭文件\nifs.close();示例：\n1#include \u0026lt;fstream\u0026gt;2#include \u0026lt;string\u0026gt;3void test01() 4{ 5\tifstream ifs; 6\tifs.open(\u0026#34;test.txt\u0026#34;, ios::in); 7 8\tif (!ifs.is_open()) 9\t{ 10 cout \u0026lt;\u0026lt; \u0026#34;文件打开失败\u0026#34; \u0026lt;\u0026lt; endl; 11 return; 12\t} 13 14\t//第一种方式 15\t//char buf[1024] = { 0 }; 16\t//while (ifs \u0026gt;\u0026gt; buf) 17\t//{ 18\t//\tcout \u0026lt;\u0026lt; buf \u0026lt;\u0026lt; endl; 19\t//} 20 21\t//第二种 22\t//char buf[1024] = { 0 }; 23\t//while (ifs.getline(buf,sizeof(buf))) 24\t//{ 25\t//\tcout \u0026lt;\u0026lt; buf \u0026lt;\u0026lt; endl; 26\t//} 27 28\t//第三种 29\t//string buf; 30\t//while (getline(ifs, buf)) 31\t//{ 32\t//\tcout \u0026lt;\u0026lt; buf \u0026lt;\u0026lt; endl; 33\t//} 34 35\tchar c; 36\twhile ((c = ifs.get()) != EOF) 37\t{ 38 cout \u0026lt;\u0026lt; c; 39\t} 40 41\tifs.close(); 42 43 44} 45 46int main() { 47 48\ttest01(); 49 50\tsystem(\u0026#34;pause\u0026#34;); 51 52\treturn 0; 53} 总结：\n 读文件可以利用 ifstream ，或者fstream类 利用is_open函数可以判断文件是否打开成功 close 关闭文件    二进制文件 以二进制的方式对文件进行读写操作\n打开方式要指定为 ios::binary\n写文件 二进制方式写文件主要利用流对象调用成员函数write\n函数原型 ：ostream\u0026amp; write(const char * buffer,int len);\n参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数\n1#include \u0026lt;fstream\u0026gt;2#include \u0026lt;string\u0026gt;3 4class Person 5{ 6public: 7\tchar m_Name[64]; 8\tint m_Age; 9}; 10 11//二进制文件 写文件 12void test01() 13{ 14\t//1、包含头文件 15 16\t//2、创建输出流对象 17\tofstream ofs(\u0026#34;person.txt\u0026#34;, ios::out | ios::binary); 18\t19\t//3、打开文件 20\t//ofs.open(\u0026#34;person.txt\u0026#34;, ios::out | ios::binary); 21 22\tPerson p = {\u0026#34;张三\u0026#34; , 18}; 23 24\t//4、写文件 25\tofs.write((const char *)\u0026amp;p, sizeof(p)); 26 27\t//5、关闭文件 28\tofs.close(); 29} 读文件 二进制方式读文件主要利用流对象调用成员函数read\n函数原型：istream\u0026amp; read(char *buffer,int len);\n参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数\n示例：\n1#include \u0026lt;fstream\u0026gt;2#include \u0026lt;string\u0026gt;3 4class Person 5{ 6public: 7\tchar m_Name[64]; 8\tint m_Age; 9}; 10 11void test01() 12{ 13\tifstream ifs(\u0026#34;person.txt\u0026#34;, ios::in | ios::binary); 14\tif (!ifs.is_open()) 15\t{ 16\tcout \u0026lt;\u0026lt; \u0026#34;文件打开失败\u0026#34; \u0026lt;\u0026lt; endl; 17\t} 18 19\tPerson p; 20\tifs.read((char *)\u0026amp;p, sizeof(p)); 21 22\tcout \u0026lt;\u0026lt; \u0026#34;姓名： \u0026#34; \u0026lt;\u0026lt; p.m_Name \u0026lt;\u0026lt; \u0026#34; 年龄： \u0026#34; \u0026lt;\u0026lt; p.m_Age \u0026lt;\u0026lt; endl; 23} 15.模板 模板的概念 模板就是建立通用的模具，大大提高复用性\n函数模板   C++另一种编程思想称为 泛型编程，主要利用的技术就是模板\n  C++提供两种模板机制:函数模板和类模板\n  函数模板语法 建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个虚拟的类型来代表。\n语法：\n1template\u0026lt;typename T\u0026gt; 2函数声明或定义 解释：\ntemplate \u0026mdash; 声明创建模板\ntypename \u0026mdash; 表面其后面的符号是一种数据类型，可以用class代替\nT \u0026mdash; 通用的数据类型，名称可以替换，通常为大写字母\n示例：\n1//交换整型函数 2void swapInt(int\u0026amp; a, int\u0026amp; b) { 3\tint temp = a; 4\ta = b; 5\tb = temp; 6} 7 8//交换浮点型函数 9void swapDouble(double\u0026amp; a, double\u0026amp; b) { 10\tdouble temp = a; 11\ta = b; 12\tb = temp; 13} 14 15//利用模板提供通用的交换函数 16template\u0026lt;typename T\u0026gt; 17void mySwap(T\u0026amp; a, T\u0026amp; b) 18{ 19\tT temp = a; 20\ta = b; 21\tb = temp; 22} 23 24void test01() 25{ 26\tint a = 10; 27\tint b = 20; 28\t29\t//swapInt(a, b); 30 31\t//利用模板实现交换 32\t//1、自动类型推导 33\tmySwap(a, b); 34 35\t//2、显示指定类型 36\tmySwap\u0026lt;int\u0026gt;(a, b); 37 38\tcout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; 39\tcout \u0026lt;\u0026lt; \u0026#34;b = \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; 40 41} 总结：\n 函数模板利用关键字 template 使用函数模板有两种方式：自动类型推导、显示指定类型 模板的目的是为了提高复用性，将类型参数化  函数模板注意事项   自动类型推导，必须推导出一致的数据类型T,才可以使用\n  模板必须要确定出T的数据类型，才可以使用\n  1//利用模板提供通用的交换函数 2template\u0026lt;class T\u0026gt; 3void mySwap(T\u0026amp; a, T\u0026amp; b) 4{ 5\tT temp = a; 6\ta = b; 7\tb = temp; 8} 9 10 11// 1、自动类型推导，必须推导出一致的数据类型T,才可以使用 12void test01() 13{ 14\tint a = 10; 15\tint b = 20; 16\tchar c = \u0026#39;c\u0026#39;; 17 18\tmySwap(a, b); // 正确，可以推导出一致的T 19\t//mySwap(a, c); // 错误，推导不出一致的T类型 20} 21 22 23// 2、模板必须要确定出T的数据类型，才可以使用 24template\u0026lt;class T\u0026gt; 25void func() 26{ 27\tcout \u0026lt;\u0026lt; \u0026#34;func 调用\u0026#34; \u0026lt;\u0026lt; endl; 28} 29 30void test02() 31{ 32\t//func(); //错误，模板不能独立使用，必须确定出T的类型 33\tfunc\u0026lt;int\u0026gt;(); //利用显示指定类型的方式，给T一个类型，才可以使用该模板 34} 函数模板案例 案例描述：\n 利用函数模板封装一个排序的函数，可以对不同数据类型数组进行排序 排序规则从大到小，排序算法为选择排序 分别利用char数组和int数组进行测试  1//交换的函数模板 2template\u0026lt;typename T\u0026gt; 3void mySwap(T \u0026amp;a, T\u0026amp;b) 4{ 5\tT temp = a; 6\ta = b; 7\tb = temp; 8} 9 10 11template\u0026lt;class T\u0026gt; // 也可以替换成typename 12//利用选择排序，进行对数组从大到小的排序 13void mySort(T arr[], int len) 14{ 15\tfor (int i = 0; i \u0026lt; len; i++) 16\t{ 17\tint max = i; //最大数的下标 18\tfor (int j = i + 1; j \u0026lt; len; j++) 19\t{ 20\tif (arr[max] \u0026lt; arr[j]) 21\t{ 22\tmax = j; 23\t} 24\t} 25\tif (max != i) //如果最大数的下标不是i，交换两者 26\t{ 27\tmySwap(arr[max], arr[i]); 28\t} 29\t} 30} 31template\u0026lt;typename T\u0026gt; 32void printArray(T arr[], int len) { 33 34\tfor (int i = 0; i \u0026lt; len; i++) { 35\tcout \u0026lt;\u0026lt; arr[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 36\t} 37\tcout \u0026lt;\u0026lt; endl; 38} 39void test01() 40{ 41\t//测试char数组 42\tchar charArr[] = \u0026#34;bdcfeagh\u0026#34;; 43\tint num = sizeof(charArr) / sizeof(char); 44\tmySort(charArr, num); 45\tprintArray(charArr, num); 46} 47 48void test02() 49{ 50\t//测试int数组 51\tint intArr[] = { 7, 5, 8, 1, 3, 9, 2, 4, 6 }; 52\tint num = sizeof(intArr) / sizeof(int); 53\tmySort(intArr, num); 54\tprintArray(intArr, num); 55} 普通函数与函数模板的区别 普通函数与函数模板区别：\n 普通函数调用时可以发生自动类型转换（隐式类型转换） 函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换 如果利用显示指定类型的方式，可以发生隐式类型转换  1//普通函数 2int myAdd01(int a, int b) 3{ 4\treturn a + b; 5} 6 7//函数模板 8template\u0026lt;class T\u0026gt; 9T myAdd02(T a, T b) 10{ 11\treturn a + b; 12} 13 14//使用函数模板时，如果用自动类型推导，不会发生自动类型转换,即隐式类型转换 15void test01() 16{ 17\tint a = 10; 18\tint b = 20; 19\tchar c = \u0026#39;c\u0026#39;; 20\t21\tcout \u0026lt;\u0026lt; myAdd01(a, c) \u0026lt;\u0026lt; endl; //正确，将char类型的\u0026#39;c\u0026#39;隐式转换为int类型 \u0026#39;c\u0026#39; 对应 ASCII码 99 22 23\t//myAdd02(a, c); // 报错，使用自动类型推导时，不会发生隐式类型转换 24 25\tmyAdd02\u0026lt;int\u0026gt;(a, c); //正确，如果用显示指定类型，可以发生隐式类型转换 26} 普通函数与函数模板的调用规则 调用规则如下：\n 如果函数模板和普通函数都可以实现，优先调用普通函数 可以通过空模板参数列表来强制调用函数模板 函数模板也可以发生重载 如果函数模板可以产生更好的匹配,优先调用函数模板  总结：既然提供了函数模板，最好就不要提供普通函数，否则容易出现二义性\n1//普通函数与函数模板调用规则 2void myPrint(int a, int b) 3{ 4\tcout \u0026lt;\u0026lt; \u0026#34;调用的普通函数\u0026#34; \u0026lt;\u0026lt; endl; 5} 6 7template\u0026lt;typename T\u0026gt; 8void myPrint(T a, T b) 9{ 10\tcout \u0026lt;\u0026lt; \u0026#34;调用的模板\u0026#34; \u0026lt;\u0026lt; endl; 11} 12 13template\u0026lt;typename T\u0026gt; 14void myPrint(T a, T b, T c) 15{ 16\tcout \u0026lt;\u0026lt; \u0026#34;调用重载的模板\u0026#34; \u0026lt;\u0026lt; endl; 17} 18 19void test01() 20{ 21\t//1、如果函数模板和普通函数都可以实现，优先调用普通函数 22\t// 注意 如果告诉编译器 普通函数是有的，但只是声明没有实现，或者不在当前文件内实现，就会报错找不到 23\tint a = 10; 24\tint b = 20; 25\tmyPrint(a, b); //调用普通函数 26 27\t//2、可以通过空模板参数列表来强制调用函数模板 28\tmyPrint\u0026lt;\u0026gt;(a, b); //调用函数模板 29 30\t//3、函数模板也可以发生重载 31\tint c = 30; 32\tmyPrint(a, b, c); //调用重载的函数模板 33 34\t//4、 如果函数模板可以产生更好的匹配,优先调用函数模板 35\tchar c1 = \u0026#39;a\u0026#39;; 36\tchar c2 = \u0026#39;b\u0026#39;; 37\tmyPrint(c1, c2); //调用函数模板 38} 模板的局限性 例如：\n1\ttemplate\u0026lt;class T\u0026gt; 2\tvoid f(T a, T b) 3\t{ 4 a = b; 5 } 在上述代码中提供的赋值操作，如果传入的a和b是一个数组，就无法实现了\n再例如：\n1\ttemplate\u0026lt;class T\u0026gt; 2\tvoid f(T a, T b) 3\t{ 4 if(a \u0026gt; b) { ... } 5 } 在上述代码中，如果T的数据类型传入的是像Person这样的自定义数据类型，也无法正常运行\n因此C++为了解决这种问题，提供模板的重载，可以为这些特定的类型提供具体化的模板\n1//普通函数模板 2template\u0026lt;class T\u0026gt; 3bool myCompare(T\u0026amp; a, T\u0026amp; b) 4{ 5\tif (a == b) 6\t{ 7\treturn true; 8\t} 9\telse 10\t{ 11\treturn false; 12\t} 13} 14 15 16//具体化，显示具体化的原型和定意思以template\u0026lt;\u0026gt;开头，并通过名称来指出类型 17//具体化优先于常规模板 18template\u0026lt;\u0026gt; bool myCompare(Person \u0026amp;p1, Person \u0026amp;p2) 19{ 20\tif ( p1.m_Name == p2.m_Name \u0026amp;\u0026amp; p1.m_Age == p2.m_Age) 21\t{ 22\treturn true; 23\t} 24\telse 25\t{ 26\treturn false; 27\t} 28} 29 30void test01() 31{ 32\tint a = 10; 33\tint b = 20; 34\t//内置数据类型可以直接使用通用的函数模板 35\tbool ret = myCompare(a, b); 36\tif (ret) 37\t{ 38\tcout \u0026lt;\u0026lt; \u0026#34;a == b \u0026#34; \u0026lt;\u0026lt; endl; 39\t} 40\telse 41\t{ 42\tcout \u0026lt;\u0026lt; \u0026#34;a != b \u0026#34; \u0026lt;\u0026lt; endl; 43\t} 44} 45 46void test02() 47{ 48\tPerson p1(\u0026#34;Tom\u0026#34;, 10); 49\tPerson p2(\u0026#34;Tom\u0026#34;, 10); 50\t//自定义数据类型，不会调用普通的函数模板 51\t//可以创建具体化的Person数据类型的模板，用于特殊处理这个类型 52\tbool ret = myCompare(p1, p2); 53\tif (ret) 54\t{ 55\tcout \u0026lt;\u0026lt; \u0026#34;p1 == p2 \u0026#34; \u0026lt;\u0026lt; endl; 56\t} 57\telse 58\t{ 59\tcout \u0026lt;\u0026lt; \u0026#34;p1 != p2 \u0026#34; \u0026lt;\u0026lt; endl; 60\t} 61} 类模板 类模板语法 建立一个通用类，类中的成员 数据类型可以不具体制定，用一个虚拟的类型来代表。\n语法：\n1template\u0026lt;typename T\u0026gt; 2类 解释：\ntemplate \u0026mdash; 声明创建模板\ntypename \u0026mdash; 表面其后面的符号是一种数据类型，可以用class代替\nT \u0026mdash; 通用的数据类型，名称可以替换，通常为大写字母\n示例：\n1#include \u0026lt;string\u0026gt;2//类模板 3template\u0026lt;class NameType, class AgeType\u0026gt; 4class Person 5{ 6public: 7\tPerson(NameType name, AgeType age) 8\t{ 9\tthis-\u0026gt;mName = name; 10\tthis-\u0026gt;mAge = age; 11\t} 12\tvoid showPerson() 13\t{ 14\tcout \u0026lt;\u0026lt; \u0026#34;name: \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;mName \u0026lt;\u0026lt; \u0026#34; age: \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;mAge \u0026lt;\u0026lt; endl; 15\t} 16public: 17\tNameType mName; 18\tAgeType mAge; 19}; 20 21void test01() 22{ 23\t// 指定NameType 为string类型，AgeType 为 int类型 24\tPerson\u0026lt;string, int\u0026gt;P1(\u0026#34;孙悟空\u0026#34;, 999); 25\tP1.showPerson(); 26} 类模板与函数模板区别 类模板与函数模板区别主要有两点：\n 类模板没有自动类型推导的使用方式 类模板在模板参数列表中可以有默认参数  1#include \u0026lt;string\u0026gt;2//类模板 3template\u0026lt;class NameType, class AgeType = int\u0026gt; 4class Person 5{ 6public: 7\tPerson(NameType name, AgeType age) 8\t{ 9\tthis-\u0026gt;mName = name; 10\tthis-\u0026gt;mAge = age; 11\t} 12\tvoid showPerson() 13\t{ 14\tcout \u0026lt;\u0026lt; \u0026#34;name: \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;mName \u0026lt;\u0026lt; \u0026#34; age: \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;mAge \u0026lt;\u0026lt; endl; 15\t} 16public: 17\tNameType mName; 18\tAgeType mAge; 19}; 20 21//1、类模板没有自动类型推导的使用方式 22void test01() 23{ 24\t// Person p(\u0026#34;孙悟空\u0026#34;, 1000); // 错误 类模板使用时候，不可以用自动类型推导 25\tPerson \u0026lt;string ,int\u0026gt;p(\u0026#34;孙悟空\u0026#34;, 1000); //必须使用显示指定类型的方式，使用类模板 26\tp.showPerson(); 27} 28 29//2、类模板在模板参数列表中可以有默认参数 30void test02() 31{ 32\tPerson \u0026lt;string\u0026gt; p(\u0026#34;猪八戒\u0026#34;, 999); //类模板中的模板参数列表 可以指定默认参数 33\tp.showPerson(); 34} 类模板中成员函数创建时机 类模板中成员函数和普通类中成员函数创建时机是有区别的：\n 普通类中的成员函数一开始就可以创建 类模板中的成员函数在调用时才创建  类模板对象做函数参数 一共有三种传入方式：\n 指定传入的类型 \u0026mdash; 直接显示对象的数据类型 参数模板化 \u0026mdash; 将对象中的参数变为模板进行传递 整个类模板化 \u0026mdash; 将这个对象类型 模板化进行传递  1//1、指定传入的类型 2void printPerson1(Person\u0026lt;string, int\u0026gt; \u0026amp;p) 3{ 4\tp.showPerson(); 5} 6void test01() 7{ 8\tPerson \u0026lt;string, int \u0026gt;p(\u0026#34;孙悟空\u0026#34;, 100); 9\tprintPerson1(p); 10} 11 12//2、参数模板化 13template \u0026lt;class T1, class T2\u0026gt; 14void printPerson2(Person\u0026lt;T1, T2\u0026gt;\u0026amp;p) 15{ 16\tp.showPerson(); 17\tcout \u0026lt;\u0026lt; \u0026#34;T1的类型为： \u0026#34; \u0026lt;\u0026lt; typeid(T1).name() \u0026lt;\u0026lt; endl; 18\tcout \u0026lt;\u0026lt; \u0026#34;T2的类型为： \u0026#34; \u0026lt;\u0026lt; typeid(T2).name() \u0026lt;\u0026lt; endl; 19} 20void test02() 21{ 22\tPerson \u0026lt;string, int \u0026gt;p(\u0026#34;猪八戒\u0026#34;, 90); 23\tprintPerson2(p); 24} 25 26//3、整个类模板化 27template\u0026lt;class T\u0026gt; 28void printPerson3(T \u0026amp; p) 29{ 30\tcout \u0026lt;\u0026lt; \u0026#34;T的类型为： \u0026#34; \u0026lt;\u0026lt; typeid(T).name() \u0026lt;\u0026lt; endl; 31\tp.showPerson(); 32 33} 34void test03() 35{ 36\tPerson \u0026lt;string, int \u0026gt;p(\u0026#34;唐僧\u0026#34;, 30); 37\tprintPerson3(p); 38} 类模板与继承 当类模板碰到继承时，需要注意一下几点：\n 当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型 如果不指定，编译器无法给子类分配内存 如果想灵活指定出父类中T的类型，子类也需变为类模板  1template\u0026lt;class T\u0026gt; 2class Base 3{ 4\tT m; 5}; 6 7//class Son:public Base //错误，c++编译需要给子类分配内存，必须知道父类中T的类型才可以向下继承 8class Son :public Base\u0026lt;int\u0026gt; //必须指定一个类型 9{ 10}; 11void test01() 12{ 13\tSon c; 14} 15 16//类模板继承类模板 ,可以用T2指定父类中的T类型 17template\u0026lt;class T1, class T2\u0026gt; 18class Son2 :public Base\u0026lt;T2\u0026gt; 19{ 20public: 21\tSon2() 22\t{ 23\tcout \u0026lt;\u0026lt; typeid(T1).name() \u0026lt;\u0026lt; endl; 24\tcout \u0026lt;\u0026lt; typeid(T2).name() \u0026lt;\u0026lt; endl; 25\t} 26}; 27 28void test02() 29{ 30\tSon2\u0026lt;int, char\u0026gt; child1; 31} 类模板成员函数 类外实现 1#include \u0026lt;string\u0026gt;2 3//类模板中成员函数类外实现 4template\u0026lt;class T1, class T2\u0026gt; 5class Person { 6public: 7\t//成员函数类内声明 8\tPerson(T1 name, T2 age); 9\tvoid showPerson(); 10 11public: 12\tT1 m_Name; 13\tT2 m_Age; 14}; 15 16//构造函数 类外实现 17template\u0026lt;class T1, class T2\u0026gt; 18Person\u0026lt;T1, T2\u0026gt;::Person(T1 name, T2 age) { 19\tthis-\u0026gt;m_Name = name; 20\tthis-\u0026gt;m_Age = age; 21} 22 23//成员函数 类外实现 24template\u0026lt;class T1, class T2\u0026gt; 25void Person\u0026lt;T1, T2\u0026gt;::showPerson() { 26\tcout \u0026lt;\u0026lt; \u0026#34;姓名: \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;m_Name \u0026lt;\u0026lt; \u0026#34; 年龄:\u0026#34; \u0026lt;\u0026lt; this-\u0026gt;m_Age \u0026lt;\u0026lt; endl; 27} 28 29void test01() 30{ 31\tPerson\u0026lt;string, int\u0026gt; p(\u0026#34;Tom\u0026#34;, 20); 32\tp.showPerson(); 33} 类模板分文件编写 问题：\n 类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到  解决：\n 解决方式1：直接包含.cpp源文件 解决方式2：将声明和实现写到同一个文件中，并更改后缀名为.hpp，hpp是约定的名称，并不是强制  主流的解决方式是第二种，将类模板成员函数写到一起，并将后缀名改为.hpp\nperson.hpp中代码：\n1#pragma once 2#include \u0026lt;iostream\u0026gt;3using namespace std; 4#include \u0026lt;string\u0026gt;5 6template\u0026lt;class T1, class T2\u0026gt; 7class Person { 8public: 9\tPerson(T1 name, T2 age); 10\tvoid showPerson(); 11public: 12\tT1 m_Name; 13\tT2 m_Age; 14}; 15 16//构造函数 类外实现 17template\u0026lt;class T1, class T2\u0026gt; 18Person\u0026lt;T1, T2\u0026gt;::Person(T1 name, T2 age) { 19\tthis-\u0026gt;m_Name = name; 20\tthis-\u0026gt;m_Age = age; 21} 22 23//成员函数 类外实现 24template\u0026lt;class T1, class T2\u0026gt; 25void Person\u0026lt;T1, T2\u0026gt;::showPerson() { 26\tcout \u0026lt;\u0026lt; \u0026#34;姓名: \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;m_Name \u0026lt;\u0026lt; \u0026#34; 年龄:\u0026#34; \u0026lt;\u0026lt; this-\u0026gt;m_Age \u0026lt;\u0026lt; endl; 27} 类模板分文件编写.cpp中代码\n1#include\u0026lt;iostream\u0026gt;2using namespace std; 3 4//#include \u0026#34;person.h\u0026#34; 5#include \u0026#34;person.cpp\u0026#34; //解决方式1，包含cpp源文件6 7//解决方式2，将声明和实现写到一起，文件后缀名改为.hpp 8#include \u0026#34;person.hpp\u0026#34;9void test01() 10{ 11\tPerson\u0026lt;string, int\u0026gt; p(\u0026#34;Tom\u0026#34;, 10); 12\tp.showPerson(); 13} 14 15int main() { 16 17\ttest01(); 18 19\tsystem(\u0026#34;pause\u0026#34;); 20 21\treturn 0; 22} 类模板与友元 全局函数类内实现 - 直接在类内声明友元即可\n全局函数类外实现 - 需要提前让编译器知道全局函数的存在\n建议全局函数做类内实现，用法简单，而且编译器可以直接识别\n1#include \u0026lt;string\u0026gt;2 3//2、全局函数配合友元 类外实现 - 先做函数模板声明，下方在做函数模板定义，在做友元 4template\u0026lt;class T1, class T2\u0026gt; class Person; 5 6//如果声明了函数模板，可以将实现写到后面，否则需要将实现体写到类的前面让编译器提前看到 7//template\u0026lt;class T1, class T2\u0026gt; void printPerson2(Person\u0026lt;T1, T2\u0026gt; \u0026amp; p); 8 9template\u0026lt;class T1, class T2\u0026gt; 10void printPerson2(Person\u0026lt;T1, T2\u0026gt; \u0026amp; p) 11{ 12\tcout \u0026lt;\u0026lt; \u0026#34;类外实现 ---- 姓名： \u0026#34; \u0026lt;\u0026lt; p.m_Name \u0026lt;\u0026lt; \u0026#34; 年龄：\u0026#34; \u0026lt;\u0026lt; p.m_Age \u0026lt;\u0026lt; endl; 13} 14 15template\u0026lt;class T1, class T2\u0026gt; 16class Person 17{ 18\t//1、全局函数配合友元 类内实现 19\tfriend void printPerson(Person\u0026lt;T1, T2\u0026gt; \u0026amp; p) 20\t{ 21\tcout \u0026lt;\u0026lt; \u0026#34;姓名： \u0026#34; \u0026lt;\u0026lt; p.m_Name \u0026lt;\u0026lt; \u0026#34; 年龄：\u0026#34; \u0026lt;\u0026lt; p.m_Age \u0026lt;\u0026lt; endl; 22\t} 23 24 25\t//全局函数配合友元 类外实现 26\tfriend void printPerson2\u0026lt;\u0026gt;(Person\u0026lt;T1, T2\u0026gt; \u0026amp; p); 27 28public: 29 30\tPerson(T1 name, T2 age) 31\t{ 32\tthis-\u0026gt;m_Name = name; 33\tthis-\u0026gt;m_Age = age; 34\t} 35 36 37private: 38\tT1 m_Name; 39\tT2 m_Age; 40 41}; 42 43//1、全局函数在类内实现 44void test01() 45{ 46\tPerson \u0026lt;string, int \u0026gt;p(\u0026#34;Tom\u0026#34;, 20); 47\tprintPerson(p); 48} 49 50 51//2、全局函数在类外实现 52void test02() 53{ 54\tPerson \u0026lt;string, int \u0026gt;p(\u0026#34;Jerry\u0026#34;, 30); 55\tprintPerson2(p); 56} 16.STL初识 STL基本概念  STL(Standard Template Library,标准模板库) STL 从广义上分为: 容器(container) 算法(algorithm) 迭代器(iterator) 容器和算法之间通过迭代器进行无缝连接。 STL 几乎所有的代码都采用了模板类或者模板函数  STL六大组件 STL大体分为六大组件，分别是:容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器\n 容器：各种数据结构，如vector、list、deque、set、map等,用来存放数据。 算法：各种常用的算法，如sort、find、copy、for_each等 迭代器：扮演了容器与算法之间的胶合剂。 仿函数：行为类似函数，可作为算法的某种策略。 适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。 空间配置器：负责空间的配置与管理。  STL中容器、算法、迭代器 **容器：**置物之所也\nSTL容器就是将运用最广泛的一些数据结构实现出来\n常用的数据结构：数组, 链表,树, 栈, 队列, 集合, 映射表 等\n这些容器分为序列式容器和关联式容器两种:\n​\t序列式容器:强调值的排序，序列式容器中的每个元素均有固定的位置。 ​\t关联式容器:二叉树结构，各元素之间没有严格的物理上的顺序关系\n**算法：**问题之解法也\n有限的步骤，解决逻辑或数学上的问题，这一门学科我们叫做算法(Algorithms)\n算法分为:质变算法和非质变算法。\n质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等\n非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等\n**迭代器：**容器和算法之间粘合剂\n提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。\n每个容器都有自己专属的迭代器\n迭代器使用非常类似于指针，初学阶段我们可以先理解迭代器为指针\n迭代器种类：\n   种类 功能 支持运算     输入迭代器 对数据的只读访问 只读，支持++、==、！=   输出迭代器 对数据的只写访问 只写，支持++   前向迭代器 读写操作，并能向前推进迭代器 读写，支持++、==、！=   双向迭代器 读写操作，并能向前和向后操作 读写，支持++、\u0026ndash;，   随机访问迭代器 读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器 读写，支持++、\u0026ndash;、[n]、-n、\u0026lt;、\u0026lt;=、\u0026gt;、\u0026gt;=    常用的容器中迭代器种类为双向迭代器，和随机访问迭代器\n容器算法迭代器初识 vector存放内置数据类型 1#include \u0026lt;vector\u0026gt;2#include \u0026lt;algorithm\u0026gt;3 4void MyPrint(int val) 5{ 6\tcout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; endl; 7} 8 9void test01() { 10 11\t//创建vector容器对象，并且通过模板参数指定容器中存放的数据的类型 12\tvector\u0026lt;int\u0026gt; v; 13\t//向容器中放数据 14\tv.push_back(10); 15\tv.push_back(20); 16\tv.push_back(30); 17\tv.push_back(40); 18 19\t//每一个容器都有自己的迭代器，迭代器是用来遍历容器中的元素 20\t//v.begin()返回迭代器，这个迭代器指向容器中第一个数据 21\t//v.end()返回迭代器，这个迭代器指向容器元素的最后一个元素的下一个位置 22\t//vector\u0026lt;int\u0026gt;::iterator 拿到vector\u0026lt;int\u0026gt;这种容器的迭代器类型 23 24\tvector\u0026lt;int\u0026gt;::iterator pBegin = v.begin(); 25\tvector\u0026lt;int\u0026gt;::iterator pEnd = v.end(); 26 27\t//第一种遍历方式： 28\twhile (pBegin != pEnd) { 29\tcout \u0026lt;\u0026lt; *pBegin \u0026lt;\u0026lt; endl; 30\tpBegin++; 31\t} 32 33\t34\t//第二种遍历方式： 35\tfor (vector\u0026lt;int\u0026gt;::iterator it = v.begin(); it != v.end(); it++) { 36\tcout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl; 37\t} 38\tcout \u0026lt;\u0026lt; endl; 39 40\t//第三种遍历方式： 41\t//使用STL提供标准遍历算法 头文件 algorithm 42\tfor_each(v.begin(), v.end(), MyPrint); 43} Vector存放自定义数据类型 1//存放对象 2void test01() { 3 4\tvector\u0026lt;Person\u0026gt; v; 5 6\t//创建数据 7\tPerson p1(\u0026#34;aaa\u0026#34;, 10); 8\tPerson p2(\u0026#34;bbb\u0026#34;, 20); 9\tPerson p3(\u0026#34;ccc\u0026#34;, 30); 10\tPerson p4(\u0026#34;ddd\u0026#34;, 40); 11\tPerson p5(\u0026#34;eee\u0026#34;, 50); 12 13\tv.push_back(p1); 14\tv.push_back(p2); 15\tv.push_back(p3); 16\tv.push_back(p4); 17\tv.push_back(p5); 18 19\tfor (vector\u0026lt;Person\u0026gt;::iterator it = v.begin(); it != v.end(); it++) { 20\tcout \u0026lt;\u0026lt; \u0026#34;Name:\u0026#34; \u0026lt;\u0026lt; (*it).mName \u0026lt;\u0026lt; \u0026#34; Age:\u0026#34; \u0026lt;\u0026lt; (*it).mAge \u0026lt;\u0026lt; endl; 21 22\t} 23} 24 25 26//放对象指针 27void test02() { 28 29\tvector\u0026lt;Person*\u0026gt; v; 30 31\t//创建数据 32\tPerson p1(\u0026#34;aaa\u0026#34;, 10); 33\tPerson p2(\u0026#34;bbb\u0026#34;, 20); 34\tPerson p3(\u0026#34;ccc\u0026#34;, 30); 35\tPerson p4(\u0026#34;ddd\u0026#34;, 40); 36\tPerson p5(\u0026#34;eee\u0026#34;, 50); 37 38\tv.push_back(\u0026amp;p1); 39\tv.push_back(\u0026amp;p2); 40\tv.push_back(\u0026amp;p3); 41\tv.push_back(\u0026amp;p4); 42\tv.push_back(\u0026amp;p5); 43 44\tfor (vector\u0026lt;Person*\u0026gt;::iterator it = v.begin(); it != v.end(); it++) { 45\tPerson * p = (*it); 46\tcout \u0026lt;\u0026lt; \u0026#34;Name:\u0026#34; \u0026lt;\u0026lt; p-\u0026gt;mName \u0026lt;\u0026lt; \u0026#34; Age:\u0026#34; \u0026lt;\u0026lt; (*it)-\u0026gt;mAge \u0026lt;\u0026lt; endl; 47\t} 48} Vector容器嵌套容器 1#include \u0026lt;vector\u0026gt;2 3//容器嵌套容器 4void test01() { 5 6\tvector\u0026lt; vector\u0026lt;int\u0026gt; \u0026gt; v; 7 8\tvector\u0026lt;int\u0026gt; v1; 9\tvector\u0026lt;int\u0026gt; v2; 10\tvector\u0026lt;int\u0026gt; v3; 11\tvector\u0026lt;int\u0026gt; v4; 12 13\tfor (int i = 0; i \u0026lt; 4; i++) { 14\tv1.push_back(i + 1); 15\tv2.push_back(i + 2); 16\tv3.push_back(i + 3); 17\tv4.push_back(i + 4); 18\t} 19 20\t//将容器元素插入到vector v中 21\tv.push_back(v1); 22\tv.push_back(v2); 23\tv.push_back(v3); 24\tv.push_back(v4); 25 26 27\tfor (vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;::iterator it = v.begin(); it != v.end(); it++) { 28 29\tfor (vector\u0026lt;int\u0026gt;::iterator vit = (*it).begin(); vit != (*it).end(); vit++) { 30\tcout \u0026lt;\u0026lt; *vit \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 31\t} 32\tcout \u0026lt;\u0026lt; endl; 33\t} 34 35} 17.STL- 常用容器 string容器 string基本概念 string 类内部封装了很多成员方法\n例如：查找find，拷贝copy，删除delete 替换replace，插入insert\nstring管理char*所分配的内存，不用担心复制越界和取值越界等，由类内部进行负责\nstring构造函数 构造函数原型：\n string(); //创建一个空的字符串 例如: string str; string(const char* s);\t//使用字符串s初始化 string(const string\u0026amp; str); //使用一个string对象初始化另一个string对象 string(int n, char c); //使用n个字符c初始化  1#include \u0026lt;string\u0026gt;2//string构造 3void test01() 4{ 5\tstring s1; //创建空字符串，调用无参构造函数 6\tcout \u0026lt;\u0026lt; \u0026#34;str1 = \u0026#34; \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; 7 8\tconst char* str = \u0026#34;hello world\u0026#34;; 9\tstring s2(str); //把c_string转换成了string 10 11\tcout \u0026lt;\u0026lt; \u0026#34;str2 = \u0026#34; \u0026lt;\u0026lt; s2 \u0026lt;\u0026lt; endl; 12 13\tstring s3(s2); //调用拷贝构造函数 14\tcout \u0026lt;\u0026lt; \u0026#34;str3 = \u0026#34; \u0026lt;\u0026lt; s3 \u0026lt;\u0026lt; endl; 15 16\tstring s4(10, \u0026#39;a\u0026#39;); 17\tcout \u0026lt;\u0026lt; \u0026#34;str3 = \u0026#34; \u0026lt;\u0026lt; s3 \u0026lt;\u0026lt; endl; 18} string赋值操作  string\u0026amp; operator=(const char* s); //char*类型字符串 赋值给当前的字符串 string\u0026amp; operator=(const string \u0026amp;s); //把字符串s赋给当前的字符串 string\u0026amp; operator=(char c); //字符赋值给当前的字符串 string\u0026amp; assign(const char *s); //把字符串s赋给当前的字符串 string\u0026amp; assign(const char *s, int n); //把字符串s的前n个字符赋给当前的字符串 string\u0026amp; assign(const string \u0026amp;s); //把字符串s赋给当前字符串 string\u0026amp; assign(int n, char c); //用n个字符c赋给当前字符串  1void test01() 2{ 3\tstring str1; 4\tstr1 = \u0026#34;hello world\u0026#34;; 5\tcout \u0026lt;\u0026lt; \u0026#34;str1 = \u0026#34; \u0026lt;\u0026lt; str1 \u0026lt;\u0026lt; endl; 6 7\tstring str2; 8\tstr2 = str1; 9\tcout \u0026lt;\u0026lt; \u0026#34;str2 = \u0026#34; \u0026lt;\u0026lt; str2 \u0026lt;\u0026lt; endl; 10 11\tstring str3; 12\tstr3 = \u0026#39;a\u0026#39;; 13\tcout \u0026lt;\u0026lt; \u0026#34;str3 = \u0026#34; \u0026lt;\u0026lt; str3 \u0026lt;\u0026lt; endl; 14 15\tstring str4; 16\tstr4.assign(\u0026#34;hello c++\u0026#34;); 17\tcout \u0026lt;\u0026lt; \u0026#34;str4 = \u0026#34; \u0026lt;\u0026lt; str4 \u0026lt;\u0026lt; endl; 18 19\tstring str5; 20\tstr5.assign(\u0026#34;hello c++\u0026#34;,5); 21\tcout \u0026lt;\u0026lt; \u0026#34;str5 = \u0026#34; \u0026lt;\u0026lt; str5 \u0026lt;\u0026lt; endl; 22 23 24\tstring str6; 25\tstr6.assign(str5); 26\tcout \u0026lt;\u0026lt; \u0026#34;str6 = \u0026#34; \u0026lt;\u0026lt; str6 \u0026lt;\u0026lt; endl; 27 28\tstring str7; 29\tstr7.assign(5, \u0026#39;x\u0026#39;); 30\tcout \u0026lt;\u0026lt; \u0026#34;str7 = \u0026#34; \u0026lt;\u0026lt; str7 \u0026lt;\u0026lt; endl; 31} 32 string字符串拼接  string\u0026amp; operator+=(const char* str); //重载+=操作符 string\u0026amp; operator+=(const char c); //重载+=操作符 string\u0026amp; operator+=(const string\u0026amp; str); //重载+=操作符 string\u0026amp; append(const char *s);  //把字符串s连接到当前字符串结尾 string\u0026amp; append(const char *s, int n); //把字符串s的前n个字符连接到当前字符串结尾 string\u0026amp; append(const string \u0026amp;s); //同operator+=(const string\u0026amp; str) string\u0026amp; append(const string \u0026amp;s, int pos, int n);//字符串s中从pos开始的n个字符连接到字符串结尾  1void test01() 2{ 3\tstring str1 = \u0026#34;我\u0026#34;; 4 5\tstr1 += \u0026#34;爱玩游戏\u0026#34;; 6 7\tcout \u0026lt;\u0026lt; \u0026#34;str1 = \u0026#34; \u0026lt;\u0026lt; str1 \u0026lt;\u0026lt; endl; 8\t9\tstr1 += \u0026#39;:\u0026#39;; 10 11\tcout \u0026lt;\u0026lt; \u0026#34;str1 = \u0026#34; \u0026lt;\u0026lt; str1 \u0026lt;\u0026lt; endl; 12 13\tstring str2 = \u0026#34;LOL DNF\u0026#34;; 14 15\tstr1 += str2; 16 17\tcout \u0026lt;\u0026lt; \u0026#34;str1 = \u0026#34; \u0026lt;\u0026lt; str1 \u0026lt;\u0026lt; endl; 18 19\tstring str3 = \u0026#34;I\u0026#34;; 20\tstr3.append(\u0026#34; love \u0026#34;); 21\tstr3.append(\u0026#34;game abcde\u0026#34;, 4); 22\t//str3.append(str2); 23\tstr3.append(str2, 4, 3); // 从下标4位置开始 ，截取3个字符，拼接到字符串末尾 24\tcout \u0026lt;\u0026lt; \u0026#34;str3 = \u0026#34; \u0026lt;\u0026lt; str3 \u0026lt;\u0026lt; endl; 25} string查找和替换  int find(const string\u0026amp; str, int pos = 0) const; //查找str第一次出现位置,从pos开始查找 int find(const char* s, int pos = 0) const;  //查找s第一次出现位置,从pos开始查找 int find(const char* s, int pos, int n) const;  //从pos位置查找s的前n个字符第一次位置 int find(const char c, int pos = 0) const;  //查找字符c第一次出现位置 int rfind(const string\u0026amp; str, int pos = npos) const; //查找str最后一次位置,从pos开始查找 int rfind(const char* s, int pos = npos) const; //查找s最后一次出现位置,从pos开始查找 int rfind(const char* s, int pos, int n) const; //从pos查找s的前n个字符最后一次位置 int rfind(const char c, int pos = 0) const;  //查找字符c最后一次出现位置 string\u0026amp; replace(int pos, int n, const string\u0026amp; str);  //替换从pos开始n个字符为字符串str string\u0026amp; replace(int pos, int n,const char* s);  //替换从pos开始的n个字符为字符串s  find找到字符串后返回查找的第一个字符位置，找不到返回-1\n1//查找和替换 2void test01() 3{ 4\t//查找 5\tstring str1 = \u0026#34;abcdefgde\u0026#34;; 6 7\tint pos = str1.find(\u0026#34;de\u0026#34;); 8 9\tif (pos == -1) 10\t{ 11\tcout \u0026lt;\u0026lt; \u0026#34;未找到\u0026#34; \u0026lt;\u0026lt; endl; 12\t} 13\telse 14\t{ 15\tcout \u0026lt;\u0026lt; \u0026#34;pos = \u0026#34; \u0026lt;\u0026lt; pos \u0026lt;\u0026lt; endl; 16\t} 17\t18 19\tpos = str1.rfind(\u0026#34;de\u0026#34;); 20 21\tcout \u0026lt;\u0026lt; \u0026#34;pos = \u0026#34; \u0026lt;\u0026lt; pos \u0026lt;\u0026lt; endl; 22 23} 24 25void test02() 26{ 27\t//替换 28\tstring str1 = \u0026#34;abcdefgde\u0026#34;; 29\tstr1.replace(1, 3, \u0026#34;1111\u0026#34;); 30 31\tcout \u0026lt;\u0026lt; \u0026#34;str1 = \u0026#34; \u0026lt;\u0026lt; str1 \u0026lt;\u0026lt; endl; 32} string字符串比较  字符串比较是按字符的ASCII码进行对比  = 返回 0\n\u0026gt; 返回 1\n\u0026lt; 返回 -1\n int compare(const string \u0026amp;s) const;  //与字符串s比较 int compare(const char *s) const; //与字符串s比较  string字符存取  char\u0026amp; operator[](int n);  //通过[]方式取字符 char\u0026amp; at(int n);  //通过at方法获取字符  1void test01() 2{ 3\tstring str = \u0026#34;hello world\u0026#34;; 4 5\tfor (int i = 0; i \u0026lt; str.size(); i++) 6\t{ 7\tcout \u0026lt;\u0026lt; str[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 8\t} 9\tcout \u0026lt;\u0026lt; endl; 10 11\tfor (int i = 0; i \u0026lt; str.size(); i++) 12\t{ 13\tcout \u0026lt;\u0026lt; str.at(i) \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 14\t} 15\tcout \u0026lt;\u0026lt; endl; 16 17 18\t//字符修改 19\tstr[0] = \u0026#39;x\u0026#39;; 20\tstr.at(1) = \u0026#39;x\u0026#39;; 21\tcout \u0026lt;\u0026lt; str \u0026lt;\u0026lt; endl; 22\t23} string插入和删除  string\u0026amp; insert(int pos, const char* s);  //插入字符串 string\u0026amp; insert(int pos, const string\u0026amp; str);  //插入字符串 string\u0026amp; insert(int pos, int n, char c); //在指定位置插入n个字符c string\u0026amp; erase(int pos, int n = npos); //删除从Pos开始的n个字符  string子串 string substr(int pos = 0, int n = npos) const; //返回由pos开始的n个字符组成的字符串\n1//子串 2void test01() 3{ 4 5\tstring str = \u0026#34;abcdefg\u0026#34;; 6\tstring subStr = str.substr(1, 3); 7\tcout \u0026lt;\u0026lt; \u0026#34;subStr = \u0026#34; \u0026lt;\u0026lt; subStr \u0026lt;\u0026lt; endl; 8 9\tstring email = \u0026#34;hello@sina.com\u0026#34;; 10\tint pos = email.find(\u0026#34;@\u0026#34;); 11\tstring username = email.substr(0, pos); 12\tcout \u0026lt;\u0026lt; \u0026#34;username: \u0026#34; \u0026lt;\u0026lt; username \u0026lt;\u0026lt; endl; 13 14} vector容器 vector基本概念 vector数据结构和数组非常相似，也称为单端数组\nvector可以动态扩展, 并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间\nvector容器的迭代器是支持随机访问的迭代器\nvector构造函数  vector\u0026lt;T\u0026gt; v;  //采用模板实现类实现，默认构造函数 vector(v.begin(), v.end());  //将v[begin(), end())区间中的元素拷贝给本身。 vector(n, elem); //构造函数将n个elem拷贝给本身。 vector(const vector \u0026amp;vec); //拷贝构造函数。  1#include \u0026lt;vector\u0026gt;2 3void printVector(vector\u0026lt;int\u0026gt;\u0026amp; v) { 4 5\tfor (vector\u0026lt;int\u0026gt;::iterator it = v.begin(); it != v.end(); it++) { 6\tcout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 7\t} 8\tcout \u0026lt;\u0026lt; endl; 9} 10 11void test01() 12{ 13\tvector\u0026lt;int\u0026gt; v1; //无参构造 14\tfor (int i = 0; i \u0026lt; 10; i++) 15\t{ 16\tv1.push_back(i); 17\t} 18\tprintVector(v1); 19 20\tvector\u0026lt;int\u0026gt; v2(v1.begin(), v1.end()); 21\tprintVector(v2); 22 23\tvector\u0026lt;int\u0026gt; v3(10, 100); 24\tprintVector(v3); 25\t26\tvector\u0026lt;int\u0026gt; v4(v3); 27\tprintVector(v4); 28} vector赋值操作   vector\u0026amp; operator=(const vector \u0026amp;vec);//重载等号操作符\n  assign(beg, end); //将[beg, end)区间中的数据拷贝赋值给本身。\n  assign(n, elem); //将n个elem拷贝赋值给本身。\n  1#include \u0026lt;vector\u0026gt;2 3void printVector(vector\u0026lt;int\u0026gt;\u0026amp; v) { 4 5\tfor (vector\u0026lt;int\u0026gt;::iterator it = v.begin(); it != v.end(); it++) { 6\tcout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 7\t} 8\tcout \u0026lt;\u0026lt; endl; 9} 10 11//赋值操作 12void test01() 13{ 14\tvector\u0026lt;int\u0026gt; v1; //无参构造 15\tfor (int i = 0; i \u0026lt; 10; i++) 16\t{ 17\tv1.push_back(i); 18\t} 19\tprintVector(v1); 20 21\tvector\u0026lt;int\u0026gt;v2; 22\tv2 = v1; 23\tprintVector(v2); 24 25\tvector\u0026lt;int\u0026gt;v3; 26\tv3.assign(v1.begin(), v1.end()); 27\tprintVector(v3); 28 29\tvector\u0026lt;int\u0026gt;v4; 30\tv4.assign(10, 100); 31\tprintVector(v4); 32} vector容量和大小   empty();  //判断容器是否为空\n  capacity(); //容器的容量\n  size(); //返回容器中元素的个数\n  resize(int num); //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。\n​\t//如果容器变短，则末尾超出容器长度的元素被删除。\n  resize(int num, elem); //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。\n​\t//如果容器变短，则末尾超出容器长度的元素被删除\n  1void test01() 2{ 3\tvector\u0026lt;int\u0026gt; v1; 4\tfor (int i = 0; i \u0026lt; 10; i++) 5\t{ 6\tv1.push_back(i); 7\t} 8\tprintVector(v1); 9\tif (v1.empty()) 10\t{ 11\tcout \u0026lt;\u0026lt; \u0026#34;v1为空\u0026#34; \u0026lt;\u0026lt; endl; 12\t} 13\telse 14\t{ 15\tcout \u0026lt;\u0026lt; \u0026#34;v1不为空\u0026#34; \u0026lt;\u0026lt; endl; 16\tcout \u0026lt;\u0026lt; \u0026#34;v1的容量 = \u0026#34; \u0026lt;\u0026lt; v1.capacity() \u0026lt;\u0026lt; endl; 17\tcout \u0026lt;\u0026lt; \u0026#34;v1的大小 = \u0026#34; \u0026lt;\u0026lt; v1.size() \u0026lt;\u0026lt; endl; 18\t} 19 20\t//resize 重新指定大小 ，若指定的更大，默认用0填充新位置，可以利用重载版本替换默认填充 21\tv1.resize(15,10); 22\tprintVector(v1); 23 24\t//resize 重新指定大小 ，若指定的更小，超出部分元素被删除 25\tv1.resize(5); 26\tprintVector(v1); 27} vector插入和删除  push_back(ele); //尾部插入元素ele pop_back(); //删除最后一个元素 insert(const_iterator pos, ele); //迭代器指向位置pos插入元素ele insert(const_iterator pos, int count,ele);//迭代器指向位置pos插入count个元素ele erase(const_iterator pos); //删除迭代器指向的元素 erase(const_iterator start, const_iterator end);//删除迭代器从start到end之间的元素 clear(); //删除容器中所有元素  1void test01() 2{ 3\tvector\u0026lt;int\u0026gt; v1; 4\t//尾插 5\tv1.push_back(10); 6\tv1.push_back(20); 7\tv1.push_back(30); 8\tv1.push_back(40); 9\tv1.push_back(50); 10\tprintVector(v1); 11\t//尾删 12\tv1.pop_back(); 13\tprintVector(v1); 14\t//插入 15\tv1.insert(v1.begin(), 100); 16\tprintVector(v1); 17 18\tv1.insert(v1.begin(), 2, 1000); 19\tprintVector(v1); 20 21\t//删除 22\tv1.erase(v1.begin()); 23\tprintVector(v1); 24 25\t//清空 26\tv1.erase(v1.begin(), v1.end()); 27\tv1.clear(); 28\tprintVector(v1); 29} vector数据存取  at(int idx);  //返回索引idx所指的数据 operator[];  //返回索引idx所指的数据 front();  //返回容器中第一个数据元素 back(); //返回容器中最后一个数据元素  vector互换容器 swap(vec); // 将vec与本身的元素互换\nswap可以使两个容器互换，可以达到实用的收缩内存效果\n1void test01() 2{ 3\tvector\u0026lt;int\u0026gt;v1; 4\tfor (int i = 0; i \u0026lt; 10; i++) 5\t{ 6\tv1.push_back(i); 7\t} 8\tprintVector(v1); 9 10\tvector\u0026lt;int\u0026gt;v2; 11\tfor (int i = 10; i \u0026gt; 0; i--) 12\t{ 13\tv2.push_back(i); 14\t} 15\tprintVector(v2); 16 17\t//互换容器 18\tcout \u0026lt;\u0026lt; \u0026#34;互换后\u0026#34; \u0026lt;\u0026lt; endl; 19\tv1.swap(v2); 20\tprintVector(v1); 21\tprintVector(v2); 22} 23 24void test02() 25{ 26\tvector\u0026lt;int\u0026gt; v; 27\tfor (int i = 0; i \u0026lt; 100000; i++) { 28\tv.push_back(i); 29\t} 30 31\tcout \u0026lt;\u0026lt; \u0026#34;v的容量为：\u0026#34; \u0026lt;\u0026lt; v.capacity() \u0026lt;\u0026lt; endl; 32\tcout \u0026lt;\u0026lt; \u0026#34;v的大小为：\u0026#34; \u0026lt;\u0026lt; v.size() \u0026lt;\u0026lt; endl; 33 34\tv.resize(3); 35 36\tcout \u0026lt;\u0026lt; \u0026#34;v的容量为：\u0026#34; \u0026lt;\u0026lt; v.capacity() \u0026lt;\u0026lt; endl; 37\tcout \u0026lt;\u0026lt; \u0026#34;v的大小为：\u0026#34; \u0026lt;\u0026lt; v.size() \u0026lt;\u0026lt; endl; 38 39\t//收缩内存 40\tvector\u0026lt;int\u0026gt;(v).swap(v); //匿名对象 41 42\tcout \u0026lt;\u0026lt; \u0026#34;v的容量为：\u0026#34; \u0026lt;\u0026lt; v.capacity() \u0026lt;\u0026lt; endl; 43\tcout \u0026lt;\u0026lt; \u0026#34;v的大小为：\u0026#34; \u0026lt;\u0026lt; v.size() \u0026lt;\u0026lt; endl; 44} vector预留空间 减少vector在动态扩展容量时的扩展次数\nreserve(int len);//容器预留len个元素长度，预留位置不初始化，元素不可访问。\n1void test01() 2{ 3\tvector\u0026lt;int\u0026gt; v; 4 5\t//预留空间 6\tv.reserve(100000); 7 8\tint num = 0; 9\tint* p = NULL; 10\tfor (int i = 0; i \u0026lt; 100000; i++) { 11\tv.push_back(i); 12\tif (p != \u0026amp;v[0]) { 13\tp = \u0026amp;v[0]; 14\tnum++; 15\t} 16\t} 17 18\tcout \u0026lt;\u0026lt; \u0026#34;num:\u0026#34; \u0026lt;\u0026lt; num \u0026lt;\u0026lt; endl; 19} deque容器 deque容器基本概念 双端数组，可以对头端进行插入删除操作\ndeque与vector区别：\n vector对于头部的插入删除效率低，数据量越大，效率越低 deque相对而言，对头部的插入删除速度回比vector快 vector访问元素时的速度会比deque快,这和两者内部实现有关  deque内部工作原理:\ndeque内部有个中控器，维护每段缓冲区中的内容，缓冲区中存放真实数据\n中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间\ndeque构造函数  deque\u0026lt;T\u0026gt; deqT; //默认构造形式 deque(beg, end); //构造函数将[beg, end)区间中的元素拷贝给本身。 deque(n, elem); //构造函数将n个elem拷贝给本身。 deque(const deque \u0026amp;deq); //拷贝构造函数  deque赋值操作   deque\u0026amp; operator=(const deque \u0026amp;deq);  //重载等号操作符\n  assign(beg, end); //将[beg, end)区间中的数据拷贝赋值给本身。\n  assign(n, elem); //将n个elem拷贝赋值给本身。\n  deque大小操作   deque.empty(); //判断容器是否为空\n  deque.size(); //返回容器中元素的个数\n  deque.resize(num); //重新指定容器的长度为num,若容器变长，则以默认值填充新位置。\n​\t//如果容器变短，则末尾超出容器长度的元素被删除。\n  deque.resize(num, elem); //重新指定容器的长度为num,若容器变长，则以elem值填充新位置。\n​ //如果容器变短，则末尾超出容器长度的元素被删除。\n  deque 插入和删除 两端插入操作：\n push_back(elem); //在容器尾部添加一个数据 push_front(elem); //在容器头部插入一个数据 pop_back(); //删除容器最后一个数据 pop_front(); //删除容器第一个数据  指定位置操作：\n  insert(pos,elem); //在pos位置插入一个elem元素的拷贝，返回新数据的位置。\n  insert(pos,n,elem); //在pos位置插入n个elem数据，无返回值。\n  insert(pos,beg,end); //在pos位置插入[beg,end)区间的数据，无返回值。\n  clear(); //清空容器的所有数据\n  erase(beg,end); //删除[beg,end)区间的数据，返回下一个数据的位置。\n  erase(pos); //删除pos位置的数据，返回下一个数据的位置。\n  1void test01() 2{ 3\tdeque\u0026lt;int\u0026gt; d; 4\t//尾插 5\td.push_back(10); 6\td.push_back(20); 7\t//头插 8\td.push_front(100); 9\td.push_front(200); 10 11\tprintDeque(d); 12 13\t//尾删 14\td.pop_back(); 15\t//头删 16\td.pop_front(); 17\tprintDeque(d); 18} 19 20//插入 21void test02() 22{ 23\tdeque\u0026lt;int\u0026gt; d; 24\td.push_back(10); 25\td.push_back(20); 26\td.push_front(100); 27\td.push_front(200); 28\tprintDeque(d); 29 30\td.insert(d.begin(), 1000); 31\tprintDeque(d); 32 33\td.insert(d.begin(), 2,10000); 34\tprintDeque(d); 35 36\tdeque\u0026lt;int\u0026gt;d2; 37\td2.push_back(1); 38\td2.push_back(2); 39\td2.push_back(3); 40 41\td.insert(d.begin(), d2.begin(), d2.end()); 42\tprintDeque(d); 43 44} 45 46//删除 47void test03() 48{ 49\tdeque\u0026lt;int\u0026gt; d; 50\td.push_back(10); 51\td.push_back(20); 52\td.push_front(100); 53\td.push_front(200); 54\tprintDeque(d); 55 56\td.erase(d.begin()); 57\tprintDeque(d); 58 59\td.erase(d.begin(), d.end()); 60\td.clear(); 61\tprintDeque(d); 62} deque 数据存取  at(int idx);  //返回索引idx所指的数据 operator[];  //返回索引idx所指的数据 front();  //返回容器中第一个数据元素 back(); //返回容器中最后一个数据元素  deque 排序 sort(iterator beg, iterator end) //对beg和end区间内元素进行排序\n1void test01() 2{ 3 4\tdeque\u0026lt;int\u0026gt; d; 5\td.push_back(10); 6\td.push_back(20); 7\td.push_front(100); 8\td.push_front(200); 9 10\tprintDeque(d); 11\tsort(d.begin(), d.end()); 12\tprintDeque(d); 13 14} stack容器 stack 基本概念 stack是一种先进后出(First In Last Out,FILO)的数据结构，它只有一个出口\nstack 常用接口 构造函数：\n stack\u0026lt;T\u0026gt; stk; //stack采用模板类实现， stack对象的默认构造形式 stack(const stack \u0026amp;stk); //拷贝构造函数  赋值操作：\n stack\u0026amp; operator=(const stack \u0026amp;stk); //重载等号操作符  数据存取：\n push(elem); //向栈顶添加元素 pop(); //从栈顶移除第一个元素 top();  //返回栈顶元素  大小操作：\n empty(); //判断堆栈是否为空 size();  //返回栈的大小  1#include \u0026lt;stack\u0026gt;2 3//栈容器常用接口 4void test01() 5{ 6\t//创建栈容器 栈容器必须符合先进后出 7\tstack\u0026lt;int\u0026gt; s; 8 9\t//向栈中添加元素，叫做 压栈 入栈 10\ts.push(10); 11\ts.push(20); 12\ts.push(30); 13 14\twhile (!s.empty()) { 15\t//输出栈顶元素 16\tcout \u0026lt;\u0026lt; \u0026#34;栈顶元素为： \u0026#34; \u0026lt;\u0026lt; s.top() \u0026lt;\u0026lt; endl; 17\t//弹出栈顶元素 18\ts.pop(); 19\t} 20\tcout \u0026lt;\u0026lt; \u0026#34;栈的大小为：\u0026#34; \u0026lt;\u0026lt; s.size() \u0026lt;\u0026lt; endl; 21 22} queue 容器 queue 基本概念 Queue是一种先进先出(First In First Out,FIFO)的数据结构，它有两个出口\nqueue 常用接口 构造函数：\n queue\u0026lt;T\u0026gt; que; //queue采用模板类实现，queue对象的默认构造形式 queue(const queue \u0026amp;que); //拷贝构造函数  赋值操作：\n queue\u0026amp; operator=(const queue \u0026amp;que); //重载等号操作符  数据存取：\n push(elem); //往队尾添加元素 pop(); //从队头移除第一个元素 back(); //返回最后一个元素 front();  //返回第一个元素  大小操作：\n empty(); //判断堆栈是否为空 size();  //返回栈的大小  1void test01() { 2 3\t//创建队列 4\tqueue\u0026lt;Person\u0026gt; q; 5 6\t//准备数据 7\tPerson p1(\u0026#34;唐僧\u0026#34;, 30); 8\tPerson p2(\u0026#34;孙悟空\u0026#34;, 1000); 9\tPerson p3(\u0026#34;猪八戒\u0026#34;, 900); 10\tPerson p4(\u0026#34;沙僧\u0026#34;, 800); 11 12\t//向队列中添加元素 入队操作 13\tq.push(p1); 14\tq.push(p2); 15\tq.push(p3); 16\tq.push(p4); 17 18\t//队列不提供迭代器，更不支持随机访问\t19\twhile (!q.empty()) { 20\t//输出队头元素 21\tcout \u0026lt;\u0026lt; \u0026#34;队头元素-- 姓名： \u0026#34; \u0026lt;\u0026lt; q.front().m_Name 22 \u0026lt;\u0026lt; \u0026#34; 年龄： \u0026#34;\u0026lt;\u0026lt; q.front().m_Age \u0026lt;\u0026lt; endl; 23 24\tcout \u0026lt;\u0026lt; \u0026#34;队尾元素-- 姓名： \u0026#34; \u0026lt;\u0026lt; q.back().m_Name 25 \u0026lt;\u0026lt; \u0026#34; 年龄： \u0026#34; \u0026lt;\u0026lt; q.back().m_Age \u0026lt;\u0026lt; endl; 26 27\tcout \u0026lt;\u0026lt; endl; 28\t//弹出队头元素 29\tq.pop(); 30\t} 31 32\tcout \u0026lt;\u0026lt; \u0026#34;队列大小为：\u0026#34; \u0026lt;\u0026lt; q.size() \u0026lt;\u0026lt; endl; 33} list容器 list基本概念 将数据进行链式存储\nSTL中的链表是一个双向循环链表\n由于链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移，属于双向迭代器\nList有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效，这在vector是不成立的。\nlist构造函数  list\u0026lt;T\u0026gt; lst; //list采用采用模板类实现,对象的默认构造形式： list(beg,end); //构造函数将[beg, end)区间中的元素拷贝给本身。 list(n,elem); //构造函数将n个elem拷贝给本身。 list(const list \u0026amp;lst); //拷贝构造函数。  list 赋值和交换  assign(beg, end); //将[beg, end)区间中的数据拷贝赋值给本身。 assign(n, elem); //将n个elem拷贝赋值给本身。 list\u0026amp; operator=(const list \u0026amp;lst); //重载等号操作符 swap(lst); //将lst与本身的元素互换。  list 大小操作   size();  //返回容器中元素的个数\n  empty();  //判断容器是否为空\n  resize(num); //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。\n​\t//如果容器变短，则末尾超出容器长度的元素被删除。\n  resize(num, elem);  //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。\n ​\t//如果容器变短，则末尾超出容器长度的元素被删除。\r   list 插入和删除  push_back(elem);//在容器尾部加入一个元素 pop_back();//删除容器中最后一个元素 push_front(elem);//在容器开头插入一个元素 pop_front();//从容器开头移除第一个元素 insert(pos,elem);//在pos位置插elem元素的拷贝，返回新数据的位置。 insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。 insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。 clear();//移除容器的所有数据 erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。 erase(pos);//删除pos位置的数据，返回下一个数据的位置。 remove(elem);//删除容器中所有与elem值匹配的元素。  list 数据存取  front(); //返回第一个元素。 back(); //返回最后一个元素。  list容器中不可以通过[]或者at方式访问数据\n1//数据存取 2void test01() 3{ 4\tlist\u0026lt;int\u0026gt;L1; 5\tL1.push_back(10); 6\tL1.push_back(20); 7\tL1.push_back(30); 8\tL1.push_back(40); 9 10\t11\t//cout \u0026lt;\u0026lt; L1.at(0) \u0026lt;\u0026lt; endl;//错误 不支持at访问数据 12\t//cout \u0026lt;\u0026lt; L1[0] \u0026lt;\u0026lt; endl; //错误 不支持[]方式访问数据 13\tcout \u0026lt;\u0026lt; \u0026#34;第一个元素为： \u0026#34; \u0026lt;\u0026lt; L1.front() \u0026lt;\u0026lt; endl; 14\tcout \u0026lt;\u0026lt; \u0026#34;最后一个元素为： \u0026#34; \u0026lt;\u0026lt; L1.back() \u0026lt;\u0026lt; endl; 15 16\t//list容器的迭代器是双向迭代器，不支持随机访问 17\tlist\u0026lt;int\u0026gt;::iterator it = L1.begin(); 18\t//it = it + 1;//错误，不可以跳跃访问，即使是+1 19 //区别it++ 20} list 反转和排序  reverse(); //反转链表 sort(); //链表排序  1void printList(const list\u0026lt;int\u0026gt;\u0026amp; L) { 2 3\tfor (list\u0026lt;int\u0026gt;::const_iterator it = L.begin(); it != L.end(); it++) { 4\tcout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 5\t} 6\tcout \u0026lt;\u0026lt; endl; 7} 8 9bool myCompare(int val1 , int val2) 10{ 11\treturn val1 \u0026gt; val2; 12} 13 14//反转和排序 15void test01() 16{ 17\tlist\u0026lt;int\u0026gt; L; 18\tL.push_back(90); 19\tL.push_back(30); 20\tL.push_back(20); 21\tL.push_back(70); 22\tprintList(L); 23 24\t//反转容器的元素 25\tL.reverse(); 26\tprintList(L); 27 28\t//排序 29\tL.sort(); //默认的排序规则 从小到大 30\tprintList(L); 31 32\tL.sort(myCompare); //指定规则，从大到小 33\tprintList(L); 34} set/ multiset 容器 set基本概念  所有元素都会在插入时自动被排序 set/multiset属于关联式容器，底层结构是用二叉树实现。  set和multiset区别：\n set不允许容器中有重复的元素 multiset允许容器中有重复的元素  set构造和赋值 构造：\n set\u0026lt;T\u0026gt; st; //默认构造函数： set(const set \u0026amp;st); //拷贝构造函数  赋值：\n set\u0026amp; operator=(const set \u0026amp;st); //重载等号操作符  1void test01() 2{ 3\tset\u0026lt;int\u0026gt; s1; 4 5\ts1.insert(10); 6\ts1.insert(30); 7\ts1.insert(20); 8\ts1.insert(40); 9\tprintSet(s1); 10 11\t//拷贝构造 12\tset\u0026lt;int\u0026gt;s2(s1); 13\tprintSet(s2); 14 15\t//赋值 16\tset\u0026lt;int\u0026gt;s3; 17\ts3 = s2; 18\tprintSet(s3); 19} set大小和交换  size(); //返回容器中元素的数目 empty(); //判断容器是否为空 swap(st); //交换两个集合容器  1void test01() 2{ 3 4\tset\u0026lt;int\u0026gt; s1; 5\t6\ts1.insert(10); 7\ts1.insert(30); 8\ts1.insert(20); 9\ts1.insert(40); 10 11\tif (s1.empty()) 12\t{ 13\tcout \u0026lt;\u0026lt; \u0026#34;s1为空\u0026#34; \u0026lt;\u0026lt; endl; 14\t} 15\telse 16\t{ 17\tcout \u0026lt;\u0026lt; \u0026#34;s1不为空\u0026#34; \u0026lt;\u0026lt; endl; 18\tcout \u0026lt;\u0026lt; \u0026#34;s1的大小为： \u0026#34; \u0026lt;\u0026lt; s1.size() \u0026lt;\u0026lt; endl; 19\t} 20 21} 22 23//交换 24void test02() 25{ 26\tset\u0026lt;int\u0026gt; s1; 27 28\ts1.insert(10); 29\ts1.insert(30); 30\ts1.insert(20); 31\ts1.insert(40); 32 33\tset\u0026lt;int\u0026gt; s2; 34 35\ts2.insert(100); 36\ts2.insert(300); 37\ts2.insert(200); 38\ts2.insert(400); 39 40\tcout \u0026lt;\u0026lt; \u0026#34;交换前\u0026#34; \u0026lt;\u0026lt; endl; 41\tprintSet(s1); 42\tprintSet(s2); 43\tcout \u0026lt;\u0026lt; endl; 44 45\tcout \u0026lt;\u0026lt; \u0026#34;交换后\u0026#34; \u0026lt;\u0026lt; endl; 46\ts1.swap(s2); 47\tprintSet(s1); 48\tprintSet(s2); 49} set插入和删除  insert(elem); //在容器中插入元素。 clear(); //清除所有元素 erase(pos); //删除pos迭代器所指的元素，返回下一个元素的迭代器。 erase(beg, end); //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。 erase(elem); //删除容器中值为elem的元素。  1void test01() 2{ 3\tset\u0026lt;int\u0026gt; s1; 4\t//插入 5\ts1.insert(10); 6\ts1.insert(30); 7\ts1.insert(20); 8\ts1.insert(40); 9\tprintSet(s1); 10 11\t//删除 12\ts1.erase(s1.begin()); 13\tprintSet(s1); 14 15\ts1.erase(30); 16\tprintSet(s1); 17 18\t//清空 19\t//s1.erase(s1.begin(), s1.end()); 20\ts1.clear(); 21\tprintSet(s1); 22} set查找和统计  find(key); //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end(); count(key); //统计key的元素个数  1void test01() 2{ 3\tset\u0026lt;int\u0026gt; s1; 4\t//插入 5\ts1.insert(10); 6\ts1.insert(30); 7\ts1.insert(20); 8\ts1.insert(40); 9\t10\t//查找 11\tset\u0026lt;int\u0026gt;::iterator pos = s1.find(30); 12 13\tif (pos != s1.end()) 14\t{ 15\tcout \u0026lt;\u0026lt; \u0026#34;找到了元素 ： \u0026#34; \u0026lt;\u0026lt; *pos \u0026lt;\u0026lt; endl; 16\t} 17\telse 18\t{ 19\tcout \u0026lt;\u0026lt; \u0026#34;未找到元素\u0026#34; \u0026lt;\u0026lt; endl; 20\t} 21 22\t//统计 23\tint num = s1.count(30); 24\tcout \u0026lt;\u0026lt; \u0026#34;num = \u0026#34; \u0026lt;\u0026lt; num \u0026lt;\u0026lt; endl; 25} set和multiset区别  set不可以插入重复数据，而multiset可以 set插入数据的同时会返回插入结果，表示插入是否成功 multiset不会检测数据，因此可以插入重复数据  1void test01() 2{ 3\tset\u0026lt;int\u0026gt; s; 4\tpair\u0026lt;set\u0026lt;int\u0026gt;::iterator, bool\u0026gt; ret = s.insert(10); 5\tif (ret.second) { 6\tcout \u0026lt;\u0026lt; \u0026#34;第一次插入成功!\u0026#34; \u0026lt;\u0026lt; endl; 7\t} 8\telse { 9\tcout \u0026lt;\u0026lt; \u0026#34;第一次插入失败!\u0026#34; \u0026lt;\u0026lt; endl; 10\t} 11 12\tret = s.insert(10); 13\tif (ret.second) { 14\tcout \u0026lt;\u0026lt; \u0026#34;第二次插入成功!\u0026#34; \u0026lt;\u0026lt; endl; 15\t} 16\telse { 17\tcout \u0026lt;\u0026lt; \u0026#34;第二次插入失败!\u0026#34; \u0026lt;\u0026lt; endl; 18\t} 19 20\t//multiset 21\tmultiset\u0026lt;int\u0026gt; ms; 22\tms.insert(10); 23\tms.insert(10); 24 25\tfor (multiset\u0026lt;int\u0026gt;::iterator it = ms.begin(); it != ms.end(); it++) { 26\tcout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 27\t} 28\tcout \u0026lt;\u0026lt; endl; 29} pair对组创建 成对出现的数据，利用对组可以返回两个数据\n pair\u0026lt;type, type\u0026gt; p ( value1, value2 ); pair\u0026lt;type, type\u0026gt; p = make_pair( value1, value2 );  1void test01() 2{ 3\tpair\u0026lt;string, int\u0026gt; p(string(\u0026#34;Tom\u0026#34;), 20); 4\tcout \u0026lt;\u0026lt; \u0026#34;姓名： \u0026#34; \u0026lt;\u0026lt; p.first \u0026lt;\u0026lt; \u0026#34; 年龄： \u0026#34; \u0026lt;\u0026lt; p.second \u0026lt;\u0026lt; endl; 5 6\tpair\u0026lt;string, int\u0026gt; p2 = make_pair(\u0026#34;Jerry\u0026#34;, 10); 7\tcout \u0026lt;\u0026lt; \u0026#34;姓名： \u0026#34; \u0026lt;\u0026lt; p2.first \u0026lt;\u0026lt; \u0026#34; 年龄： \u0026#34; \u0026lt;\u0026lt; p2.second \u0026lt;\u0026lt; endl; 8} set容器排序 set容器默认排序规则为从小到大，利用仿函数，可以改变排序规则\n对于自定义数据类型，set必须指定排序规则才可以插入数据\n1class MyCompare 2{ 3public: 4\tbool operator()(int v1, int v2) { 5\treturn v1 \u0026gt; v2; 6\t} 7}; 8void test01() 9{ 10\tset\u0026lt;int\u0026gt; s1; 11\ts1.insert(10); 12\ts1.insert(40); 13\ts1.insert(20); 14\ts1.insert(30); 15\ts1.insert(50); 16 17\t//默认从小到大 18\tfor (set\u0026lt;int\u0026gt;::iterator it = s1.begin(); it != s1.end(); it++) { 19\tcout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 20\t} 21\tcout \u0026lt;\u0026lt; endl; 22 23\t//指定排序规则 24\tset\u0026lt;int,MyCompare\u0026gt; s2; 25\ts2.insert(10); 26\ts2.insert(40); 27\ts2.insert(20); 28\ts2.insert(30); 29\ts2.insert(50); 30 31\tfor (set\u0026lt;int, MyCompare\u0026gt;::iterator it = s2.begin(); it != s2.end(); it++) { 32\tcout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 33\t} 34\tcout \u0026lt;\u0026lt; endl; 35} 1class Person 2{ 3public: 4\tPerson(string name, int age) 5\t{ 6\tthis-\u0026gt;m_Name = name; 7\tthis-\u0026gt;m_Age = age; 8\t} 9 10\tstring m_Name; 11\tint m_Age; 12 13}; 14class comparePerson 15{ 16public: 17\tbool operator()(const Person\u0026amp; p1, const Person \u0026amp;p2) 18\t{ 19\t//按照年龄进行排序 降序 20\treturn p1.m_Age \u0026gt; p2.m_Age; 21\t} 22}; 23 24void test01() 25{ 26\tset\u0026lt;Person, comparePerson\u0026gt; s; 27 28\tPerson p1(\u0026#34;刘备\u0026#34;, 23); 29\tPerson p2(\u0026#34;关羽\u0026#34;, 27); 30\tPerson p3(\u0026#34;张飞\u0026#34;, 25); 31\tPerson p4(\u0026#34;赵云\u0026#34;, 21); 32 33\ts.insert(p1); 34\ts.insert(p2); 35\ts.insert(p3); 36\ts.insert(p4); 37 38\tfor (set\u0026lt;Person, comparePerson\u0026gt;::iterator it = s.begin(); it != s.end(); it++) 39\t{ 40\tcout \u0026lt;\u0026lt; \u0026#34;姓名： \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;m_Name \u0026lt;\u0026lt; \u0026#34; 年龄： \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;m_Age \u0026lt;\u0026lt; endl; 41\t} 42} map/ multimap容器 map基本概念  map中所有元素都是pair pair中第一个元素为key（键值），起到索引作用，第二个元素为value（实值） 所有元素都会根据元素的键值自动排序 map/multimap属于关联式容器，底层结构是用二叉树实现。  map和multimap区别：\n map不允许容器中有重复key值元素 multimap允许容器中有重复key值元素  map构造和赋值 构造：\n map\u0026lt;T1, T2\u0026gt; mp; //map默认构造函数: map(const map \u0026amp;mp); //拷贝构造函数  赋值：\n map\u0026amp; operator=(const map \u0026amp;mp); //重载等号操作符  1void printMap(map\u0026lt;int,int\u0026gt;\u0026amp;m) 2{ 3\tfor (map\u0026lt;int, int\u0026gt;::iterator it = m.begin(); it != m.end(); it++) 4\t{ 5\tcout \u0026lt;\u0026lt; \u0026#34;key = \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;first \u0026lt;\u0026lt; \u0026#34; value = \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; endl; 6\t} 7\tcout \u0026lt;\u0026lt; endl; 8} 9 10void test01() 11{ 12\tmap\u0026lt;int,int\u0026gt;m; //默认构造 13\tm.insert(pair\u0026lt;int, int\u0026gt;(1, 10)); 14\tm.insert(pair\u0026lt;int, int\u0026gt;(2, 20)); 15\tm.insert(pair\u0026lt;int, int\u0026gt;(3, 30)); 16\tprintMap(m); 17 18\tmap\u0026lt;int, int\u0026gt;m2(m); //拷贝构造 19\tprintMap(m2); 20 21\tmap\u0026lt;int, int\u0026gt;m3; 22\tm3 = m2; //赋值 23\tprintMap(m3); 24} map大小和交换  size(); //返回容器中元素的数目 empty(); //判断容器是否为空 swap(st); //交换两个集合容器  map插入和删除  insert(elem); //在容器中插入元素。 clear(); //清除所有元素 erase(pos); //删除pos迭代器所指的元素，返回下一个元素的迭代器。 erase(beg, end); //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。 erase(key); //删除容器中值为key的元素。  1void test01() 2{ 3\t//插入 4\tmap\u0026lt;int, int\u0026gt; m; 5\t//第一种插入方式 6\tm.insert(pair\u0026lt;int, int\u0026gt;(1, 10)); 7\t//第二种插入方式 8\tm.insert(make_pair(2, 20)); 9\t//第三种插入方式 10\tm.insert(map\u0026lt;int, int\u0026gt;::value_type(3, 30)); 11\t//第四种插入方式 12\tm[4] = 40; 13\tprintMap(m); 14 15\t//删除 16\tm.erase(m.begin()); 17\tprintMap(m); 18 19\tm.erase(3); 20\tprintMap(m); 21 22\t//清空 23\tm.erase(m.begin(),m.end()); 24\tm.clear(); 25\tprintMap(m); 26} map查找和统计  find(key); //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end(); count(key); //统计key的元素个数  1void test01() 2{ 3\tmap\u0026lt;int, int\u0026gt;m; 4\tm.insert(pair\u0026lt;int, int\u0026gt;(1, 10)); 5\tm.insert(pair\u0026lt;int, int\u0026gt;(2, 20)); 6\tm.insert(pair\u0026lt;int, int\u0026gt;(3, 30)); 7 8\t//查找 9\tmap\u0026lt;int, int\u0026gt;::iterator pos = m.find(3); 10 11\tif (pos != m.end()) 12\t{ 13\tcout \u0026lt;\u0026lt; \u0026#34;找到了元素 key = \u0026#34; \u0026lt;\u0026lt; (*pos).first \u0026lt;\u0026lt; \u0026#34; value = \u0026#34; \u0026lt;\u0026lt; (*pos).second \u0026lt;\u0026lt; endl; 14\t} 15\telse 16\t{ 17\tcout \u0026lt;\u0026lt; \u0026#34;未找到元素\u0026#34; \u0026lt;\u0026lt; endl; 18\t} 19 20\t//统计 21\tint num = m.count(3); 22\tcout \u0026lt;\u0026lt; \u0026#34;num = \u0026#34; \u0026lt;\u0026lt; num \u0026lt;\u0026lt; endl; 23} map容器排序 map容器默认排序规则为 按照key值进行 从小到大排序，利用仿函数，可以改变排序规则\n1#include \u0026lt;map\u0026gt;2 3class MyCompare { 4public: 5\tbool operator()(int v1, int v2) { 6\treturn v1 \u0026gt; v2; 7\t} 8}; 9 10void test01() 11{ 12\t//默认从小到大排序 13\t//利用仿函数实现从大到小排序 14\tmap\u0026lt;int, int, MyCompare\u0026gt; m; 15 16\tm.insert(make_pair(1, 10)); 17\tm.insert(make_pair(2, 20)); 18\tm.insert(make_pair(3, 30)); 19\tm.insert(make_pair(4, 40)); 20\tm.insert(make_pair(5, 50)); 21 22\tfor (map\u0026lt;int, int, MyCompare\u0026gt;::iterator it = m.begin(); it != m.end(); it++) { 23\tcout \u0026lt;\u0026lt; \u0026#34;key:\u0026#34; \u0026lt;\u0026lt; it-\u0026gt;first \u0026lt;\u0026lt; \u0026#34; value:\u0026#34; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; endl; 24\t} 25} 18.STL- 函数对象 函数对象 函数对象概念","date":"2024-10-28","permalink":"/posts/tech/code-cpp/","series":[],"tags":["","",""],"title":"C++基础查漏补缺"},{"categories":["计算机"],"content":"黑马的视频文档特别清楚, 这里我只是安装自己的话语总结一下.\nRedis 1.什么是缓存穿透？怎么解决？ 缓存穿透是指查询一个一定不存在的数据，由于存储层查不到数据因此不写入缓存，这将导致这个不存在的数据每次请求都要到 DB 去查询，可能导致 DB 挂掉。这种情况大概率是遭到了攻击。解决方案的话，我们通常都会用布隆过滤器来解决它。\n2.你能介绍一下布隆过滤器吗？ 布隆过滤器主要是用于检索一个元素是否在一个集合中。我们当时使用的是Redisson实现的布隆过滤器。它的底层原理是，先初始化一个比较大的数组，里面存放的是二进制0或1。一开始都是0，当一个key来了之后，经过3次hash计算，模数组长度找到数据的下标，然后把数组中原来的0改为1。这样，三个数组的位置就能标明一个key的存在。查找的过程也是一样的。当然，布隆过滤器有可能会产生一定的误判，我们一般可以设置这个误判率，大概不会超过5%。其实这个误判是必然存在的，要不就得增加数组的长度。5%以内的误判率一般的项目也能接受，不至于高并发下压倒数据库。\n3.什么是缓存击穿？怎么解决？ 缓存击穿的意思是，对于设置了过期时间的key，缓存在某个时间点过期的时候，恰好这个时间点对这个Key有大量的并发请求过来。这些请求发现缓存过期，一般都会从后端 DB 加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把 DB 压垮。\n解决方案有两种方式：第一，可以使用互斥锁：当缓存失效时，不立即去load db，先使用如 Redis 的 SETNX 去设置一个互斥锁。当操作成功返回时，再进行 load db的操作并回设缓存，否则重试get缓存的方法。第二种方案是设置当前key逻辑过期，大概思路如下：1) 在设置key的时候，设置一个过期时间字段一块存入缓存中，不给当前key设置过期时间；2) 当查询的时候，从redis取出数据后判断时间是否过期；3) 如果过期，则开通另外一个线程进行数据同步，当前线程正常返回数据，这个数据可能不是最新的。\n当然，两种方案各有利弊：如果选择数据的强一致性，建议使用分布式锁的方案，但性能上可能没那么高，且有可能产生死锁的问题。如果选择key的逻辑删除，则优先考虑高可用性，性能比较高，但数据同步这块做不到强一致。\n4.什么是缓存雪崩？怎么解决？ 缓存雪崩意思是，设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过重而雪崩。与缓存击穿的区别是：雪崩是很多key，而击穿是某一个key缓存。\n解决方案主要是，可以将缓存失效时间分散开。比如，可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机。这样，每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。\n5.redis做为缓存，mysql的数据如何与redis进行同步呢？（双写一致性） 我最近做的这个项目，里面有xxxx（根据自己的简历上写）的功能，需要让数据库与redis高度保持一致，因为要求时效性比较高。\n我们当时采用的读写锁保证的强一致性。我们使用的是Redisson实现的读写锁。在读的时候添加共享锁，可以保证读读不互斥、读写互斥。当我们更新数据的时候，添加排他锁。它是读写、读读都互斥，这样就能保证在写数据的同时，是不会让其他线程读数据的，避免了脏数据。这里面需要注意的是，读方法和写方法上需要使用同一把锁才行。\n数据同步可以有一定的延时（这符合大部分业务需求）。我们当时采用的阿里的Canal组件实现数据同步：不需要更改业务代码，只需部署一个Canal服务。Canal服务把自己伪装成mysql的一个从节点。当mysql数据更新以后，Canal会读取binlog数据，然后再通过Canal的客户端获取到数据，并更新缓存即可。\n6. 那这个排他锁是如何保证读写、读读互斥的呢？ 其实排他锁底层使用的也是SETNX，它保证了同时只能有一个线程操作锁住的方法。\n7. 你听说过延时双删吗？为什么不用它呢？ 延迟双删，如果是写操作，我们先把缓存中的数据删除，然后更新数据库，最后再延时删除缓存中的数据。其中，这个延时多久不太好确定。在延时的过程中，可能会出现脏数据，并不能保证强一致性，所以没有采用它。\n8.redis做为缓存，数据的持久化是怎么做的？这两种持久化方式有什么区别呢？ 在Redis中提供了两种数据持久化的方式：1) RDB；2) AOF。\nRDB是一个快照文件。它是把redis内存存储的数据写到磁盘上。当redis实例宕机恢复数据的时候，可以从RDB的快照文件中恢复数据。AOF的含义是追加文件。当redis执行写命令的时候，都会存储到这个文件中。当redis实例宕机恢复数据的时候，会从这个文件中再次执行一遍命令来恢复数据。\n9.这两种方式，哪种恢复的比较快呢？ RDB因为是二进制文件，保存时体积也比较小，所以它恢复得比较快。但它有可能会丢数据。我们通常在项目中也会使用AOF来恢复数据。虽然AOF恢复的速度慢一些，但它丢数据的风险要小很多。在AOF文件中可以设置刷盘策略。我们当时设置的就是每秒批量写入一次命令。\n10.Redis的数据过期策略有哪些？ 在redis中提供了两种数据过期删除策略。第一种是惰性删除。在设置该key过期时间后，我们不去管它。当需要该key时，我们检查其是否过期。如果过期，我们就删掉它；反之，返回该key。第二种是定期删除。就是说，每隔一段时间，我们就对一些key进行检查，并删除里面过期的key。定期清理的两种模式是：1) SLOW模式，是定时任务，执行频率默认为10hz，每次不超过25ms，可以通过修改配置文件redis.conf的hz选项来调整这个次数；2) FAST模式，执行频率不固定，每次事件循环会尝试执行，但两次间隔不低于2ms，每次耗时不超过1ms。Redis的过期删除策略是：惰性删除 + 定期删除两种策略配合使用。\n11.Redis的数据淘汰策略有哪些？ 这个在redis中提供了很多种，默认是noeviction，不删除任何数据，内部不足时直接报错。这个可以在redis的配置文件中进行设置。里面有两个非常重要的概念：一个是LRU，另外一个是LFU。LRU的意思就是最少最近使用。它会用当前时间减去最后一次访问时间。这个值越大，则淘汰优先级越高。LFU的意思是最少频率使用。它会统计每个key的访问频率。值越小，淘汰优先级越高。我们在项目中设置的是allkeys-lru，它会挑选最近最少使用的数据进行淘汰，把一些经常访问的key留在redis中。\n12.数据库有1000万数据，Redis只能缓存20w数据。如何保证Redis中的数据都是热点数据？ 可以使用allkeys-lru（挑选最近最少使用的数据淘汰）淘汰策略。那留下来的都是经常访问的热点数据。\n13.Redis的内存用完了会发生什么？ 这个要看redis的数据淘汰策略是什么。如果是默认的配置，redis内存用完以后则直接报错。我们当时设置的是allkeys-lru策略，把最近最常访问的数据留在缓存中。\n14.Redis分布式锁如何实现？ 在redis中提供了一个命令SETNX(SET if not exists)。由于redis是单线程的，用了这个命令之后，只能有一个客户端对某一个key设置值。在没有过期或删除key的时候，其他客户端是不能设置这个key的。\n15.那你如何控制Redis实现分布式锁的有效时长呢？ redis的SETNX指令不好控制这个问题。我们当时采用的是redis的一个框架Redisson实现的。在Redisson中需要手动加锁，并且可以控制锁的失效时间和等待时间。当锁住的一个业务还没有执行完成的时候，Redisson会引入一个看门狗机制。就是说，每隔一段时间就检查当前业务是否还持有锁。如果持有，就增加加锁的持有时间。当业务执行完成之后，需要使用释放锁就可以了。还有一个好处就是，在高并发下，一个业务有可能会执行很快。客户1持有锁的时候，客户2来了以后并不会马上被拒绝。它会自旋不断尝试获取锁。如果客户1释放之后，客户2就可以马上持有锁，性能也得到了提升。\n16.Redisson实现的分布式锁是可重入的吗？ 是可以重入的。这样做是为了避免死锁的产生。这个重入其实在内部就是判断是否是当前线程持有的锁，如果是当前线程持有的锁就会计数，如果释放锁就会在计数上减一。在存储数据的时候采用的hash结构，大key可以按照自己的业务进行定制，其中小key是当前线程的唯一标识，value是当前线程重入的次数。\n17.Redisson实现的分布式锁能解决主从一致性的问题吗？ 这个是不能的。比如，当线程1加锁成功后，master节点数据会异步复制到slave节点，此时如果当前持有Redis锁的master节点宕机，slave节点被提升为新的master节点，假如现在来了一个线程2，再次加锁，会在新的master节点上加锁成功，这个时候就会出现两个节点同时持有一把锁的问题。\n我们可以利用Redisson提供的红锁来解决这个问题，它的主要作用是，不能只在一个Redis实例上创建锁，应该是在多个Redis实例上创建锁，并且要求在大多数Redis节点上都成功创建锁，红锁中要求是Redis的节点数量要过半。这样就能避免线程1加锁成功后master节点宕机导致线程2成功加锁到新的master节点上的问题了。\n但是，如果使用了红锁，因为需要同时在多个节点上都添加锁，性能就变得非常低，并且运维维护成本也非常高，所以，我们一般在项目中也不会直接使用红锁，并且官方也暂时废弃了这个红锁。\n18.如果业务非要保证数据的强一致性，这个该怎么解决呢？ Redis本身就是支持高可用的，要做到强一致性，就非常影响性能，所以，如果有强一致性要求高的业务，建议使用ZooKeeper实现的分布式锁，它是可以保证强一致性的。\n19. Redis集群有哪些方案，知道吗？ 在Redis中提供的集群方案总共有三种：主从复制、哨兵模式、Redis分片集群。\n20.介绍一下主从同步 单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，可以搭建主从集群，实现读写分离。一般都是一主多从，主节点负责写数据，从节点负责读数据，主节点写入数据之后，需要把数据同步到从节点中。\n21.能说一下，主从同步数据的流程吗？ 主从同步分为了两个阶段，一个是全量同步，一个是增量同步。\n全量同步是指从节点第一次与主节点建立连接的时候使用全量同步，流程是这样的：\n第一：从节点请求主节点同步数据，其中从节点会携带自己的replication id和offset偏移量。\n第二：主节点判断是否是第一次请求，主要判断的依据就是，主节点与从节点是否是同一个replication id，如果不是，就说明是第一次同步，那主节点就会把自己的replication id和offset发送给从节点，让从节点与主节点的信息保持一致。\n第三：在同时主节点会执行BGSAVE，生成RDB文件后，发送给从节点去执行，从节点先把自己的数据清空，然后执行主节点发送过来的RDB文件，这样就保持了一致。\n当然，如果在RDB生成执行期间，依然有请求到了主节点，而主节点会以命令的方式记录到缓冲区，缓冲区是一个日志文件，最后把这个日志文件发送给从节点，这样就能保证主节点与从节点完全一致了，后期再同步数据的时候，都是依赖于这个日志文件，这个就是全量同步。\n增量同步指的是，当从节点服务重启之后，数据就不一致了，所以这个时候，从节点会请求主节点同步数据，主节点还是判断不是第一次请求，不是第一次就获取从节点的offset值，然后主节点从命令日志中获取offset值之后的数据，发送给从节点进行数据同步。\n22.怎么保证Redis的高并发高可用？ 首先可以搭建主从集群，再加上使用Redis中的哨兵模式，哨兵模式可以实现主从集群的自动故障恢复，里面就包含了对主从服务的监控、自动故障恢复、通知；如果master故障，Sentinel会将一个slave提升为master。当故障实例恢复后也以新的master为主；同时Sentinel也充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给Redis的客户端，所以一般项目都会采用哨兵的模式来保证Redis的高并发高可用。\n23.你们使用Redis是单点还是集群，哪种集群？ 我们当时使用的是主从（1主1从）加哨兵。一般单节点不超过10G内存，如果Redis内存不足则可以给不同服务分配独立的Redis主从节点。尽量不做分片集群。因为集群维护起来比较麻烦，并且集群之间的心跳检测和数据通信会消耗大量的网络带宽，也没有办法使用Lua脚本和事务。\n24.Redis集群脑裂，该怎么解决呢？ 这个在项目中很少见，不过脑裂的问题是这样的，我们现在用的是Redis的哨兵模式集群的。\n有的时候由于网络等原因可能会出现脑裂的情况，就是说，由于Redis master节点和Redis slave节点和Sentinel处于不同的网络分区，使得Sentinel没有能够心跳感知到master，所以通过选举的方式提升了一个slave为master，这样就存在了两个master，就像大脑分裂了一样，这样会导致客户端还在old master那里写入数据，新节点无法同步数据，当网络恢复后，Sentinel会将old master降为slave，这时再从新master同步数据，这会导致old master中的大量数据丢失。\n关于解决的话，我记得在Redis的配置中可以设置：第一可以设置最少的slave节点个数，比如设置至少要有一个从节点才能同步数据，第二个可以设置主从数据复制和同步的延迟时间，达不到要求就拒绝请求，就可以避免大量的数据丢失。\n25.Redis的分片集群有什么作用？ 分片集群主要解决的是海量数据存储的问题，集群中有多个master，每个master保存不同数据，并且还可以给每个master设置多个slave节点，就可以继续增大集群的高并发能力。同时每个master之间通过ping监测彼此健康状态，就类似于哨兵模式了。当客户端请求可以访问集群任意节点，最终都会被转发到正确节点。\n26.Redis分片集群中数据是怎么存储和读取的？ Redis 集群引入了哈希槽的概念，有 16384 个哈希槽，集群中每个主节点绑定了一定范围的哈希槽范围，key通过CRC16校验后对16384取模来决定放置哪个槽，通过槽找到对应的节点进行存储。取值的逻辑是一样的。\n27.Redis是单线程的，但是为什么还那么快？ 这个有几个原因吧~~~\n  完全基于内存的，C语言编写。\n  采用单线程，避免不必要的上下文切换和竞争条件。\n  使用多路I/O复用模型，非阻塞IO。\n  例如：BGSAVE和BGREWRITEAOF都是在后台执行操作，不影响主线程的正常使用，不会产生阻塞。\n28.能解释一下I/O多路复用模型？ I/O多路复用是指利用单个线程来同时监听多个Socket，并且在某个Socket可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。目前的I/O多路复用都是采用的epoll模式实现，它会在通知用户进程Socket就绪的同时，把已就绪的Socket写入用户空间，不需要挨个遍历Socket来判断是否就绪，提升了性能。\n其中Redis的网络模型就是使用I/O多路复用结合事件的处理器来应对多个Socket请求，比如，提供了连接应答处理器、命令回复处理器，命令请求处理器；\n在Redis6.0之后，为了提升更好的性能，在命令回复处理器使用了多线程来处理回复事件，在命令请求处理器中，将命令的转换使用了多线程，增加命令转换速度，在命令执行的时候，依然是单线程\nMySQL 1.MySQL中，如何定位慢查询？ 系统部署了运维监控系统Skywalking，在它的报表展示中可以看到哪个接口慢，并且能分析出接口中哪部分耗时较多，包括具体的SQL执行时间，这样就能定位到出现问题的SQL。\n如果没有这种监控系统，MySQL本身也提供了慢查询日志功能。可以在MySQL的系统配置文件中开启慢查询日志，并设置SQL执行时间超过多少就记录到日志文件，比如我们之前项目设置的是2秒，超过这个时间的SQL就会记录在日志文件中，我们就可以在那里找到执行慢的SQL。\n2.那这个SQL语句执行很慢，如何分析呢？ 如果一条SQL执行很慢，我们通常会使用MySQL的EXPLAIN命令来分析这条SQL的执行情况。通过key和key_len可以检查是否命中了索引，如果已经添加了索引，也可以判断索引是否有效。通过type字段可以查看SQL是否有优化空间，比如是否存在全索引扫描或全表扫描。通过extra建议可以判断是否出现回表情况，如果出现，可以尝试添加索引或修改返回字段来优化。\n3.了解过索引吗？（什么是索引） 索引在项目中非常常见，它是一种帮助MySQL高效获取数据的数据结构，主要用来提高数据检索效率，降低数据库的I/O成本。同时，索引列可以对数据进行排序，降低数据排序的成本，也能减少CPU的消耗。\n4.索引的底层数据结构了解过吗？ MySQL的默认存储引擎InnoDB使用的是B+树作为索引的存储结构。选择B+树的原因包括：节点可以有更多子节点，路径更短；磁盘读写代价更低，非叶子节点只存储键值和指针，叶子节点存储数据；B+树适合范围查询和扫描，因为叶子节点形成了一个双向链表。\n5.B树和B+树的区别是什么呢？   B树的非叶子节点和叶子节点都存放数据，而B+树的所有数据只出现在叶子节点，这使得B+树在查询时效率更稳定。\n  B+树在进行范围查询时效率更高，因为所有数据都在叶子节点，并且叶子节点之间形成了双向链表。\n  6.什么是聚簇索引什么是非聚簇索引？ 聚簇索引是指数据与索引放在一起，B+树的叶子节点保存了整行数据，通常只有一个聚簇索引，一般是由主键构成。\n非聚簇索引则是数据与索引分开存储，B+树的叶子节点保存的是主键值，可以有多个非聚簇索引，通常我们自定义的索引都是非聚簇索引。\n7.知道什么是回表查询吗？ 回表查询是指通过二级索引找到对应的主键值，然后再通过主键值查询聚簇索引中对应的整行数据的过程。\n8.知道什么叫覆盖索引吗？ 覆盖索引是指在SELECT查询中，返回的列全部能在索引中找到，避免了回表查询，提高了性能。使用覆盖索引可以减少对主键索引的查询次数，提高查询效率。\n9.MySQL超大分页怎么处理？ 超大分页通常发生在数据量大的情况下，使用LIMIT分页查询且需要排序时效率较低。可以通过覆盖索引和子查询来解决。首先查询数据的ID字段进行分页，然后根据ID列表用子查询来过滤只查询这些ID的数据，因为查询ID时使用的是覆盖索引，所以效率可以提升。\n10.索引创建原则有哪些？ 创建索引的原则包括：\n• 表中的数据量超过10万以上时考虑创建索引。\n• 选择查询频繁的字段作为索引，如查询条件、排序字段或分组字段。\n• 尽量使用复合索引，覆盖SQL的返回值。\n• 如果字段区分度不高，可以将其放在组合索引的后面。\n• 对于内容较长的字段，考虑使用前缀索引。\n• 控制索引数量，因为索引虽然可以提高查询速度，但也会影响插入、更新的速度。\n11.什么情况下索引会失效？ 索引可能在以下情况下失效：\n• 没有遵循最左匹配原则。\n• 使用了模糊查询且%号在前面。\n• 在索引字段上进行了运算或类型转换。\n• 使用了复合索引但在中间使用了范围查询，导致右边的条件索引失效。\n12.SQL的优化经验有哪些？ SQL优化可以从以下几个方面考虑：\n• 建表时选择合适的字段类型。\n• 使用索引，遵循创建索引的原则。\n• 编写高效的SQL语句，比如避免使用SELECT *，尽量使用UNION ALL代替UNION，以及在表关联时使用INNER JOIN。\n• 采用主从复制和读写分离提高性能。\n• 在数据量大时考虑分库分表。\n13.创建表的时候，你们是如何优化的呢？ 创建表时，我们主要参考《嵩山版》开发手册，选择字段类型时结合字段内容，比如数值类型选择TINYINT、INT、BIGINT等，字符串类型选择CHAR、VARCHAR或TEXT。\n14.在使用索引的时候，是如何优化呢？ 在使用索引时，我们遵循索引创建原则，确保索引字段是查询频繁的，使用复合索引覆盖SQL返回值，避免在索引字段上进行运算或类型转换，以及控制索引数量。\n15.你平时对SQL语句做了哪些优化呢？ 我对SQL语句的优化包括指明字段名称而不是使用SELECT *，避免造成索引失效的写法，聚合查询时使用UNION ALL代替UNION，表关联时优先使用INNER JOIN，以及在必须使用LEFT JOIN或RIGHT JOIN时，确保小表作为驱动表。\n16.事务的特性是什么？可以详细说一下吗？ 事务的特性是ACID，即原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。例如，A向B转账500元，这个操作要么都成功，要么都失败，体现了原子性。转账过程中数据要保持一致，A扣除了500元，B必须增加500元。隔离性体现在A向B转账时，不受其他事务干扰。持久性体现在事务提交后，数据要被持久化存储。\n17.并发事务带来哪些问题？ 并发事务可能导致脏读、不可重复读和幻读。脏读是指一个事务读到了另一个事务未提交的“脏数据”。不可重复读是指在一个事务内多次读取同一数据，由于其他事务的修改导致数据不一致。幻读是指一个事务读取到了其他事务插入的“幻行”。\n18.怎么解决这些问题呢？MySQL的默认隔离级别是？ 解决这些问题的方法是使用事务隔离。MySQL支持四种隔离级别：\n  未提交读（READ UNCOMMITTED）：解决不了所有问题。\n  读已提交（READ COMMITTED）：能解决脏读，但不能解决不可重复读和幻读。\n  可重复读（REPEATABLE READ）：能解决脏读和不可重复读，但不能解决幻读，这也是MySQL的默认隔离级别。\n  串行化（SERIALIZABLE）：可以解决所有问题，但性能较低。\n  19.undo log和redo log的区别是什么？ redo log记录的是数据页的物理变化，用于服务宕机后的恢复，保证事务的持久性。而undo log记录的是逻辑日志，用于事务回滚时恢复原始数据，保证事务的原子性和一致性。\n20.事务中的隔离性是如何保证的呢？（你解释一下MVCC） 事务的隔离性通过锁和多版本并发控制（MVCC）来保证。MVCC通过维护数据的多个版本来避免读写冲突。底层实现包括隐藏字段、undo log和read view。隐藏字段包括trx_id和roll_pointer。undo log记录了不同版本的数据，通过roll_pointer形成版本链。read view定义了不同隔离级别下的快照读，决定了事务访问哪个版本的数据。\n21. MySQL主从同步原理是什么？ MySQL主从复制的核心是二进制日志（Binlog）。步骤如下：\n  主库在事务提交时记录数据变更到Binlog。\n  从库读取主库的Binlog并写入中继日志（Relay Log）。\n  从库重做中继日志中的事件，反映到自己的数据中。\n  22.你们项目用过MySQL的分库分表吗？ 我们采用微服务架构，每个微服务对应一个数据库，是根据业务进行拆分的，这个其实就是垂直拆分。\n23. 那你之前使用过水平分库吗？ 使用过。当时业务发展迅速，某个表数据量超过1000万，单库优化后性能仍然很慢，因此采用了水平分库。我们首先部署了3台服务器和3个数据库，使用mycat进行数据分片。旧数据也按照ID取模规则迁移到了各个数据库中，这样各个数据库可以分摊存储和读取压力，解决了性能问题。\nSSM 1. Spring框架中的单例bean是线程安全的吗？ 不是线程安全的。当多用户同时请求一个服务时，容器会给每个请求分配一个线程，这些线程会并发执行业务逻辑。如果处理逻辑中包含对单例状态的修改，比如修改单例的成员属性，就必须考虑线程同步问题。Spring框架本身并不对单例bean进行线程安全封装，线程安全和并发问题需要开发者自行处理。\n通常在项目中使用的Spring bean是不可变状态（如Service类和DAO类），因此在某种程度上可以说Spring的单例bean是线程安全的。如果bean有多种状态（如ViewModel对象），就需要自行保证线程安全。最简单的解决办法是将单例bean的作用域由“singleton”变更为“prototype”。\n2.什么是AOP？ AOP，即面向切面编程，在Spring中用于将那些与业务无关但对多个对象产生影响的公共行为和逻辑抽取出来，实现公共模块复用，降低耦合。常见的应用场景包括公共日志保存和事务处理。\n3.你们项目中有没有使用到AOP？ 我们之前在后台管理系统中使用AOP来记录系统操作日志。主要思路是使用AOP的环绕通知和切点表达式，找到需要记录日志的方法，然后通过环绕通知的参数获取请求方法的参数，例如类信息、方法信息、注解、请求方式等，并将这些参数保存到数据库。\n4.Spring中的事务是如何实现的？ Spring实现事务的本质是利用AOP完成的。它对方法前后进行拦截，在执行方法前开启事务，在执行完目标方法后根据执行情况提交或回滚事务。\n5. Spring中事务失效的场景有哪些？ 在项目中，我遇到过几种导致事务失效的场景：\n  如果方法内部捕获并处理了异常，没有将异常抛出，会导致事务失效。因此，处理异常后应该确保异常能够被抛出。\n  如果方法抛出检查型异常（checked exception），并且没有在@Transactional注解上配置rollbackFor属性为Exception，那么异常发生时事务可能不会回滚。\n  如果事务注解的方法不是公开（public）修饰的，也可能导致事务失效。\n  6.Spring的bean的生命周期？ Spring中bean的生命周期包括以下步骤：\n  通过BeanDefinition获取bean的定义信息。\n  调用构造函数实例化bean。\n  进行bean的依赖注入，例如通过setter方法或@Autowired注解。\n  处理实现了Aware接口的bean。\n  执行BeanPostProcessor的前置处理器。\n  调用初始化方法，如实现了InitializingBean接口或自定义的init-method。\n  执行BeanPostProcessor的后置处理器，可能在这里产生代理对象。\n  最后是销毁bean。\n  7.Spring中的循环引用？ 循环依赖发生在两个或两个以上的bean互相持有对方，形成闭环。Spring框架允许循环依赖存在，并通过三级缓存解决大部分循环依赖问题：\n  一级缓存：单例池，缓存已完成初始化的bean对象。\n  二级缓存：缓存尚未完成生命周期的早期bean对象。\n  三级缓存：缓存ObjectFactory，用于创建bean对象。\n  8.那具体解决流程清楚吗？ 解决循环依赖的流程如下：\n  实例化A对象，并创建ObjectFactory存入三级缓存。\n  A在初始化时需要B对象，开始B的创建逻辑。\n  B实例化完成，也创建ObjectFactory存入三级缓存。\n  B需要注入A，通过三级缓存获取ObjectFactory生成A对象，存入二级缓存。\n  B通过二级缓存获得A对象后，B创建成功，存入一级缓存。\n  A对象初始化时，由于B已创建完成，可以直接注入B，A创建成功存入一级缓存。\n  清除二级缓存中的临时对象A。\n  9.构造方法出现了循环依赖怎么解决？ 由于构造函数是bean生命周期中最先执行的，Spring框架无法解决构造方法的循环依赖问题。可以使用@Lazy懒加载注解，延迟bean的创建直到实际需要时。\n10.SpringMVC的执行流程？ SpringMVC的执行流程包括以下步骤：\n  用户发送请求到前端控制器DispatcherServlet。\n  DispatcherServlet调用HandlerMapping找到具体处理器。\n  HandlerMapping返回处理器对象及拦截器（如果有）给DispatcherServlet。\n  DispatcherServlet调用HandlerAdapter。\n  HandlerAdapter适配并调用具体处理器（Controller）。\n  Controller执行并返回ModelAndView对象。\n  HandlerAdapter将ModelAndView返回给DispatcherServlet。\n  DispatcherServlet传给ViewResolver进行视图解析。\n  ViewResolver返回具体视图给DispatcherServlet。\n  DispatcherServlet渲染视图并响应用户。\n  11.Springboot自动配置原理？ Spring Boot的自动配置原理基于@SpringBootApplication注解，它封装了@SpringBootConfiguration、@EnableAutoConfiguration和@ComponentScan。@EnableAutoConfiguration是核心，它通过@Import导入配置选择器，读取META-INF/spring.factories文件中的类名，根据条件注解决定是否将配置类中的Bean导入到Spring容器中。\n12.Spring 的常见注解有哪些？ Spring的常见注解包括：\n  声明Bean的注解：@Component、@Service、@Repository、@Controller。\n  依赖注入相关注解：@Autowired、@Qualifier、@Resource。\n  设置作用域的注解：@Scope。\n  配置相关注解：@Configuration、@ComponentScan、@Bean。\n  AOP相关注解：@Aspect、@Before、@After、@Around、@Pointcut。\n  13.SpringMVC常见的注解有哪些？ SpringMVC的常见注解有：\n• @RequestMapping：映射请求路径。\n• @RequestBody：接收HTTP请求的JSON数据。\n• @RequestParam：指定请求参数名称。\n• @PathVariable：从请求路径中获取参数。\n• @ResponseBody：将Controller方法返回的对象转化为JSON。\n• @RequestHeader：获取请求头数据。\n• @PostMapping、@GetMapping等。\n14.Springboot常见注解有哪些？ Spring Boot的常见注解包括：\n• @SpringBootApplication：由@SpringBootConfiguration、@EnableAutoConfiguration和@ComponentScan组成。\n• 其他注解如@RestController、@GetMapping、@PostMapping等，用于简化Spring MVC的配置。\n15.MyBatis执行流程？ MyBatis的执行流程如下：\n  读取MyBatis配置文件mybatis-config.xml。\n  构造会话工厂SqlSessionFactory。\n  会话工厂创建SqlSession对象。\n  操作数据库的接口，Executor执行器。\n  Executor执行方法中的MappedStatement参数。\n  输入参数映射。\n  输出结果映射。\n  16.Mybatis是否支持延迟加载？ MyBatis支持延迟加载，即在需要用到数据时才加载。可以通过配置文件中的lazyLoadingEnabled配置启用或禁用延迟加载。\n17.延迟加载的底层原理知道吗？ 延迟加载的底层原理主要使用CGLIB动态代理实现：\n  使用CGLIB创建目标对象的代理对象。\n  调用目标方法时，如果发现是null值，则执行SQL查询。\n  获取数据后，设置属性值并继续查询目标方法。\n18.Mybatis的一级、二级缓存用过吗？ MyBatis的一级缓存是基于PerpetualCache的HashMap本地缓存，作用域为Session，默认开启。二级缓存需要单独开启，作用域为Namespace或mapper，默认也是采用PerpetualCache，HashMap存储。\n19.Mybatis的二级缓存什么时候会清理缓存中的数据？ 当作用域（一级缓存Session/二级缓存Namespaces）进行了新增、修改、删除操作后，默认该作用域下所有select中的缓存将被清空。\n微服务 1.Spring Cloud 5大组件有哪些？ 在早期，Spring Cloud的五大组件通常指的是：\n• Eureka：服务注册中心。\n• Ribbon：客户端负载均衡器。\n• Feign：声明式的服务调用。\n• Hystrix：服务熔断器。\n• Zuul/Gateway：API网关。\n随着Spring Cloud Alibaba的兴起，我们项目中也融入了一些阿里巴巴的技术组件：\n• 服务注册与配置中心：Nacos。\n• 负载均衡：Ribbon。\n• 服务调用：Feign。\n• 服务保护：Sentinel。\n• API网关：Gateway。\n2.服务注册和发现是什么意思？Spring Cloud 如何实现服务注册发现？ 服务注册与发现主要包含三个核心功能：服务注册、服务发现和服务状态监控。\n我们项目中采用了Eureka作为服务注册中心，它是Spring Cloud体系中的一个关键组件。\n• 服务注册：服务提供者将自己的信息（如服务名称、IP、端口等）注册到Eureka。\n• 服务发现：消费者从Eureka获取服务列表信息，并利用负载均衡算法选择一个服务进行调用。\n• 服务监控：服务提供者定期向Eureka发送心跳以报告健康状态；如果Eureka在一定时间内未接收到心跳，将服务实例从注册中心剔除。\n3.我看你之前也用过nacos，你能说下nacos与eureka的区别？ 在使用Nacos作为注册中心的项目中，我注意到Nacos与Eureka的共同点和区别：\n• 共同点：两者都支持服务注册与发现，以及心跳检测作为健康检查机制。\n• 区别：\na. Nacos支持服务端主动检测服务提供者状态，而Eureka依赖客户端心跳。\nb. Nacos区分临时实例和非临时实例，采用不同的健康检查策略。\nc. Nacos支持服务列表变更的消息推送，使服务更新更及时。\nd. Nacos集群默认采用AP模式，但在存在非临时实例时，会采用CP模式；而Eureka始终采用AP模式。\n4.你们项目负载均衡如何实现的？ 在服务调用过程中，我们使用Spring Cloud的Ribbon组件来实现客户端负载均衡。Feign客户端在底层已经集成了Ribbon，使得使用非常简便。\n当发起远程调用时，Ribbon首先从注册中心获取服务地址列表，然后根据预设的路由策略选择一个服务实例进行调用，常用的策略是轮询。\n5.Ribbon负载均衡策略有哪些？ Ribbon提供了多种负载均衡策略，包括：\n• RoundRobinRule：简单的轮询策略。\n• WeightedResponseTimeRule：根据响应时间加权选择服务器。\n• RandomRule：随机选择服务器。\n• ZoneAvoidanceRule：区域感知的负载均衡，优先选择同一区域中可用的服务器。\n6.如果想自定义负载均衡策略如何实现？ 自定义Ribbon负载均衡策略有两种方式：\n  创建一个类实现IRule接口，这将定义全局的负载均衡策略。\n  在客户端配置文件中指定特定服务调用的负载均衡策略，这将仅对该服务生效。\n  7.什么是服务雪崩，怎么解决这个问题？ 服务雪崩是指一个服务的失败导致整个链路的服务相继失败。我们通常通过服务降级和服务熔断来解决这个问题：\n• 服务降级：在请求量突增时，主动降低服务的级别，确保核心服务可用。\n• 服务熔断：当服务调用失败率达到一定阈值时，熔断机制会启动，防止系统过载。\n8.你们的微服务是怎么监控的？ 我们项目中采用了SkyWalking进行微服务监控：\n SkyWalking能够监控接口、服务和物理实例的状态，帮助我们识别和优化慢服务。 我们还设置了告警规则，一旦检测到异常，系统会通过短信或邮件通知相关负责  9.你们项目中有没有做过限流？怎么做的？ 在我们的项目中，由于面临可能的突发流量，我们采用了限流策略：\n• 版本1：使用Nginx进行限流，通过漏桶算法控制请求处理速率，按照IP进行限流。\n• 版本2：使用Spring Cloud Gateway的RequestRateLimiter过滤器进行限流，采用令牌桶算法，可以基于IP或路径进行限流。\n10.限流常见的算法有哪些？ 常见的限流算法包括：\n• 漏桶算法：以固定速率处理请求，平滑突发流量。\n• 令牌桶算法：按照一定速率生成令牌，请求在获得令牌后才被处理，适用于请求量有波动的场景。\n11.什么是CAP理论？ CAP理论是分布式系统设计的基础理论，包含一致性(Consistency)、可用性(Availability)和分区容错性(Partition tolerance)。在网络分区发生时，系统只能在一致性和可用性之间选择其一。\n12.为什么分布式系统中无法同时保证一致性和可用性？ 在分布式系统中，为了保证分区容错性，我们通常需要在一致性和可用性之间做出选择。如果系统优先保证一致性，可能需要牺牲可用性，反之亦然。\n13.什么是BASE理论？ BASE理论是分布式系统设计中对CAP理论中AP方案的延伸，强调通过基本可用、软状态和最终一致性来实现系统设计。\n14.你们采用哪种分布式事务解决方案？ 我们项目中使用了Seata的AT模式来解决分布式事务问题。AT模式通过记录业务数据的变更日志来保证事务的最终一致性。\n15.分布式服务的接口幂等性如何设计？ 我们通过Token和Redis来实现接口幂等性。用户操作时，系统生成一个Token并存储在Redis中，当用户提交操作时，系统会验证Token的存在性，并在验证通过后删除Token，确保每个Token只被处理一次。\n16.xxl-job路由策略有哪些？ xxl-job支持多种路由策略，包括轮询、故障转移和分片广播等。\n17.xxl-job任务执行失败怎么解决？ 面对任务执行失败，我们可以：\n  选择故障转移路由策略，优先使用健康的实例执行任务。\n  设置任务重试次数。\n  通过日志记录和邮件告警通知相关负责人。\n  18.如果有大数据量的任务同时都需要执行，怎么解决？ 我们可以通过部署多个实例并使用分片广播路由策略来分散任务负载。在任务执行代码中，根据分片信息和总数对任务进行分配。\n消息中间件 1.RabbitMQ如何保证消息不丢失？ 我们使用RabbitMQ来确保MySQL和Redis间数据双写的一致性，这要求我们实现消息的高可用性，具体措施包括：\n  开启生产者确认机制，确保消息能被送达队列，如有错误则记录日志并修复数据。\n  启用持久化功能，保证消息在未消费前不会在队列中丢失，需要对交换机、队列和消息本身都进行持久化。\n  对消费者开启自动确认机制，并设置重试次数。例如，我们设置了3次重试，若失败则将消息发送至异常交换机，由人工处理。\n  2.RabbitMQ消息的重复消费问题如何解决？ 我们遇到过消息重复消费的问题，处理方法是：\n• 设置消费者为自动确认模式，如果服务在确认前宕机，重启后可能会再次消费同一消息。\n• 通过业务唯一标识检查数据库中数据是否存在，若不存在则处理消息，若存在则忽略，避免重复消费。\n3.那你还知道其他的解决方案吗？ 是的，这属于幂等性问题，可以通过以下方法解决：\n• 使用Redis分布式锁或数据库锁来确保操作的幂等性。\n4. RabbitMQ中死信交换机了解吗？（RabbitMQ延迟队列有了解过吗？） 了解。我们项目中使用RabbitMQ实现延迟队列，主要通过死信交换机和TTL（消息存活时间）来实现。\n• 消息若超时未消费则变为死信，队列可绑定死信交换机，实现延迟功能。\n• 另一种方法是安装RabbitMQ的死信插件，简化配置，在声明交换机时指定为死信交换机，并设置消息超时时间。\n5.如果有100万消息堆积在MQ，如何解决？ 若出现消息堆积，可采取以下措施：\n  提高消费者消费能力，如使用多线程。\n  增加消费者数量，采用工作队列模式，让多个消费者并行消费同一队列。\n  扩大队列容量，使用RabbitMQ的惰性队列，支持数百万条消息存储，直接存盘而非内存。\n  6.RabbitMQ的高可用机制了解吗？ 我们项目在生产环境使用RabbitMQ集群，采用镜像队列模式，一主多从结构。\n• 主节点处理所有操作并同步给从节点，若主节点宕机，从节点可接替为主节点，但需注意数据同步的完整性。\n7.那出现丢数据怎么解决呢？ 使用仲裁队列，主从模式，基于Raft协议实现强一致性数据同步，简化配置，提高数据安全性。\n8. Kafka是如何保证消息不丢失？ Kafka保证消息不丢失的措施包括：\n  生产者使用异步回调发送消息，设置重试机制应对网络问题。\n  在Broker中通过复制机制，设置acks参数为all，确保消息在所有副本中都得到确认。\n  消费者手动提交消费成功的offset，避免自动提交可能导致的数据丢失或重复消费。\n  9. Kafka中消息的重复消费问题如何解决？ 通过以下方法解决Kafka中的重复消费问题：\n• 禁用自动提交offset，手动控制offset提交时机。\n• 确保消息消费的幂等性，例如通过唯一主键或分布式锁。\n10. Kafka是如何保证消费的顺序性？ Kafka默认不保证消息顺序性，但可以通过以下方法实现：\n• 将消息存储在同一个分区，通过指定分区号或相同的业务key来实现。\n11. Kafka的高可用机制了解吗？ Kafka的高可用性主要通过以下机制实现：\n• 集群部署，多broker实例，单点故障不影响整体服务。\n• 复制机制，每个分区有多个副本，leader和follower，leader故障时从follower中选举新leader。\n12. 解释一下复制机制中的ISR？ ISR（In-Sync Replicas）指与leader保持同步的follower副本。\n• 当leader故障时，优先从ISR中选举新leader，因为它们数据一致性更高。\n13. Kafka数据清理机制了解吗？ Kafka的数据清理包括：\n• 基于消息保留时间的清理。\n• 基于topic数据大小的清理，可配置删除最旧消息。\n14. Kafka中实现高性能的设计有了解过吗？ Kafka高性能设计包括：\n• 消息分区，提升数据处理能力。\n• 顺序读写，提高磁盘操作效率。\n• 页缓存，减少磁盘访问。\n• 零拷贝，减少数据拷贝和上下文切换。\n• 消息压缩，减少IO负载。\n• 分批发送，降低网络开销。\n常见集合 1.ArrayList源码分析 ArrayList底层是用动态的数组实现的\n• 初始容量\nArrayList初始容量为0，当第一次添加数据的时候才会初始化容量为10\n• 扩容逻辑\nArrayList在进行扩容的时候是原来容量的1.5倍，每次扩容都需要拷贝数组\n• 添加逻辑\n​\t￮ 确保数组已使用长度（size）加1之后足够存下下一个数据\n​\t￮ 计算数组的容量，如果当前数组已使用长度+1后的大于当前的数组长度，则调用grow方法扩容（原来的1.5倍）\n​\t￮ 确保新增的数据有地方存储之后，则将新元素添加到位于size的位置上。\n​\t￮ 返回添加成功布尔值。\n2.面试题-ArrayList list=new ArrayList(10)中的list扩容几次 该语句只是声明和实例了一个 ArrayList，指定了容量为 10，未扩容\n3.面试题-如何实现数组和List之间的转换 参考回答：\n• 数组转List ，使用JDK中java.util.Arrays工具类的asList方法\n• List转数组，使用List的toArray方法。无参toArray方法返回 Object数组，传入初始化长度的数组对象，返回该对象数组\n面试官再问：\n1，用Arrays.asList转List后，如果修改了数组内容，list受影响吗\n2，List用toArray转数组后，如果修改了List内容，数组受影响吗\n数组转List受影响\nList转数组不受影响\n再答：\n1，用Arrays.asList转List后，如果修改了数组内容，list受影响吗\nArrays.asList转换list之后，如果修改了数组的内容，list会受影响，因为它的底层使用的Arrays类中的一个内部类ArrayList来构造的集合，在这个集合的构造器中，把我们传入的这个集合进行了包装而已，最终指向的都是同一个内存地址\n2，List用toArray转数组后，如果修改了List内容，数组受影响吗\nlist用了toArray转数组后，如果修改了list内容，数组不会影响，当调用了toArray以后，在底层是它是进行了数组的拷贝，跟原来的元素就没啥关系了，所以即使list修改了以后，数组也不受影响\n4.面试题-ArrayList和LinkedList的区别是什么？ • 底层数据结构\n​\t￮ ArrayList 是动态数组的数据结构实现\n​\t￮ LinkedList 是双向链表的数据结构实现\n• 操作数据效率\n​\t￮ ArrayList按照下标查询的时间复杂度O(1)【内存是连续的，根据寻址公式】， LinkedList不支持下标查询\n​\t￮ 查找（未知索引）： ArrayList需要遍历，链表也需要链表，时间复杂度都是O(n)\n​\t￮ 新增和删除\n▪ ArrayList尾部插入和删除，时间复杂度是O(1)；其他部分增删需要挪动数组，时间复杂度是O(n)\n▪ LinkedList头尾节点增删时间复杂度是O(1)，其他都需要遍历链表，时间复杂度是O(n)\n• 内存空间占用\n​\t￮ ArrayList底层是数组，内存连续，节省内存\n​\t￮ LinkedList 是双向链表需要存储数据，和两个指针，更占用内存\n• 线程安全\n​\t￮ ArrayList和LinkedList都不是线程安全的\n​\t￮ 如果需要保证线程安全，有两种方案：\n​\t▪ 在方法内使用，局部变量则是线程安全的\n​\t▪ 使用线程安全的ArrayList和LinkedList\n5. 面试题-说一下HashMap的实现原理？ HashMap的数据结构： 底层使用hash表数据结构，即数组和链表或红黑树\n  当我们往HashMap中put元素时，利用key的hashCode重新hash计算出当前对象的元素在数组中的下标\n  存储时，如果出现hash值相同的key，此时有两种情况。\n​\ta. 如果key相同，则覆盖原始值；\n​\tb. 如果key不同（出现冲突），则将当前的key-value放入链表或红黑树中\n  获取时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。\n  面试官追问：HashMap的jdk1.7和jdk1.8有什么区别\n• JDK1.8之前采用的是拉链法。拉链法：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。\n• jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8） 时并且数组长度达到64时，将链表转化为红黑树，以减少搜索时间。扩容 resize( ) 时，红黑树拆分成的树的结点数小于等于临界值6个，则退化成链表\n6.面试题-HashMap的put方法的具体流程   判断键值对数组table是否为空或为null，否则执行resize()进行扩容（初始化）\n  根据键值key计算hash值得到数组索引\n  判断table[i]==null，条件成立，直接新建节点添加\n  如果table[i]==null ,不成立\n  4.1 判断table[i]的首个元素是否和key一样，如果相同直接覆盖value\n  4.2 判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对\\7. 4.3 遍历table[i]，链表的尾部插入数据，然后判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操 作，遍历过程中若发现key已经存在直接覆盖value\n  插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold（数组长度*0.75），如果超过，进行扩容。\n  7.面试题-讲一讲HashMap的扩容机制 • 在添加元素或初始化的时候需要调用resize方法进行扩容，第一次添加数据初始化数组长度为16，以后每次每次扩容都是达到了扩容阈值（数组长度 * 0.75）\n• 每次扩容的时候，都是扩容之前容量的2倍；\n• 扩容之后，会新创建一个数组，需要把老数组中的数据挪动到新的数组中\n​\t￮ 没有hash冲突的节点，则直接使用 e.hash \u0026amp; (newCap - 1) 计算新数组的索引位置\n​\t￮ 如果是红黑树，走红黑树的添加\n​\t￮ 如果是链表，则需要遍历链表，可能需要拆分链表，判断(e.hash \u0026amp; oldCap)是否为0，该元素的位置要么停留在原始位置，要么移动到原始位置+增加的数组大小这个位置上\n8.面试题-hashMap的寻址算法 首先获取key的hashCode值，然后右移16位 异或运算 原来的hashCode值，主要作用就是使原来的hash值更加均匀，减少hash冲突\n有了hash值之后，就很方便的去计算当前key的在数组中存储的下标，(n-1)\u0026amp;hash : 得到数组中的索引，代替取模，性能更好，数组长度必须是2的n次幂\n9.为何HashMap的数组长度一定是2的次幂？   计算索引时效率更高：如果是 2 的 n 次幂可以使用位与运算代替取模\n  扩容时重新计算索引效率更高： hash \u0026amp; oldCap == 0 的元素留在原来位置 ，否则新位置 = 旧位置 + oldCap\n  10.面试题-hashmap在1.7情况下的多线程死循环问题 在jdk1.7的hashmap中在数组进行扩容的时候，因为链表是头插法，在进行数据迁移的过程中，有可能导致死循环\n比如说，现在有两个线程\n线程一：读取到当前的hashmap数据，数据中一个链表，在准备扩容时，线程二介入\n线程二：也读取hashmap，直接进行扩容。因为是头插法，链表的顺序会进行颠倒过来。比如原来的顺序是AB，扩容后的顺序是BA，线程二执行结束。\n线程一：继续执行的时候就会出现死循环的问题。\n线程一先将A移入新的链表，再将B插入到链头，由于另外一个线程的原因，B的next指向了A，\n所以B-\u0026gt;A-\u0026gt;B,形成循环。\n当然，JDK 8 将扩容算法做了调整，不再将元素加入链表头（而是保持与扩容前一样的顺序），尾插法，就避免了jdk7中死循环的问题。\n11.面试题-HashSet与HashMap的区别 (1)HashSet实现了Set接口, 仅存储对象; HashMap实现了 Map接口, 存储的是键值对.\n(2)HashSet底层其实是用HashMap实现存储的, HashSet封装了一系列HashMap的方法. 依靠HashMap来存储元素值,(利用hashMap的key键进行存储), 而value值默认为Object对象. 所以HashSet也不允许出现重复值, 判断标准和HashMap判断标准相同, 两个元素的hashCode相等并且通过equals()方法返回true.\n12.面试题-HashTable与HashMap的区别 \r13.说一说Java提供的常见集合？ 在java中提供了两大类的集合框架，主要分为两类：\n第一个是Collection 属于单列集合，第二个是Map 属于双列集合\n• 在Collection中有两个子接口List和Set。在我们平常开发的过程中用的比较多像list接口中的实现类ArrarList和LinkedList。 在Set接口中有实现类HashSet和TreeSet。\n• 在map接口中有很多的实现类，平时比较常见的是HashMap、TreeMap，还有一个线程安全的map:ConcurrentHashMap\n14.hashmap是线程安全的吗 不是线程安全的, 我们可以采用ConcurrentHashMap进行使用，它是一个线程安全的HashMap.\n多线程 1.线程和进程的区别？ 当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。\nJava 中，线程作为最小调度单位，进程作为资源分配的最小单位。在 windows 中进程是不活动的，只是作为线程的容器\n二者对比\n• 进程是正在运行程序的实例，进程中包含了线程，每个线程执行不同的任务\n• 不同的进程使用不同的内存空间，在当前进程下的所有线程可以共享内存空间\n• 线程更轻量，线程上下文切换成本一般上要比进程上下文切换低(上下文切换指的是从一个线程切换到另一个线程)\n2.并行和并发有什么区别？ 现在都是多核CPU，在多核CPU下\n并发是同一时间应对多件事情的能力，多个线程轮流使用一个或多个CPU\n并行是同一时间动手做多件事情的能力，4核CPU同时执行4个线程\n3.创建线程的四种方式 在java中一共有四种常见的创建方式，分别是：继承Thread类、实现runnable接口、实现Callable接口、线程池创建线程。通常情况下，我们项目中都会采用线程池的方式创建线程。\n4.runnable 和 callable 有什么区别   Runnable 接口run方法没有返回值；Callable接口call方法有返回值，是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果\n  Callalbe接口支持返回执行结果，需要调用FutureTask.get()得到，此方法会阻塞主进程的继续往下执行，如果不调用不会阻塞。\n  Callable接口的call()方法允许抛出异常；而Runnable接口的run()方法的异常只能在内部消化，不能继续上抛\n  5.线程的 run()和 start()有什么区别？ start(): 用来启动线程，通过该线程调用run方法执行run方法中所定义的逻辑代码。start方法只能被调用一次。\nrun(): 封装了要被线程执行的代码，可以被调用多次。\n6.线程包括哪些状态，状态之间是如何变化的 在JDK中的Thread类中的枚举State里面定义了6中线程的状态分别是：新建、可运行、终结、阻塞、等待和有时限等待六种。\n关于线程的状态切换情况比较多。我分别介绍一下\n当一个线程对象被创建，但还未调用 start 方法时处于新建状态，调用了 start 方法，就会由新建进入可运行状态。如果线程内代码已经执行完毕，由可运行进入终结状态。当然这些是一个线程正常执行情况。\n如果线程获取锁失败后，由可运行进入 Monitor 的阻塞队列阻塞，只有当持锁线程释放锁时，会按照一定规则唤醒阻塞队列中的阻塞线程，唤醒后的线程进入可运行状态\n如果线程获取锁成功后，但由于条件不满足，调用了 wait() 方法，此时从可运行状态释放锁等待状态，当其它持锁线程调用 notify() 或 notifyAll() 方法，会恢复为可运行状态\n还有一种情况是调用 sleep(long) 方法也会从可运行状态进入有时限等待状态，不需要主动唤醒，超时时间到自然恢复为可运行状态\n7.新建 T1、T2、T3 三个线程，如何保证它们按顺序执行？ 可以这么做，在多线程中有多种方法让线程按特定顺序执行，可以用线程类的join()方法在一个线程中启动另一个线程，另外一个线程完成该线程继续执行。\n比如说：\n使用join方法，T3调用T2，T2调用T1，这样就能确保T1就会先完成而T3最后完成\n8.notify()和 notifyAll()有什么区别？ notifyAll：唤醒所有wait的线程\nnotify：只随机唤醒一个 wait 线程\n9.在 java 中 wait 和 sleep 方法的不同？ 共同点\n• wait() ，wait(long) 和 sleep(long) 的效果都是让当前线程暂时放弃 CPU 的使用权，进入阻塞状态\n不同点\n• 方法归属不同\n​\t￮ sleep(long) 是 Thread 的静态方法\n​\t￮ 而 wait()，wait(long) 都是 Object 的成员方法，每个对象都有\n• 醒来时机不同\n​\t￮ 执行 sleep(long) 和 wait(long) 的线程都会在等待相应毫秒后醒来\n​\t￮ wait(long) 和 wait() 还可以被 notify 唤醒，wait() 如果不唤醒就一直等下去\n​\t￮ 它们都可以被打断唤醒\n• 锁特性不同（重点）\n​\t￮ wait 方法的调用必须先获取 wait 对象的锁，而 sleep 则无此限制\n​\t￮ wait 方法执行后会释放对象锁，允许其它线程获得该对象锁（我放弃 cpu，但你们还可以用）\n​\t￮ 而 sleep 如果在 synchronized 代码块中执行，并不会释放对象锁（我放弃 cpu，你们也用不了）\n10.如何停止一个正在运行的线程？ 有三种方式可以停止线程\n• 使用退出标志，使线程正常退出，也就是当run方法完成后线程终止\n• 使用stop方法强行终止（不推荐，方法已作废）\n• 使用interrupt方法中断线程\n11.讲一下synchronized关键字的底层原理？ synchronized 底层使用的JVM级别中的Monitor 来决定当前线程是否获得了锁，如果某一个线程获得了锁，在没有释放锁之前，其他线程是不能或得到锁的。synchronized 属于悲观锁。\nsynchronized 因为需要依赖于JVM级别的Monitor ，相对性能也比较低。\nmonitor对象存在于每个Java对象的对象头中，synchronized 锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因\nmonitor内部维护了三个变量\n• WaitSet：保存处于Waiting状态的线程\n• EntryList：保存处于Blocked状态的线程\n• Owner：持有锁的线程\n只有一个线程获取到的标志就是在monitor中设置成功了Owner，一个monitor中只能有一个Owner\n在上锁的过程中，如果有其他线程也来抢锁，则进入EntryList 进行阻塞，当获得锁的线程执行完了，释放了锁，就会唤醒EntryList 中等待的线程竞争锁，竞争的时候是非公平的。\n12.synchronized关键字的底层原理-进阶 Java中的synchronized有偏向锁、轻量级锁、重量级锁三种形式，分别对应了锁只被一个线程持有、不同线程交替持有锁、多线程竞争锁三种情况。\n重量级锁：底层使用的Monitor实现，里面涉及到了用户态和内核态的切换、进程的上下文切换，成本较高，性能比较低。\n轻量级锁：线程加锁的时间是错开的（也就是没有竞争），可以使用轻量级锁来优化。轻量级修改了对象头的锁标志，相对重量级锁性能提升很多。每次修改都是CAS操作，保证原子性\n偏向锁：一段很长的时间内都只被一个线程使用锁，可以使用了偏向锁，在第一次获得锁时，会有一个CAS操作，之后该线程再获取锁，只需要判断mark word中是否是自己的线程id即可，而不是开销相对较大的CAS命令\n一旦锁发生了竞争，都会升级为重量级锁\n13.你谈谈 JMM（Java 内存模型） Java内存模型是Java虚拟机规范中定义的一种非常重要的内存模型。它的主要作用是描述Java程序中线程共享变量的访问规则，以及这些变量在JVM中是如何被存储和读取的，涉及到一些底层的细节。\n这个模型有几个核心的特点。首先，所有的共享变量，包括实例变量和类变量，都被存储在主内存中，也就是计算机的RAM。需要注意的是，局部变量并不包含在内，因为它们是线程私有的，所以不存在竞争问题。\n其次，每个线程都有自己的工作内存，这里保留了线程所使用的变量的工作副本。这意味着，线程对变量的所有操作，无论是读还是写，都必须在自己的工作内存中完成，而不能直接读写主内存中的变量。\n最后，不同线程之间不能直接访问对方工作内存中的变量。如果线程间需要传递变量的值，那么这个过程必须通过主内存来完成。\n14.CAS 你知道吗？ CAS的全称是： Compare And Swap(比较再交换);它体现的一种乐观锁的思想，在无锁状态下保证线程操作数据的原子性。\n• CAS使用到的地方很多：AQS框架、AtomicXXX类\n• 在操作共享变量的时候使用的自旋锁，效率上更高一些\nCAS的底层是调用的Unsafe类中的方法，都是操作系统提供的，其他语言实现\n15.请谈谈你对 volatile 的理解 volatile 是一个关键字，可以修饰类的成员变量、类的静态成员变量，主要有两个功能\n第一：保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的,volatile关键字会强制将修改的值立即写入主存。\n第二： 禁止进行指令重排序，可以保证代码执行有序性。底层实现原理是，添加了一个内存屏障，通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化\n16.什么是AQS？ AQS的话，其实就一个jdk提供的类AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架。\n内部有一个属性 state 属性来表示资源的状态，默认state等于0，表示没有获取锁，state等于1的时候才标明获取到了锁。通过cas 机制设置 state 状态\n在它的内部还提供了基于 FIFO 的等待队列，是一个双向列表，其中\n• tail 指向队列最后一个元素\n• head 指向队列中最久的一个元素\n其中我们刚刚聊的ReentrantLock底层的实现就是一个AQS。\n17.ReentrantLock的实现原理 ReentrantLock是一个可重入锁:，调用 lock 方 法获取了锁之后，再次调用 lock，是不会再阻塞，内部直接增加重入次数 就行了，标识这个线程已经重复获取一把锁而不需要等待锁的释放。\nReentrantLock是属于juc报下的类，属于api层面的锁，跟synchronized一样，都是悲观锁。通过lock()用来获取锁，unlock()释放锁。\n它的底层实现原理主要利用CAS+AQS队列来实现。它支持公平锁和非公平锁，两者的实现类似\n构造方法接受一个可选的公平参数（默认非公平锁），当设置为true时，表示公平锁，否则为非公平锁。公平锁的效率往往没有非公平锁的效率高。\n18.synchronized和Lock有什么区别 ? 第一，语法层面\n• synchronized 是关键字，源码在 jvm 中，用 c++ 语言实现，退出同步代码块锁会自动释放\n• Lock 是接口，源码由 jdk 提供，用 java 语言实现，需要手动调用 unlock 方法释放锁\n第二，功能层面\n• 二者均属于悲观锁、都具备基本的互斥、同步、锁重入功能\n• Lock 提供了许多 synchronized 不具备的功能，例如获取等待状态、公平锁、可打断、可超时、多条件变量，同时Lock 可以实现不同的场景，如 ReentrantLock， ReentrantReadWriteLock\n第三，性能层面\n• 在没有竞争时，synchronized 做了很多优化，如偏向锁、轻量级锁，性能不赖\n• 在竞争激烈时，Lock 的实现通常会提供更好的性能\n统合来看，需要根据不同的场景来选择不同的锁的使用。\n19.死锁产生的条件是什么？ 嗯，是这样的，一个线程需要同时获取多把锁，这时就容易发生死锁，举个例子来说：\nt1 线程获得A对象锁，接下来想获取B对象的锁\nt2 线程获得B对象锁，接下来想获取A对象的锁\n这个时候t1线程和t2线程都在互相等待对方的锁，就产生了死锁\n20.如何进行死锁诊断？ 我们只需要通过jdk自动的工具就能搞定\n我们可以先通过jps来查看当前java程序运行的进程id\n然后通过jstack来查看这个进程id，就能展示出来死锁的问题，并且，可以定位代码的具体行号范围，我们再去找到对应的代码进行排查就行了。\n21.ConcurrentHashMap ConcurrentHashMap 是一种线程安全的高效Map集合，jdk1.7和1.8也做了很多调整。\n• JDK1.7的底层采用是分段的数组+链表 实现\n• JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。\n在jdk1.7中 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一 种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构 的元素，每个 Segment 守护着一个HashEntry数组里的元素，当对 HashEntry 数组的数据进行修 改时，必须首先获得对应的 Segment的锁。\nSegment 是一种可重入的锁 ReentrantLock，每个 Segment 守护一个HashEntry 数组里得元 素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 锁\n在jdk1.8中的ConcurrentHashMap 做了较大的优化，性能提升了不少。首先是它的数据结构与jdk1.8的hashMap数据结构完全一致。其次是放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保 证并发安全进行实现，synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲 突，就不会产生并发 , 效率得到提升\n22.导致并发程序出现问题的根本原因是什么 Java并发编程有三大核心特性，分别是原子性、可见性和有序性。\n首先，原子性指的是一个线程在CPU中的操作是不可暂停也不可中断的，要么执行完成，要么不执行。比如，一些简单的操作如赋值可能是原子的，但复合操作如自增就不是原子的。为了保证原子性，我们可以使用synchronized关键字或JUC里面的Lock来进行加锁。\n其次，可见性是指让一个线程对共享变量的修改对另一个线程可见。由于线程可能在自己的工作内存中缓存共享变量的副本，因此一个线程对共享变量的修改可能不会立即反映在其他线程的工作内存中。为了解决这个问题，我们可以使用synchronized关键字、volatile关键字或Lock来确保可见性。\n最后，有序性是指处理器为了提高程序运行效率，可能会对输入代码进行优化，导致程序中各个语句的执行先后顺序与代码中的顺序不一致。虽然处理器会保证程序最终执行结果与代码顺序执行的结果一致，但在某些情况下我们可能需要确保特定的执行顺序。为了解决这个问题，我们可以使用volatile关键字来禁止指令重排。\n23.说一下线程池的核心参数（线程池的执行原理知道嘛） 在线程池中一共有7个核心参数：\n  corePoolSize 核心线程数目 - 池中会保留的最多线程数\n  maximumPoolSize 最大线程数目 - 核心线程+救急线程的最大数目\n  keepAliveTime 生存时间 - 救急线程的生存时间，生存时间内没有新任务，此线程资源会释放\n  unit 时间单位 - 救急线程的生存时间单位，如秒、毫秒等\n  workQueue - 当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建救急线程执行任务\n  threadFactory 线程工厂 - 可以定制线程对象的创建，例如设置线程名字、是否是守护线程等\n  handler 拒绝策略 - 当所有线程都在繁忙，workQueue 也放满时，会触发拒绝策略\n  拒绝策略有4种，当线程数过多以后，第一种是抛异常、第二种是由调用者执行任务、第三是丢弃当前的任务，第四是丢弃最早排队任务。默认是直接抛异常。\n24.线程池中有哪些常见的阻塞队列 Jdk中提供了很多阻塞队列，开发中常见的有两个：ArrayBlockingQueue和LinkedBlockingQueue\nArrayBlockingQueue和LinkedBlockingQueue是Java中两种常见的阻塞队列，它们在实现和使用上有一些关键的区别。\n首先，ArrayBlockingQueue是一个有界队列，它在创建时必须指定容量，并且这个容量不能改变。而LinkedBlockingQueue默认是无界的，但也可以在创建时指定最大容量，使其变为有界队列。\n其次，它们在内部数据结构上也有所不同。ArrayBlockingQueue是基于数组实现的，而LinkedBlockingQueue则是基于链表实现的。这意味着ArrayBlockingQueue在访问元素时可能会更快，因为它可以直接通过索引访问数组中的元素。而LinkedBlockingQueue则在添加和删除元素时可能更快，因为它不需要移动其他元素来填充空间。\n另外，它们在加锁机制上也有所不同。ArrayBlockingQueue使用一把锁来控制对队列的访问，这意味着读写操作都是互斥的。而LinkedBlockingQueue则使用两把锁，一把用于控制读操作，另一把用于控制写操作，这样可以提高并发性能。\n25.如何确定核心线程数 ① 高并发、任务执行时间短 \u0026ndash;\u0026gt;（ CPU核数+1 ），减少线程上下文的切换\n② 并发不高、任务执行时间长\n• IO密集型的任务 \u0026ndash;\u0026gt; (CPU核数 * 2 + 1)\n• 计算密集型任务 \u0026ndash;\u0026gt; （ CPU核数+1 ）\n③ 并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置，设置参考（2）\n26.线程池的种类有哪些 在jdk中默认提供了4中方式创建线程池\n第一个是：newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回 收空闲线程，若无可回收，则新建线程。\n第二个是：newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列 中等待。\n第三个是：newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。\n第四个是：newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任 务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。\n27.为什么不建议用Executors创建线程池 主要原因是如果使用Executors创建线程池的话，它允许的请求队列默认长度是Integer.MAX_VALUE，这样的话，有可能导致堆积大量的请求，从而导致OOM（内存溢出）。\n所以，我们一般推荐使用ThreadPoolExecutor来创建线程池，这样可以明确规定线程池的参数，避免资源的耗尽。\n28.线程池使用场景CountDownLatch、Future（你们项目哪里用到了多线程） 参考场景一：\nes数据批量导入\n在我们项目上线之前，我们需要把数据量的数据一次性的同步到es索引库中，但是当时的数据好像是1000万左右，一次性读取数据肯定不行（oom异常），如果分批执行的话，耗时也太久了。所以，当时我就想到可以使用线程池的方式导入，利用CountDownLatch+Future来控制，就能大大提升导入的时间。\n参考场景二：\n在我做那个xx电商网站的时候，里面有一个数据汇总的功能，在用户下单之后需要查询订单信息，也需要获得订单中的商品详细信息（可能是多个），还需要查看物流发货信息。因为它们三个对应的分别三个微服务，如果一个一个的操作的话，互相等待的时间比较长。所以，我当时就想到可以使用线程池，让多个线程同时处理，最终再汇总结果就可以了，当然里面需要用到Future来获取每个线程执行之后的结果才行\n参考场景三：\n《黑马头条》项目中使用的\n我当时做了一个文章搜索的功能，用户输入关键字要搜索文章，同时需要保存用户的搜索记录（搜索历史），这块我设计的时候，为了不影响用户的正常搜索，我们采用的异步的方式进行保存的，为了提升性能，我们加入了线程池，也就说在调用异步方法的时候，直接从线程池中获取线程使用\n29.如何控制某个方法允许并发访问线程的数量？ 在jdk中提供了一个Semaphore[seməfɔːr]类（信号量）\n它提供了两个方法，semaphore.acquire() 请求信号量，可以限制线程的个数，是一个正数，如果信号量是-1,就代表已经用完了信号量，其他线程需要阻塞了\n第二个方法是semaphore.release()，代表是释放一个信号量，此时信号量的个数+1\n30.谈谈你对ThreadLocal的理解 ThreadLocal 主要功能有两个，第一个是可以实现资源对象的线程隔离，让每个线程各用各的资源对象，避免争用引发的线程安全问题，第二个是实现了线程内的资源共享\n31.那你知道ThreadLocal的底层原理实现吗？ 在ThreadLocal内部维护了一个一个 ThreadLocalMap 类型的成员变量，用来存储资源对象\n当我们调用 set 方法，就是以 ThreadLocal 自己作为 key，资源对象作为 value，放入当前线程的 ThreadLocalMap 集合中\n当调用 get 方法，就是以 ThreadLocal 自己作为 key，到当前线程中查找关联的资源值\n当调用 remove 方法，就是以 ThreadLocal 自己作为 key，移除当前线程关联的资源值\n32.那关于ThreadLocal会导致内存溢出这个事情，了解吗？ 嗯，我之前看过源码，我想一下~~\n是因为ThreadLocalMap 中的 key 被设计为弱引用，它是被动的被GC调用释放key，不过关键的是只有key可以得到内存释放，而value不会，因为value是一个强引用。\n在使用ThreadLocal 时都把它作为静态变量（即强引用），因此无法被动依靠 GC 回收，建议主动的remove 释放 key，这样就能避免内存溢出。\n","date":"2024-10-20","permalink":"/posts/tech/java-0-audition-4/","series":["Java"],"tags":[""],"title":"Java面试准备4"},{"categories":["计算机"],"content":"JD 职位描述： 1、负责制定应用运维管理体系的标准、流程、规范及落地实施，探索、研究新的应用运维技术方向； 2、负责应用服务系统的整体规划、架构设计及优化等工作，保障业务系统性能、可用性与稳定性； 3、负责应用系统灾备体系的建立； 4、负责处理系统方面日常变更、控制突发情况，对疑难问题进行分析并解决； 5、参与设计和优化应用服务系统的监控报警系统、策略和实施。\n任职要求： 1、本科学士及以上，计算机科学，软件科学技术，电子信息工程等相关专业，应届毕业生； 2、有良好的Java基础知识，掌握Spring、SpringMVC、MyBatis、SpringBoot等主流框架技术的应用；具备良好的沟通交流能力、理解能力，条理清晰，认真负责，团队协作意识强；能够按要求撰写技术文档，有良好的工作计划制定和总结习惯；具有较强的学习和独立分析能力、工作责任心。\n个人介绍 我是xxx, 我来自xxxx大学, 今年23岁, 我熟悉Java语法，了解Spring，SpringMVC，Springboot等常见web框架，熟悉Mybatis及MybatisPlus开发过程. 熟悉MySQL数据库，能熟练地进行增删改查等常见操作, 能编写复杂的SQL语句, 了解Mysql性能优化, 掌握SpringCloud微服务技术, 掌握分布式事务, 多线程等高性能开发技术. 在校期间获通过大学英语四级, 获得过计算机三级信息安全技术, 数学建模等奖项和证书.\n知识准备 其他需要的查阅我之前的笔记即可.\n在校项目-问答系统 MyBatis SpringMVC开发流程 SpringBoot开发流程 使用的拦截器是HandlerInterceptor接口实现, 利用preHandle和afterCompletion做用户验证, 用户拦截和方向, 用户删除.\nSpringCloud 用户存储\n1private static final ThreadLocal\u0026lt;Long\u0026gt; tl = new ThreadLocal\u0026lt;\u0026gt;(); 拦截器实现GlobalFilter接口, 利用filter方法做拦截.\nJWT: 配置类实现keyPair方法利用加密文件和密码作为生成. 后面的keyPair来生成jwtSigner, 并且解密和加密都要用到.JWT.create()加密, JWT.of解密\nJava三大特性 封装, 继承, 多态.\n1、封装，就是将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问。\n2、继承，就是子类拥有父类的所有属性和方法，从而实现了实现代码的复用。\n3、多态，就是父类引用指向子类对象，从而产生多种形态。\n工作中异常怎么处理 统一的异常处理包, 定义各种的异常. 有一个父异常继承的RuntimeException\n工作中一般是用try catch处理异常而不是直接抛出去, 在catch部分会构造自己定义的异常, 然后写上异常的原因, 并且还可能发送日志或邮件进行记录.\nthrow和throws的区别 throws 和 throw 是 Java 中间的关键词，但它们的用法不同。\nthrows 关键字用于声明一种方法可能抛出的异常类型。它通常出现在方法的声明中，其次是一种或多种异常类型。在方法体内，可能会出现异常，但不会进行异常处理。调用此方法的代码需要异常处理。\nthrow 关键字用于手动抛出异常。它通常用于方法体内部，后面有一个异常对象。它表示代码运行过程中有特殊情况，需要立即抛出异常。\n总之，throws 用于声明可能抛出的异常， throw 用于手动抛出异常。\n八大排序算法 插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等\n  插入排序不说了.\n  希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。\n希尔排序的基本思想: 先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。\nhttps://www.runoob.com/data-structures/shell-sort.html\n  选择排序, 首先在未排序序列中找到最小(大)元素，存放到排序序列的起始位置, 再从剩余未排序元素中继续寻找最小(大)元素，然后放到已排序序列的末尾。\n  冒泡排序不说了.\n  归并排序将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。, 归并排序是递归算法的一个实例，这个算法中基本的操作是合并两个已排序的数组\n  快速排序不说了\n  堆排序, 堆是一个近似 完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。第一个非叶子节点，我们从它开始逐一向前分别把每个元素作为根节点进行 shift down 操作满足最大堆的性质。\n操作就是先把一个序列映射到堆上(完全二叉树) ,从第一个非叶子节点进行shift down, 如何从一个最大堆中取出一个元素，称为 shift down\nhttps://www.runoob.com/data-structures/heap-sort.html\n  基数排序是桶排序的扩展，它的基本思想是：将整数按位数切割成不同的数字，然后按每个位数分别比较。 具体做法是：将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。\n  List为什么输出内容而不是地址 Object类的toString()方法中,返回的是 getClass().getName() + \u0026quot;@\u0026quot; + Integer.toHexString(hashCode())也就是地址值,打印ArrayList对象没有输出地址值,便可知道ArrayList重写了toString()方法.\n不过这个重写是在外祖父那里重写的.\n分析源码:   使用Iterator迭代器判断集合中是否含有元素,没有的话就只返回一对\u0026quot;[]\u0026quot;\n  在循环外创建StringBuilder对象,先添加左方括号\n  循环集合,添加当前元素到StringBuilder对象\n  判断当前元素是否为最后一位,是则添加右方括号,执行StringBuilder的toString()方法并返回,\n不是则添加一个逗号一位空格,继续下一层循环\n  常量优化机制 https://blog.csdn.net/li847250110/article/details/132112931\n静态常量可以再编译器确定字面量，但常量并不一定在编译期就确定了, 也可以在运行时确定，所以 Java 针对某些情况制定了常量优化机制。\n1、给一个变量赋值，如果“=”号右边是常量的表达式没有一个变量，那么就会在编译阶段计算该表达式的结果。 2、然后判断该表达式的结果是否在左边类型所表示范围内。 3、如果在，那么就赋值成功，如果不在，那么就赋值失败。\n常量优化机制顾名思义，只能有常量参与表达式，不能有变量参与\n这个有很多方面. 这里贴案例自己理解.\n1byte b1 = 1 + 2; 2System.out.println(b1); 3// 输出结果 3 4 5byte b1 = 3; 6byte b2 = 4; 7byte b3 = b1 + b2; 8System.out.println(b3); // 程序报错 9 10byte b1 = 3; 11byte b2 = 4; 12byte b3 = b1 + b2; 13System.out.println(b3); // 程序报错 14byte b4 = b1 + 3; 15System.out.println(b4); // 程序报错 16 17byte b1 = 3; 18byte b3 = b1 + 4; 19System.out.println(b3); // 程序报错 20 21byte b1 = 127 + 2; 22System.out.println(b4); // 程序报错 23 24int num1 = 10; 25final int num2 = 10; 26byte var1 = num1 + 20; // 存在变量，编译报错 27byte var2 = num2 + 20; // 编译通过 28 29int a = 1; 30int b = 2; 31int c = a + b; 32System.out.println(c); 33 34 byte b=1; 35 byte c=2; 36 byte d=1+2;//编译通过正常执行 37 // byte e=b+c;//编译出错 38 byte e=(byte)(b+c);//强转之后不会出错 39 40 41byte var = 10; 42var = var + 20; // 编译报错，运算中存在变量 43var += 20; // 等效于: var = (short) (var + 20); 没有走常量优化机制，而是进行了类型转换 44 45String s1 = \u0026#34;abc\u0026#34;; 46String s2 = \u0026#34;a\u0026#34;+\u0026#34;b\u0026#34;+\u0026#34;c\u0026#34;; 47System.out.println(s1 == s2); //true 48 49String a = \u0026#34;a1\u0026#34;; 50String b = \u0026#34;a\u0026#34; + 1; 51System.out.println((a == b)); //result = true 52 53String a = \u0026#34;atrue\u0026#34;; 54String b = \u0026#34;a\u0026#34; + true; 55System.out.println((a == b)); //result = true 56 57String a = \u0026#34;a3.4\u0026#34;; 58String b = \u0026#34;a\u0026#34; + 3.4; 59System.out.println((a == b)); //result = true 60 61 62String s1 = \u0026#34;ab\u0026#34;; 63String s2 = \u0026#34;abc\u0026#34;; 64String s3 = s1 + \u0026#34;c\u0026#34;; 65System.out.println(s3 == s2); //false 66 67 为什么小数不能进行常量优化 HTTP和HTTPS的区别 1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。\n2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。\n3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。\n4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。\nTCP协议三次握手和四次挥手 三次握手(开始交流) 第一次：客户端向服务端发送连接请求报文段，标识为syn（建立连接），产生一个序列号seq=x，表明传送数据时的第一个数据字节序号为 x\n第二次：服务端的TCP 收到连接请求报文段后，如果同意，则发挥连接同意报文\n服务端在连接同意报文中使用俩个标识SYN和ACK，其随机序列号为seq=y,确认序列号为ack=x+1\n第三次：客户端收到服务端的报文，发送确认报文ACK，随机序列号为seq=x+1，ack=y+1\n四次挥手(挥手再见) TCP是基于全双工通信的，所以双方都可以主动释放连接。 四次挥手的意义就在于，当 A 发送完最后一条数据之后，但可能B还有未发送给A 的数据。 所以A在发送完收据后可以请求释放连接，此时B给与A响应，告诉A我知道你想断开连接，此时A还可以继续接收B发送的信息。 在B处理完工作后，也请求释放连接。A同意后，就断开连接。 这样可以保证数据正常可靠的交互。\n第一次：数据传输结束后，通信双方都可以释放连接\n假设A已经向B传输完数据，A就可以发生释放连接报文段，并停止发送数据，主动关闭TCP连接\nA 连接释放报文首部 FIN，其序列号 seq = u，等待 B 的确认。\n第二次：B收到后，发送确认报文，意思是我收到了确认号 ack = u+1，而这个报文段自己的序号为seq = v\n从A 到 B 这个方向的连接就释放了，TCP 连接处于半关闭状态。B 若发送数据,A仍需要接收\n第三次：当B发送完数据后，就可以释放连接。\nB 发出的连接释放报文 的 FIN，序号为w，ack仍为u+1\n第四次： A 收到连接释放报文后，必须发出确认。确认好 ack = w +1，序号seq = u+1。\n(ack都是在seq的基础上+1, 而sql要么是新生成的, 要么是ack的.)\n如何遍历map数据   使用 for-each 循环遍历 Map.Entry\n1for (Map.Entry\u0026lt;String, Integer\u0026gt; entry : map.entrySet()) { 2 System.out.println(\u0026#34;Key: \u0026#34; + entry.getKey() + \u0026#34;, Value: \u0026#34; + entry.getValue()); 3}   使用 for-each 循环遍历 keySet\n1for (String key : map.keySet()) { 2 Integer value = map.get(key); 3 System.out.println(\u0026#34;Key: \u0026#34; + key + \u0026#34;, Value: \u0026#34; + value); 4 }   使用 Iterator 遍历 Map.Entry\n1Iterator\u0026lt;Map.Entry\u0026lt;String, Integer\u0026gt;\u0026gt; iterator = map.entrySet().iterator(); 2 while (iterator.hasNext()) { 3 Map.Entry\u0026lt;String, Integer\u0026gt; entry = iterator.next(); 4 System.out.println(\u0026#34;Key: \u0026#34; + entry.getKey() + \u0026#34;, Value: \u0026#34; + entry.getValue()); 5 }   使用 Stream API 遍历 Map\n1map.entrySet().stream() 2 .forEach(entry -\u0026gt; System.out.println(\u0026#34;Key: \u0026#34; + entry.getKey() + \u0026#34;, Value: \u0026#34; + entry.getValue())); 3 } 4   HashMap为什么要扩容 HashMap的默认大小是16。\n当HashMap里面的元素个数超过临界值的时候会自动触发扩容。等于负载因子 乘以 容量大小，负载因子的默认值是0.75，而容量大小默认是16,。也就是说，第1次扩容的动作会在元素个数达到12的时候触发，扩容的大小是原来的2倍。HashMap的最大容量是Integer.MAX_VALUE也就是2的31次方减1。\n由于动态扩容机制的存在，所以我们在实际应用的时候，最好在集合初始化的时候明确去指定集合的大小，从而避免频繁扩容带来性能上的消耗。\nJVM内存模型 方法区, 虚拟机栈, 本地方法栈, 堆(新生代, 老年代), 程序计数器\n工作中SQL如何优化的  对insert, 分成多个insert, 按主键顺序插入.同时手动事务提交. 或者用load指令 对主键, 降低主键长度, 插入数据尽量顺序插入, 尽量不要使用UUID做主键或者其他自然主键, 如身份证, 业务操作避免对主键的修改. 对order by, 根据排序字段建立合适的索引, 多字段排序时, 遵循最左前缀法则. 尽量使用覆盖索引, 多字段排序, 一个升序一个降序, 此时需要注意联合所以在创建时的规则, 如果不可避免的出现filesort, 大数据量排序时, 可以适当增大排序缓冲区大小 对于group by, 还是根据分组字段创建索引, 准寻最左前缀法则 对于limit分页, 一般分页查询时, 通过创建覆盖索引能够较好地提高性能, 可以通过覆盖查询+子查询的形式进行优化 count, count(*) ≈ count(1) \u0026gt; count(主键) \u0026gt; count(字段) update, Innodb的行锁是针对索引加的锁, 不是针对记录加的锁, 使用的条件一定要有索引不然就是表锁; 该索引不能失效, 否则行锁变为列锁  Spring和SpringMVC的区别(实现原理) Spring是一个综合性的应用程序开发框架，提供了依赖注入、面向切面编程、事务管理等功能，旨在简化企业级应用程序的开发。而Spring MVC是Spring框架中的一个模块，用于Web应用程序的开发，实现了MVC（Model-View-Controller）模式。\nSpring的核心功能是IoC容器和AOP，它可以帮助开发者管理对象之间的依赖关系，实现松耦合的应用程序设计。而Spring MVC的核心功能是控制器、视图解析器等Web相关组件，用于协调请求和响应之间的关系，实现Web应用程序的开发。\nSpring是一个综合性的框架，可以与其他模块集成，如Hibernate、iBatis、JMS、JDBC等。而Spring MVC是基于Spring功能之上添加的Web框架，它已经集成了这些模块的功能，使得开发者可以更快速地开发Web应用程序。\n为什么用SpringBoot, 去掉SSM框架 编码更简单(与第三方框架快速整合), 配置变得更简单(Application.yaml, 不需要多个配置文件), 部署更简单(启动类Application一键部署, 不需要tomcat).\nSpringMVC, SpringBoot, SpringCloud三者区别 Spring和SpringMVC：Spring是一站式轻量级java开发框架，其核心是控制反转（IOC）和面向切面（AOP），为开发WEB层而开发的WEB(springMvc)、业务层(Ioc)、持久层(jdbcTemplate)SpringMVC是Spring基础上的MVC框架，主要处理web开发的路径映射和视图渲染，属于spring框架中web层开发的一部分；\nSpringMVC VS SpringBoot：SpringMVC属于企业WEB开发的MVC框架，包括前端视图开发、文件配置、后台接口逻辑开发等，XML、config等配置比较复杂；与SpringMVC框架相比，SpringBoot框架更注重微服务后台接口的开发，而不是前端视图的开发；\nSpringBoot和SpringCloud：SpringBoot采用默认大于配置的概念，集成了快速开发的多个Spring插件，自动过滤不需要配置的多余插件，简化了项目的开发配置过程，在一定程度上取消了xml配置，是一套快速配置开发的脚手架，单个微服务可以快速开发；SpringCloud的大部分功能插件都是基于SpringBoot实现的。SpringCloud注重整体微服务的整合和管理，整合和管理多个SpringBoot单个微服务；SpringCloud依赖于SpringBoot开发，SpringBoot可以独立开发；\n@Autowired和@resource区别 1.来源不同 @Autowired 和 @Resource 来自不同的“父类”，其中 @Autowired 是 Spring 定义的注解，而 @Resource 是 Java 定义的注解\n2.依赖查找顺序不同 依赖注入的功能，是通过先在 Spring IoC 容器中查找对象，再将对象注入引入到当前类中。而查找有分为两种实现：按名称（byName）查找或按类型（byType）查找，其中 @Autowired 和 @Resource 都是既使用了名称查找又使用了类型查找，但二者进行查找的顺序却截然相反。 @Autowired 先根据类型（byType）查找，如果存在多个（Bean）再根据名称（byName）进行查找； @Resource 先根据名称（byName）查找，如果（根据名称）查找不到，再根据类型（byType）进行查找。\n3.支持的参数不同\n4.依赖注入的支持不同 @Autowired 支持属性注入、构造方法注入和 Setter 注入，而 @Resource 只支持属性注入和 Setter 注入\nRedis怎么用的, Redis分布式锁 ES如何同步数据 开发项目流程","date":"2024-08-13","permalink":"/posts/tech/java-0-audition-3/","series":["Java"],"tags":[""],"title":"Java面试准备3"},{"categories":["计算机"],"content":"题目来源: https://www.nowcoder.com/\n好像是以选择题的形式, 所以暂时准备选择题.\n刷了一下感觉没什么意思, 还是搞算法吧.\n京东2019春招京东Java开发类试卷   在对问题的解空间树进行搜索的方法中，一个结点有多次机会成为活结点的是: 回溯法\n  京东商城plus会员的消费记录金额分别为900，512，613，700，810，若采用选择排序算法对其进行从小到大的排序，第三趟排序结果为：512，613，700，900，810\n(关于选择排序: 给定一个数组arr,其长度为n; 第一次从 arr[0] 到 arr[n-1] 中选取一个最值（按照需求，可以是最大值，可以是最小值，下同）与arr[0]进行交换; 第二次从arr[1] 到 arr[n-1] 中选取一个最值与arr[1]进行交换； 以此类推，直到arr[n-2]到arr[n-1]中选出最值交换后即完成排序。)\n  线性链表中的各元素在存储空间中的位置不一定是连续的，且各元素的存储顺序也是任意的\n  关于TCP协议的描述，错误的是可提供多播服务, 广播和多播仅应用于UDP；TCP是一个面向连接的协议.\n  在 bash shell 环境下，当一命令正在执行时，按下 control-Z 会将前台任务转入后台\n  对象间存在一对多关系，当一个对象被修改时，则会自动通知它的依赖对象，采用观察者模式设计模式最好 (观察者模式：对象间存在一对多关系，如果一个对象被修改时，会自动通知它的依赖对象。)\n  关于redis说法错误的是分区可以让Redis管理更大的内存. Redis Cluster在设计中没有使用一致性哈希(Consistency Hashing),而是使用数据分片引入哈希槽(hash slot)来实现\n  元数据区区域不属于新生代. Java 中的堆是 JVM 所管理的最大的一块内存空间，主要用于存放各种类的实例对象。 在 Java 中，堆被划分成两个不同的区域：新生代 ( Young )、老年代 ( Old )。新生代 ( Young ) 又被划分为三个区域：Eden、From Survivor、To Survivor。这样划分的目的是为了使 JVM 能够更好的管理堆内存中的对象，包括内存的分配以及回收。\n  程序:\n1int a =100,b=50,c=a---b,d=a---b; 2 System.out.println(a); 3 System.out.println(b); 4 System.out.println(c); 5 System.out.println(d); 输出98 50 50 49, 这样看: a\u0026ndash; -b, a\u0026ndash; -b.\n  JVM内存不包含Heap Frame. 包含Heap, Stacks, PC寄存器\n  java有8种基本类型，请问byte、int、long、char、float、double、boolean各占1 4 8 2 4 8 1字节.\n  程序:\n1Integer a = 1; 2Integer b = 1; 3Integer c = 500; 4Integer d = 500; 5System.out.print(a == b); 6System.out.print(c == d); 返回true、false. Integer类型在-128\u0026ndash;\u0026gt;127范围之间是被缓存了的，也就是每个对象的内存地址是相同的，赋值就直接从缓存中取，不会有新的对象产生，而大于这个范围，将会重新创建一个Integer对象，也就是new一个对象出来，当然地址就不同了，也就！=；\n  java8中，HashMap类用到了解决哈希冲突的开放定址法\n  当我们需要所有线程都执行到某一处，才进行后面的的代码执行我们可以使用CyclicBarrier. CountDownLatch 是等待一组线程执行完，才执行后面的代码。此时这组线程已经执行完。 CyclicBarrier 是等待一组线程至某个状态后再同时全部继续执行线程。此时这组线程还未执行完。\n  volatile能保证数据的可见性，但不能完全保证数据的原子性，synchronized即保证了数据的可见性也保证了原子性. volatile关键字是线程同步的轻量级实现，所以volatile性能肯定比synchronized关键字要好。但是volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块。实际开发中使用 synchronized 关键字的场景还是更多一些。\n多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞\nvolatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证。\nvolatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized关键字解决的是多个线程之间访问资源的同步性。\n  在方法中，修改一个基础类型的参数不会影响原始参数值; 在方法中，改变一个对象参数的引用不会影响到原始引用(Java中方法的参数传递都是值传递); 在方法中，修改一个对象的属性会影响原始对象参数; 在方法中，修改集合和Maps的元素会影响原始集合参数.\n  spring默认使用jdk动态代理，那么下面配置\u0026lt;aop:aspectj-autoproxy proxy-target-class=\u0026ldquo;true\u0026rdquo;/\u0026gt;是开启强制使用cglib代理\n  算法的基本要素有对数据对象的运算和操作和算法的控制结构.\n  执行以下shell语句，可以生成/test文件的是（假定执行前没有/test文件）：touch /test, a=\\touch /test, \u0026gt;/test\n  不合法的shell头是(不合法指运行会报错)：!#/bin/bas (如果不是#!开头的话默认都是认为是注释的)\n  可以用来获取shell脚本参数的是$1, $*\n  Redis支持的数据类型是 String hash list set sortedset\n  数据结构 数组  长度为n 的非空顺序表，若在第i个位置插入新的元素X，则i的取值范围是 1≤i≤n+1，需要移动的元素个数为n-i+1 数组A[8][10] 中（下标均从0开始）， 每个元素的长度为3个字节，按列存储时，元素A[4][7]的起始地址为（SA为数组存储时的首地址）SA+180 稀疏矩阵压缩的存储方法是三元组, 十字链表.  字符串   执行以下代码段(程序已包含所有必需的头文件)会输出4, 3\n1 char a[] = \u0026#34;abc\u0026#34;; 2 char b[] = {\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;}; 3 printf(\u0026#34;%d, %d\u0026#34;, sizeof(a), sizeof(b)); 不同的是数组a的长度是4个字符，而数组b的长度为3个字符，因为字符串后面会有一个'\\0\u0026rsquo;作为结束符\n  有如下一段代码，The phrase of PRAISE has 42 letters and occupies 43 memory cells.是该段代码的正确输出。\n1int main(){ 2 printf(\u0026#34;The phrase of PRAISE has %zd letters \u0026#34;,strlen(PRAISE)); 3 printf(\u0026#34;and occupies %zd memory cells.\u0026#34;,sizeof(PRAISE)); 4 return 0; 5} 使用strlen可得到字符串中包括空格和标点符号在内的字符数。\n使用sizeof运算符，得到的数会更大，因为它会把字符串末尾不可见的空字符也计算在内\n  设栈的初始状态为空，当字符序列 \u0026ldquo;a3_\u0026rdquo; 作为栈的输入时，输出长度为 3 的且可以用作 C 语言标识符的字符串序列有3个。(C语言的标识符不能以数字开头，去除3a_和3_a 答案为3)\n  已知串 S= \u0026ldquo;babab \u0026ldquo;, 其 Next 数值序列为01123.\nNext数值序列需要计算字符串前缀和后缀最长匹配相同的长度加一而得。\n第1位一定是0\n看S第一位“b” ，没有前缀和后缀 所以一般第2位一定是1（0+1）；\n看S.substring（0,2）“ba” 前缀b后缀a，相等长度为0，第3位是1（0+1）；\n看S.substring（0,3）“bab” 前缀b=后缀b，相等长度为1，第4位是2（1+1）；\n看S.substring（0,4）“baba” 前缀ba=后缀ba，相等长度为2，第5位是3（2+1）；\n则S的Next数值序列为 01123\n  Java中，String类型的数据存放有两种情况；\n如果是String s=“nowcoder”,则是放在字符串常量池中。\n如果是String ss=new String(\u0026ldquo;nowcoder\u0026rdquo;)，则是放在堆中。\n  由 4 个 \u0026ldquo;1\u0026rdquo; 和 4 个 \u0026ldquo;0\u0026rdquo; 组成的 8 位二进制补码，能表示的最小整数是：-121. 最大和最小分别是01111000 10000111,那么10000111的原码是11111001为-121\n  已知一段文本有1382个字符，使用了1382个字节进行存储，这段文本全部是由a、b、c、d、e这5个字符组成，a出现了354次，b出现了483次，c出现了227次，d出现了96次，e出现了232次，对这5个字符使用哈夫曼（Huffman）算法进行编码，则\nA正确，Huffman树就是求最优解。可以有多套方案，但最终每套方案生成的编码长度都相同且都是最优解。\nB错误，我们可以将左子树定为1右子树定为0也可以反之，不同的方案获得的编码值是不同的，但每个字符的编码长度是固定的。\nC正确，不同的方案影响的只是通向节点的路径为0还是1，而不会影响Huffman树的层次结构\nD正确，生成了Huffman树之后，我们就能看到，出现频率越高的节点越靠近根，深度越小即编码值尾数越短；出现频率越低的节点越远离根，深度越大即编码位数越长。\n  字符串是一种对象, 是一种数据类型, 是一种引用数据类型.\n  链表   关于线性表的说法不正确的是线性表中的每个结点都有且只有一个直接前趋和直接后继。\n线性表中的数据元素可以是数字、字符、记录等不同类型。(Object类)\n线性表中包含的数据元素个数不是任意的。(顺序表提前分配好空间)\n存在这样的线性表：表中各结点都没有直接前趋和直接后继。(空表, 单元素表)\n是正确的.\n  某线性表中最常用的操作是在最后一个元素之后插入一个元素和删除第一个元素,则采用仅有尾指针的单循环链表存储方式最节省运算时间。\n  栈  链栈与顺序栈相比，其特点之一是通常不会出现栈满的情况。采用链栈不必预先估计栈的最大容量，只要系统有可用空间，就不会溢出。 new 创建对象时，对象的内存和指向对象的指针分别分配在堆区，栈区 堆：自己做菜自己吃，什么时候收盘子自己知道，但是可能会浪费（产生碎片），因为可能自己一个人吃不完。 桟：公司食堂，你吃饭由食堂工作人员帮你打饭和分配位置，吃完了工作人员帮你收盘子。你浪费粮食（碎片）那是不可能的，因为食堂会把碎片拿去喂猪。 局部变量是分配在栈上的，new出来的对象是分配在堆上的 用俩个栈模拟实现一个队列，如果栈的容量分别是O和P(O\u0026gt;P)，那么模拟实现的队列最大容量是2P+1  队列   用链接方式存储的队列，在进行删除运算时头、尾指针可能都要修改.\n1\u0026gt; 当有多于一个节点时，链表表示的队列的删除操作只需要修改头指针即可，将头指针定义为head=head.next 此时不需要修改尾指针；\n2\u0026gt; 当队列只有一个节点时，该节点既是头又是尾，如果head==tail 则需要修改尾指针将队列置空。\n  已知循环队列存储在一维数组A[0..n-1]中，且队列非空时 front 和 rear 分别指向队头和队尾元素。若初始时队列为空，且要求第 1 个进入队列的元素存储在 A[0]处，则初始时 front和 rear 的值分别是0， n-1.\n当进元素时，rear将后移，以便指向新的队尾元素。出队时，front后移，更新指向新的队头。\n反推，front不用动，但是rear要退一个位置，往哪退？按照循环，第一个元素位置可以直接到最后一个位置上，因此，如图所示。所以在数组中初态就是0，n-1.\n  某带链的队列初始状态为 front=rear=NULL 。经过一系列正常的入队与退队操作后， front=rear=10 。该队列中的元素个数为1.\n初始时 front=rear=0 , 插入第 1 个元素时， rear+1 指向该元素， front+1 也指向该元素，插入第 2 个元素时 rear+1 ， front 不变，删除 1 个元素时 front+1 。即 front=rear 不为空时带链的队列中只有一个元素。\n  基础算法 复杂度   设某堆中有 n 个结点，则在该堆中插入一个新结点的时间复杂度为 O(log2n)\n  归并排序法的最好时间复杂度和此情况下的空间复杂度分别是O(nlogn) 和O(n)\n  一个算法所需时间由下述递归方程表示：T(n)=2T(n/2)+n, 该算法的时间复杂度是O(n*log(n))\n  给定一个递归算法的时间复杂度表达式，为T(n)=4T(n/2)+3n^2+2n , 则该算法的时间复杂度为O(n^2 * logn)\n(master公式: T(N)=a*T(N/b) + O(N^d), 则当logba \u0026lt; d时, O(N^d)); 当logba\u0026gt;d, O(N^logba); 当logba=d, O(N^d * logN) ) logba是以b为底a的对数.\n   排序   归并排序平均时间复杂度为O(nlogn)\n选择排序平均时间复杂度为O(n^2)\n希尔排序平均时间复杂度为O(n^1.5)\n堆排序平均时间复杂度为O(nlogn)\n冒泡排序平均时间复杂度O(n^2)\n  插入排序是一种最简单的排序方法，它的基本操作是将一个记录插入到已排好序的有序表中，从而得到一个新的、记录数增1的有序表。\n冒泡排序每轮排序从前往后扫，如果当前位置的数比其后面相邻的数大，则交换两个位置的数。\n希尔排序为插入排序的改进，先将序列分成若干个子序列进行直接插入排序，待整个序列中的记录“基本有序”是，再对全体记录进行依次直接插入排序。\n快速排序从未排序序列中选择一个元素，该元素将当前参加排序的那些元素分成前后两个部分，前一部分中所有元素都小于等于所选元素，后一部分中所有元素都大于等于所选元素，而所选元素处在排序的最终位置。\n  采用递归方式对顺序表进行快速排序, 递归次数与每次划分后得到的分区处理顺序无关\n  基本有序的情况下：快排最慢，堆排最快。\n直接插入排序是数据越有序越快，最快时间复杂度可达到O(n) .\n选择排序无论何时都是O（n^2）\n归并排序固定O(n*log n)，有序只是减少了元素交换次数。\n快速排序越有序越慢，它要从后到前遍历找比基准小的，时间复杂度达到O(n)\n  精俭排序，即一对数字不进行两次和两次以上的比较，是“精俭排序”的是插入排序, 归并排序\n  查找 哈希   设哈希表长m=13,哈希函数H(key)=key MOD 11。表中已有4个节点:addr(16)=5,addr(28)=6,addr(84)=7,addr(19)=8，其余地址为空,如用线性探测再散列处理冲突，则关键字为38的地址为9\n  假设把整数关键码K散列到有N个槽的散列表，h(k)=k mod N是好的散列函数, 而h(k)=(k + Random(N )) mod N；Random(N)返回一个0到N-1的整数不是. 使用随机函数可以使得数更均匀随机地分布在各个槽中，但当查找时由于散列函数是个随机函数所以得到的值对应的槽内可能压根没有放关键码k，可能会使得查找失败。\n  一个线性序列（30，14，40，63，22，5），假定采用散列函数Hash(key)=key%7来计算散列地址，将其散列存储在A[0~6]中，采用链地址法解决冲突。若查找每个元素的概率相同，则查找成功的平均查找长度是4/3.\n  线程安全的map在JDK 1.5及其更高版本环境 有哪几种方法可以实现:\nMap map = new ConcurrentHashMap();\nMap map = Collections.synchronizedMap(new HashMap());\n1.HashMap,TreeMap 未进行同步考虑，是线程不安全的。\n2.HashTable 和 ConcurrentHashMap 都是线程安全的。区别在于他们对加锁的范围不同，HashTable 对整张Hash表进行加锁，而ConcurrentHashMap将Hash表分为16桶(segment)，每次只对需要的桶进行加锁。\n3.Collections 类提供了synchronizedXxx()方法，可以将指定的集合包装成线程同步的集合。比如， List list = Collections.synchronizedList(new ArrayList()); Set set = Collections.synchronizedSet(new HashSet());\n  递归   求解第n个斐波那契数的递归写法，分析它的时间复杂度是O(2^N)\n1int func(unsigned int n) 2{ 3 if(n\u0026lt;2) 4 return n; 5 return fabonaci(n-1) + fabonaci(n-2); 6}   计算机基础 设计模式   如果需要在不影响其他对象的情况下，以动态，透明的方式给对象添加职责，应该选择装饰模式.\n  假设一个电源总开关可以控制四盏灯、一个风扇、一台空调和一台电视机的启动和关闭。通过该电源总开关可以同时控制上述所有电器设备，可以使用外观模式来模拟设计该系统。\n  不同级别的用户对同一对象拥有不同的访问权利或某个客户端不能直接操作到某个对象，但又必须和那个对象有所互动，这种情况最好使用Proxy模式设计模式。\n  KFC套餐一般包含主食（如汉堡、鸡肉卷等）和饮料（如果汁、可乐等）等组成部分，不同的套餐有不同的组成部分，而KFC的服务员可以根据顾客的要求，一步一步装配这些组成部分，构造一份完整的套餐，然后返回给顾客。可以使用建造者模式描述KFC如何创建套餐。\n  创建型模式关注的是对象创建\n  共享网络设备模拟：很多网络设备都是支持共享的，如交换机、集线器等，多台终端计算机可以连接同一台网络设备，并通过该网络设备进行数据转发。共享网络设备可以使用享元模式模拟共享网络设备的设计原理。\n  策略模式和模板模式的联系与区别 策略模式和模板模式在某些应用场景下可以互换。 模板模式使用的是继承关系实现，策略模式使用的是组合关系实现。 模板模式倾向于把解决问题过程定义为一个完整框架，把过程中的若干实现步骤延迟到子类中实现。\n  用户已经有一个两相插座，最的又买了一个三相插座。现在用户想使用新的三相插座来使用三相的洗衣机和二相插座的电视机，这种问题可以使用适配器模式模式来进行设计。\n  在模拟毛笔的使用过程中提供了大中小3种型号的画笔，够绘制5种不同颜色。我们可以使用桥接来模拟实现模拟毛笔的使用。\n  关于简单工厂模式与工厂方法模式\n1、简单工厂模式中包含判断什么对象的逻辑，而工厂方法模式则需要调用者判断要实例化什么具体类型的工厂进而创建出想要的对象。当增加新类时，简单工厂模式需要修改工厂类，而工厂方法模式不需要，因此工厂方法模式遵守了开闭原则，而简单工厂模式没遵守。\n2、简单工厂模式因为采用了静态方法，所以不利于继承，而工厂方法模式恰恰相反，需要利用到继承来从抽象工厂中派生出各种各样的具体工厂。\n3、工厂模式就是为了消除if else\n  工厂模式可理解为：当客户获取产品时，工厂模式作为获取产品的接口。\n1、简单工厂模式：由接口直接负责获取产品\n2、工厂方法模式：客户必须清楚地指出想获取哪种产品；由接口的子类负责获取产品\n3、抽象工厂模式：客户不知道其想获取哪种产品；由接口中判断调用哪个子类，通过子类获取产品。\n  网络基础  www.tsinghua.edu.cn   cn：顶级域名\nedu：二级域名\ntsinghua：三级域名\nwww：主机名（万维网主机）\n DNS（端口53）同时占用UDP和TCP是公认的，DNS在进行区域传输或者响应报文超过512字节的时候使用TCP协议，其它时候则使用UDP协议。\n  IP数据报分片在信源机或者路由器，重组在目的机\n  一台交换机具有 24 个 10/100Mbps 全双工端口和 2 个 1000Mbps 全双工端口，如果所有的端口都工作在全双工状态，那么交换机总带宽等于8.8Gbps。\n  数据库   设有两个数据库表，父表和子表之间是一对多的联系，为控制子表和父表的关联，可以设置\u0026quot;参照完整性规则\u0026rdquo;，为此要求这两个表在父表连接字段上建立主索引，在子表连接字段上建立普通索引.\n  Mysql中表student_table(id,name,birth,sex)，插入如下记录：\n(\u0026lsquo;1004\u0026rsquo; , \u0026lsquo;张三\u0026rsquo; ,\u0026lsquo;2000-08-06\u0026rsquo; , \u0026lsquo;男\u0026rsquo;); (\u0026lsquo;1009\u0026rsquo; , \u0026lsquo;李四\u0026rsquo;, \u0026lsquo;2000-01-01\u0026rsquo;, \u0026lsquo;男\u0026rsquo;); (\u0026lsquo;1010\u0026rsquo; , \u0026lsquo;李四\u0026rsquo;, \u0026lsquo;2001-01-01\u0026rsquo;, \u0026lsquo;男\u0026rsquo;); (\u0026lsquo;1006\u0026rsquo; , \u0026lsquo;王五\u0026rsquo;, \u0026lsquo;2000-08-06\u0026rsquo; , \u0026lsquo;女\u0026rsquo;); (\u0026lsquo;1008\u0026rsquo; , \u0026lsquo;张三\u0026rsquo;, \u0026lsquo;2002-12-01\u0026rsquo;, \u0026lsquo;女\u0026rsquo;); (\u0026lsquo;1012\u0026rsquo; , \u0026lsquo;张三\u0026rsquo;, \u0026lsquo;2001-12-01\u0026rsquo;, \u0026lsquo;女\u0026rsquo;); (\u0026lsquo;1011\u0026rsquo; , \u0026lsquo;李四\u0026rsquo;, \u0026lsquo;2002-08-06\u0026rsquo; , \u0026lsquo;女\u0026rsquo;);\n执行\nselect t1.,t2. from ( select * from student_table where sex = \u0026lsquo;男\u0026rsquo; ) t1 right join (select * from student_table where sex = \u0026lsquo;女\u0026rsquo;)t2 on t1.name = t2.name ; 的结果行数是5\n1）不论左右连接，两表排序都是先写的放在左边，后写的放在右边 2）左右连接中，以谁为主表，则其信息全部保存。从表中有多于一项符合条件的，则额外重复一次主表从而列出全部从表情况\n  ACCESS中表和数据库的关系是一个数据库可以包含多个表\n  3NF消除主属性对码的部分和传递函数依赖规范化为BCNF。\n  数据库三级模式体系结构的划分，有利于保持数据库的 数据独立性\n  在高并发的线上事务中，几乎无法避免锁等待或死锁的产生\n  有关系 R 和 S ， R －（ R － S ）的运算等价于R∩S\n  左连接时，结果集的行数可能大于左表的行数\n  概念数据模型是现实世界到信息世界的第一层抽象。 数据结构模型是对现实世界进行的第二层抽象。\n  操作系统  相比于单道程序设计（内存中仅有一道作业），多道程序设计按照一定的作业调度算法将作业队列中的作业调入内存，使他们共享CPU和各种资源。因此需要更大的内存以容纳超过一道的作业。 不管系统中是否有线程，进程都是拥有资源的独立单位. 用户级线程切换不涉及内核，在进程的时间片内，由用户程序控制线程的切换，然后使用进程获取的资源. 对于普通的操作系统，未引入线程的话，进程是系统进行资源分 配和调度的独立单位。在多处理机操作系统中，引入线程后，进程是资源的分配单 位或者叫做资源的容器，线程是处理机的调度单位。 renice命令可以改变进程的优先级 使用一个信号量协调6个进程对4个同类临界资源的访问, 信号量值可以出现-2 到 4 连续分配方式可能产生外部碎片，可以考虑采用“紧凑”的方法将内存中所有作业进行移动，从而使得外部碎片集中在一起形成一个大的分区。为了使移动后的作业能正常运行，需要进行动态重定位. 为了实现设备独立性，在操作系统中，用户在使用I/O设备时，通常采用逻辑设备名 软链接也叫符号链接, 如果原始文件被删除，所有指向它的软链接也都被破坏, 软链接指明了原始文件的位置，用户需要对原始文件的位置有访问权限才可以使用, 软链接可以跨文件系统，可以指向远程文件系统的文件 页表的作用是实现从页号到物理块号的地址映射 32位处理器是指处理器的数据总线是32位的 静态重定位的时机是程序装入时 在段式存储管理中，一个段是一个不定长的连续区域。  Java   抽象类必须有“abstract class”修饰, 抽象类是可以实现接口的，而且抽象类也可以继承自抽象类 , 抽象类指有abstract修饰的class，其可以包含抽象方法，也可以不包含 , 抽象类和接口都是不能被实例化的，只有具体的类才可以被实例化\n  下面程序的运行结果是pongping\n1public static void main(String args[]) { 2 3 Thread t = new Thread() { 4 public void run() { 5 pong(); 6 } 7 }; 8 9 t.run(); 10 System.out.print(\u0026#34;ping\u0026#34;); 11} 12 13 static void pong() { 14 System.out.print(\u0026#34;pong\u0026#34;); 15 } 16 17 t.run是调用的Thead类中的run()方法，t.start才是执行线程，所以这题就是执行普通run()方法，先输出pong，在输出ping。 t.start是另起线程，与当前线程同时竞争cpu资源，结果存在不确定性\n  Log4j的日志打印级别不可以在运行时重新设置\n  方法重载：同一类中的相同的方法名，参数和返回值均可不同。 方法重写：之类对父类已经实现的方法重新定义。\n  int a = \u0026lsquo;2\u0026rsquo;,这种定义与int a = 2是完全不同的\nint a = \u0026lsquo;2\u0026rsquo;中的数字2使用单引号来表示字符2，字符2对用的ascii码值是50，因此这种情况下，a的值是50\nint a = 2中的数字2表示了数字本身，这种情况下，a的值是2\n  创建并启动线程的过程为：定义线程-\u0026gt;实例化线程-\u0026gt;启动线程。\n定义线程有两种方式，一种是继承java.lang.Thread类，一种是实现java.lang.Runnable接口。这两种方式实例化线程区别在于，如果是继承了Thread类，直接new一个对象就可以了，如果是实现了Runnable接口的类，则需要用Thread的构造方法new Thread(new MyRunnable()).start()\n  CMS垃圾回收器在初始标记, 重新标记阶段是没用用户线程参与的\n  事务隔离级别是由数据库系统实现的\n  new URL()时必须捕获检查异常，但这个异常是由于字符串格式和URL不符导致的，与网址是否存在无关。URL的toString方法返回字符串，无论网址是否存在。\n  抽象类中可以有普通成员变量，接口中没有普通成员变量。抽象类和接口中都可以包含静态成员常量。一个类可以实现多个接口，但只能继承一个抽象类. 抽象类中可以包含非抽象的普通方法，接口中的方法必须是抽象的，不能有非抽象的普通方法。\n  java中创建对象有以下几种方法：\n1.用new语句创建对象，这是最常用的创建对象的方式。\n  ​ 2.运用反射手段，调用java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法。 3.调用对象的clone()方法。 4.运用反序列化手段，调用java.io.ObjectInputStream对象的readObject()方法.   下面的输出结果是false\n1public class Demo { 2 public static void main(String args[]) 3 { 4 String str=new String(\u0026#34;hello\u0026#34;); 5 if(str==\u0026#34;hello\u0026#34;) 6 { 7 System.out.println(\u0026#34;true\u0026#34;); 8 } 9 else { 10 System.out.println(\u0026#34;false\u0026#34;); 11 } 12 } 13} ==判断的是对象引用地址是否相同， String str=new String(\u0026ldquo;hello\u0026rdquo;); 这句话new了一个新的String对象，所以地址与\u0026quot;hello\u0026quot;字符串常量的地址不同，答案为false 如果判断字符串是否相等应给用str.equals(\u0026ldquo;hello\u0026rdquo;)方法\n  ArrayList list = new ArrayList(20);中的list扩充0次. Arraylist默认数组大小是10，扩容后的大小是扩容前的1.5倍，最大值小于Integer 的最大值减8，如果新创建的集合有带初始值，默认就是传入的大小，也就不会扩容\n  以下代码结果是代码可以编译运行，输出“AB.B”。\n1public class foo { 2 public static void main(String sgf[]) { 3 4 StringBuffer a=new StringBuffer(\u0026#34;A\u0026#34;); 5 6 StringBuffer b=new StringBuffer(\u0026#34;B\u0026#34;); 7 8 operate(a,b); 9 10 System.out.println(a+\u0026#34;.\u0026#34;+b); 11 } 12 static void operate(StringBuffer x,StringBuffer y) { 13 x.append(y); 14 y=x; 15 } 16} a,b,x,y就是四个指针. “=”, y就指向了x所指向的目标即是a指向的对象，因此原来b所指向的目标并没有发生任何改变。\n  下列程序运行的结果good and gbc\n1public class Example{ 2 String str = new String(\u0026#34;good\u0026#34;); 3 char[ ] ch = { \u0026#39;a\u0026#39; , \u0026#39;b\u0026#39; , \u0026#39;c\u0026#39; }; 4 public static void main(String args[]){ 5 Example ex = new Example(); 6 ex.change(ex.str,ex.ch); 7 System.out.print(ex.str + \u0026#34; and \u0026#34;); 8 System.out.print(ex.ch); 9 } 10 public void change(String str,char ch[ ]){ 11 str = \u0026#34;test ok\u0026#34;; 12 ch[0] = \u0026#39;g\u0026#39;; 13 } 14} 首先说下String确实是个不可变对象，这个不可变是JDK特有的，写JAVA的人特意针对的\n但是这与本题无关，题目中的形参str只是原引用ex.str的一个引用副本，传的是一个副本地址值，这个值与ex.str地址值是不一样的,但是它们同时指向了堆中的对象new String(\u0026ldquo;good\u0026rdquo;)，当你在函数中改变形参也就是地址的副本值也就是这句str=\u0026ldquo;test ok\u0026quot;只是将副本地址指向常量\u0026quot;test ok\u0026rdquo;，并没有改变原ex.str的指向方向，它还是指向对象new String(\u0026ldquo;good\u0026rdquo;)的\nchar数组与String一样传的也是地址的副本，但是关键是形参ch它没有新的指向 ch[0]只是ch在指向原对象时改变了对象的内部结构, 所以在ex.ch指向与它是同一个对象的情况下当然也会随之变化\n  静态方法中没有this关键词，因为静态方法是和类同时被加载的，而this是随着对象的创建存在的，静态比对象优先存在. 静态可以访问静态，但静态不能访问非静态而非静态可以访问静态。\n在静态方法中可直接调用本类的静态方法，也可以通过类名.静态方法名的方式来调用其他类的静态方法\n静态方法不能直接调用实例方法和对象，但可以通过在静态方法中创建类的实例的方式间接调用。\n  HashMap是非线程安全的，其对应的线程安全类是HashTable\nVector(相当于一个线程安全的List), StringBuffer(相当于一个线程安全的StringBuilder), Properties是线程安全的\n  interface中的方法默认为public abstract 的 ，变量默认为public static final\n接口中不允许有static类型的方法\nJDK8及以后，允许我们在接口中定义static方法和default方法。\n在jdk8之前，interface之中可以定义变量和方法，变量必须是public、static、final的，方法必须是public、abstract的。这些修饰符都是默认的\n ","date":"2024-08-08","permalink":"/posts/tech/java-0-audition-2/","series":["Java"],"tags":[""],"title":"Java面试准备2"},{"categories":["计算机"],"content":"参考资料:\nhttps://www.bilibili.com/video/BV1NY411P7VX?vd_source=0885d58575f3c82f15a5a40588fe0cd5\nhttps://github.com/HelloWorld521/swagger2-boot-starter/tree/master/swagger2-boot-starter\nhttps://www.cnblogs.com/progor/p/13297904.html\nhttps://blog.csdn.net/cj151525/article/details/140099389\n一, SpringBoot自动配置原理 自动装配和自动配置 自动配置(Auto-Configuration): 基于引入的依赖Jar包, 对SpringBoot应用进行自动配置.\n自动装配(Autowire): Spring中的依赖注入.\n另外, 配置类(Configuration Class)有广义和狭义之分:\n 广义: 被注解@Component直接或间接修饰的某个类, 常说的Spring组件, 其中包括了@Configuration类 狭义: 特指被注解@Configuration所修饰的某个类, 又称为@Configuration类  SpringBoot的启动流程  创建一个ApplicationContext实例, 即我们常说的IoC容器. 将主类(primaryClass)注册到IoC容器中(简单但重要的第一步). 源配置类: 通常是main方法所在的类, 会被@SpringBootApplication所修饰, 我们又称之为主类. 递归加载并处理所有的配置类. 自动配置就属于其中一环. 实例化所有的单例Bean(Singleton Bean). 实例化所有的单例Bean. 依赖注入和自动装配就属于其中的环节. 如果是web应用, 则启动web服务器(如Tomcat)  SpringBoot加载配置类的流程  处理@ComponentScan: 根据@ComponentScan扫描制定的package. 处理@Import: 得到一系列被导入的配置类 处理@Bean方法 处理@Import导入的ImportBeanDefinitionRegistrar 加入到一个全局的配置类集合中 将配置类本身注册到IoC容器中 处理配置类中的@Bean方法, 将其返回类型注册到IoC容器中 处理通过@Import导入的ImportBeanDefinitionRegistrar  SpringBoot加载配置类的方式 @ComponentScan: 对指定的package进行扫描, 找到符合条件的类, 默认是搜索被注解@Component修饰的配置类; 通过属性basePackages或basePackageClasses指定要进行扫描的package; 未指定package则默认扫描当前@ComponentScan所修饰的类所在的package.\n例:\n1@ComponentScan 2 3@ComponentScan(basePackages={\u0026#34;cn.anyuanwai.code\u0026#34;, \u0026#34;cn.memset.code\u0026#34;}) 4 5@ComponentScan( 6 excludeFilters = {@Filter( 7 type = FilterType.CUSTOM, 8 classes = {TypeExcludeFilter.class} 9), @Filter( 10 type = FilterType.CUSTOM, 11 classes = {AutoConfigurationExcludeFilter.class} 12)} 13) @Import: 提供了一种显示地从其他地方加载配置类的方式, 这样可以避免使用性能较差得到组件扫描(Component Scan). 支持导入:\n  导入普通类(效果类似于这个普通类被注解@Component)\n1@Configuration 2//ConfigA里有Bean方法. 3//这样之后ConfigA和ConfigB都可以作为Bean使用了. 4@Import(ConfigA.class) 5public class ConfigB{ 6 7}   导入选择器接口ImportSelector的实现类(ImportSelector有selectImports方法返回值是一个数组, 每一个元素分别代表一个将被导入的配置类的全限定名, 利用该特性我们可以给IoC容器动态地导入多个配置类)\n1public class ZooImportSelector implements ImportSelector{ 2\t@Override 3\tpublic String[] selectImports(AnnotationMetadata metadata){ 4 return new String[]{\u0026#34;cn.memset.ZooConfig\u0026#34;}; 5\t} 6} 1//配置类 2//这样ZooConfig和ZooConfig里面的Bean都在容器中. 3@Configuration 4@Import({ZooImportSelector.class}) 5public class ConfigB{ 6 7}   导入注册器接口ImportBeanDefinitionRegistrar的实现类(通过它可以手动将多个BeanDefinition注册到IoC容器, 实现个性化的定制)\n1public class ZooRegistrar implements ImportBeanDefinitionRegistrar{ 2\t@Override 3\tpublic void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry){ 4 //手动注入Dog 5 bd.setBeanClass(Dog.class); 6 registry.registerBeanDefinition(\u0026#34;dog\u0026#34;, bd); 7\t} 8} 1//配置类 2//这样Bean Dog在容器中. 3@Configuration 4@Import({ZooImportSelector.class}) 5public class ConfigB{ 6 7}   关于加载配置类这几种方式\n @ComponentScan需要记住jar包中的package名称, 不方便 @Import导入普通类,需要记住第三方Jar包中具体的类名才能导入, 不方便 @Import导入注册器ImportBeanDefinitionRegistrar是对@Bean方法的一个补充,针对BeanDefinition层面的. 只有ImportBeanDefinitionRegistrar导入选择器方便点.  SpringBoot自动配置原理剖析 \r@SpringBootApplication修饰的类会被@Configuration间接修饰, 即源配置类\nSpringBoot框架会对源配置类的package进行组件扫描(ComponentScan)\nSpringBoot框架最终会导入AutoConfigurationImportSelector来实现自动配置\nAutoConfigurationImportSelector如何优雅实现自动配置呢? 用户只需导入jar包即可, 至于jar包有哪些自动配置类, 类名是什么都不用关心. 这恰好是Java SPI的优点. Spring框架中有个SpringFactories机制, 它是Java SPI设计思想的延伸和扩展, 自动配置就借助它实现.\nSpringFactories机制 核心逻辑是从classpath中读取所有Jar包中的配置文件META_INF/spring.factories, 然后根据key从配置文件中解析处对应的value.\n通过类SpringFactoriesLoader, 返回一个类名的集合, 可以根据实际需求对这些类名进行下一步处理.\n当然这是spring2的机制, spring3中目录META_INF/spring.factories改变为/META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports\nAutoConfigurationImportSelector整体逻辑 AutoConfigurationImportSelector中的selectImports方法中的getAutoConfigurationEntry是自动配置的入口方法. 在getAutoConfigurationEntry中:\n 获取annotationMetadata的注解@EnableAutoConfiguration的属性 从资源文件spring.factories中获取EnableAutoConfiguration对应的所有的类(getCandidateConfigurations中基于是SpringFactories机制) 通过在注解@EnableAutoConfiguration设置exclude的相关属性, 可以排除指定的自动配置类 根据注解@Confitional来判断是否需要排除某些自动配置类 触发AutoConfiguration导入的相关时间.  总结 \r理解Redis自动配置 spring-boot-starter-data-redis依赖了spring-boot-starter和spring-data-redis(工具类库Jar包, 定义了RedisTemplate等常用类), spring-boot-starter依赖了spring-boot-autoconfigure是SpringBoot内置的自动配置列的Jar包, 包含了spring.factories文件, 这里面就有很多redis的自动配置类类名.\n二, SpringBoot自动配置实战案例 什么是Starter Starter是一站式服务(one-step)的依赖jar包:\n 包含Spring以及相关技术(比如Redis)的所有依赖 提供了自动配置的功能, 开箱即用 提供了良好的依赖管理, 避免了包遗漏, 版本冲突的问题  Starter的结构图 \rStarter项目主要由两个模块构成: starter module和autoConfigure module(里面又包括自动配置类, 配置文件spring.factories, 自定义的配置项). starter module会依赖第三方组件的Jar包, 而autoConfigure module是可选依赖(Optional)第三方Jar包的.\n可选依赖(Optional的作用: 阻断依赖传递.\n如项目A可选依赖项目B, 那么使用Maven编译项目A时, 会将项目B添加到项目A的classpath中 ,此时可选依赖和普通依赖的表现是一致的\n这时如果项目X依赖于项目A, 使用Maven编译项目X时, 项目B是不会被添加到项目X的classpath中的, 除非项目X直接依赖项目B.\nSwagger的配置类 添加依赖包:\n1 \u0026lt;dependency\u0026gt; 2 \u0026lt;groupId\u0026gt;io.springfox\u0026lt;/groupId\u0026gt; 3 \u0026lt;artifactId\u0026gt;springfox-swagger2\u0026lt;/artifactId\u0026gt; 4 \u0026lt;version\u0026gt;2.9.2\u0026lt;/version\u0026gt; 5 \u0026lt;/dependency\u0026gt; 6 \u0026lt;dependency\u0026gt; 7 \u0026lt;groupId\u0026gt;io.springfox\u0026lt;/groupId\u0026gt; 8 \u0026lt;artifactId\u0026gt;springfox-swagger-ui\u0026lt;/artifactId\u0026gt; 9 \u0026lt;version\u0026gt;2.9.2\u0026lt;/version\u0026gt; 10 \u0026lt;/dependency\u0026gt; 配置类:\n1package com.example.config; 2 3import org.springframework.context.annotation.Bean; 4import org.springframework.context.annotation.Configuration; 5import springfox.documentation.builders.ApiInfoBuilder; 6import springfox.documentation.builders.PathSelectors; 7import springfox.documentation.builders.RequestHandlerSelectors; 8import springfox.documentation.service.ApiInfo; 9import springfox.documentation.spi.DocumentationType; 10import springfox.documentation.spring.web.plugins.Docket; 11import springfox.documentation.swagger2.annotations.EnableSwagger2; 12 13 14@Configuration // 标明是配置类 15@EnableSwagger2 //开启swagger功能 16public class SwaggerConfig { 17 @Bean 18 public Docket createRestApi() { 19 return new Docket(DocumentationType.SWAGGER_2) // DocumentationType.SWAGGER_2 固定的，代表swagger2 20// .groupName(\u0026#34;分布式任务系统\u0026#34;) // 如果配置多个文档的时候，那么需要配置groupName来分组标识 21 .apiInfo(apiInfo()) // 用于生成API信息 22 .select() // select()函数返回一个ApiSelectorBuilder实例,用来控制接口被swagger做成文档 23 .apis(RequestHandlerSelectors.basePackage(\u0026#34;com.example.controller\u0026#34;)) // 用于指定扫描哪个包下的接口 24 .paths(PathSelectors.any())// 选择所有的API,如果你想只为部分API生成文档，可以配置这里 25 .build(); 26 } 27 28 /** 29* 用于定义API主界面的信息，比如可以声明所有的API的总标题、描述、版本 30* @return 31*/ 32 private ApiInfo apiInfo() { 33 return new ApiInfoBuilder() 34 .title(\u0026#34;XX项目API\u0026#34;) // 可以用来自定义API的主标题 35 .description(\u0026#34;XX项目SwaggerAPI管理\u0026#34;) // 可以用来描述整体的API 36 .termsOfServiceUrl(\u0026#34;\u0026#34;) // 用于定义服务的域名 37 .version(\u0026#34;1.0\u0026#34;) // 可以用来定义版本。 38 .build(); // 39 } 40} 41 进行Swagger的自动配置 spring.factories:\n1org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\ 2com.moming.swagger.autoconfigure.Swagger2AutoConfiguration 配置文件:\n1package com.moming.swagger.properties; 2 3import lombok.Data; 4import org.springframework.boot.context.properties.ConfigurationProperties; 5import org.springframework.context.annotation.Configuration; 6import org.springframework.context.annotation.DependsOn; 7import org.springframework.context.annotation.Import; 8import org.springframework.stereotype.Component; 9 10import java.util.LinkedHashMap; 11import java.util.Map; 12 13/** 14* 读取 application 配置文件 15* 16* @author hjy 17**/ 18@Data 19@Component 20@ConfigurationProperties(\u0026#34;swagger2\u0026#34;) 21public class Swagger2Properties { 22 23 /** 24* 分组 25*/ 26 private Map\u0026lt;String, GroupInfo\u0026gt; groups = new LinkedHashMap\u0026lt;\u0026gt;(); 27 28 29 @Data 30 public static class GroupInfo { 31 /** 32* swagger 会解析的包路径 33*/ 34 private String basePackage; 35 36 /** 37* title 38*/ 39 private String title; 40 41 /** 42* swagger 组相关说明 43*/ 44 private String description; 45 } 46} 47 自动配置类:\n1package com.moming.swagger.autoconfigure; 2 3import com.moming.swagger.properties.Swagger2Properties; 4import org.springframework.beans.BeansException; 5import org.springframework.beans.factory.BeanFactory; 6import org.springframework.beans.factory.BeanFactoryAware; 7import org.springframework.beans.factory.config.ConfigurableBeanFactory; 8import org.springframework.context.annotation.Bean; 9import org.springframework.context.annotation.Configuration; 10import springfox.documentation.builders.ApiInfoBuilder; 11import springfox.documentation.builders.PathSelectors; 12import springfox.documentation.builders.RequestHandlerSelectors; 13import springfox.documentation.service.ApiInfo; 14import springfox.documentation.spi.DocumentationType; 15import springfox.documentation.spring.web.plugins.Docket; 16import springfox.documentation.swagger2.annotations.EnableSwagger2; 17 18import java.util.ArrayList; 19import java.util.List; 20 21/** 22* 1. 读取配置文件 23* 2. 将配置文件内容赋值到 swagger 的 Docket 对象 24* 3. 将 Docket 依次注入到 bean 中 （需要实现 BeanFactoryAware 获取beanFatory） 25* 关键是对组的操作 26* 27* @author hjy 28**/ 29@Configuration 30@EnableSwagger2 31public class Swagger2AutoConfiguration implements BeanFactoryAware { 32 33 private BeanFactory beanFactory; 34 35 /** 36* 获取 beanFactroy 37* @param beanFactory beanFactory 38* @throws BeansException BeansException 39*/ 40 @Override 41 public void setBeanFactory(BeanFactory beanFactory) throws BeansException { 42 this.beanFactory = beanFactory; 43 } 44 45 @Bean 46 public Swagger2Properties properties() { 47 return new Swagger2Properties(); 48 } 49 50 51 @Bean(\u0026#34;createRestOpenApi\u0026#34;) 52 public List\u0026lt;Docket\u0026gt; createRestOpenApi(Swagger2Properties properties) { 53 ConfigurableBeanFactory configurableBeanFactory = (ConfigurableBeanFactory) beanFactory; 54 List\u0026lt;Docket\u0026gt; docketList = new ArrayList\u0026lt;\u0026gt;(); 55 // swagger 配置 56 for (String groupName : properties.getGroups().keySet()) { 57 Swagger2Properties.GroupInfo groupInfo = properties.getGroups().get(groupName); 58 String basePackage = groupInfo.getBasePackage(); 59 Docket docket = new Docket(DocumentationType.SWAGGER_2) 60 .groupName(groupName) 61 .apiInfo(openApiInfo(groupInfo)) 62 .select() 63 .apis(RequestHandlerSelectors.basePackage(basePackage)) 64 .paths(PathSelectors.any()) 65 .build(); 66 docketList.add(docket); 67 // docket 加入 IOC 容器 68 configurableBeanFactory.registerSingleton(groupName, docket); 69 } 70 return docketList; 71 } 72 73 74 private ApiInfo openApiInfo(Swagger2Properties.GroupInfo groupInfo) { 75 return new ApiInfoBuilder() 76 .title(groupInfo.getTitle()) 77 .description(groupInfo.getDescription()) 78 .version(\u0026#34;1.0\u0026#34;) 79 .build(); 80 } 81 82 83} 84 他这里相比普通的配置多了些东西. 它实现了BeanFactoryAware接口, 这样Spring 容器会在 bean 的初始化 过程中自动调用这个方法，并传入当前的 BeanFactory 实例, 然后就可以利用BeanFactory将docket加入到ioc容器了.\n可能是它这里为了便捷配置接口组, 所以采用的是List形式.\nKnife4j","date":"2024-08-03","permalink":"/posts/tech/java-6-autoconfiguration/","series":["Java"],"tags":["","",""],"title":"项目: swagger的自动装配"},{"categories":["计算机"],"content":"字符串搜索 主串A: a, b, c, d, e, f, g\n模式串B: c, d, e\n判断B是否在A中, 存在返回在A中的下标, 不存在返回-1\n再如: A: ABCABCAABCABCD; B: ABCABCD; 返回值7.\nBF: 暴力破解 复杂度O( (n-m)*m )\n1//BF:暴力破解 2 int BF(String A, String B){ 3 int aLength = A.length(); 4 int bLength = B.length(); 5 //这里aLength - bLength稍微优化了一下 6 for (int i = 0; i \u0026lt;= aLength - bLength; i++) { 7 int j; 8 for (j = 0; j \u0026lt; bLength; j++) { 9 if (A.charAt(i+j) != B.charAt(j)){ 10 break; 11 } 12 } 13 //需要判断上面的子循环什么时候将B完整遍历了一遍 14 //当j=B.length时, 刚好执行了最后一次j++ 15 if(j == B.length()){ 16 return i; 17 } 18 } 19 return -1; 20 } RK算法: hash算法 基于BF进行优化, 将A中的字符串按照顺序截取B字符串的长度: abc, bcd, cde, def, efg. 进行hash运算然后与B的hash值进行比较. 时间复杂度: O(m*n), hash算法参与字符串位数, 主串长度相关.\n优化: hash算法: 按26进制取和, abc=1+2+3=6, 进行量化. 每个子串的hash值是前一个子串的hash值-前串最小下标对应字母的值+本串最大下标字母对应的值.\n此时间复杂度为O(n), 只与主串长度相关, 但hash冲突极端情况下退化为BF\n1//RK:hash算法 2 static int RK(String A, String B){ 3 int aLength = A.length(); 4 int bLength = B.length(); 5 int bCode = B.hashCode(); 6 for (int i = 0; i \u0026lt;= aLength - bLength; i++) { 7 String aSub = A.substring(i, i + bLength); 8 if(aSub.hashCode() == bCode){ 9 //防止hash碰撞 10 int j; 11 for (j = 0; j \u0026lt; bLength; j++) { 12 if (aSub.charAt(j) != B.charAt(j)){ 13 return -1; 14 } 15 } 16 if (j == bLength){ 17 return i; 18 } 19 } 20 } 21 return -1; 22 } 23 24 //RK: hash算法 优化hash 25 static int hashCode(String string){ 26 int hashCode = 0; 27 //初始化字母表 28 HashMap\u0026lt;Character, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); 29 int base = (int)\u0026#39;A\u0026#39;-1; 30 for (char c=\u0026#39;A\u0026#39;; c\u0026lt;=\u0026#39;Z\u0026#39;; c++){ 31 map.put(c, (int)c-base); 32 } 33 for (char c=\u0026#39;a\u0026#39;; c\u0026lt;=\u0026#39;z\u0026#39;; c++){ 34 map.put(c, (int)c-base); 35 } 36 37 for (int i = 0; i \u0026lt; string.length(); i++) { 38 hashCode += map.get(string.charAt(i)); 39 } 40 return hashCode; 41 } BM算法 1.坏字符规则: 从右往左匹配, 找到A中第一个不匹配的字符(坏字符), 将B串右移, 直到出现与A串坏字符对齐的字符, 再从右往左寻找坏字符. 如果B串中没有该坏字符, 则直接移到该坏字符的下一位即可.\n例如A串:ABCABCAABCABCD; B串ABCDBC. A串前6个为ABCABC, 初始从右往左匹配, 这时B串的C与A串该位置的C对应, 继续匹配B, 然后B串中的D与A串中的对应位置A不匹配, 出现换字符.\n1ABCABCAABCABCD 2ABCDBC 于是右移B串, 第一个与A坏字符对应的B串位置就是第一个字母, 现在变成了\n1ABCABCAABCABCD 2 ABCDBC B串往右移动了两格. 又开始从右往左寻找坏字符, 这时第一个B与C就冲突了, 于是又开始右移, 对齐这个坏字符:\n1ABCABCAABCABCD 2 ABCDBC B串往右移动一格后坏字符对齐, 又开始从右往左寻找坏字符, A与D出现冲突, 右移:\n1ABCABCAABCABCD 2 ABCDBC B串右移三格. 这一次再移动一格就到头了, 不行.\n坏字符规则是从右往左比较的, 并且这个移动规则保证了跳过多余的比较同时又不会遗留.\n2.好后缀规则: 从右往左匹配, 找到坏字符(坏字符后面的串是匹配的, 是好串), 往左寻找B中是否还有该好后缀, 如果有, 将B右移到该位置与A好后缀进行对齐. 重复该规则. 如果B串往右没有该好后缀, 则右移到好后缀的往右错一位的位置, 重复该规则. 避免B串的前缀与好后缀的后缀匹配\n还是以上面为例:\n1ABCABCAABCABCD 2ABCDBC 这时好串是BC, 往前寻找发现还有这个好后缀, 于是进行对齐:\n1ABCABCAABCABCD 2 ABCDBC 这时坏字符是第一个, 没有好串, 只有先对齐了:\n1ABCABCAABCABCD 2 ABCDBC 有好串了, 继续\n1ABCABCAABCABCD 2 ABCDBC 在移动就超过长度了, 于是没有匹配的.\n再举有匹配的一例:\n1ABCABCAABCABCD 2ABCABCD 3开始位置0; 坏字符下标:6; 需要移位:3; 4 5ABCABCAABCABCD 6 ABCABCD 7开始位置3; 坏字符下标:6; 需要移位:1; 8 9ABCABCAABCABCD 10 ABCABCD 11开始位置4; 坏字符下标:6; 需要移位:3 12 13ABCABCAABCABCD 14 ABCABCD 15开始位置7; 无坏字符. 两种规则综合使用, 哪种移动的位数多使用哪种\n时间复杂度: O(n/m), 最坏O(m*n)\n1//BM 2 static int BM(String A, String B){ 3 int aLength = A.length(); 4 int bLength = B.length(); 5 //每次操作结束后A串对齐B串的标志位 6 int index = 0; 7 while (true) { 8 for (int j = bLength-1; j \u0026gt; 0; j--) { 9 //出现坏字符 10 if (A.charAt(index + j) != B.charAt(j)){ 11 Boolean ifHaveBad = false; 12 for (int i = j; i \u0026gt; 0; i--) { 13 //B串中有坏字符 14 if (A.charAt(index + j) == B.charAt(i)){ 15 ifHaveBad = true; 16 index += j-i; 17 break; 18 } 19 } 20 21 if (!ifHaveBad){ 22 //B串中没有坏字符, 应移位到坏字符下一位 23 index += j; 24 } 25 26 //如果已经不能再移位了, 说明没有匹配的. 27 if (aLength - index \u0026lt; bLength) return -1; 28 29 //移位, 进行下一次规则循环比较. 30 break; 31 } 32 //在B串一次循环中没有一次进入if分支, 说明全部匹配 33 return index; 34 } 35 } 36 } KMP算法 前缀: 字符串A=B+S, S非空, 那么B就是A的前缀\n后缀: 字符串A=S+B, S非空, 那么B是A的后缀\nPMT值: 前缀集合和后缀集合的交集中, 最长元素的长度\n部分匹配表: PMT值集合, 字符串的所有前缀的PMT值\nperfix数组: 每一个下标位置对应一个PMT值, 组成的数组\nnext数组: perfix向右移一个下标位置, 组成next数组\n\r这个PMT值就是我们每次找到坏字符后, pattern字符串需要移动的距离.\n求next数组:\n1//KMP: next数组生成 2 static void getNext(char[] pattern, int[]next){ 3 //next数组其余位置默认是0. 4 next[0] = -1; 5 int i = 0, j = -1; 6 7 while (i \u0026lt; pattern.length){ 8 //每当j=-1时, 就是说明当前子串已经找完了. 9 if(j == -1){ 10 i++; 11 j++; 12 }else if(pattern[i] == pattern[j]){ 13 i++; 14 j++; 15 //这时i位置上的值赋值的是i-1位置上的KMP值, 错位了. 16 next[i] = j; 17 }else { 18 //当字母不匹配后回到这里, j慢慢缩小直到-1. 19 j = next[j]; 20 } 21 } 22 } 以ABCABCD串解释如何求出next数组.\n1.默认情况下i=0, j=-1, 这时刚好寻找下标为0子串的KMP值, 这是肯定为0的, 所以我们进行i++,j++.\n1ABCABCD 2ABCABCD 2.现在变成了i=1, j=0; 由于此时B != A, 说明子串AB的KMP值为0, 于是将j赋值为-1, 这样i就会++. 表明这个位置没有匹配的, 仍需要移动\n1ABCABCD 2 ABCABCD 3.现在i=1, j=-1, 又变成i=2, j=0, C!=A, 第一个仍然不匹配, 继续\n1ABCABCD 2 ABCABCD 4.现在i=3, j=0, 匹配了, 将next[4] = 1, i++, j++后继续匹配, next[5] = 2, i++, j++后继续匹配, next[6] = 3, 当i=6, j=3时, 不匹配了, 又回到j=0了, 然后j=-1, 最后i = 7 = pattern的长度了.\n1ABCABCD 2 ABCABCD 最后一个问题, j = next[j];是否一定会让j变成-1, 有没有例外情况? 我们举例来看看:\n1如果串是: ABCABCDABCDA 2 3ABCABCDABCDA 4 ABCABCDABCDA 5这时i=10 j=3时不匹配, 那么j=next[3]=0 初步估计这个next数组是越来越大的, 因为子串的长度在不断增大, KMP值越来越大, 所以它总会收敛于-1的.\n算法本体:\n1//KMP 2 static int search(char[] str, char[] pattern, int[] next){ 3 int i = 0; 4 int j = 0; 5 6 while (i \u0026lt; str.length \u0026amp;\u0026amp; j \u0026lt; pattern.length){ 7 if (j == -1 || str[i] == pattern[j]){ 8 i++; 9 j++; 10 }else { 11 //不匹配了 , 就往后移动. 12 //所以下标0的-1也是移动的手段, 13 j = next[j]; 14 } 15 } 16 17 //如果j最后一直到了最后都和i匹配, 说明找到了. 18 if (j == pattern.length){ 19 return i - j; 20 }else { 21 return -1; 22 } 23 } 测试:\n1public static void main(String[] args) { 2 String A = \u0026#34;ABCABCAABCABCD\u0026#34;; 3 String B = \u0026#34;ABCABCD\u0026#34;; 4 System.out.println(BF(A, B)); 5 System.out.println(RK(A, B)); 6 //System.out.println(hashCode(B)); 7 System.out.println(BM(A,B)); 8 9 int[] next = new int[B.length()]; 10 getNext(B.toCharArray(), next); 11 int i = search(A.toCharArray(), B.toCharArray(), next); 12 System.out.println(Arrays.toString(next)); 13 System.out.println(i); 14 System.out.println(A.indexOf(B)); 15 } 打家劫舍 动态规划三要素:\n 最优子结构: 每一个问题的最优解都包含子问题的最优解(n的最优依赖的是n-1的最优) 递推公式(状态转移方程): 找问题的规律, 解和前面解的关系 重叠子问题  初始问题 问题: 小偷偷钱, 不能偷相邻的房间. 给定一个代表每个房屋存放金额的非负整数数组, 计算你不触动警报装置的情况下, 一夜能偷窃到的最高金额\n输入: [1,2,3,1] 输出:4\n输入:[2,7,9,3,1] 输出12\n1public class Rob { 2 3 public static void main(String[] args) { 4 int[] num = new int[]{100, 2, 1, 100}; 5 int index = num.length -1; 6 System.out.println(maxMoney(num, index)); 7 System.out.println(maxMoney2(num)); 8 } 9 10 11 static int maxMoney(int[] num, int index){ 12 if (num == null || index \u0026lt; 0){ 13 return 0; 14 } 15 if (index == 0){ 16 return num[index]; 17 } 18 return Math.max(maxMoney(num, index-1), num[index]+maxMoney(num, index-2)); 19 } 20 21 static int maxMoney2(int[] num){ 22 //健壮性 23 int length = num.length; 24 if (num == null || length == 0){ 25 return 0; 26 } 27 if (length == 1){ 28 return num[length-1]; 29 } 30 31 //dp数组, 存放以及计算的值, 优化计算 32 int[] dp = new int[num.length]; 33 dp[0] = num[0]; 34 dp[1] = Math.max(num[0], num[1]); 35 for (int i = 2; i \u0026lt;length; i++) { 36 dp[i] = Math.max(dp[i-1], dp[i-2]+num[i]); 37 } 38 39 return dp[length-1]; 40 } 41 42 //优化空间复杂度, 只放两个位置. 43 static int maxMoney3(int[] num){ 44 //健壮性 45 int length = num.length; 46 if (num == null || length == 0){ 47 return 0; 48 } 49 if (length == 1){ 50 return num[length-1]; 51 } 52 53 //只需要两个变量, 优化空间复杂度从O(n)到O(1) 54 int first = num[0]; 55 int second = Math.max(num[0], num[1]); 56 for (int i = 2; i \u0026lt;length; i++) { 57 int temp = second; 58 second = Math.max(second, first+num[i]); 59 first = temp; 60 } 61 62 return second; 63 } 64} 65 首尾相连 街道房间是圆形的. 第一个和最后一个也算是相邻的.\n由于第一个和最后一个是互斥的, 于是分解为两个子问题: 第一个房子到倒数第二个房子的最优解, 与第二个房子到最后一个房子的最优解. 分别求出来比较大小.\n1public static void main(String[] args) { 2 int[] num = new int[]{100, 2, 1, 100}; 3 System.out.println(Math.max( 4 maxMoney4(num, 0, num.length-2), 5 maxMoney4(num, 1, num.length-1) 6 )); 7 } 8 9 10//将下标作为变量, 分别进行最优解运算. 11 static int maxMoney4(int[] num, int start, int end){ 12 //健壮性 13 int length = num.length; 14 if (num == null || length == 0){ 15 return 0; 16 } 17 if (length == 1){ 18 return num[length-1]; 19 } 20 21 //只需要两个变量, 优化空间复杂度从O(n)到O(1) 22 int first = num[start]; 23 int second = Math.max(num[start], num[start+1]); 24 for (int i = start+2; i \u0026lt;= end; i++) { 25 int temp = second; 26 second = Math.max(second, first+num[i]); 27 first = temp; 28 } 29 30 return second; 31 } 二叉树 父子关系就是相邻的情况.\n1public static void main(String[] args) { 2 TreeNode node5 = new TreeNode(1, null, null); 3 TreeNode node4 = new TreeNode(3, null, null); 4 TreeNode node3 = new TreeNode(3, null, node5); 5 TreeNode node2 = new TreeNode(2, null, node4); 6 TreeNode node1 = new TreeNode(3, node2, node3); 7 //传入根节点 8 int[] dfs = dfs(node1); 9 System.out.println(Math.max(dfs[0], dfs[1])); 10 } 11 12 13//深度优先算法 14 public static int[] dfs(TreeNode node){ 15 //int[]两个值, 一是选了这个节点select的最优解,第二个是没选这个节点not select的最优解 16 if (node == null){ 17 //如果是null节点, 选与不选结果都是1. 18 return new int[]{0,0}; 19 } 20 int[] l = dfs(node.left); 21 int[] r = dfs(node.right); 22 //选这个节点意味着不能选下面的节点 23 int select = node.val + l[1] + r[1]; 24 //不选这个节点意味着选子节点, 选子节点最大的情况. 25 int notSelect = Math.max(l[0], l[1]) + Math.max(r[0], r[1]); 26 return new int[]{select, notSelect}; 27 } 反转链表 1.迭代 用变量保存当前节点和下一个节点的信息, 以此赋值.\n1public class ReverseList { 2 3 public static void main(String[] args) { 4 ListNode node5 = new ListNode(5, null); 5 ListNode node4 = new ListNode(4, node5); 6 ListNode node3 = new ListNode(3, node4); 7 ListNode node2 = new ListNode(2, node3); 8 ListNode node1 = new ListNode(1, node2); 9 ListNode iterate = iterate(node1); 10 } 11 12 static class ListNode{ 13 int val; 14 ListNode next; 15 16 public ListNode(int val, ListNode next){ 17 this.val = val; 18 this.next = next; 19 } 20 } 21 22 public static ListNode iterate(ListNode head){ 23 //保存前一个节点 24 ListNode pre = null; 25 //保存当前节点 26 ListNode curr = head; 27 ListNode next; 28 while (curr != null){ 29 //先保存下一个节点的信息, 避免被覆盖 30 next = curr.next; 31 //在pre还未指向新的pre之前给自己赋值 32 curr.next = pre; 33 pre = curr; 34 curr = next; 35 } 36 return pre; 37 } 38 39 40} 41 2.递归 以相似的方式重复, 类似于树结构, 从最里面开始遍历.\n1public static ListNode recursion(ListNode head){ 2 if (head == null || head.next == null){ 3 return head; 4 } 5 //从最后往前修改 6 ListNode new_head = recursion(head.next); 7 head.next.next = head; // 后一个指向前一个 8 head.next = null; //断原来的链 9 return new_head; 10 } 素数个数统计 1.暴力算法 对每个数字x继续筛选, 看x是否会被小于根号x的数字整除. 可以用i * i \u0026lt; x 表示根号.\n1public class PrimeSearch { 2 3 4 public static int bf(int x){ 5 int count = 0; 6 for (int i = 2; i \u0026lt;= x; i++) { 7 count += isPrime(i) ? 1 : 0; 8 } 9 return count; 10 } 11 12 private static boolean isPrime(int i) { 13 for (int j = 2; j * j \u0026lt;= i; j++) { 14 if (i % j == 0){ 15 return false; 16 } 17 } 18 return true; 19 } 20} 21 2.埃氏筛选 埃氏筛选: 找到一个质数, 立刻将这个质数所有的倍数都淘汰为合数.\n1 public static int eratosthenes(int n){ 2 int count = 0; 3 //由于数组下标的因素, 设置为n+1 4 Boolean[] isPrime = new Boolean[n+1]; //初始化为false 5 Arrays.fill(isPrime, true); //所有默认为true 6 for (int i = 2; i \u0026lt;= n; i++) { 7 if (isPrime[i]){ 8 count++; 9 //排除所有这个质数的倍数的合数. 10 for (int j = i*i; j \u0026lt;= n; j+=i) { 11 isPrime[j] = false; 12 } 13 } 14 } 15 return count; 16 } 删除排序数组中的重复项 一个有序数组nums, 原地删除重复出现的元素, 使每个元素只出现一次, 返回删除后数组的新长度\n不能使用额外的数组空间, 必须在原地修改数组并在使用O(1)额外空间的条件下完成.\n输入: [0,1,2,2,3,3,4]\n输出: 5\nJava中没有数组元素删除操作, 删除了只能置为null. 或者只能新建数组拷贝.\n双指针算法: i(慢指针)和j(快指针)依次指向第一个和第二个, 如果他们对应元素不相等, 则都+1; 如果对应元素相等, 那么j+1; 如果是相等之后出现了不相等, 那么这时将j所在位置的元素赋值给i+1所在位置的元素(nums[i+1]=nums[j]); 如果j到了最后一个, 则返回i.\n1public class SortedArrayDuplicates { 2 3 public static void main(String[] args) { 4 System.out.println( 5 removeDuplicates(new int[]{0,1,2,2,2,3,3,4}) 6 ); 7 } 8 9 public static int removeDuplicates(int[] nums){ 10 if (nums.length == 0){ 11 return 0; 12 } 13 14 int i = 0; 15 for (int j = 1; j \u0026lt; nums.length; j++) { 16 //当不相等时, 如果是挨着的, 那么nums[i] = nums[j];无影响 17 //如果不是挨着的, 那么会将重复的元素赋值为下一个不重复的元素 18 if (nums[i] != nums[j]){ 19 i++; 20 nums[i] = nums[j]; 21 } 22 } 23 24 return i + 1; 25 } 26} 27 寻找数组的中心下标 给定一个整数数组nums, 返回数组\u0026quot;中心下标\u0026quot;的方法, 不存在返回-1, 有多个则返回最靠近左边的那个.\n中心下标是数组的一个下标, 其左侧的所有元素相加的和等于右侧所有元素相加的和. 中心下标可能出现在数组的两端.\n这道题的关键是理解题意, 左边等于右边, 这是不包括当前位置的值的. 于是思路有\n  轮到下标为i元素时, 判断0+1+..+i-1+ i 是否等于 sum - 0 - 1 - (i-1). 双方都加一个当前元素等于没有加.\n1public static int pivotIndex(int[] nums){ 2 int sumMinusPrev = Arrays.stream(nums).sum(); 3 int leftPlusCurr = 0; 4 for (int i = 0; i \u0026lt; nums.length; i++) { 5 leftPlusCurr += nums[i]; 6 if (leftPlusCurr == sumMinusPrev){ 7 return i; 8 } 9 sumMinusPrev -= nums[i]; 10 } 11 return -1; 12 }   既然左边右边是相等的, 那么2*(0+1+2+\u0026hellip;+i-1) + i = sum总和.\n1public static int pivotIndex2(int[] nums){ 2 int sum = Arrays.stream(nums).sum(); 3 int ima = 0; 4 for (int i = 0; i \u0026lt; nums.length; i++){ 5 if (ima * 2 + nums[i] == sum){ 6 return i; 7 } 8 ima += nums[i]; 9 } 10 return -1; 11 }   验证:\n1public static void main(String[] args) { 2 System.out.println(pivotIndex(new int[]{1,7,3,6,5,6})); 3 System.out.println(pivotIndex2(new int[]{1,7,3,6,5,6})); 4 } X的平方根 不使用sqrt函数, 得到x的平方根的整数部分.\n二分法 寻找i * i \u0026lt; x 但 (i+1)*(i+1) \u0026gt; x的值, 使用二分法缩减寻找次数.\n1public static int binarySearch(int x){ 2 int index = -1; 3 int lP = 0, rP = x; 4 while (lP \u0026lt;= rP){ 5 //计算新的左右指针的中间值 6 int mid = (lP + rP) / 2; 7 if (mid * mid \u0026lt;= x){ 8 lP = mid + 1; 9 //取小值 10 index = mid; 11 }else { 12 rP = mid - 1; 13 } 14 15 } 16 return index; 17 } 牛顿迭代 原理: x/n 与 n的均值比他们原来更趋近于根号x.\n原本的牛顿迭代是迭代选取的点对应切线与x轴交点的值(x1 = x0 - f(x0)/df(x0)),\n这里相当于是求x^2-x0=0方程的根, 化简之后就是(i + x/i)/2, 和牛顿迭代一致.\n1public static int newton(int x){ 2 //第一个参数值无所谓, 越接近根号x, 则迭代次数越少. 3 return (int)sqrt(x, x); 4 } 5 6 public static double sqrt(double i, int x){ 7 double res = (i + x/i)/2; 8 if (res == i){ 9 return res; 10 }else { 11 sqrt(res, x); 12 } 13 } 数组中三个数的最大乘积 整形数组nums, 在数组中找出由三个数字组成的最大乘积, 并输出.\n当数组全为整数时, 最大乘积为前三个最大的数的乘积;\n当数组有一个负数时, 最大乘积为前三个最大的数的乘积;\n当数组由两个及以上的负数时, 最大乘积为前三个最大的数的乘积 和 最大的数与两个最小的数的乘积之大者.\n先排序后计算 算法复杂度取决于排序算法.\n1public static int sortAndCalc(int[] nums){ 2 int length = nums.length; 3 Arrays.sort(nums); 4 return Math.max( 5 nums[0]*nums[1]*nums[length-1], 6 nums[length-1]*nums[length-2]*nums[length-3] 7 ); 8 } 线性扫描: 只找出前三最大和前二最小 1public static int getMax3AndMin2(int[] nums){ 2 int max1 = Integer.MIN_VALUE, max2 = Integer.MIN_VALUE, max3 = Integer.MIN_VALUE; 3 int min1 = Integer.MAX_VALUE, min2 = Integer.MAX_VALUE; 4 for (int num : nums){ 5 if (num \u0026gt; max1){ 6 max3 = max2; 7 max2 = max1; 8 max1 = num; 9 }else if (num \u0026gt; max2){ 10 max3 = max2; 11 max2 = num; 12 }else if (num \u0026gt; max3){ 13 max3 = num; 14 } 15 16 if (num \u0026lt; min1){ 17 min2 = min1; 18 min1 = num; 19 }else if (num \u0026lt; min2){ 20 min2 = num; 21 } 22 } 23 24 return Math.max( 25 max1*max2*max3, 26 max1*min1*min2 27 ); 28 } 两数之和\u0026ndash;无序数组 给定整数数组nums, 从中寻找两个数满足他们之和为给定目标target.\n不可重复使用元素, 返回两数的下标值, 以数组形式返回.\n可以使用暴力算法.\n或者利用map记录扫描过的数及下标. 这样空间复杂度会稍高.\n1import java.util.Arrays; 2import java.util.HashMap; 3import java.util.Map; 4 5public class TwoNumberForSum { 6 7 public static void main(String[] args) { 8 System.out.println( 9 Arrays.toString(solution(new int[]{1, 2, 3, 4, 5, 6}, 10)) 10 ); 11 } 12 13 14 public static int[] solution(int[] nums, int target){ 15 Map\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); 16 for (int i = 0; i \u0026lt; nums.length; i++) { 17 if (map.containsKey(target - nums[i])){ 18 return new int[]{map.get(target - nums[i]), i}; 19 } 20 map.put(nums[i], i); 21 } 22 return new int[0]; 23 } 24} 25 两数之和\u0026ndash;有序数组 二分查找 遍历左边的界限, 在界限之中应用二分查找target-nums[i]的数.\n1public static int[] twoSearch(int[] nums, int target){ 2 for (int i = 0; i \u0026lt; nums.length; i++) { 3 int low = nums[i], high = nums.length - 1; 4 while (low \u0026lt;= high){ 5 int mid = (low + high) / 2; 6 if (nums[mid] == target - nums[i]){ 7 return new int[]{i, mid}; 8 }else if (nums[mid] \u0026gt; target - nums[i]){ 9 high = mid - 1; 10 }else { 11 low = mid + 1; 12 } 13 } 14 } 15 return new int[0]; 16 } 双指针 前提是有序.\n1public static int[] twoPointer(int[] nums, int target){ 2 int low = 0, high = nums.length - 1; 3 while (low \u0026lt; high){ 4 int sum = nums[low] + nums[high]; 5 if (sum == target){ 6 return new int[]{low, high}; 7 }else if (sum \u0026gt; target){ 8 high--; 9 }else { 10 low++; 11 } 12 } 13 return new int[0]; 14 } 计算斐波那契数列 0, 1, 1, 2, 3, 5, 8, \u0026hellip;. 后一项等于前面两项的和.\n暴力递归 直接递归, 这样有些项存在严重的重复计算.\n1public static int BFRecursion(int num){ 2 if (num == 0) return 0; 3 if (num == 1) return 1; 4 return BFRecursion(num - 1) + BFRecursion(num - 2); 5 } 去重递归 用空间保存计算过的项. 时间O(n) 空间O(n)\n1public static int SavedRecursion(int num){ 2 //由于第一个是0, 所以需要多一个空间. 3 int[] saveArr = new int[num + 1]; 4 return Recursion(saveArr, num); 5 } 6 7 private static int Recursion(int[] saveArr, int num) { 8 if (num == 0) return 0; 9 if (num == 1) return 1; 10 //如果之前这个位置已经被运算, 直接返回. 11 if (saveArr[num] != 0) return saveArr[num]; 12 saveArr[num] = Recursion(saveArr, num - 1) + Recursion(saveArr, num - 2); 13 return saveArr[num]; 14 } 双指针迭代 只需要两个位置保存, 节省了空间至O(1)\n1public static int TwoPointer(int num){ 2 if (num == 0) return 0; 3 if (num == 1) return 1; 4 int first = 1, second = 0; 5 for (int i = 2; i \u0026lt;= num; i++) { 6 int temp = first; 7 first = first + second; 8 second = temp; 9 } 10 return first; 11 } 排列硬币 n枚硬币, 将他们排列为阶梯形状, 第k行有k枚硬币.\n给定一个数字n, 找出可形成完整阶梯行的总行数. 就是可以剩, 不需要全部用完.\n暴力迭代 啥也不管, 一行一行地排\n1public static int arrangeCoinBF(int n){ 2 for (int i = 1; i \u0026lt; n; i++) { 3 n -= i; 4 if (n \u0026lt; i + 1){ 5 return i; 6 } 7 } 8 return -1; 9 } 二分查找 行数必定在0到n之间, 查找这之中满足求和=n的值, 找不到就返回最大的行使求和\u0026lt;n.\n1public static int arrangeCoinSearch(int n){ 2 int low = 0, high = n - 1; 3 while (low \u0026lt; high){ 4 int mid = (low + high) / 2; 5 int predict = ((mid + 1) * mid) / 2; 6 if (n == predict){ 7 return mid; 8 }else if (n \u0026lt; predict){ 9 high = mid - 1; 10 }else { 11 low = mid + 1; 12 } 13 } 14 return low; 15 } 牛顿迭代 给定总数n求行数x, 由于 (x^2 + x) /2= n, 想求对应的x, 实际上是函数f(x) = (x^2 + x) /2 - n的根, 于是可以采用牛顿迭代, 每次迭代x1 = x0 - f(x0)/df(x0) = (x0^2 + 2n)/(2x0+1), 如果从n开始迭代, 则第一次为\n1public static double newtonRecursion(int n, int res){ 2 res = (res * res + 2 * n) / (res * 2 + 1); 3 if (res * res + res == 2 * n){ 4 return res; 5 }else { 6 return newtonRecursion(n, res); 7 } 8 } 环形链表 给定额链表, 判断链表中是否有环(如果链表有某个节点可以通过连续跟踪next指针再次到该节点, 就存在环). 存在环返回true, 否则返回false.\n内部类:\n1//内部类 2 static class ListNode{ 3 int val; 4 ListNode next; 5 6 public ListNode(int val, ListNode next){ 7 this.val = val; 8 this.next = next; 9 } 10 } 11 12 public static void main(String[] args) { 13 ListNode node5 = new ListNode(5, null); 14 ListNode node4 = new ListNode(4, node5); 15 ListNode node3 = new ListNode(3, node4); 16 ListNode node2 = new ListNode(2, node3); 17 ListNode node1 = new ListNode(1, node2); 18 //node5.next = node3; 19 20 System.out.println(isCycle(node1)); 21 System.out.println(isCycleTwoPointer(node1)); 22 } 普通循环 时间O(n), 空间O(n)\n1public static Boolean isCycle(ListNode head){ 2 HashSet\u0026lt;ListNode\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); 3 while (head != null){ 4 if (!set.add(head)){ 5 return true; 6 } 7 head = head.next; 8 } 9 return false; 10 } 双指针 如果快指针和慢指针可以重叠, 说明存在环; 如果快指针到达了null, 说明没有环.\n时间O(n), 空间O(1)\n1public static Boolean isCycleTwoPointer(ListNode head){ 2 if (head == null || head.next == null) return false; 3 ListNode slow = head; 4 ListNode fast = head.next; 5 while (fast.next != null \u0026amp;\u0026amp; fast.next.next != null){ 6 if (slow == fast) return true; 7 slow = slow.next; 8 fast = fast.next.next; 9 } 10 return false; 11 } 合并两个有序数组 两个有序整数数组nums1和nums2, 将nums2合并到nums1中, 使nums1成为一个有序数组. nums1和nums2元素个数分别为m和n, 假设nums1的空间大小等于m+n.\n合并后排序 取决于排序的时间复杂度O(N*logN), 不消化额外空间\n1//m为nums1实际元素个数, n为nums2实际元素个数 2 public static int[] mergeAndSort(int[] nums1, int m, int[] nums2, int n){ 3 //将数组2拷贝至数组1的后面. 4 System.arraycopy(nums2, 0, nums1, m, n); 5 //排序, 复杂度取决于排序的复杂度, 为N*logN 6 Arrays.sort(nums1); 7 return nums1; 8 } 双指针 需要消耗O(n)的空间\n1public static int[] compareAndInsert(int[] nums1, int m, int[] nums2, int n){ 2 //要求返回nums1, 所以我们需要处理一下. 3 int[] num1Copy = new int[m]; 4 System.arraycopy(nums1, 0, num1Copy, 0, m); 5 int pointerNum1 = 0, pointerNum2 = 0; 6 int i = 0; 7// int[] res = new int[m+n]; 8 9 while (pointerNum1 \u0026lt; m \u0026amp;\u0026amp; pointerNum2 \u0026lt; n){ 10 //被选中的才会++, 且是先用后++. 11 nums1[i++] = num1Copy[pointerNum1] \u0026lt; nums2[pointerNum2] ? num1Copy[pointerNum1++] : nums2[pointerNum2++]; 12// if (nums1[pointerNum1] \u0026gt; nums2[pointerNum2]){ 13// res[i] = nums2[pointerNum2]; 14// pointerNum2++; 15// }else { 16// res[i] = nums1[pointerNum1]; 17// pointerNum1++; 18// } 19// i++; 20 } 21 if (pointerNum2 \u0026lt; n){ 22 System.arraycopy(nums2, pointerNum2, nums1, pointerNum1 + pointerNum2, m + n - pointerNum2 -pointerNum1); 23 } 24 if (pointerNum1 \u0026lt; m){ 25 System.arraycopy(num1Copy, pointerNum1, nums1, pointerNum1 + pointerNum2, m + n - pointerNum2 -pointerNum1); 26 } 27 return nums1; 28 } 倒着排 1 public static int[] reverseMerge(int[] nums1, int m, int[] nums2, int n) { 2 int p1 = m - 1, p2 = n-1; 3 int i = m+n-1; 4 5 while (p1 \u0026gt;= 0 \u0026amp;\u0026amp; p2 \u0026gt;= 0) { 6 nums1[i--] = nums1[p1] \u0026gt; nums2[p2] ? nums1[p1--] : nums2[p2--]; 7 } 8 //有两种情况, 1是nums2下标先走完至-1, 这时无序任何操作 9 //2是nums1下标先走完至-1, 这是nums2还有额外的元素需要复制 10 System.arraycopy(nums2, 0, nums1, 0, p2 + 1); 11 return nums1; 12 } 子数组最大平均数 给一个整数数组, 找出平均数最大且长度为k的下标连续的子数组, 并输出该最大平均数.\n输入: [1,12,-5,-6,50,3], k=4\n输出: 12.75\n最大平均数 (12-5-6+50)/4=12.75\n滑动窗口 是双指针的特例:\n1public static double twoPointer(int[] nums, int k){ 2 int pl = 0, pr = k-1; 3 int maxSum = 0; 4 for (int i = pl; i \u0026lt;= pr; i++) { 5 maxSum += nums[i]; 6 } 7 8 while (pr \u0026lt; nums.length - 1){ 9 int tempSum = maxSum -nums[pl] + nums[pr+1]; 10 if (tempSum \u0026gt; maxSum) maxSum = tempSum; 11 pl++; 12 pr++; 13 } 14 15 return 1.0 * maxSum/k; 16 } 由于长度固定, 故只需要一个指针:\n1public static double slideWindow(int[] nums, int k){ 2 int sum = 0; 3 for (int i = 0; i \u0026lt; k; i++) { 4 sum += nums[i]; 5 } 6 int max = sum; 7 8 for (int i = k; i \u0026lt; nums.length; i++) { 9 sum = sum - nums[i-k] + nums[i]; 10 max = Math.max(sum, max); 11 } 12 13 return 1.0 * max/4; 14 } 二叉树的最小深度 最小深度是从根节点到最近叶子节点的最短路径上的节点数量.\n深度优先 先找到叶子节点, 然后从叶子节点往上找, 计算每个节点的最小深度(取左右叶子节点较小的那个+1.\n空间复杂度O(logN) 取决于树的深度, 时间复杂度O(N)\n1\tpublic static int minDepth(TreeNode root) { 2 //空节点 3 if (root == null) return 0; 4 //叶子节点 5 if (root.left == null \u0026amp;\u0026amp; root.right == null) return 1; 6 7 int min = Integer.MAX_VALUE; 8 //寻找左右子节点中最小的深度 9 if (root.left != null) min = Math.min(min, minDepth(root.left)); 10 if (root.right != null) min = Math.min(min, minDepth(root.right)); 11 12 //最后加上本节点的1返回. 13 return min + 1; 14 } 广度优先 一层一层遍历, 遍历到的第一个叶子节点就是最小深度.\n空间复杂度取决于队列O(N), 时间复杂度O(N)\n1public static int minWidth(TreeNode root){ 2 if (root == null) return 0; 3 4 //由于队列的性质, 它是广度遍历. 遍历完同一层才会遍历下一层 5 Queue\u0026lt;TreeNode\u0026gt; queue = new LinkedList\u0026lt;TreeNode\u0026gt;(); 6 root.setDeep(1); 7 //入队 8 queue.offer(root); 9 10 while (!queue.isEmpty()){ 11 //出队 12 TreeNode node = queue.poll(); 13 14 //遍历到根节点直接返回 15 if (node.left == null \u0026amp;\u0026amp; node.right == null){ 16 return node.deep; 17 } 18 19 if (node.left != null) { 20 node.left.setDeep(node.getDeep() + 1); 21 queue.offer(node.left); 22 } 23 if (node.right != null){ 24 node.right.setDeep(node.getDeep() + 1); 25 queue.offer(node.right); 26 } 27 } 28 29 //非正常退出 30 return -1; 31 } 最长连续递增序列 给定一个未排序的整数数组, 找到最长且连续递增的子序列, 并返回该序列的长度.\n方式一: 记录当前序列的开始位置, 如果后面的数字小于这个序列最后一个数, 则更新开始下标.\n方式二: 直接记录最大序列的长度和当前序列的长度.\n1public class MaxSeq { 2 3 public static void main(String[] args) { 4 System.out.println(findLength(new int[]{1,2,3,2,3,4,3,4,5,6,7})); 5 } 6 7 public static int findLength(int[] nums){ 8 int start = 0; 9 int max = 0; 10 for (int i = 1; i \u0026lt; nums.length; i++) { 11 if (nums[i] \u0026lt; nums[i-1]) start = i; 12 max = Math.max(max, i - start + 1); 13 } 14 return max; 15 } 16} 17 柠檬水找零 每杯柠檬水5美元, 顾客排队买, 顾客只会付5, 10, 20美元, 必须给顾客正确找零. 一开始手里面没有任何零钱, 如果能正确找零返回true, 否则返回false.\n分析: 对于顾客付的5美元, 直接收下; 对于顾客付的10美元, 只能找5美元; 对于20美元, 可以三个5, 也可以10+5, 但是为了局部最优, 最好10+5. 因为这里5是万能的, 尽量减少使用.\n1public class LemonWater { 2 3 public static void main(String[] args) { 4 System.out.println(isCanGiveChange(new int[]{5,5,5,20})); 5 6 } 7 8 public static boolean isCanGiveChange(int[] nums){ 9 //5和10的票子数量 10 int fiveNum = 0, tenNum = 0; 11 for (int num: nums) { 12 switch (num){ 13 case 5: 14 fiveNum++; 15 break; 16 case 10: 17 if (fiveNum \u0026gt; 0){ 18 fiveNum--; 19 tenNum++; 20 }else 21 return false; 22 break; 23 case 20: 24 if (fiveNum \u0026gt; 0 \u0026amp;\u0026amp; tenNum \u0026gt; 0){ 25 fiveNum--; 26 tenNum--; 27 }else if (fiveNum \u0026gt;= 3){ 28 fiveNum -= 3; 29 }else 30 return false; 31 } 32 } 33 34 return true; 35 } 36} 37 三角形的最大周长 给一个正数数组arr, 返回由其3个数组成的, 面积不为0的三角形的周长可能的最大值.\n直接找最大和的三个数, 看看是否能形成三角形, 不行就减少最大数继续. 因为既然最大的三个数不行, 那么前两最大的数和任何一个数都不行了, 所以只能往下找.\n1import java.util.Arrays; 2 3public class Triangle { 4 5 public static void main(String[] args) { 6 System.out.println(maxPerimeter(new int[]{3,6,3,2})); 7 } 8 9 public static int maxPerimeter(int[] nums){ 10 Arrays.sort(nums); 11 for (int i = nums.length - 1; i \u0026gt;= 2 ; i--) { 12 if (nums[i-1] + nums[i-2] \u0026gt; nums[i]){ 13 return nums[i] + nums[i-1] + nums[i-2]; 14 } 15 } 16 return 0; 17 } 18} 19 二叉树遍历 前序 递归实现 1//前序:根左右 2 public static void preorder(TreeNode root){ 3 if (root == null) return; 4 5 System.out.println(root.val); 6 preorder(root.left); 7 preorder(root.right); 8 } 中序 递归实现 1 //中序 2 public static void midorder(TreeNode root){ 3 if (root == null) return; 4 5 if (root.left != null){ 6 preorder(root.left); 7 } 8 9 System.out.println(root.val); 10 11 if (root.right != null){ 12 preorder(root.right); 13 } 14 15 } 后序 递归实现 1//后序 2 public static void postorder(TreeNode root){ 3 if (root == null) return; 4 5 if (root.left != null){ 6 preorder(root.left); 7 } 8 9 if (root.right != null){ 10 preorder(root.right); 11 } 12 13 System.out.println(root.val); 14 } 层序 递归实现 1//层序遍历 2 //这个参数i代表的第几层, 由于树不是完全的, 所以一定之间会有null值 3 public static void levelorder(TreeNode root, int i, ArrayList list){ 4 if (root == null) return; 5 6 int length = list.size(); 7 //为防止数组越界, 这里提前填充至i. 8 if (length \u0026lt;= i){ 9 for (int j = 0; j \u0026lt;= i - length; j++) { 10 list.add(length+j, null); 11 } 12 } 13 14 list.set(i, root.val); 15 levelorder(root.left, 2*i, list); 16 levelorder(root.right, 2*i+1, list); 17 } ","date":"2024-07-28","permalink":"/posts/tech/java-5-algorithm/","series":["Java"],"tags":["","",""],"title":"算法刷题"},{"categories":["计算机"],"content":"面向对象高级一 权限修饰符    修饰符 在本类中 同一个包下的其他类里 任意包下的子类里 任意包下的任意类里     private √      缺省 √ √     protected √ √ √    public √ √ √ √    说明: protected修饰的方法可以在任意包下的子类里访问, 但是这个子类对应的实例是不能访问的.\n方法重写规则  使用@Override注解可以帮忙检查是否书写错误 重写父类方法, 子类方法访问权限大于等于父类该方法权限(public\u0026gt;protected\u0026gt;缺省) 重写方法返回值, 必须与被重写方法的返回值类型一样, 或者范围更小 私有方法, 静态方法不能被重写  个人理解这些规则的目的是为了兼容性和安全性.\n子类构造器 子类的全部构造器, 都会默认先调用父类的无参构造器(super()), 再执行自己. 如果父类没有无参构造器, 必须在子类构造器第一行手写super(\u0026hellip;) 调用父类的有参构造器.\n集合框架 \r总结:\r  如果希望记住元素的添加顺序，需要存储重复的元素，又要频繁的根据索引查询数据？\n用ArrayList集合（有序、可重复、有索引），底层基于数组的。（常用）\n  如果希望记住元素的添加顺序，且增删首尾数据的情况较多？\n用LinkedList集合（有序、可重复、有索引），底层基于双链表实现的。\n  如果不在意元素顺序，也没有重复元素需要存储，只希望增删改查都快？\n用HashSet集合（无序，不重复，无索引），底层基于哈希表实现的。 （常用）\n  如果希望记住元素的添加顺序，也没有重复元素需要存储，且希望增删改查都快？\n用LinkedHashSet集合（有序，不重复，无索引）， 底层基于哈希表和双链表。\n  如果要对元素进行排序，也没有重复元素需要存储？且希望增删改查都快？\n用TreeSet集合，基于红黑树实现。\n  Collection接口下有list和set接口, list有序 可重复 有索引, set无序，不重复，无索引.\nCollection接口 特有方法  add(): 添加元素 clear(): 清除集合的元素 isEmpty(): 判断集合是否为空 Size(): 获取集合的大小 contains(Object obj): 判断是否包含 remove(Object obj): 删除元素,有多个删除第一个 toArray(): 将集合转为数组 addAll(Collection): 将一个集合的全部数据倒入到另一个集合中去  1\tCollection\u0026lt;String\u0026gt; c = new ArrayList\u0026lt;\u0026gt;(); // 多态写法 2 // 1.public boolean add(E e)：添加元素, 添加成功返回true。 3 c.add(\u0026#34;java1\u0026#34;); 4 c.add(\u0026#34;java1\u0026#34;); 5 c.add(\u0026#34;java2\u0026#34;); 6 c.add(\u0026#34;java2\u0026#34;); 7 c.add(\u0026#34;java3\u0026#34;); 8 System.out.println(c); 9 10 // 2.public void clear()：清空集合的元素。 11 //c.clear(); 12 //System.out.println(c); 13 14 // 3.public boolean isEmpty()：判断集合是否为空 是空返回true,反之。 15 System.out.println(c.isEmpty()); // false 16 17 // 4.public int size()：获取集合的大小。 18 System.out.println(c.size()); 19 20 // 5.public boolean contains(Object obj)：判断集合中是否包含某个元素。 21 System.out.println(c.contains(\u0026#34;java1\u0026#34;)); // true 22 System.out.println(c.contains(\u0026#34;Java1\u0026#34;)); // false 23 24 // 6.public boolean remove(E e)：删除某个元素:如果有多个重复元素默认删除前面的第一个！ 25 System.out.println(c.remove(\u0026#34;java1\u0026#34;)); 26 System.out.println(c); 27 28 // 7.public Object[] toArray()：把集合转换成数组 29\t//泛型的原因在运行时会擦除, 不能确保集合里都是字符串, 所以是Object数组. 30 Object[] arr = c.toArray(); 31 System.out.println(Arrays.toString(arr)); 32 33\t//这种方式必须确保集合里面都是字符串 34 String[] arr2 = c.toArray(new String[c.size()]); 35 System.out.println(Arrays.toString(arr2)); 36 37 System.out.println(\u0026#34;--------------------------------------------\u0026#34;); 38 // 把一个集合的全部数据倒入到另一个集合中去。 39 Collection\u0026lt;String\u0026gt; c1 = new ArrayList\u0026lt;\u0026gt;(); 40 c1.add(\u0026#34;java1\u0026#34;); 41 c1.add(\u0026#34;java2\u0026#34;); 42 Collection\u0026lt;String\u0026gt; c2 = new ArrayList\u0026lt;\u0026gt;(); 43 c2.add(\u0026#34;java3\u0026#34;); 44 c2.add(\u0026#34;java4\u0026#34;); 45 c1.addAll(c2); // 就是把c2集合的全部数据倒入到c1集合中去。 46 System.out.println(c1); 47 System.out.println(c2); 遍历 1.使用迭代器, iterator()方法返回一个迭代器 迭代器方法:\n boolean hasNext() 询问当前位置是否有元素存在 E next() 获取当前位置的元素, 并同时将迭代器对象指向下一个元素处.  1\tCollection\u0026lt;String\u0026gt; c = new ArrayList\u0026lt;\u0026gt;(); 2 c.add(\u0026#34;赵敏\u0026#34;); 3 c.add(\u0026#34;小昭\u0026#34;); 4 c.add(\u0026#34;素素\u0026#34;); 5 // c.add(\u0026#34;灭绝\u0026#34;); 6 System.out.println(c); 7 // c = [赵敏, 小昭, 素素] 8 // it 9 10 // 使用迭代器遍历集合 11 // 1、从集合对象中获取迭代器对象。 12 Iterator\u0026lt;String\u0026gt; it = c.iterator(); 13// System.out.println(it.next()); 14// System.out.println(it.next()); 15// System.out.println(it.next()); 16// System.out.println(it.next()); 17 // System.out.println(it.next()); // 出现异常的 18 19 // 2、我们应该使用循环结合迭代器遍历集合。 20 while (it.hasNext()){ 21 String ele = it.next(); 22 System.out.println(ele); 23 24 } 2.使用for循环, 本质是迭代器遍历集合. 也可以用来遍历数组 1\tCollection\u0026lt;String\u0026gt; c = new ArrayList\u0026lt;\u0026gt;(); 2 c.add(\u0026#34;赵敏\u0026#34;); 3 c.add(\u0026#34;小昭\u0026#34;); 4 c.add(\u0026#34;素素\u0026#34;); 5 c.add(\u0026#34;灭绝\u0026#34;); 6 System.out.println(c); 7 // c = [赵敏, 小昭, 素素, 灭绝] 8 // ele 9 10 // 使用增强for遍历集合或者数组。 11 for (String ele : c) { 12 System.out.println(ele); 13 } 14 15 String[] names = {\u0026#34;迪丽热巴\u0026#34;, \u0026#34;古力娜扎\u0026#34;, \u0026#34;稀奇哈哈\u0026#34;}; 16 for (String name : names) { 17 System.out.println(name); 18 } 3.Lambda表达式遍历 1\tCollection\u0026lt;String\u0026gt; c = new ArrayList\u0026lt;\u0026gt;(); 2 c.add(\u0026#34;赵敏\u0026#34;); 3 c.add(\u0026#34;小昭\u0026#34;); 4 c.add(\u0026#34;殷素素\u0026#34;); 5 c.add(\u0026#34;周芷若\u0026#34;); 6 System.out.println(c); 7 // [赵敏, 小昭, 殷素素, 周芷若] 8 // s 9 10 // default void forEach(Consumer\u0026lt;? super T\u0026gt; action): 结合Lambda表达式遍历集合： 11 //forEach是Iterable的方法, Collection是Iterable的子接口. 12 c.forEach(new Consumer\u0026lt;String\u0026gt;() { 13 @Override 14 public void accept(String s) { 15 System.out.println(s); 16 } 17 }); 18 19 //@FunctionalInterface函数式注解, 可以将匿名内部类替换为Lambda表达式. 20 c.forEach((String s) -\u0026gt; { 21 System.out.println(s); 22 }); 23 24 c.forEach(s -\u0026gt; { 25 System.out.println(s); 26 }); 27 28 //只有一行可以去掉大括号 29 c.forEach(s -\u0026gt; System.out.println(s) ); 30 31 //函数引用, 前后参数一样的情况下可以用方法引用. System.out这个对象调用println这个方法. 32 c.forEach(System.out::println ); List接口 特有方法  add(int index, E element): 指定位置插入元素, 如果位置已有元素也不会覆盖, 就是中间插, 别的挤旁边了. E remove(int index): 删除指定位置的元素, 返回被删除的值 E set(int index, E element): 修改指定索引处的元素, 返回被修改的元素 E get(int index): 返回指定索引处的元素  1\t// 1.创建一个ArrayList集合对象（有序、可重复、有索引） 2 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); // 一行经典代码 3 list.add(\u0026#34;蜘蛛精\u0026#34;); 4 list.add(\u0026#34;至尊宝\u0026#34;); 5 list.add(\u0026#34;至尊宝\u0026#34;); 6 list.add(\u0026#34;牛夫人\u0026#34;); 7 System.out.println(list); // [蜘蛛精, 至尊宝, 至尊宝, 牛夫人] 8 9 // 2.public void add(int index, E element): 在某个索引位置插入元素。 10 list.add(2, \u0026#34;紫霞仙子\u0026#34;); 11 System.out.println(list); 12 13 // 3.public E remove(int index): 根据索引删除元素,返回被删除元素 14 System.out.println(list.remove(2)); 15 System.out.println(list); 16 17 // 4.public E get(int index): 返回集合中指定位置的元素。 18 System.out.println(list.get(3)); 19 20 // 5.public E set(int index, E element): 修改索引位置处的元素,修改成功后，会返回原来的数据 21 System.out.println(list.set(3, \u0026#34;牛魔王\u0026#34;)); 22 System.out.println(list); 遍历方式 1.Collection支持的它也支持 2.for循环遍历(索引遍历) 1\tList\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); 2 list.add(\u0026#34;糖宝宝\u0026#34;); 3 list.add(\u0026#34;蜘蛛精\u0026#34;); 4 list.add(\u0026#34;至尊宝\u0026#34;); 5 6 //（1）for循环 7 for (int i = 0; i \u0026lt; list.size(); i++) { 8 // i = 0 1 2 9 String s = list.get(i); 10 System.out.println(s); 11 } 12 13 //（2）迭代器。 14 Iterator\u0026lt;String\u0026gt; it = list.iterator(); 15 while (it.hasNext()) { 16 System.out.println(it.next()); 17 } 18 19 //（3）增强for循环（foreach遍历） 20 for (String s : list) { 21 System.out.println(s); 22 } 23 24 //（4）JDK 1.8开始之后的Lambda表达式 25 list.forEach(s -\u0026gt; { 26 System.out.println(s); 27 }); ArrayList的底层原理 特点: 基于数组实现  查询速度快(是根据索引查询数据快): 查询数据通过地址值和索引定位, 查询任意数据耗时相同 删除效率低: 可能需要把后面很多的数据进行前移 添加效率极低:可能需要把后面很多数据后移, 或者需要对数组扩容  底层原理  利用无参构造创建ArrayList时, 底层创建一个长度为0的数组 添加第一个元素时, 底层创建一个新的长度为10的数组 存满时, 扩容至1.5倍 如果一次添加多个数据, 同时即使扩容1.5被也放不下, 那么新创建数组的长度就以刚刚装满为准.  实用场景 适合: 查询数据较多, 或者数据量不是很大时\n不适合: 数据量大的同时又需要频繁进行增删操作.\nLinkedList底层原理 特点: 基于双链表实现 查询慢, 增删相对较快. 对首尾元素进行增删改查的速度是极快的.\n新增方法  addFirst(E e): 开头插入元素, push一样 addLast(E e): 追加元素至末尾, pop一样 E get First(): 返回第一个元素 E get Last(): 返回最后一个元素 E removeFirst(): 从列表中删除并返回第一个元素 E removeLast(): 从列表中删除并返回最后一个元素  应用场景 设计队列:\n1\t// 1、创建一个队列。 2 LinkedList\u0026lt;String\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); 3 // 入队 4 queue.addLast(\u0026#34;第1号人\u0026#34;); 5 queue.addLast(\u0026#34;第2号人\u0026#34;); 6 queue.addLast(\u0026#34;第3号人\u0026#34;); 7 queue.addLast(\u0026#34;第4号人\u0026#34;); 8 System.out.println(queue); 9 // 出队 10 System.out.println(queue.removeFirst()); 11 System.out.println(queue.removeFirst()); 12 System.out.println(queue.removeFirst()); 13 System.out.println(queue); 14 System.out.println(\u0026#34;--------------------------------------------------\u0026#34;); 设计栈:\n1 // 2、创建一个栈对象。 2 LinkedList\u0026lt;String\u0026gt; stack = new LinkedList\u0026lt;\u0026gt;(); 3 // 压栈(push) 4 stack.push(\u0026#34;第1颗子弹\u0026#34;); 5 stack.push(\u0026#34;第2颗子弹\u0026#34;); 6 stack.push(\u0026#34;第3颗子弹\u0026#34;); 7 stack.push(\u0026#34;第4颗子弹\u0026#34;); 8 System.out.println(stack); 9 // 出栈(pop) 10 System.out.println(stack.pop()); 11 System.out.println(stack.pop()); 12 System.out.println(stack); Set接口 set下的实现类增删改查都快.\n HashSet: 无序, 不重复, 无索引 LinkedHashSet: 有序(按添加顺序), 不重复, 无索引 TreeSet: 排序(默认升序), 不重复, 无索引  set几乎没有新增的功能, 都是用Collection的.\n1\t// 1、创建一个Set集合的对象 2 //Set\u0026lt;Integer\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); // 创建了一个HashSet的集合对象 一行经典代码 HashSet: 无序 不重复 无索引 3 Set\u0026lt;Integer\u0026gt; set = new LinkedHashSet\u0026lt;\u0026gt;(); // 有序 不重复 无索引 4// Set\u0026lt;Integer\u0026gt; set = new TreeSet\u0026lt;\u0026gt;(); // 可排序（升序） 不重复 无索引 5 set.add(666); 6 set.add(555); 7 set.add(555); 8 set.add(888); 9 set.add(888); 10 set.add(777); 11 set.add(777); 12 System.out.println(set); HashSet底层原理 Java中每个对象都有个哈希值, 使用hashCode方法返回一个哈希值, 范围是-21亿多到+21亿多. 不同的对象哈希值有可能会相同(哈希碰撞)\nHashSet是基于哈希表实现的, 哈希表是一种增删改查性能都较好的数据结构\n在Jdk8之前哈希表=数组+链表; 在Jdk8开始, 哈希表=数组+链表+红黑树.\njdk8之前:\n 创建一个默认长度16的数组, 默认加载因子0.75, 数组名table 使用元素的哈希值对数组长度求余, 计算存入位置 如果该位置为null, 直接存入 如果该位置不为null, 调用equals方法比较是否相等, 不相等则存入数组(jdk8之前新元素存入数组老元素挂下面; jdk8开始新元素挂老元素下面) 当占满了16(数组长度)*0.75(加载因子)个位置, 数组就开始扩容, 扩大约两倍, 防止链表过长影响查询效率.  jdk8开始, 当链表长度超过8, 同时数组长度\u0026gt;=64时, 自动将链表转成红黑树.\n需了解的树结构  二叉树: 度小于等于2的数 二叉搜索(查找)树: 小的放左边, 大的放右边, 一样的不放. 可能会出现变成链表的情况. 平衡二叉树: 满足查找二叉树规则情况下, 使这棵树尽量变矮. 红黑树: 可以自平衡的二叉树  HashSet去重复 要让HashSet将内容一样的两个对象认为是重复的去重的话, 需要重写hashCode和equals方法.\n1\t// 只要两个对象内容一样就返回true 2 @Override 3 public boolean equals(Object o) { 4 if (this == o) return true; 5 if (o == null || getClass() != o.getClass()) return false; 6 Student student = (Student) o; 7 return age == student.age \u0026amp;\u0026amp; Double.compare(student.height, height) == 0 \u0026amp;\u0026amp; Objects.equals(name, student.name); 8 } 9 10 // 只要两个对象内容一样，返回的哈希值就是一样的。 11 @Override 12 public int hashCode() { 13 // 姓名 年龄 身高计算哈希值的 14 return Objects.hash(name, age, height); 15 } LinkedHashSet底层原理 基于哈希表(数组, 链表, 红黑树)实现. 每个元素额外多了一个双链表机制记录它前后元素的位置. 所以可以有序. 但额外占内存\nTresSet 底层是基于红黑树实现的排序\n 对于数值, 按数值本身大小排序 对于字符串, 按首字母编号升序排序 对于自定义类型, 默认无法直接排序  自定义排序规则 方式一: 自定义类实现Comparable接口, 重写compareTo方法\n1\t@Override 2 public int compareTo(Student o) { 3 // 如果认为左边对象大于右边对象返回正整数 4 // 如果认为左边对象小于右边对象返回负整数 5 // 如果认为左边对象等于右边对象返回0 6 // 需求：按照年龄升序排序、 7 return this.age - o.age; 8 } 方式二: 调用TreeSet有参构造器, 设置Comparator对象\n(Double.compare比较小数, 返回整数.)\n1\tSet\u0026lt;Integer\u0026gt; set1 = new TreeSet\u0026lt;\u0026gt;(); 2 set1.add(6); 3 set1.add(5); 4 set1.add(5); 5 set1.add(7); 6 System.out.println(set1); 7 8 // TreeSet就近选择自己自带的比较器对象进行排序 9// Set\u0026lt;Student\u0026gt; students = new TreeSet\u0026lt;\u0026gt;(new Comparator\u0026lt;Student\u0026gt;() { 10// @Override 11// public int compare(Student o1, Student o2) { 12// // 需求：按照身高升序排序 13// return Double.compare(o1.getHeight() , o2.getHeight()); 14// } 15// }); 16 Set\u0026lt;Student\u0026gt; students = new TreeSet\u0026lt;\u0026gt;(( o1, o2) -\u0026gt; Double.compare(o1.getHeight() , o2.getHeight())); 17 students.add(new Student(\u0026#34;蜘蛛精\u0026#34;,23, 169.7)); 18 students.add(new Student(\u0026#34;紫霞\u0026#34;,22, 169.8)); 19 students.add(new Student(\u0026#34;至尊宝\u0026#34;,26, 165.5)); 20 students.add(new Student(\u0026#34;牛魔王\u0026#34;,22, 183.5)); 21 System.out.println(students); 注意\n 这里既规定了大小, 也规定了相等, 而相等是不存放的. 如果两者都规定了, TreeSet就近选择自己自带的比较器对象进行排序 默认是升序, 如果想要降序只需要将返回值相应地设反即可(大就返回负数).  集合并发修改异常问题 使用集合的remove方法删除的是第一个元素, 这导致出现错位的问题.\n解决方案: 1. 使用迭代器自带的删除方法\n​\t2. for循环倒着删除, 或者每次删除后下标减1.\n1public static void main(String[] args) { 2 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); 3 list.add(\u0026#34;王麻子\u0026#34;); 4 list.add(\u0026#34;小李子\u0026#34;); 5 list.add(\u0026#34;李爱花\u0026#34;); 6 list.add(\u0026#34;张全蛋\u0026#34;); 7 list.add(\u0026#34;晓李\u0026#34;); 8 list.add(\u0026#34;李玉刚\u0026#34;); 9 System.out.println(list); 10 // [王麻子, 小李子, 李爱花, 张全蛋, 晓李, 李玉刚] 11 12 // 需求：找出集合中全部带“李”的名字，并从集合中删除。 13// Iterator\u0026lt;String\u0026gt; it = list.iterator(); 14// while (it.hasNext()){ 15// String name = it.next(); 16// if(name.contains(\u0026#34;李\u0026#34;)){ 17// list.remove(name); 18// } 19// } 20// System.out.println(list); 21 22 // 使用for循环遍历集合并删除集合中带李字的名字 23 // [王麻子, 小李子, 李爱花, 张全蛋, 晓李, 李玉刚] 24 // [王麻子, 李爱花, 张全蛋, 李玉刚] 25 // i 26// for (int i = 0; i \u0026lt; list.size(); i++) { 27// String name = list.get(i); 28// if(name.contains(\u0026#34;李\u0026#34;)){ 29// list.remove(name); 30// } 31// } 32// System.out.println(list); 33 34 System.out.println(\u0026#34;---------------------------------------------------------\u0026#34;); 35 // 怎么解决呢？ 36 // 使用for循环遍历集合并删除集合中带李字的名字 37 // [王麻子, 小李子, 李爱花, 张全蛋, 晓李, 李玉刚] 38 // [王麻子, 张全蛋] 39 // i 40 for (int i = 0; i \u0026lt; list.size(); i++) { 41 String name = list.get(i); 42 if(name.contains(\u0026#34;李\u0026#34;)){ 43 list.remove(name); 44 i--; 45 } 46 } 47 System.out.println(list); 48 // 倒着去删除也是可以的。 49 50 // 需求：找出集合中全部带“李”的名字，并从集合中删除。 51 Iterator\u0026lt;String\u0026gt; it = list.iterator(); 52 while (it.hasNext()){ 53 String name = it.next(); 54 if(name.contains(\u0026#34;李\u0026#34;)){ 55 // list.remove(name); // 并发修改异常的错误。 56 it.remove(); // 删除迭代器当前遍历到的数据，每删除一个数据后，相当于也在底层做了i-- 57 } 58 } 59 System.out.println(list); 60 61 // 使用增强for循环遍历集合并删除数据，没有办法解决bug. 62// for (String name : list) { 63// if(name.contains(\u0026#34;李\u0026#34;)){ 64// list.remove(name); 65// } 66// } 67// System.out.println(list); 68 69// list.forEach(name -\u0026gt; { 70// if(name.contains(\u0026#34;李\u0026#34;)){ 71// list.remove(name); 72// } 73// }); 74// System.out.println(list); 75 } Collections工具类 可变参数, 可以不传也可以传多个(type\u0026hellip; var), 在方法内部就是一个数组, 支持数组的方法.\n关于＜? super T＞:理解Java泛型的复杂写法＜? super T＞,＜? extend T＞ , 大概＜? super T＞代指T及T的父类; ＜? extend T＞指T及T的子类.\n  1public static \u0026lt;T\u0026gt; boolean addAll(Collection\u0026lt;? super T\u0026gt; c, T...elements)：为集合批量添加数据   1public static void shuffle(List\u0026lt;?\u0026gt; list)：打乱List集合中的元素顺序。   1public static \u0026lt;T\u0026gt; void sort(List\u0026lt;T\u0026gt; list)：对List集合中的元素进行升序排序。   1public static \u0026lt;T\u0026gt; void sort(List\u0026lt;T\u0026gt; list， Comparator\u0026lt;? super T\u0026gt; c): 对List集合中元素，按照比较器对象指定的规则进行排序   1\t// 1、public static \u0026lt;T\u0026gt; boolean addAll(Collection\u0026lt;? super T\u0026gt; c, T...elements)：为集合批量添加数据 2 List\u0026lt;String\u0026gt; names = new ArrayList\u0026lt;\u0026gt;(); 3 Collections.addAll(names, \u0026#34;张三\u0026#34;, \u0026#34;王五\u0026#34;, \u0026#34;李四\u0026#34;, \u0026#34;张麻子\u0026#34;); 4 System.out.println(names); 5 6 // 2、public static void shuffle(List\u0026lt;?\u0026gt; list)：打乱List集合中的元素顺序。 7 Collections.shuffle(names); 8 System.out.println(names); 9 10 // 3、 public static \u0026lt;T\u0026gt; void sort(List\u0026lt;T\u0026gt; list)：对List集合中的元素进行升序排序。 11 List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); 12 list.add(3); 13 list.add(5); 14 list.add(2); 15 Collections.sort(list); 16 System.out.println(list); 17 18 List\u0026lt;Student\u0026gt; students = new ArrayList\u0026lt;\u0026gt;(); 19 students.add(new Student(\u0026#34;蜘蛛精\u0026#34;,23, 169.7)); 20 students.add(new Student(\u0026#34;紫霞\u0026#34;,22, 169.8)); 21 students.add(new Student(\u0026#34;紫霞\u0026#34;,22, 169.8)); 22 students.add(new Student(\u0026#34;至尊宝\u0026#34;,26, 165.5)); 23 // Collections.sort(students); 24 // System.out.println(students); 25 26 // 4、public static \u0026lt;T\u0026gt; void sort(List\u0026lt;T\u0026gt; list， Comparator\u0026lt;? super T\u0026gt; c): 对List集合中元素，按照比较器对象指定的规则进行排序 27 Collections.sort(students, new Comparator\u0026lt;Student\u0026gt;() { 28 @Override 29 public int compare(Student o1, Student o2) { 30 return Double.compare(o1.getHeight(), o2.getHeight()); 31 } 32 }); 33 System.out.println(students); Map接口 \r特点(都是由键决定的, 对值没有要求):\n HashMap: 无序, 不重复, 无索引 LinkedHashMap: 有序, 不重复, 无索引 TreeMap: 按照大小默认升序, 不重复, 无索引  1\tpublic static void main(String[] args) { 2 // Map\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); // 一行经典代码。 按照键 无序，不重复，无索引。 3 Map\u0026lt;String, Integer\u0026gt; map = new LinkedHashMap\u0026lt;\u0026gt;(); // 有序，不重复，无索引。 4 map.put(\u0026#34;手表\u0026#34;, 100); 5 map.put(\u0026#34;手表\u0026#34;, 220); // 后面重复的数据会覆盖前面的数据（键） 6 map.put(\u0026#34;手机\u0026#34;, 2); 7 map.put(\u0026#34;Java\u0026#34;, 2); 8 map.put(null, null); 9 System.out.println(map); 10 11 Map\u0026lt;Integer, String\u0026gt; map1 = new TreeMap\u0026lt;\u0026gt;(); // 可排序，不重复，无索引 12 map1.put(23, \u0026#34;Java\u0026#34;); 13 map1.put(23, \u0026#34;MySQL\u0026#34;); 14 map1.put(19, \u0026#34;李四\u0026#34;); 15 map1.put(20, \u0026#34;王五\u0026#34;); 16 System.out.println(map1); 17 } Map的常用方法  put添加元素: 无序, 不重复, 无索引 public int size(): 获取集合的大小 public void clear(): 清空集合 public boolean isEmpty(): 判断集合是否为空, 为空返回true public V get(Object key): 根据键获取对应值 public V remove(Object key): 根据键删除整个元素(删除键会返回键的值) public boolean containsKey(Object key): 判断是否包含某个键 , 包含返回true public boolean containsValue(Object value): 判断是否包含某个值 public Set keySet(): 获取Map集合的全部键 public Collection values(): 获取Map集合的全部值 putAll把其他Map集合的数据倒入到自己集合中来  1\tpublic static void main(String[] args) { 2 // 1.添加元素: 无序，不重复，无索引。 3 Map\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); 4 map.put(\u0026#34;手表\u0026#34;, 100); 5 map.put(\u0026#34;手表\u0026#34;, 220); 6 map.put(\u0026#34;手机\u0026#34;, 2); 7 map.put(\u0026#34;Java\u0026#34;, 2); 8 map.put(null, null); 9 System.out.println(map); 10 // map = {null=null, 手表=220, Java=2, 手机=2} 11 12 // 2.public int size():获取集合的大小 13 System.out.println(map.size()); 14 15 // 3、public void clear():清空集合 16 //map.clear(); 17 //System.out.println(map); 18 19 // 4.public boolean isEmpty(): 判断集合是否为空，为空返回true ,反之！ 20 System.out.println(map.isEmpty()); 21 22 // 5.public V get(Object key)：根据键获取对应值 23 int v1 = map.get(\u0026#34;手表\u0026#34;); 24 System.out.println(v1); 25 System.out.println(map.get(\u0026#34;手机\u0026#34;)); // 2 26 System.out.println(map.get(\u0026#34;张三\u0026#34;)); // null 27 28 // 6. public V remove(Object key)：根据键删除整个元素(删除键会返回键的值) 29 System.out.println(map.remove(\u0026#34;手表\u0026#34;)); 30 System.out.println(map); 31 32 // 7.public boolean containsKey(Object key): 判断是否包含某个键 ，包含返回true ,反之 33 System.out.println(map.containsKey(\u0026#34;手表\u0026#34;)); // false 34 System.out.println(map.containsKey(\u0026#34;手机\u0026#34;)); // true 35 System.out.println(map.containsKey(\u0026#34;java\u0026#34;)); // false 36 System.out.println(map.containsKey(\u0026#34;Java\u0026#34;)); // true 37 38 // 8.public boolean containsValue(Object value): 判断是否包含某个值。 39 System.out.println(map.containsValue(2)); // true 40 System.out.println(map.containsValue(\u0026#34;2\u0026#34;)); // false 41 42 // 9.public Set\u0026lt;K\u0026gt; keySet(): 获取Map集合的全部键。 43 Set\u0026lt;String\u0026gt; keys = map.keySet(); 44 System.out.println(keys); 45 46 // 10.public Collection\u0026lt;V\u0026gt; values(); 获取Map集合的全部值。 47 Collection\u0026lt;Integer\u0026gt; values = map.values(); 48 System.out.println(values); 49 50 // 11.把其他Map集合的数据倒入到自己集合中来。(拓展) 51 Map\u0026lt;String, Integer\u0026gt; map1 = new HashMap\u0026lt;\u0026gt;(); 52 map1.put(\u0026#34;java1\u0026#34;, 10); 53 map1.put(\u0026#34;java2\u0026#34;, 20); 54 Map\u0026lt;String, Integer\u0026gt; map2 = new HashMap\u0026lt;\u0026gt;(); 55 map2.put(\u0026#34;java3\u0026#34;, 10); 56 map2.put(\u0026#34;java2\u0026#34;, 222); 57 map1.putAll(map2); // putAll：把map2集合中的元素全部倒入一份到map1集合中去。 58 System.out.println(map1); 59 System.out.println(map2); 60 } 遍历 1. 先获取全部键, 再找值 1for (String key : keys) { 2 // 根据键获取对应的值 3 double value = map.get(key); 4 System.out.println(key + \u0026#34;=====\u0026gt;\u0026#34; + value); 5 } 2. 将键值对看做整体遍历 将键值对封装成一个entry对象, 然后用getKey和getValue取里面的键值.\n1\t// 1、调用Map集合提供entrySet方法，把Map集合转换成键值对类型的Set集合 2 Set\u0026lt;Map.Entry\u0026lt;String, Double\u0026gt;\u0026gt; entries = map.entrySet(); 3 for (Map.Entry\u0026lt;String, Double\u0026gt; entry : entries) { 4 String key = entry.getKey(); 5 double value = entry.getValue(); 6 System.out.println(key + \u0026#34;----\u0026gt;\u0026#34; + value); 7 } 3.Lambda遍历 1map.forEach(( k, v) -\u0026gt; { 2 System.out.println(k + \u0026#34;----\u0026gt;\u0026#34; + v); 3 }); HashMap底层原理 HashMap和HashSet底层原理一模一样, 都是基于哈希表实现, 这是因为Set系列的底层就是基于Map实现, 只是Set只需要键数据, 不需要值数据. 算位置时都是根据键算的, 每个位置放的都是一个Entry对象.\nLinkedHashMap底层原理 底层数据结构依然是基于哈希表实现的, 只是每个键值对元素又额外的多了一个双链表的机制记录元素顺序(保证有序). 实际上: 原来学习的LinkedHashSet集合的底层原理就是LinkedHashMap.\nTreeMap TreeMap跟TreeSet集合的底层原理是一样的，都是基于红黑树实现的排序。\nTreeMap 集合同样也支持两种方式来指定排序规则\n 让类实现Comparable接口，重写比较规则。 TreeMap集合有一个有参数构造器，支持创建Comparator比较器对象，以便用来指定比较规则。  Stream流 初识Stream流 使用stream()方法获得流对象, 然后filter过滤, 其中的s表示对每个列表中的元素进行过滤. 最后使用collect方法传入Collectors.toList()将其转化为列表.\n1\tpublic static void main(String[] args) { 2 List\u0026lt;String\u0026gt; names = new ArrayList\u0026lt;\u0026gt;(); 3 Collections.addAll(names, \u0026#34;张三丰\u0026#34;,\u0026#34;张无忌\u0026#34;,\u0026#34;周芷若\u0026#34;,\u0026#34;赵敏\u0026#34;,\u0026#34;张强\u0026#34;); 4 System.out.println(names); 5 // names = [张三丰, 张无忌, 周芷若, 赵敏, 张强] 6 // name 7 8 // 找出姓张，且是3个字的名字，存入到一个新集合中去。 9 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); 10 for (String name : names) { 11 if(name.startsWith(\u0026#34;张\u0026#34;) \u0026amp;\u0026amp; name.length() == 3){ 12 list.add(name); 13 } 14 } 15 System.out.println(list); 16 17 // 开始使用Stream流来解决这个需求。 18 List\u0026lt;String\u0026gt; list2 = names.stream().filter(s -\u0026gt; s.startsWith(\u0026#34;张\u0026#34;)) 19 .filter(a -\u0026gt; a.length()==3).collect(Collectors.toList()); 20 System.out.println(list2); 21 } 获取Stream流 对于List和Set, 调用stream方法即可. 对于Map, 需要分开键值对, 或者直接调用entrySet得到Entry对象的集合再使用Stream\nArrays和Stream类都提供了静态方法来创建Stream: Arrays.stream(), Stream.of().\n这里还使用了Stream的foreach方法对stream进行遍历.\n1\tpublic static void main(String[] args) { 2 // 1、如何获取List集合的Stream流？ 3 List\u0026lt;String\u0026gt; names = new ArrayList\u0026lt;\u0026gt;(); 4 Collections.addAll(names, \u0026#34;张三丰\u0026#34;,\u0026#34;张无忌\u0026#34;,\u0026#34;周芷若\u0026#34;,\u0026#34;赵敏\u0026#34;,\u0026#34;张强\u0026#34;); 5 Stream\u0026lt;String\u0026gt; stream = names.stream(); 6 7 // 2、如何获取Set集合的Stream流？ 8 Set\u0026lt;String\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); 9 Collections.addAll(set, \u0026#34;刘德华\u0026#34;,\u0026#34;张曼玉\u0026#34;,\u0026#34;蜘蛛精\u0026#34;,\u0026#34;马德\u0026#34;,\u0026#34;德玛西亚\u0026#34;); 10 Stream\u0026lt;String\u0026gt; stream1 = set.stream(); 11 stream1.filter(s -\u0026gt; s.contains(\u0026#34;德\u0026#34;)).forEach(s -\u0026gt; System.out.println(s)); 12 13 // 3、如何获取Map集合的Stream流？ 14 Map\u0026lt;String, Double\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); 15 map.put(\u0026#34;古力娜扎\u0026#34;, 172.3); 16 map.put(\u0026#34;迪丽热巴\u0026#34;, 168.3); 17 map.put(\u0026#34;马尔扎哈\u0026#34;, 166.3); 18 map.put(\u0026#34;卡尔扎巴\u0026#34;, 168.3); 19 20 Set\u0026lt;String\u0026gt; keys = map.keySet(); 21 Stream\u0026lt;String\u0026gt; ks = keys.stream(); 22 23 Collection\u0026lt;Double\u0026gt; values = map.values(); 24 Stream\u0026lt;Double\u0026gt; vs = values.stream(); 25 26 Set\u0026lt;Map.Entry\u0026lt;String, Double\u0026gt;\u0026gt; entries = map.entrySet(); 27 Stream\u0026lt;Map.Entry\u0026lt;String, Double\u0026gt;\u0026gt; kvs = entries.stream(); 28 kvs.filter(e -\u0026gt; e.getKey().contains(\u0026#34;巴\u0026#34;)) 29 .forEach(e -\u0026gt; System.out.println(e.getKey()+ \u0026#34;--\u0026gt;\u0026#34; + e.getValue())); 30 31 // 4、如何获取数组的Stream流？ 32 String[] names2 = {\u0026#34;张翠山\u0026#34;, \u0026#34;东方不败\u0026#34;, \u0026#34;唐大山\u0026#34;, \u0026#34;独孤求败\u0026#34;}; 33 Stream\u0026lt;String\u0026gt; s1 = Arrays.stream(names2); 34 Stream\u0026lt;String\u0026gt; s2 = Stream.of(names2); 35 } Stream流的中间方法 返回的也是stream, 所以支持链式编程.\n  filter: 过滤, 滤出满足条件的元素\n  sorted: 默认升序. 如果是复杂的对象需要提供比较器, 第一个大于第二个返回正数就是升序\n(对于小数创建比较器, 由于比较器返回的必须是整数, 因此使用Double.compare方法很便利)\n  limit(long maxSize): 取出前面的maxSize个元素\n  skip(long n): 跳过前面n个元素, 还剩size()-n个元素.\n  map: 映射, 将一个东西用另一个东西来表示.\n  distinct: 去重复, 内部使用hashCode和equals比较.\n  concat: 合并两个流为一个, 两个流里面的元素可以不一样, 返回object流.\n  1\tpublic static void main(String[] args) { 2 List\u0026lt;Double\u0026gt; scores = new ArrayList\u0026lt;\u0026gt;(); 3 Collections.addAll(scores, 88.5, 100.0, 60.0, 99.0, 9.5, 99.6, 25.0); 4 // 需求1：找出成绩大于等于60分的数据，并升序后，再输出。 5 scores.stream().filter(s -\u0026gt; s \u0026gt;= 60).sorted().forEach(s -\u0026gt; System.out.println(s)); 6 7 List\u0026lt;Student\u0026gt; students = new ArrayList\u0026lt;\u0026gt;(); 8 Student s1 = new Student(\u0026#34;蜘蛛精\u0026#34;, 26, 172.5); 9 Student s2 = new Student(\u0026#34;蜘蛛精\u0026#34;, 26, 172.5); 10 Student s3 = new Student(\u0026#34;紫霞\u0026#34;, 23, 167.6); 11 Student s4 = new Student(\u0026#34;白晶晶\u0026#34;, 25, 169.0); 12 Student s5 = new Student(\u0026#34;牛魔王\u0026#34;, 35, 183.3); 13 Student s6 = new Student(\u0026#34;牛夫人\u0026#34;, 34, 168.5); 14 Collections.addAll(students, s1, s2, s3, s4, s5, s6); 15 // 需求2：找出年龄大于等于23,且年龄小于等于30岁的学生，并按照年龄降序输出. 16 students.stream().filter(s -\u0026gt; s.getAge() \u0026gt;= 23 \u0026amp;\u0026amp; s.getAge() \u0026lt;= 30) 17 .sorted((o1, o2) -\u0026gt; o2.getAge() - o1.getAge()) 18 .forEach(s -\u0026gt; System.out.println(s)); 19 20 // 需求3：取出身高最高的前3名学生，并输出。 21 students.stream().sorted((o1, o2) -\u0026gt; Double.compare(o2.getHeight(), o1.getHeight())) 22 .limit(3).forEach(System.out::println); 23 System.out.println(\u0026#34;----------------------------------------------------------------\u0026#34;); 24 25 // 需求4：取出身高倒数的2名学生，并输出。 s1 s2 s3 s4 s5 s6 26 students.stream().sorted((o1, o2) -\u0026gt; Double.compare(o2.getHeight(), o1.getHeight())) 27 .skip(students.size() - 2).forEach(System.out::println); 28 29 // 需求5：找出身高超过168的学生叫什么名字，要求去除重复的名字，再输出。 30 students.stream().filter(s -\u0026gt; s.getHeight() \u0026gt; 168).map(Student::getName) 31 .distinct().forEach(System.out::println); 32 33 // distinct去重复，自定义类型的对象（希望内容一样就认为重复，重写hashCode,equals） 34 students.stream().filter(s -\u0026gt; s.getHeight() \u0026gt; 168) 35 .distinct().forEach(System.out::println); 36 37 Stream\u0026lt;String\u0026gt; st1 = Stream.of(\u0026#34;张三\u0026#34;, \u0026#34;李四\u0026#34;); 38 Stream\u0026lt;String\u0026gt; st2 = Stream.of(\u0026#34;张三2\u0026#34;, \u0026#34;李四2\u0026#34;, \u0026#34;王五\u0026#34;); 39 Stream\u0026lt;String\u0026gt; allSt = Stream.concat(st1, st2); 40 allSt.forEach(System.out::println); 41 } Stream流的终结方法  forEach: 每个进行遍历. count: 返回stream里面的元素个数. max: 返回装有最大值的一个容(Optional), 必要时提供比较器. 最后使用get()取出 min: 找最小值. 其余同上  收集Stream流  collect: 将流处理后的结果收集到一个指定的集合中 toArray: 收集到一个数组中. 默认是Object数组, 如果希望是其他类型需要显式提供  收集方式:\n Collections.toList() Collections.toSet(): 自动去重复, 去重依赖于hashCode和equals. Collections.toMap(): 需要提供键和值.  注意, 流只能使用一个, 在被收集之后就关闭了.\n1public static void main(String[] args) { 2 List\u0026lt;Student\u0026gt; students = new ArrayList\u0026lt;\u0026gt;(); 3 Student s1 = new Student(\u0026#34;蜘蛛精\u0026#34;, 26, 172.5); 4 Student s2 = new Student(\u0026#34;蜘蛛精\u0026#34;, 26, 172.5); 5 Student s3 = new Student(\u0026#34;紫霞\u0026#34;, 23, 167.6); 6 Student s4 = new Student(\u0026#34;白晶晶\u0026#34;, 25, 169.0); 7 Student s5 = new Student(\u0026#34;牛魔王\u0026#34;, 35, 183.3); 8 Student s6 = new Student(\u0026#34;牛夫人\u0026#34;, 34, 168.5); 9 Collections.addAll(students, s1, s2, s3, s4, s5, s6); 10 // 需求1：请计算出身高超过168的学生有几人。 11 long size = students.stream().filter(s -\u0026gt; s.getHeight() \u0026gt; 168).count(); 12 System.out.println(size); 13 14 // 需求2：请找出身高最高的学生对象，并输出。 15 Student s = students.stream().max((o1, o2) -\u0026gt; Double.compare(o1.getHeight(), o2.getHeight())).get(); 16 System.out.println(s); 17 18 // 需求3：请找出身高最矮的学生对象，并输出。 19 Student ss = students.stream().min((o1, o2) -\u0026gt; Double.compare(o1.getHeight(), o2.getHeight())).get(); 20 System.out.println(ss); 21 22 // 需求4：请找出身高超过170的学生对象，并放到一个新集合中去返回。 23 // 流只能收集一次。 24 List\u0026lt;Student\u0026gt; students1 = students 25 .stream() 26 .filter(a -\u0026gt; a.getHeight() \u0026gt; 170) 27 .collect(Collectors.toList()); 28 System.out.println(students1); 29 30 Set\u0026lt;Student\u0026gt; students2 = students 31 .stream() 32 .filter(a -\u0026gt; a.getHeight() \u0026gt; 170) 33 .collect(Collectors.toSet()); 34 System.out.println(students2); 35 36 // 需求5：请找出身高超过170的学生对象，并把学生对象的名字和身高，存入到一个Map集合返回。 37// Map\u0026lt;String, Double\u0026gt; map = students 38// .stream() 39// .filter(a -\u0026gt; a.getHeight() \u0026gt; 170) 40// .distinct() 41// .collect(Collectors.toMap(a -\u0026gt; a.getName(), a -\u0026gt; a.getHeight())); 42 43 Map\u0026lt;String, Student\u0026gt; map = students 44 .stream() 45 .filter(a -\u0026gt; a.getHeight() \u0026gt; 170) 46 .distinct() 47 .collect(Collectors.toMap(a -\u0026gt; a.getName(), a -\u0026gt; a)); 48 System.out.println(map); 49 50 // Object[] arr = students.stream().filter(a -\u0026gt; a.getHeight() \u0026gt; 170).toArray(); 51 // Student[] arr = students.stream().filter(a -\u0026gt; a.getHeight() \u0026gt; 170).toArray(len -\u0026gt; new Student[len]); 52 Student[] arr = students.stream().filter(a -\u0026gt; a.getHeight() \u0026gt; 170).toArray(Student[]::new); 53 System.out.println(Arrays.toString(arr)); 54 } 我感觉stream编程里面很多都可以使用方法引用, 这时Lambda表达式都多余了. Lambda表达式里面的变量随便设置.\nJava高级 反射 获取类的字节码: Class对象  静态方法: 类名.class 调用Class的方法forName, 填入类的名称 调用Object类的方法getClass, 需要现有这个类的对象, 然后: 对象.getClass()  一个类的Class对象只有一个, 不同方式获取的Class对象指向的是同一地址.\n1\tpublic static void main(String[] args) throws Exception { 2 Class c1 = Student.class; 3 System.out.println(c1.getName()); // 全类名 4 System.out.println(c1.getSimpleName()); // 简名：Student 5 6 Class c2 = Class.forName(\u0026#34;com.itheima.d2_reflect.Student\u0026#34;); 7 System.out.println(c1 == c2); 8 9 Student s = new Student(); 10 Class c3 = s.getClass(); 11 System.out.println(c3 == c2); 12 } 由Class获取类的构造器并初始化对象 属于Class类的方法:\n getConstructors: 获取全部构造器(只能获取public修饰的) getDeclaredConstructors: 获取全部构造器(只要存在就能拿到) getConstructor(Class\u0026lt;?\u0026gt;): 获取某个构造器(只能获取public修饰的), 需要时填入对应方法对应参数的字节码. getDeclaredConstructor(Class\u0026lt;?\u0026gt;): 获取某个构造器(只要存在就能拿到), 需要时填入对应方法对应参数的字节码.  一般就用getDeclaredConstructor(s), 都可以得到.\n获取类的构造器的作用是初始化一个对象返回, 下面的Constructor对象的方法:\n T newInstance(Object\u0026hellip; initargs): 调用构造器, 传入对应需要的参数, 完成对象初始化并返回. setAccessible(boolean): 设置为true, 表示禁止检查访问控制(暴力反射)  构造器有个泛型, 不指定的话返回的都是Object类, 需要强转.\n1@Test 2 public void testGetConstructors(){ 3 // 1、反射第一步：必须先得到这个类的Class对象 4 Class c = Cat.class; 5 // 2、获取类的全部构造器 6 // Constructor[] constructors = c.getConstructors(); 7 Constructor[] constructors = c.getDeclaredConstructors(); 8 // 3、遍历数组中的每个构造器对象 9 for (Constructor constructor : constructors) { 10 System.out.println(constructor.getName() + \u0026#34;---\u0026gt;\u0026#34; 11 + constructor.getParameterCount()); 12 } 13 } 14 15 @Test 16 public void testGetConstructor() throws Exception { 17 // 1、反射第一步：必须先得到这个类的Class对象 18 Class c = Cat.class; 19 // 2、获取类的某个构造器：无参数构造器 20 Constructor constructor1 = c.getDeclaredConstructor(); 21 System.out.println(constructor1.getName() + \u0026#34;---\u0026gt;\u0026#34; 22 + constructor1.getParameterCount()); 23 constructor1.setAccessible(true); // 禁止检查访问权限 24 Cat cat = (Cat) constructor1.newInstance(); 25 System.out.println(cat); 26 27 AtomicInteger a; 28 29 30 // 3、获取有参数构造器 31 Constructor constructor2 = 32 c.getDeclaredConstructor(String.class, int.class); 33 System.out.println(constructor2.getName() + \u0026#34;---\u0026gt;\u0026#34; 34 + constructor2.getParameterCount()); 35 constructor2.setAccessible(true); // 禁止检查访问权限 36 Cat cat2 = (Cat) constructor2.newInstance(\u0026#34;叮当猫\u0026#34;, 3); 37 System.out.println(cat2); 38 39 } 由Class获取类的成员变量并赋值和取值 属于Class类的方法:\n Field[] getFields(): 获取类的全部成员变量(只能获取public修饰的) Field[] getDeclaredFields(): 获取类的全部成员变量(只要存在就能拿到) Field getField(String name): 获取类的某个成员变量(只能获取public修饰的) Field getDeclaredField(String name): 获取类的某个成员变量(只要存在就能拿到)  获取成员变量是用来赋值和取值, 下面的方法Field对象的\n set(Object obj, Object value): 赋值, 第一个参数是对象实例, 第二个是赋值的内容 get(Object obj): 取值, 传入对应对象. setAccessible: 设置禁止检查访问控制  1\t@Test 2 public void testGetFields() throws Exception { 3 // 1、反射第一步：必须是先得到类的Class对象 4 Class c = Cat.class; 5 // 2、获取类的全部成员变量。 6 Field[] fields = c.getDeclaredFields(); 7 // 3、遍历这个成员变量数组 8 for (Field field : fields) { 9 System.out.println(field.getName() + \u0026#34;---\u0026gt; \u0026#34;+ field.getType()); 10 } 11 // 4、定位某个成员变量 12 Field fName = c.getDeclaredField(\u0026#34;name\u0026#34;); 13 System.out.println(fName.getName() + \u0026#34;---\u0026gt;\u0026#34; + fName.getType()); 14 15 Field fAge = c.getDeclaredField(\u0026#34;age\u0026#34;); 16 System.out.println(fAge.getName() + \u0026#34;---\u0026gt;\u0026#34; + fAge.getType()); 17 18 // 赋值 19 Cat cat = new Cat(); 20 fName.setAccessible(true); // 禁止访问控制权限 21 fName.set(cat, \u0026#34;卡菲猫\u0026#34;); 22 System.out.println(cat); 23 24 // 取值 25 String name = (String) fName.get(cat); 26 System.out.println(name); 27 } 由Class获取类的成员方法并 属于Class类的方法:\n Method[] getMethods(): 获取类的全部成员方法(只能获取public修饰的) Method[] getDeclaredMethods(): 获取类的全部成员方法(只要存在) Method[] getMethod(String name, Class\u0026lt;?\u0026gt;\u0026hellip; ): 获取类的某个成员方法(只能获取public修饰的), 第一个参数是方法名. 对于某些方法重载, 需要填入参数的字节码对象才能定位. Method[] getDeclaredMethod(String name, Class\u0026lt;?\u0026gt;\u0026hellip; ): 获取类的某个成员方法(只要存在), 第一个参数是方法名. 对于某些方法重载, 需要填入参数的字节码对象才能定位.  获取类的成员方法是执行方法, 下面是Method类的方法:\n Object invoke(Object, Object\u0026hellip; args): 触发某个对象该方法的执行. 第一个参数是对象实例. setAccessible: 设置禁止检查访问控制  1\t@Test 2 public void testGetMethods() throws Exception { 3 // 1、反射第一步：先得到Class对象。 4 Class c = Cat.class; 5 // 2、获取类的全部成员方法。 6 Method[] methods = c.getDeclaredMethods(); 7 // 3、遍历这个数组中的每个方法对象 8 for (Method method : methods) { 9 System.out.println(method.getName() + \u0026#34;---\u0026gt;\u0026#34; 10 + method.getParameterCount() + \u0026#34;----\u0026gt;\u0026#34; 11 + method.getReturnType()); 12 } 13 // 4、获取某个方法对象 14 Method run = c.getDeclaredMethod(\u0026#34;run\u0026#34;); // 拿run方法，无参数的 15 System.out.println(run.getName() + \u0026#34;---\u0026gt;\u0026#34; 16 + run.getParameterCount() + \u0026#34;----\u0026gt;\u0026#34; 17 + run.getReturnType()); 18 19 Method eat = c.getDeclaredMethod(\u0026#34;eat\u0026#34;, String.class); 20 System.out.println(eat.getName() + \u0026#34;---\u0026gt;\u0026#34; 21 + eat.getParameterCount() + \u0026#34;----\u0026gt;\u0026#34; 22 + eat.getReturnType()); 23 24 Cat cat = new Cat(); 25 run.setAccessible(true); // 禁止检查访问权限 26 Object rs = run.invoke(cat); // 调用无参数的run方法，用cat对象触发调用的。 27 System.out.println(rs); 28 29 eat.setAccessible(true); // 禁止检查访问权限 30 String rs2 = (String) eat.invoke(cat, \u0026#34;鱼儿\u0026#34;); 31 System.out.println(rs2); 32 } 都有setAccessible是因为Constructor, Field, Method类的父类都有AccessibleObject, 里面就有setAccessible.\n作用, 应用场景  得到一个类的全部成分然后操作 可以破坏封装性 适合做Java的框架, 基于反射设计通用的功能.  需求: 将对象的字段名和对应的值都保存到文件中\n1\t// 目标：保存任意对象的字段和其数据到文件中去 2 public static void saveObject(Object obj) throws Exception { 3 PrintStream ps = new PrintStream(new FileOutputStream(\u0026#34;junit-reflect-annotation-proxy-app\\\\src\\\\data.txt\u0026#34;, true)); 4 // obj是任意对象，到底有多少个字段要保存。 5 Class c = obj.getClass(); 6 String cName = c.getSimpleName(); 7 ps.println(\u0026#34;---------------\u0026#34; + cName + \u0026#34;------------------------\u0026#34;); 8 // 2、从这个类中提取它的全部成员变量 9 Field[] fields = c.getDeclaredFields(); 10 // 3、遍历每个成员变量。 11 for (Field field : fields) { 12 // 4、拿到成员变量的名字 13 String name = field.getName(); 14 // 5、拿到这个成员变量在对象中的数据。 15 field.setAccessible(true); // 禁止检查访问控制 16 String value = field.get(obj) + \u0026#34;\u0026#34;; 17 ps.println(name + \u0026#34;=\u0026#34; + value); 18 } 19 ps.close(); 20 } 注解 让别的程序根据注解信息决定怎么执行该程序\n自定义注解 1public @interface 注解名称{ 2\tpublic 属性类型 属性名() default 默认值; 3} 比如:\n1public @interface MyTest1 { 2 String aaa(); 3 boolean bbb() default true; 4 String[] ccc(); 5} 在其他类使用注解时, 需要添加上这些属性的值:\n1@MyTest1(aaa=\u0026#34;牛魔王\u0026#34;, ccc={\u0026#34;HTML\u0026#34;, \u0026#34;Java\u0026#34;}) 2// @MyTest2(value = \u0026#34;孙悟空\u0026#34;) 3//@MyTest2(\u0026#34;孙悟空\u0026#34;) 4//@MyTest2(value = \u0026#34;孙悟空\u0026#34;, age = 1000) 5@MyTest2(\u0026#34;孙悟空\u0026#34;) 6public class AnnotationTest1 { 7 @MyTest1(aaa=\u0026#34;铁扇公主\u0026#34;, bbb=false, ccc={\u0026#34;Python\u0026#34;, \u0026#34;前端\u0026#34;, \u0026#34;Java\u0026#34;}) 8 public void test1(){ 9 10 } 11 12 public static void main(String[] args) { 13 14 } 15} 注意: value属性, 如果只有一个value属性的情况下, 使用value属性的时候可以省略value名称不写!! l但是如果有多个属性, 且多个属性没有默认值, 那么value名称是不能省略的.\n1public @interface MyTest2 { 2 String value(); // 特殊属性 3 int age() default 23; 4} 注解的原理 注解本质是一个接口, Java中所有注解都是继承了Annotation接口的, 而@注解其实就是一个实现类对象, 实现了该注解以及Annotaion接口.\n上面的MyTest1注解经过编译后变成了:\n1public interface MyTest1 extends Annotaion{ 2\tpublic abstract String aaa(); 3\tpublic abstract boolean bbb(); 4\tpublic abstract String[] ccc(); 5} 元注解 修饰注解的注解\n@Target注解: 声明被修饰的注解只能在哪些位置使用\n TYPE: 类, 接口 FIELD: 成员变量 METHOD: 成员方法 PARAMETER: 方法参数 CONSTRUCTOR: 构造器 LOCAL_VARIABLE: 局部变量  如@Target(ElementType.TYPE)就只能用在类或接口上, 其余的都不行.\n@Retention: 声明注解的保留周期\n SOURCE: 只作用在源码阶段, 字节码文件中不存在 CLASS(默认): 保留到字节码文件阶段, 运行阶段不存在 RUNTIME(开发常用): 一直保留到运行阶段  如@Retention(RetentionPolicy.RUNTIME)代码修饰的这个注解运行时也能看到.\n1@Target({ElementType.TYPE, ElementType.METHOD}) // 当前被修饰的注解只能用在类上，方法上。 2@Retention(RetentionPolicy.RUNTIME) // 控制下面的注解一直保留到运行时 3public @interface MyTest3 { 4} 1@MyTest3 2public class AnnotationTest2 { 3 4 // @MyTest3 5 private String name; 6 7 @MyTest3 8 public void test(){ 9 10 } 11} 注解的解析 判断类上, 方法上, 成员变量上等地方是否存在注解, 并将注解的内容解析出来.\n要解析谁上面的注解, 就应先把谁拿到; 解析类上的先拿Class对象, 解析方法上的拿Method对象.\nClass, Method, Field, Constructor都实现了AnnotatedElement接口, 它们都有解析注解的能力.\n Annotaion[] getDeclaredAnnotaions(): 获取当前对象上的注解 T getDeclaredAnnotaion(Class\u0026lt;T\u0026gt; annotaionClass): 获取指定的注解对象 boolean isAnnotaionPresent(Class\u0026lt;Annotaion\u0026gt; annotaionClass): 判断某个对象上是否存在某个注解  1@Test 2 public void parseClass(){ 3 // 1、先得到Class对象 4 Class c = Demo.class; 5 // 2、解析类上的注解 6 // 判断类上是否包含了某个注解 7 if(c.isAnnotationPresent(MyTest4.class)){ 8 MyTest4 myTest4 = 9 (MyTest4) c.getDeclaredAnnotation(MyTest4.class); 10 System.out.println(myTest4.value()); 11 System.out.println(myTest4.aaa()); 12 System.out.println(Arrays.toString(myTest4.bbb())); 13 } 14 } 15 16 @Test 17 public void parseMethod() throws Exception { 18 // 1、先得到Class对象 19 Class c = Demo.class; 20 Method m = c.getDeclaredMethod(\u0026#34;test1\u0026#34;); 21 // 2、解析方法上的注解 22 // 判断方法对象上是否包含了某个注解 23 if(m.isAnnotationPresent(MyTest4.class)){ 24 MyTest4 myTest4 = 25 (MyTest4) m.getDeclaredAnnotation(MyTest4.class); 26 System.out.println(myTest4.value()); 27 System.out.println(myTest4.aaa()); 28 System.out.println(Arrays.toString(myTest4.bbb())); 29 } 30 } 模拟junit 注解就是标记程序, 让其他程序根据注解信息决定如何对待它们.\n1public class AnnotationTest4 { 2 // @MyTest 3 public void test1(){ 4 System.out.println(\u0026#34;===test1====\u0026#34;); 5 } 6 7 @MyTest 8 public void test2(){ 9 System.out.println(\u0026#34;===test2====\u0026#34;); 10 } 11 12 @MyTest 13 public void test3(){ 14 System.out.println(\u0026#34;===test3====\u0026#34;); 15 } 16 17 @MyTest 18 public void test4(){ 19 System.out.println(\u0026#34;===test4====\u0026#34;); 20 } 21 22 public static void main(String[] args) throws Exception { 23 AnnotationTest4 a = new AnnotationTest4(); 24 // 启动程序！ 25 // 1、得到Class对象 26 Class c = AnnotationTest4.class; 27 // 2、提取这个类中的全部成员方法 28 Method[] methods = c.getDeclaredMethods(); 29 // 3、遍历这个数组中的每个方法，看方法上是否存在@MyTest注解，存在 30 // 触发该方法执行。 31 for (Method method : methods) { 32 if(method.isAnnotationPresent(MyTest.class)){ 33 // 说明当前方法上是存在@MyTest，触发当前方法执行。 34 method.invoke(a); 35 } 36 } 37 } 38} 动态代理 对象嫌身上干的事太多的话, 可以通过代理转义部分职责\n对象有什么方法想被代理. 代理一定要有对应的方法.\n规范: 对象想被代理需创建一个对应的接口, 并实现这个接口. 之后代理方法返回的就是这个接口\n首先通过Proxy.newProxyInstance创建一个代理对象, 该方法有三个参数. 第三个参数是一个回调函数, 之后之后代理对象完成原本对象方法时会先进入这个回调方法, 我们就在这个回调方法里面做功能添加. 原本方法会返回值就return出去.\n创建代理对象的方法:\n1public class ProxyUtil { 2 public static Star createProxy(BigStar bigStar){ 3 /* newProxyInstance(ClassLoader loader, 4Class\u0026lt;?\u0026gt;[] interfaces, 5InvocationHandler h) 6参数1：用于指定一个类加载器 7参数2：指定生成的代理长什么样子，也就是有哪些方法 8参数3：用来指定生成的代理对象要干什么事情 9*/ 10 // Star starProxy = ProxyUtil.createProxy(s); 11 // starProxy.sing(\u0026#34;好日子\u0026#34;) starProxy.dance() 12 Star starProxy = (Star) Proxy.newProxyInstance(ProxyUtil.class.getClassLoader(), 13 new Class[]{Star.class}, new InvocationHandler() { 14 @Override // 回调方法 15 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { 16 // 代理对象要做的事情，会在这里写代码 17 if(method.getName().equals(\u0026#34;sing\u0026#34;)){ 18 System.out.println(\u0026#34;准备话筒，收钱20万\u0026#34;); 19 }else if(method.getName().equals(\u0026#34;dance\u0026#34;)){ 20 System.out.println(\u0026#34;准备场地，收钱1000万\u0026#34;); 21 } 22 return method.invoke(bigStar, args); 23 } 24 }); 25 return starProxy; 26 } 27} 实体类\n1public class BigStar implements Star{ 2 private String name; 3 4 public BigStar(String name) { 5 this.name = name; 6 } 7 8 public String sing(String name){ 9 System.out.println(this.name + \u0026#34;正在唱：\u0026#34; + name); 10 return \u0026#34;谢谢！谢谢！\u0026#34;; 11 } 12 13 public void dance(){ 14 System.out.println(this.name + \u0026#34;正在优美的跳舞~~\u0026#34;); 15 } 16} 测试\n1public class Test { 2 public static void main(String[] args) { 3 BigStar s = new BigStar(\u0026#34;杨超越\u0026#34;); 4 Star starProxy = ProxyUtil.createProxy(s); 5 6 String rs = starProxy.sing(\u0026#34;好日子\u0026#34;); 7 System.out.println(rs); 8 9 starProxy.dance(); 10 } 11} 应用: 利用代理模式实现AOP, 测试方法耗时.\n1public static UserService createProxy(UserService userService){ 2 UserService userServiceProxy = (UserService) Proxy.newProxyInstance(ProxyUtil.class.getClassLoader(), 3 new Class[]{UserService.class}, new InvocationHandler() { 4 @Override 5 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { 6 7 if(method.getName().equals(\u0026#34;login\u0026#34;) || method.getName().equals(\u0026#34;deleteUsers\u0026#34;)|| 8 method.getName().equals(\u0026#34;selectUsers\u0026#34;)){ 9 long startTime = System.currentTimeMillis(); 10 11 Object rs = method.invoke(userService, args); 12 13 long endTime = System.currentTimeMillis(); 14 System.out.println(method.getName() + \u0026#34;方法执行耗时：\u0026#34; + (endTime - startTime)/ 1000.0 + \u0026#34;s\u0026#34;); 15 return rs; 16 }else { 17 Object rs = method.invoke(userService, args); 18 return rs; 19 } 20 } 21 }); 22 return userServiceProxy; 23 } ","date":"2024-06-13","permalink":"/posts/tech/java-4-basic/","series":["Java"],"tags":["","",""],"title":"Java基础查漏补缺"},{"categories":["计算机"],"content":"SQL语法 DDL DDL 数据库操作 1SHOW DATABASES; -- 查询所有数据库 2SELECT DATABASE(); -- 查询当前数据库 3CREATE DATABASE IF NOT EXISTS learndatabase DEFAULT CHARSET utf8mb4; -- 创建数据库 4USE learndatabase; -- 使用数据库 5DROP DATABASE IF EXISTS learndatabase; -- 删除数据库 DDL 表结构 1SHOW TABLES; -- 查询数据库所有的表 2DESC tableName; -- 查询表结构 3SHOW CREATE TABLE tableName; -- 查询表的建表语句 4 5CREATE TABLE tableName( -- 创建表 6 id INT COMMENT \u0026#39;编号\u0026#39;, 7 name VARCHAR(50) COMMENT \u0026#39;姓名\u0026#39;, 8 age INT COMMENT \u0026#39;年龄\u0026#39;, 9 gender VARCHAR(1) COMMENT \u0026#39;性别\u0026#39; 10) COMMENT \u0026#39;用户表\u0026#39;; 11 12ALTER TABLE tableName ADD nickname VARCHAR(20) COMMENT \u0026#39;昵称\u0026#39;; -- 修改表,添加字段 13alter table tb add date DATE comment \u0026#39;入职日期\u0026#39;; 14ALTER TABLE tableName CHANGE nickname username VARCHAR(30) COMMENT \u0026#39;用户名\u0026#39;; -- 修改字段名,同时修改字段类型 15ALTER TABLE tableName MODIFY username CHAR(30); -- 修改数据类型 16ALTER TABLE tableName DROP username; -- 删除字段username 17 18ALTER TABLE tableName RENAME TO tb; -- 修改表名 19 20DROP TABLE IF EXISTS tableName; -- 删除表 21TRUNCATE TABLE tableName; -- 删除表,重新创建该表;其实就是清空数据 数据类型 三大类:数值,字符串,日期.\n TINYINT 1byte 取值在-128,127,无符号在0,255. 于是age字段就可以这样: age TINYINT UNSIGNED DOUBLE(4,1) 最长4为,允许出现1位小数 于是成绩字段score DOUBLE(4,1) CHAR 定长字符串,性能高,没有的部分用空格填补,适合用变化不大的字段,如gender CHAR(1) VARCHAR 变长字符串,对于字符串长度变化很大的字段比较适合,如 username VARCHAR(50) DATE是年月日 TIME是时分秒 YEAR就是年; DATETIME是年月日时分秒, birthday DATE TIMESTAMP也是年月日时分秒,但是最大范围是2038年  DML DML 数据操作语言INSERT UPDATE DELETE\nDML INSERT 添加字符串,日期要加引号; 数据范围要符合要求\n1-- 选择字段插入 2INSERT INTO tb(id, name, age, gender, username, date) VALUES (1, \u0026#39;赵四\u0026#39;, 13, \u0026#39;男\u0026#39;, \u0026#39;四娘\u0026#39;, \u0026#39;2001-05-28\u0026#39;); 3-- 全部字段插入 4insert into tb values (1, \u0026#39;张三\u0026#39;, 15, \u0026#39;女\u0026#39;, \u0026#39;三爹\u0026#39;, \u0026#39;2005-05-05\u0026#39;); 5-- 插入多条数据 6insert into tb values (3, \u0026#39;王五\u0026#39;, 29, \u0026#39;女\u0026#39;, \u0026#39;五爹\u0026#39;, \u0026#39;1998-12-15\u0026#39;),(4, \u0026#39;李四\u0026#39;, 30, \u0026#39;男\u0026#39;, \u0026#39;四爹\u0026#39;, \u0026#39;1970-01-30\u0026#39;); DML UPDATE 1-- 修改 2update tb set date=\u0026#39;2010-09-01\u0026#39; where name=\u0026#39;赵四\u0026#39;; 3update tb set id=2, date=\u0026#39;2001-05-28\u0026#39; where username=\u0026#39;三爹\u0026#39;; 4-- 没有加where, 改所有数据 5update tb set date=\u0026#39;2000-01-01\u0026#39; DML DELETE 1-- 删除 2delete from tb where id=1 and name=\u0026#39;赵四\u0026#39;; 3-- 删除索引 4delete from tb; DQL DQL 数据查询语言\n select 字段列表 from 表名列表 where 条件列表 group by 分组字段列表 having 分组后的条件列表 order by 排序字段列表 limit 分页参数  1-- 查询多个字段 2select id, name from tb; 3-- 查询所有, 写*效率不高,最好写出所有字段,清晰明了 4select * from tb; 5-- 设置别名 6select id as \u0026#39;爱迪\u0026#39;, name as \u0026#39;姓名\u0026#39; from tb; 7-- 查询去重 8select distinct * from tb; 条件查询  \u0026gt;=, \u0026lt;, \u0026lt;= , = , !=(\u0026lt;\u0026gt;), between and, in, like(_单个字符,%任意字符), is null  1-- and or not, \u0026amp;\u0026amp; || ! 2select * from tb where age = 13; 3select * from tb where age \u0026lt; 20; 4select * from tb where age \u0026lt;= 20; 5select * from tb where username is null ; -- 查询没有username字段的数据 6select * from tb where username is not null ; -- 查询有username字段的数据 7select * from tb where age != 13; 8select * from tb where age \u0026lt;\u0026gt; 13; 9select * from tb where age \u0026lt;= 20 \u0026amp;\u0026amp; age \u0026gt;= 10; 10select * from tb where age \u0026lt;= 20 and age \u0026gt;= 10; 11select * from tb where age between 10 and 20; -- between and 包括最大值和最小值 12select * from tb where age=10 or age=13 or age=20; 13select * from tb where age in(10,13,20); -- age在in里面的数其一即可 14select * from tb where name like \u0026#39;__\u0026#39;; -- 查询姓名只有两个字符的数据 15select * from tb where username like \u0026#39;%x\u0026#39;; -- 查询username最后一位是x的数据 聚合函数 聚合函数,将一列数据作为整体, 纵向计算\ncount-数量, max min, avg-平均值, sum-求和\n1-- 聚合函数不计算null值 2select sum(age) from tb; 3select count(1) from tb; 4select count(*) from tb; 5select avg(age) from tb; 6select max(age) from tb; 7select sum(age) from tb where id=1; 分组查询 分组查询 group by, 分组之后一般查询分组字段和聚合函数, 其他的无意义\n1select gender, count(*) from tb group by gender; -- 根据性别分组,分组后统计数量,相当于对每个组分别处理 2select gender, avg(age) from tb group by gender; -- 性别分组,统计男女的平均年龄 3 4-- where在分组前进行过滤, having在分组后过滤,having可以对聚合函数过滤,where不行. 5-- 虽然组合在一起的sql语句很麻烦,但是一步一步地加条件来看,就不麻烦了,sql就是在简单查询结果基础上一步一步处理的. 6-- 先where得到有条件的表,然后group by得到两行分组后的数据,最后对这两行数据进行having筛选. 7select gender, count(*) from tb where age\u0026lt;= 30 and age \u0026gt;= 10 group by gender having count(*) \u0026gt; 2; 8-- 给聚合起别名 9select gender, count(*) as gender_count from tb where age\u0026lt;= 30 and age \u0026gt;= 10 group by gender having gender_count \u0026gt; 2; 排序查询 排序查询 order by\norder by多字段,当第一个字段相同则按照第二个字段排序, asc升序 desc降序\n1select * from tb order by age asc; 2select * from tb order by age desc; 3select * from tb order by date desc; 4-- 先按照age升序,age相同再按照date降序排序 5select * from tb order by age asc ,date desc; 分页查询 1-- 分页查询 limit 起始索引,查询记录数 2-- 起始索引从0开始, 起始索引=(查询页码-1)*每页记录数 3-- 如果是第一页数据,可以省略 4select * from tb limit 0, 2; 5select * from tb limit 2, 3; DQL执行顺序:\n编写顺序: select from where group by having order by limit\n执行顺序: from where group by having select order by limit\nDCL DCL 数据控制语言 管理用户,控制访问\nDCL 管理用户 1-- 查询用户 2use mysql; 3select * from user; 4-- 创建用户 用户名@主机名 后面是密码,创建的用户没有权限 5-- 创建用户bnaod,只能在当前主机访问,密码password 6create user \u0026#39;bnaod\u0026#39;@\u0026#39;localhost\u0026#39; identified by \u0026#39;password\u0026#39;; 7-- 创建用户,在任意主机访问 8create user \u0026#39;bnaod\u0026#39;@\u0026#39;%\u0026#39; identified by \u0026#39;password\u0026#39;; 9-- 修改用户密码 10alter user \u0026#39;bnaod\u0026#39;@\u0026#39;localhost\u0026#39; identified with mysql_native_password by \u0026#39;newpassword\u0026#39;; 11-- 删除用户 12drop user \u0026#39;bnaod\u0026#39;@\u0026#39;localhost\u0026#39;; DCL 权限控制 1-- 查询权限 2show grants for \u0026#39;bnaod\u0026#39;@\u0026#39;localhost\u0026#39;; 3-- 授予权限 on后接数据库名.表名 *代替全部 如*.*表示所有数据库的所有表 后面是用户 4grant all on learndatabase.* to \u0026#39;bnaod\u0026#39;@\u0026#39;localhost\u0026#39;; 5-- 撤销权限 6revoke all on learndatabase.* from \u0026#39;bnaod\u0026#39;@\u0026#39;localhost\u0026#39;; 函数 字符串函数  concat字符串拼接函数, lower转小写, upper转大写\\ lpad(str,n,pad) 左填充,用字符串pad对str左边填充,达到n长度 rpad(str,n,pad) 右填充,用字符串pad对str右边填充,达到n长度 trim 去掉字符串头部和尾部的空格 substring(str,start,len)返回字符串str从start位置起的len个长度的字符串  1select concat(\u0026#39;hello\u0026#39;, \u0026#39; mysql\u0026#39;); 2select lower(\u0026#39;HEllo\u0026#39;); 3select upper(\u0026#39;HEllo\u0026#39;); 4select lpad(\u0026#39;01\u0026#39;, 5, \u0026#39;@\u0026#39;); 5select rpad(\u0026#39;01\u0026#39;, 5, \u0026#39;@\u0026#39;); 6select trim(\u0026#39; HELLO MYSQL \u0026#39;); 7select substring(\u0026#39;HELLO,MYSQL\u0026#39;, 1, 5); -- 这个不是字符串下标,就是单纯的第一个 8-- 将编号补成5位数,如1-\u0026gt;00001 9select lpad(id, 5, \u0026#39;0\u0026#39;) from tb; 数值函数  ceil(x) 向上取整 floor(x) 向下取整 mod(x,y) 返回x/y的模 rand() 返回0~1的随机数 round(x,y) 对x四舍五入,保留y位小数  1select ceil(1.1); 2select floor(1.1); 3select mod(3,4); 4select mod(4,4); 5select rand(); 6select round(pi(), 7); 7-- 生成6位随机验证码 8select lpad(1000000 * round(rand(),6), 6, \u0026#39;0\u0026#39;); 日期函数  curdate() 当前日期 curtime() 当前时间 now() 当前日期+时间 year(date) 取得date的年 month(date) 取得date的月 day(date) 取得date的日 date_add(date, INTERVAL expr type) 返回日期/时间加上一个时间间隔expr后的时间值 datediff(date1, date2) 返回结束date1和起始date2之间的天数(day)  1select curdate(); 2select curtime(); 3select now(); 4select year(now()); 5select year(date) from tb; 6select month(date) from tb; 7select day(date) from tb; 8select date_add(now(), INTERVAL 70 DAY ); 9select date_add(now(), INTERVAL 70 MONTH ); 10select date_add(now(), INTERVAL 70 YEAR ); 11select datediff(now(), \u0026#39;2001-05-28\u0026#39;); 12select datediff(now(), \u0026#39;1992-08-17\u0026#39;); 13-- 员工入职天数降序排列 14select datediff(now(), date) as jointime from tb order by jointime desc ; 流程控制函数  if(value, t, f) ifnull(value1, value2) 如果value1不为空返回value1,否则返回value2 case when [val1] then [res1] else [default] end 如果val1为true,返回res1,\u0026hellip;,否则返回default 这个相对于if elseif结构 case [expr] when [val1] then [res1] else [default] end 如果expr等于val1返回res1,\u0026hellip;.,否则返回default 这个相对于switch结构  1select if(true, \u0026#39;ok\u0026#39;, \u0026#39;error\u0026#39;); 2select if(false, \u0026#39;ok\u0026#39;, \u0026#39;error\u0026#39;); 3 4select ifnull(\u0026#39;ok\u0026#39;, \u0026#39;default\u0026#39;); 5select ifnull(\u0026#39;\u0026#39;, \u0026#39;default\u0026#39;); 6select ifnull(null, \u0026#39;default\u0026#39;); 7 8select case when true then \u0026#39;res1\u0026#39; else \u0026#39;default\u0026#39; end; 9 10-- 查询员工年龄,如果大于50就显示老毕登, 如果大于15就显示中壁灯, 如果小于15就显示小壁灯 11select id, 12 name, 13 (case when age\u0026gt;=50 then \u0026#39;老毕登\u0026#39; when age\u0026gt;=15 then\u0026#39;中壁灯\u0026#39; else \u0026#39;小壁灯\u0026#39; end) as nickname 14from tb ; 约束 这些东西idea可以直接图像界面改动.\n 非空约束 不能为null NOT NULL 唯一约束 数据是唯一的 UNIQUE 主键约束 一行数据唯一标识,要求非空且唯一 PRIMARY KEY 默认约束 未指定该字段的值,则采用默认值 DEFAULT 检查约束 保证字段满足一个条件 CHECK 外键约束 用来建立两个表的连接 FOREIGN KEY  1create table user( 2 id int primary key auto_increment, -- 主键,且自动增长 3 name varchar(10) not null unique , -- 不为null,唯一 4 age int check ( age \u0026gt; 0 and age \u0026lt;= 120 ), -- 年龄在0到120之间 5 status char(1) default \u0026#39;1\u0026#39;, -- 默认为1 6 gender char(1) 7) comment \u0026#39;user table\u0026#39; 8 9desc user; 10 11insert into user(name, age, status, gender) values (\u0026#39;tom1\u0026#39;, 19, \u0026#39;1\u0026#39;, \u0026#39;男\u0026#39;), (\u0026#39;tom2\u0026#39;, 31, \u0026#39;0\u0026#39;, \u0026#39;男\u0026#39;); 12insert into user(name, age, status, gender) values (null, 20,\u0026#39;1\u0026#39;,\u0026#39;女\u0026#39;); 13insert into user(name, age, status, gender) values (\u0026#39;tom1\u0026#39;, 20,\u0026#39;1\u0026#39;,\u0026#39;女\u0026#39;); 14insert into user(name, age, status, gender) values (\u0026#39;tom3\u0026#39;, -1,\u0026#39;1\u0026#39;,\u0026#39;女\u0026#39;); 15insert into user(name, age, gender) values (\u0026#39;tom3\u0026#39;, 23,\u0026#39;女\u0026#39;); 外键 有外键的是子表,关联的是父表, 建立外键保证数据的一致性和完整性.\n1-- 准备 2create table dept( 3 id int auto_increment primary key , 4 name varchar(50) not null 5); 6insert into dept(id, name) VALUES (1,\u0026#39;研发部\u0026#39;),(2,\u0026#39;市场部\u0026#39;),(3,\u0026#39;财务部\u0026#39;),(4,\u0026#39;销售部\u0026#39;),(5,\u0026#39;总经办\u0026#39;); 7alter table user add dept_id int; 8alter table user add manager_id int; 9insert into user(id, name, age, status, gender, dept_id) values (null, \u0026#39;jerry2\u0026#39;, 73, \u0026#39;0\u0026#39;, \u0026#39;女\u0026#39;, null); 10 11-- 添加外键.在创建表时额外添加一行, 也可以额外修改 12-- constraint [外键名称] foreign key (外键字段名) references 主表(主表列名) 13alter table user add constraint fk_user_dept_id foreign key (dept_id) references dept(id); 14-- 这样父表的字段不能直接删除,因为有子表外键关联 15-- 删除外键 16-- alter table 表名 drop foreign key 外键名称; 17alter table user drop foreign key fk_user_dept_id; 删除更新行为  no action/restrict 父表中有更新和删除行为,检测有对应外键,有就不允许删除/更新 cascade 父表删除/更新,有外键,那么也会删除/更新在子表的记录 set null 父表删除,有外键的话,将子表的值设置为null(要求该外键可以为null) set default 父表数据变成,子表将外键设置默认值(innodb不支持)  1-- constraint [外键名称] foreign key (外键字段名) references 主表(主表列名) on update cascade on delete cascade 2-- on update在更新时要进行的行为,on delete在删除时要进行的行为 3alter table user add constraint fk_user_dept_id foreign key (dept_id) references dept(id) on update cascade on delete cascade; 4alter table user add constraint fk_user_dept_id foreign key (dept_id) references dept(id) on update set null on delete set null ; 多表查询 一对多,就是一个外键\n多对多,需要维护一个中间表,两个外键\n一对一,用作单表拆分,维护一个外键,而且该外键字段需要设置unique,保证它是一对一.\n1-- 进行笛卡尔积, 组合的所有情况 2select * from user,dept; 3-- 消除笛卡尔积, 加一个条件, 这里没有外键也可以 4select * from user,dept where dept_id = dept.id; 连接查询   内连接:查询AB交集\n1-- 隐式内连接 2-- select 字段列表 from 表1,表2 where 条件; 3-- 显示内连接 4-- select 字段列表 from 表1 inner join 表2 on 连接条件; 5-- 查询员工姓名,关联的部门 6select user.name, dept.name from user, dept where user.dept_id=dept.id; -- 隐式内连接 7select u.name, d.name from user u, dept d where u.dept_id=d.id; -- 取别名 8select u.name, d.name from user u inner join dept d on u.dept_id=d.id; -- 显式内连接   左外连接:查询左表的所有数据,包括AB交集\n  右外连接:查询右表的所有数据,包括AB交集\n1-- 左外连接 完全包含左表(即便没有外键值),还有交集 2-- select 字段列表 from 表1 left [outer] join 表2 on 条件; 3-- 右外连接 完全包含右表(即便没有外键值),还有交集 4-- select 字段列表 from 表1 right [outer] join 表2 on 条件; 5select u.*, d.name from user u left outer join dept d on d.id = u.dept_id; -- 左外 6select d.*, u.name from user u right outer join dept d on d.id = u.dept_id; -- 右外 7select d.*, u.name from dept d left join user u on d.id = u.dept_id; -- 将右外改为左外   自连接:当前表与自身连接查询\n1-- 自连接 2-- select 字段列表 from 表A 别名A join 表A 别名B ON 条件; 3-- 查询员工及其所属领导(员工和领导在同一表中), 将他们看做两张表,员工表和领导表 4select u1.name, u2.name from user u1 join user u2 on u1.manager_id=u2.id; 5-- 即便没有领导也查询 6select u1.name, u2.name from user u1 left join user u2 on u1.manager_id=u2.id;   联合查询 1-- 联合查询 union union all,将多次查询的结果合并起来, 列数必须保持一致 2-- select from union [all] select from 3-- 将年龄小于50岁 和 状态为1 的员工查询出来 4select * from user where age \u0026lt; 50 union all select * from user where status = 1; -- 结果有重复,直接将查询结果合并 5select * from user where age \u0026lt; 50 union select * from user where status = 1; -- 结果没重复,合并后去重 子查询 子查询, 在select中嵌套select,又称嵌套查询\n这部分最重要的就是一部分一部分来, 查询一个阶段再将结果作为另一个阶段\n1select * from t1 where column1=(select column1 from t2) 外部可以是select/update/insert/delete 子查询分类:\n  标量子查询(结果为单值), 操作符一般是\u0026gt; \u0026gt;= 之类\n1-- 查询单个部门的员工信息,(select id from dept where name = \u0026#39;研发部\u0026#39;)只有一条记录 2select * from user where dept_id=(select id from dept where name = \u0026#39;研发部\u0026#39;);   列子查询, 操作符是in, not in, any/some, all\n1-- any some是任意有一个满足即可 2-- all是子查询返回的列表的所有值都要满足 3-- 查询两个部门的员工信息 4select * from user where dept_id in (select id from dept where name = \u0026#39;研发部\u0026#39; or name = \u0026#39;市场部\u0026#39;); 5-- 查询比市场部所有人年龄都小的员工 6select * from user where age \u0026lt; all (select age from user where dept_id=(select id from dept where name = \u0026#39;总经办\u0026#39;));   行子查询, 操作符= \u0026lt;\u0026gt; in not in\n1-- 查询和编号2员工的年龄与状态相同的员工,行元素对应 2select * from user where (age, status) = (select age, status from user where id=1); 3-- 表子查询,操作符in 4-- 查询与编号1,编号2员工的年龄和状态相同的员工,也是每一行对应一个,用in 5select * from user where (age, status) in (select age, status from user where id=1 or id=2); 6-- 查询年龄小于50的员工信息和部门信息 7select e.*, d.* from (select * from user where age \u0026lt; 50) e left join dept d on e.dept_id = d.id;   事务 准备:\n1create table account( 2 id int auto_increment primary key , 3 name varchar(50) , 4 money int 5); 6insert into account(id, name, money) VALUES (null, \u0026#39;lisan\u0026#39;, 2000); 7insert into account(id, name, money) VALUES (null, \u0026#39;wangsan\u0026#39;, 2000); 8-- 恢复数据 9update account set money = 2000 where name = \u0026#39;lisan\u0026#39; or name = \u0026#39;wangsan\u0026#39;; 10-- 查询lisan余额 11select * from account where name=\u0026#39;lisan\u0026#39;; 12-- 转账操作 13update account set money = money - 1000 where name = \u0026#39;lisan\u0026#39;; 14update account set money = money + 1000 where name = \u0026#39;wangsan\u0026#39;; 管理事务 方式一 1-- 查看事务的提交方式 2select @@autocommit; 3-- 设置为手动提交, 0为手动,1为自动 4set @@autocommit = 0; -- 设置为手动 5set @@autocommit = 1; -- 设置为自动 6-- 操作 7update account set money = money - 1000 where name = \u0026#39;lisan\u0026#39;; 8update account set money = money + 1000 where name = \u0026#39;wangsan\u0026#39;; 9-- 提交事务 10commit; 11-- 回滚事务, 如果出错了就回滚 12rollback; 方式二 1-- 开启事务 2start transaction; 3begin; 4-- 提交事务 5commit; 6-- 回滚 7rollback; 事务的四大特性ACID  原子性atomicity: 不可分割的最小操作,一起成功,一起失败 一致性consistency: 事务完成,数据保持一致状态,比如余额是一定的 隔离性isolation: 数据库提供的隔离机制, 事务不受外部并发操作影响独立环境执行 持久性durability: 事务一旦提交或回滚, 对数据的改变是永久的  并发事务问题  脏读:事务读取来另一个事务没有提交的数据 不可重复读: 事务先后读取同一数据,两次读取的数据不同 幻读:查询时没有这行数据,但是插入时又存在这行数据  事务的隔离级别  read uncommitted 脏读会出现 不可重复读会出现 幻读会出现 性能最高 read committed(oracle默认) 脏读不会出现 repeatable read(mysql默认) 脏读,不可重复读不会出现 serializable 脏读,不可重复读,幻读不会出现 性能最差  事务隔离级别越高,数据越安全,性能越低.\n1-- 查看事务隔离级别 2select @@transaction_isolation; 3-- 设置事务隔离级别 4-- set [session|global] transaction isolation level {read uncommitted|read committed|repeatable read|serializable}; 5set session transaction isolation level serializable ; 6set session transaction isolation level repeatable read ; 模拟并发问题 模拟脏读 1-- 模拟脏读 2-- 窗口1 3set session transaction isolation level read uncommitted ; 4start transaction ; 5select * from account; -- 这时候可以看到lisan减了1000块,就是因为可以读到未提交的(read uncommitted) 6-- 窗口2 7start transaction ; 8update account set money = money - 1000 where name=\u0026#39;lisan\u0026#39;; 模拟不可重复读 1-- 模拟不可重复读 2-- 窗口1 3set session transaction isolation level read committed ; 4start transaction ; 5select * from account; -- 在commit之前查询 6select * from account; -- 在commit之后查询, 可以查询到变更的. 7commit ; 8-- 窗口2 9start transaction ; 10update account set money = money + 1000 where name=\u0026#39;lisan\u0026#39;; 11commit ; 模拟幻读 1-- 模拟幻读 2-- 窗口1 3set session transaction isolation level repeatable read ; 4start transaction ; 5select * from account where id=3; -- 1查不到 6insert into account(id, name, money) VALUES (null, \u0026#39;zangsan\u0026#39;, 3000); -- 4这边后执行,发现插入不了 7select * from account where id=3; -- 5再次查询,还是没有, 这是因为已经解决了不可重复读了. 8-- 窗口2 9start transaction ; 10insert into account(id, name, money) VALUES (null, \u0026#39;zangsan\u0026#39;, 3000); -- 2这边先insert 11commit ; -- 3先提交,这时已经有这一行了. 索引 mysql体系结构: 连接池(授权认证), 服务层(sql接口,sql分析优化,函数执行), 引擎层(数据存储和提取), 存储层\n存储引擎: 存储数据,建立索引,更新/查询数据等技术的视线方式. 存储引擎是基于表的而不是库.\n1-- 查询建表语句,默认innodb 2show create table account; 3# CREATE TABLE `account` ( 4# `id` int NOT NULL AUTO_INCREMENT, 5# `name` varchar(50) DEFAULT NULL, 6# `money` int DEFAULT NULL, 7# PRIMARY KEY (`id`) 8# ) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci 9 10-- 查询当前数据库支持的存储引擎 11show engines; 12-- 创建表,指定引擎为MyISAM 13create table my_myisam( 14 id int auto_increment primary key, 15 name varchar(50) 16)engine = MyISAM; 17-- 创建表,指定引擎为MEMORY 18create table my_memory( 19 id int auto_increment primary key , 20 name varchar(50) 21)engine = Momory; 存储引擎的特点   innodb是mysql5.5之后默认的存储引擎, 特点:DML遵循ACID模型,支持事务; 行级锁,提高并发性能; 支持外键foreign key 文件:xxx.ibd, 每张表都会对应一个表空间文件,存储改变的表结构(frm,sdi),数据和索引. 逻辑存储结构:一个表空间TableSpace包含很多Segment段,一个段包含很多Extent区,一个区包含很多Page页,一个页包含很多Row行(行数据). 一个row包含trx id,roll pointer, col1, col2, 适用于并发条件下要求数据的一致性, 除了插入查询还有很多的更新删除操作\n  MyISAM, mysql早期的默认存储引擎. 不支持事务,不支持外键, 支持表锁, 不支持行锁,访问速度快 文件: sdi表结构信息,myd数据,myi索引 读操作和插入操作为主, 更新和删除较少时选用\n  Memory, 存储在内存,只能作为临时表或缓存 内存存放,访问速度快, hash索引 通常做缓存\n  innodb与MyISAM区别:innodb支持外键,是行锁,支持事务.MyISAM是表锁\n索引 索引: 高效获取数据的数据结构(有序)\n优点:提高检索效率,降低数据库io成本;通过索引进行排序,降低数据排序的成本\n缺点:费空间,提高了查询效率但是降低了更新效率\n索引结构 有B+Tree索引(常见), Hash索引(性能高,不支持范围查询),R-tree(空间索引),Full-text(全文索引)\n二叉树:顺序插入时形成链表,层级深\n红黑树:自平衡二叉树,但是数据量大的时候层级也深.\nB-Tree(多路平衡查找), 从下面往上面走的.\nB+Tree:相比B-Tree,所有的元素会出现的叶子结点(向上分裂的同时保留自己),叶子节点会形成单向链表\nMySQL在B+Tree的基础上,将叶子节点的链表变为了双向循环链表,提高区间访问性能.\nHash索引:将键值换算成Hash值,映射在对应的槽位,存储在Hash表中.如果Hash冲突就增加链表.(就是HashSet原理), 只能用于对等比较= in,不能范围查询; 无法排序; 查询效率高. Memory支持hash索引.\n索引分类 主键索引(primary, 只能有一个), 唯一索引(unique), 常规索引, 全文索引(fulltext)\n根据存储形式分类:聚集索引(数据存储和索引一块,叶子结点保存行数据,必须要,只能有一个), 二级索引(数据和索引分开, 叶子结点是主键,可以多个)\n索引选取规则:\n 如果存在主键, 主键索引就是聚集索引 没有主键, 选取第一个unique唯一索引作为聚集索引 都没有,Innodb自动生成rowid作为隐藏的聚集索引  如select * from user where name = \u0026lsquo;li\u0026rsquo;; 先从二级索引找主键,再从聚集索引找数据.这就是回表查询\n索引语法 1-- 创建索引 create [unique|fulltext] index index_name on table_name (index_col_name,..) 2-- 查看索引 show index from table_name; 3show index from learndatabase.user; 4-- 删除索引 drop index index_name on table_name; 5-- 为name字段创建索引,该字段可能重复(常规索引) 6create index idx_user_name on user(name); 7-- 为phone创建唯一索引(唯一索引, 单列索引) 8create unique index idx_user_phone on user(phone); 9-- 为多个字段创建索引(联合索引),使用最频繁的字段放左侧(最左前缀原则) 10create index idx_user_name_phone_age on user(name, phone, age); SQL性能分析 SQL执行频率 1-- show [session|global] status; 2-- 查看select, update, delete, insert等执行次数 3show global status like \u0026#39;Com_______\u0026#39;; 慢查询日志 慢查询日志: 记录执行时间超过指定参数long_time_query,默认10秒的日志\n记录位置: /var/lib/mysql/localhost-slow.log\n默认没有开启,在MySQL配置文件/etc/my.cnf配置, slow_query_log=1 1表示开, long_time_query=2 2秒\n1-- 查看是否开启 2show variables like \u0026#39;slow_query_log\u0026#39;; 查看时间耗费 show profiles能够在做sql优化的时候帮助我们了解时间耗费到哪去了\nhave_profiling参数查看是否支持profile\n1select @@have_profiling; 2-- 查看是否开启 3select @@profiling; 4-- 设置开启 5set profiling = 1; 6-- 查看耗时情况 7show profiles; 8-- 查看指定query_id的sql语句每个阶段的耗时情况 9-- show profile for query [query_id]; 10show profile for query 3; 查看sql语句的执行计划 explain[/desc] 查看sql语句的执行计划, 如何执行的\n1explain select * from learndatabase.user where age \u0026lt; 50;  id字段:id相同,执行顺序从上往下, id越大越先执行 select_type:SIMPLE简单表(不使用表连接或子查询),primary(主查询,即外层的查询), union(union中第二个或者后面的查询语句), subquery(select或where之后包含的子查询) type:连接类型. 性能由好到坏是NULL(不查任何表), system, const(唯一索引), eq_ref, ref(非唯一性索引), range, index(扫描索引), all(全表扫描) possible_key:可能用到的索引 key:实际用到的索引 key_len:使用索引的字节数 rows:必须要执行查询的行数 filtered:返回结果的行数占需读取行数的百分比,越大越好  索引使用 1-- 验证索引效率:先执行一条没有索引的sql,再创建索引再执行 2select * from tb_sku where sn=\u0026#39;100001\u0026#39;; 3create index idx_sku_sn on tb_sku(sn); 4select * from tb_sku where sn=\u0026#39;100001\u0026#39;; 最左前缀法则: 查询从索引最左列开始, 并且不跳过索引中的列; 如果跳过某列, 索引将部分失效(后面的字段失效)\n1-- 假设创建了联合索引且顺序为profession,age,status,那么 2explain select * from user where profession=\u0026#39;软件工程\u0026#39; and age=31 and status=\u0026#39;0\u0026#39;; -- 会用到索引,所有字段都走索引 3explain select * from user where profession=\u0026#39;软件工程\u0026#39; and age=31; -- 会用到索引,所有字段都走索引 4explain select * from user where profession=\u0026#39;软件工程\u0026#39; -- 会用到索引,所有字段都走索引 5explain select * from user where age=31 and status=\u0026#39;0\u0026#39;; -- 不会用到索引 6explain select * from user where profession=\u0026#39;软件工程\u0026#39; and status=\u0026#39;0\u0026#39;; -- 只有profession会用到索引 7explain select * from user where age=31 and profession=\u0026#39;软件工程\u0026#39; and status=\u0026#39;0\u0026#39;; -- 会用到索引,这个sql语句的顺序无关,只需要存在 范围查询: 联合索引中, 出现范围查询(\u0026lt;.\u0026gt;),那么范围查询右侧的列索引失效\n1explain select * from user where profession=\u0026#39;软件工程\u0026#39; and age\u0026lt;31 and status=\u0026#39;0\u0026#39;; -- profession和age走索引,status不走 2explain select * from user where profession=\u0026#39;软件工程\u0026#39; and age\u0026lt;=31 and status=\u0026#39;0\u0026#39;; -- 都走,其实只有=那里都走 索引失效 1-- 索引列运算操作, 会导致索引失效 2explain select * from user where substring(phone, 10, 2) = \u0026#39;15\u0026#39;; -- 没用索引 3-- 字符串没加引号, 会导致索引失效 4explain select * from user where name = lisan; 5explain select * from user where profession=\u0026#39;软件工程\u0026#39; and age=31 and status=0; -- status没有走索引 6-- 模糊查询, 如果仅仅是尾部模糊, 索引不会失效; 头部模糊匹配会失效 7explain select * from user where profession like \u0026#39;软件%\u0026#39;; -- 走索引 8explain select * from user where profession like \u0026#39;%软件\u0026#39;; -- 不走 9explain select * from user where profession like \u0026#39;%件%\u0026#39;; -- 不走 10-- or连接的条件: 前面列有索引,后面列没索引,那么索引都不会用到; 只有都有索引才会用到 11explain select * from user where phone=\u0026#39;17712312310\u0026#39; or age=13; -- age没索引,所以没有用任何索引 12-- 数据分布影响: 如果MySQL评估使用索引比全表更慢,则不使用索引 13explain select * from user where phone\u0026gt;\u0026#39;17700000000\u0026#39;; -- 绝大部分数据都满足,这时就没用索引 14explain select * from user where phone is not null; -- 绝大部分都满足,没走索引 15explain select * from user where phone is null; -- 绝大部分都不满足,走索引 SQL提示 给mysql说想要什么索引(如果有多个可用的)之类,达到优化操作的目的\n1-- 比如既有单个索引,又有联合索引的情况. 2-- use index: 建议用哪个索引 ignore index: 不用哪个索引 force index:必须用哪个索引 3explain select * from user use index(idx_user_pro) where profession=\u0026#39;软件工程\u0026#39;; 4explain select * from user ignore index(idx_user_pro) where profession=\u0026#39;软件工程\u0026#39;; 5explain select * from user force index(idx_user_pro) where profession=\u0026#39;软件工程\u0026#39;; 覆盖索引 查询使用索引, 并且需要返回的列, 在该索引中已经全部能够找到, 这样只需要查联合索引即可, 不需要回表查询\n所以需要减少select *的使用, 这样可以提高效率\n1-- 如现有索引profession, age, status的联合索引 2explain select id, profession, age, status from user where profession=\u0026#39;软件工程\u0026#39; and age=31 and stauts=\u0026#39;0\u0026#39;; -- 效率高 3explain select id, profession, age, status, name from user where profession=\u0026#39;软件工程\u0026#39; and age=31 and stauts=\u0026#39;0\u0026#39;; -- 效率低 前缀索引 索引很长的字符串,让索引变得很大,查询时浪费大量磁盘IO. 此时将字符串的一部分前缀建立索引,节约索引空间\n1create index idx_xxxx on table_name(column(n)); 前缀长度的选取: 根据选择性决定. 选择性是不重复的所有值比上记录总数, 选择性越高效率越高, 唯一索引的选择性是1.\n一般是根据需求选择, 不需要必须选择性为1, 0.9的效率也可以.\n1select count(distinct email) / count(*) from tb_user; -- 全部字段的选择性 2select count(distinct substring(email, 1, 5)) / count(*) from tv_user; -- email字段截取前5个的选择性 在查询的时候, 查索引, 然后回表对比是否一致; 继续查索引链表的下一个看看是否一致. 这是以时间换空间.\n总结 单列索引和联合索引的选择: 存在多个查询条件, 考虑针对查询字段建立索引时, 建议建立联合索引\n索引设计原则:\n 数据量大(一百万), 查询频繁建立索引 常作为查询条件where, 排序order by, 分组group by操作的字段建立索引 尽量选择区分度高(效率高)的列作为索引, 尽量建立唯一索引 字符串类型字段,长度长的话可以建立前缀索引 尽量使用联合索引. 查询时联合索引很多时候可以覆盖索引, 节省存储空间, 避免回表 控制索引数量, 索引越多, 维护代价越大, 影响增删改效率 如果索引列不能存储NULL值, 创建表时使用NOT NULL约束它. 当优化器知道每列是否包含null值时, 它可以更好确定那个索引最有效用于查询  SQL优化 插入数据, insert优化   批量插入, 一次性插入500-1000条, 特别大量的插入分成多个insert\n1insert into tb_test values (1,\u0026#39;tom\u0026#39;), (2,\u0026#39;cat\u0026#39;), (3,\u0026#39;jerry\u0026#39;);   手动事务提交\n1start transaction ; 2insert into ; 3insert into ; 4commit ;   主键顺序插入\n  使用load指令(大批量数据)\n1①连接mysql加参数--local-infile 2mysql --local-infile -u root -p 3②设置全局参数local_file为1, 开启从本地加载文件导入数据的开关 4set global local_infile =1; 5③执行load指令. fields terminated by \u0026#39;,\u0026#39;表示列之间的分隔符, lines terminated by \u0026#39;\\n\u0026#39;表示行数据的分隔符 6load data local infile \u0026#39;/root/sql1.log\u0026#39; into table \u0026#39;tb_user\u0026#39; fields terminated by \u0026#39;,\u0026#39; lines terminated by \u0026#39;\\n\u0026#39;;   主键优化 页分裂: 当一个数据插入到页已经满的地方时, 就会页分裂. 这时复制后50%到另一个页里面, 然后将数据插入另一个页, 最后再修改页指针执行新的页\n页合并: 当删除一行记录, 并没有真正地被物理删除, 只是标记删除并且它的空间允许其他记录使用. 当删除页达到MERGE_THRESHOLD(默认页50%), Innodb开始寻找最靠近的页 看看是否可以将两个页合并以优化空间使用.\n主键设计原则:\n 尽量降低主键长度(辅助索引叶子节点挂的都是主键, 会导致空间占用很多) 插入数据尽量顺序插入, 选择使用AUTO_INCREMENT自增主键 尽量不要使用UUID做主键或者其他自然主键, 如身份证 业务操作避免对主键的修改.  order by 优化 using filesort: 通过表的索引或全表扫描, 读取满足条件的数据行, 然后在排序缓冲区sort buffer中完成排序操作.\n所有不是通过索引直接返回排序结果的排序都叫filesort排序, 覆盖索引是前提.\nusing index: 通过有序索引顺序扫描直接返回有序数据, 不需要额外排序, 操作效率高.\n1explain select id, age, phone from tb_user order by age, phone -- 没有索引时, using filesort 2 3create index idx_user_age_phone_aa on tb_user(age, phone); -- 创建两个升序索引 4explain select id, age, phone from tb_user order by age, phone; -- 有索引时, using index 5 6explain select * from tb_user order by age, phone; -- 没用索引, using filesort, 这时不是覆盖查询了, 回表了. 7 8explain select id, age, phone from tb_user order by age desc, phone desc; -- 反向利用索引, using index 9 10explain select id, age, phone from tb_user order by age asc, phone desc; -- 没有用到索引 using filesort 11 12create index idx_user_age_phone_ad on tb_user(age asc, phone desc); -- 创建一个升序,一个降序索引 13explain select id, age, phone from tb_user order by age asc, phone desc; -- 用到索引 using index OrderBy优化:\n 根据排序字段建立合适的索引, 多字段排序时, 遵循最左前缀法则. 尽量使用覆盖索引 多字段排序, 一个升序一个降序, 此时需要注意联合所以在创建时的规则, show index中的collation就是排序规则,A升D降 如果不可避免的出现filesort, 大数据量排序时, 可以适当增大排序缓冲区大小sort_buffer_size(默认256k)  group by 优化 1explain select profession, count(*) from tb_user group by profession; -- 没有查询的时候, 用临时表 2create index idx_user_pro_age_sta on tb_user(profession, age, status); -- 创建联合索引 3explain select profession, count(*) from tb_user group by profession; -- 用了联合索引 4explain select age, count(*) from tb_user group by age; -- 违反最左前缀法则, 用到临时表 5explain select profession, age, count(*) from tb_user group by profession, age; -- 用联合索引 6explain select age, count(*) from tb_user where profession=\u0026#39;软件工程\u0026#39; group by age; -- 用到联合索引, 最左前缀 limit优化 limit 1000000, 10 此时MySQL需要排序前1000010条记录, 仅仅返回1000000-1000010的记录, 其他丢弃\n一般分页查询时, 通过创建覆盖索引能够较好地提高性能, 可以通过覆盖查询+子查询的形式进行优化\n1select * from tb_sku limit 1000000, 10; -- 19s 2select t.* from tb_sku t, (select id from tb_sku order by id limit 1000000, 10) a where t.id = a.id; -- 11s 3 count优化 MyISAM引擎把一个表总行数存在了磁盘上, 因此执行count(*)的时候直接返回这个数, 效率很高\nInnodb执行count(*)需要把数据一行行从引擎里面读出来, 累积计数.\n  count()是一个聚合函数, 对于返回结果集, 一行行判断. 如果count函数的参数不是null, 累计数+1, 否则不加. 最后返回累计值\n  count(*): Innodb并不会把全部字段取出来, 专门做了优化, 不取值, 服务层直接按行进行累加.\n  count(1): Innodb遍历整张表, 但不取值, 服务层对于返回的每一行, 放一个数'1\u0026rsquo;进去, 直接按行进行累加. 当然其他数都可以\n  count(主键): Innodb遍历整张表, 把每一行的主键id取出来, 返回服务层, 服务层拿到主键直接按行进行累加(主键没有null)\n  count(字段): 没有not null的字段, 取出来之后到服务层, 服务层需要判断是否是null, 不为null计数累加\n  count(字段): 有not null的字段, 取出来之后到服务层, 服务层直接按行进行累加\n  效率: count(*) ≈ count(1) \u0026gt; count(主键) \u0026gt; count(字段)\nupdate优化 Innodb的行锁是针对索引加的锁, 不是针对记录加的锁, 使用的条件一定要有索引不然就是表锁; 该索引不能失效, 否则行锁变为列锁\n1-- 使用主键索引 2update student set no=\u0026#39;20010101\u0026#39; where id=1; -- 此时事务加的行锁, 对其他并发事务修改其他行没有影响 3update student set no=\u0026#39;20010101\u0026#39; where name=\u0026#39;韦一笑\u0026#39;; -- 当name字段没有索引时,此时加的是表锁, 对表的其他行均不能使用update变更 视图 1-- 视图 2-- 介绍: 视图是一种虚拟存在的表. 视图中的数据并不在数据库中实际存在, 行和列数据来定义自定义视图的查询中使用的表, 并且是在使用视图时动态生成的 3-- 作用: 1.简单:简化用户对数据的理解, 也可以简化他们的操作. 那些被经常使用的查询可以被定义为视图 4-- 2.安全:数据库可以授权,但不能授权到数据库特定的行和列上. 通过视图用户只能查询和修改他们所能见到的数据 5-- 3.数据独立: 视图可帮助用户屏蔽真实表结构带来的影响. 6 7-- 创建: create [or replace] view 视图名称[(列名列表)] as select语句 [with [cascaded|local] check option] 8create or replace view stu_v_1 as select id,name from student where id\u0026lt;=10; 9-- 查询: 查看视图创建语句 show create view 视图名称; 10-- 查看视图数据 select * from 视图名称....; 11show create view stu_v_1; 12select * from stu_v_1; 13select * from stu_v_1 where id\u0026lt;3; 14-- 修改: 方式一:create [or replace] view 视图名称[(列名列表)] as select语句 [with [cascaded|local] check option] 15-- 方式二:alter view 视图名称[(列名列表)] as select语句 [with [cascaded|local] check option] 16create or replace view stu_v_1 as select id,name,no from student where id\u0026lt;=10; 17alter view stu_v_1 as select id,name from student where id\u0026lt;=10; 18-- 删除: drop view [if exist] 视图名称 [,视图名称]... 19drop view if exists stu_v_1; 20 21 22-- 检查选项 with [cascaded|local] check option 23-- 当使用with check option子句创建视图, mysql会通过视图检查正在更改的每个行, 如插入,删除,更新, 使其符合试图定义 24-- mysql允许基于另一个视图创建视图, 它还会检查依赖视图中的规则以保持一致性. 为了确定检查范围提供了两个选项cascaded和local, 默认cascaded 25-- 没有check的视图, 可以随便插入数据 26create or replace view stu_v_1 as select id, name from student where id \u0026lt;= 10; 27insert into stu_v_1 values (30, \u0026#39;tom\u0026#39;); -- 可以插入 28-- 普通的with check option的作用: 29create or replace view stu_v_1 as select id, name from student where id \u0026lt;= 10 with local check option ; 30insert into stu_v_1 values (6,\u0026#39;tom\u0026#39;); -- 可以插入,满足要求 31insert into stu_v_1 values (13,\u0026#39;tom\u0026#39;); -- 不能插入, 不满足\u0026lt;=10的要求 32-- cascaded选项, 级联的意思, 就是向下的视图不管有没有check选项都要检查 33create or replace view stu_v_1 as select id, name from student where id \u0026lt;= 20; -- 视图1, 没有check 34create or replace view stu_v_2 as select id, name from stu_v_1 where id \u0026gt;= 10 with cascaded check option ; -- 视图2, 级联检查 35insert into stu_v_2 values (7,\u0026#39;tom\u0026#39;); -- 不行, 不满足视图2的要求 36insert into stu_v_2 values (30,\u0026#39;tom\u0026#39;); -- 不行, 不满足视图1的要求 37insert into stu_v_2 values (15,\u0026#39;tom\u0026#39;); -- 可以 38-- 再在基础上新增一个视图3, 这时cascaded不会影响上层视图 39create or replace view stu_v_3 as select id, name from stu_v_2 where id \u0026gt;= 15; 40insert into stu_v_3 values (11,\u0026#39;tom\u0026#39;); -- 满足视图1和2的要求, 可以. 视图3的要求没有check所以条件无所谓 41insert into stu_v_3 values (17,\u0026#39;tom\u0026#39;); -- 满足要求, 可以 42insert into stu_v_3 values (28,\u0026#39;tom\u0026#39;); -- 不满足 43-- LOCAL选项: 它只影响本视图, 不会影响上下. 44 45-- 视图的更新: 要使视图更新, 视图中的行与基础表的行之间必须存在一对一的关系 46-- 视图包含以下任一项 视图不可更新 47-- 1.聚合函数或窗口函数(sum, min, max count等) 48-- 2.distinct 49-- 3.group by 50-- 4.having 51-- 5.union或union all 52 53 54-- 视图案例 55-- 1.为了保证数据库安全, 开发人员在操作tb_user表时, 只能看到用户的基本字段,屏蔽手机号和邮箱两个字段 56create view tb_user_view as select id, name, profession, gender, status, create_time from tb_user; 57select * from tb_user_view; 58-- 2.查询学生选修的课程(三表联查),为了简化操作,定义视图 59create view tb_stu_cource_view as select s.name student_name, s.no student_no, c.name course_name from student s, student_course sc, course c where s.id=sc.studentid and sc.courseid=c.id; 存储过程/函数/触发器 1-- 存储过程: 事先经过编译并存储在数据库中的一段SQL语句的集合, 调用存储过程可以简化应用开发人员的很多工作, 2-- 减少数据在数据库和应用服务器之间的传输,对提高数据处理的效率有好处 3-- 存储过程的思想很简单, 就是数据库SQL语言层面的代码封装与重用 4-- 特点: 封装复用; 可以接收参数, 返回数据; 减少网络交互提升效率 5 6 7-- 创建存储过程 8# create procedure 存储过程名称([参数列表]) 9# begin 10# -- sql语句 11# end; 12create procedure p1() 13begin 14 select count(*) from user; 15end; 16-- 如果在命令行中创建存储过程, 需要指定sql语句的结束符, 通过delimiter 17-- delimiter $$ 设置结束以$$结束 18# create procedure p1() 19# begin 20# select count(*) from user; 21# end$$ 22 23-- 调用 24-- call 名称([参数]); 25call p1(); 26-- 查看存储过程 27-- select * from information_schema.ROUTINES where ROUTINE_SCHEMA=\u0026#39;数据库名字\u0026#39;; -- 查询指定数据库存储过程及状态信息 28-- show create procedure 存储过程名称; -- 查询某个存储过程定义 29select * from information_schema.ROUTINES where ROUTINE_SCHEMA=\u0026#39;bbs\u0026#39;; 30show create procedure p1; 31-- 删除 32-- drop procedure if exists 存储过程名称; 33drop procedure if exists p1; 34 35 36-- 变量 37 38-- 系统变量是是MySQL服务器提供的, 不是用户定义的, 属于服务器层面. 分为全局变量(global)和会话变量(session) 39-- 全局变量在所有MySQL会话都有效, 会话变量只在当前会话有效 40-- 查看系统变量, 默认都是session 41-- 查看所有系统变量 show [global|session] variables; 42-- 通过模糊匹配查看变量 show [global|session] variables like \u0026#39;....\u0026#39;; 43-- 查看指定变量 select @@[global|session]系统变量名; 44show variables ; 45show session variables ; 46show global variables ; 47show variables like \u0026#39;auto%\u0026#39;; 48show global variables like \u0026#39;auto%\u0026#39;; 49select @@autocommit; 50select @@session.autocommit; 51select @@global.autocommit; 52 53-- 设置系统变量, MySQL服务重启后, 所设置的全局变量会失效, 要想不失效,可以在/etc/my.cnf中配置 54-- set [session|global] 系统变量名=值; 55-- set @@[session|global] 系统变量名=值; 56set session autocommit = 0; 57set global autocommit = 0; 58 59-- 用户定义变量: 不用提前声明, 用的时候直接用@变量名 60-- 作用域是当前会话, 其他会话用不了. 61-- 赋值, 推荐使用:=, 因为=可以作为比较运算符 62-- set @var_name =expr [,@var_name=expr]...; 63-- set @var_name :=expr [,@var_name:=expr]...; 64-- select @var_name :=expr [,@var_name :=expr] ...; 65-- select 字段名 into @var_name from 表名; 66set @caonima=\u0026#39;cnm\u0026#39;; 67set @mygender:=\u0026#39;男\u0026#39;, @myhobby:=\u0026#39;java\u0026#39;; 68select @cnm:=\u0026#39;red\u0026#39;; 69select count(*) into @usercount from learndatabase.user; 70-- 使用 71-- select @var_name; 72select @caonima; 73select @mygender, @myhobby, @usercount; 74select @abc; -- 没声明赋值,结果是null 75 76-- 局部变量: 需要定义的在局部生效的变量, 访问需要declare声明. 可用作存储过程的局部变量和输入参数 77-- 局部变量的范围是在其内声明的begin and块. 78-- 声明, 没有@符号了 79-- declare 变量名 变量类型 [default...]; 80-- 变量类型: int, bigint, char, varchar, date, time等 81-- 赋值, 没有@符号. 82-- set 变量名=值; 83-- set 变量名:=值; 84-- select 字段 into 变量名 from 表名; 85create procedure p2() 86begin 87 declare stu_count int default 0; 88 select count(*) into stu_count from learndatabase.user; 89 select stu_count; 90end; 91call p2(); 92 93 94-- 流程控制结构 95-- if语法 96# if 条件1 then 97# ... 98# elseif 条件2 then 99# ... 100# else 101# ... 102# end if; 103create procedure p3() 104begin 105 declare score int default 59; 106 declare result varchar(10); 107 108 if score \u0026gt;= 85 then 109 set result:=\u0026#39;优秀\u0026#39;; 110 elseif score \u0026gt;=60 then 111 set result:=\u0026#39;及格\u0026#39;; 112 else 113 set result:=\u0026#39;不及格\u0026#39;; 114 end if; 115 116 select result; 117end; 118 119call p3(); 120 121-- 参数 122-- 类型: IN 作为输入的参数, 需要调用时传值, 此为默认 123-- OUT 作为输出的参数, 该参数可以作为返回值 124-- INOUT 既可以作为输入, 也可以作为输出的参数 125# create procedure 存储过程名称([in/out/inout 参数名 参数类型]) 126# begin 127# -- sql 128# end; 129-- 判断成绩的存储过程 130create procedure p4(in score int, out result varchar(10)) 131begin 132 if score \u0026gt;= 85 then 133 set result:=\u0026#39;优秀\u0026#39;; 134 elseif score \u0026gt;=60 then 135 set result:=\u0026#39;及格\u0026#39;; 136 else 137 set result:=\u0026#39;不及格\u0026#39;; 138 end if; 139end; 140call p4(90, @result); 141select @result; 142 143-- 将传入的200分制的分数, 换算成100分制的分数 144create procedure p5(inout score double) 145begin 146 set score:=score * 0.5; 147end; 148set @score:=199.8; 149call p5(@score); 150select @score; 151 152-- case 153-- 语法1 154# case case_value 155# when when_value1 then statement_list1 -- 当case_value=value1时执行when之后的sql语句 156# [when when_value2 then statement_list2]... 157# [else statement_list] -- 都不满足时执行的sql语句 158# end case; 159-- 语法2 160# case 161# when search_condition1 then statement_list1 -- 当search_condition1为true时执行 162# [when search_condition2 then statement_list2]... 163# [else statement_list] -- 都不满足时执行的sql语句 164# end case; 165-- 根据传入的月份,判断月份所属的季节 166create procedure p6(in month int) 167begin 168 declare result varchar(10); 169 case 170 when month \u0026gt;= 1 and month \u0026lt;= 3 then set result:=\u0026#39;第一季度\u0026#39;; 171 when month \u0026gt;= 4 and month \u0026lt;= 6 then set result:=\u0026#39;第二季度\u0026#39;; 172 when month \u0026gt;= 7 and month \u0026lt;= 9 then set result:=\u0026#39;第三季度\u0026#39;; 173 when month \u0026gt;= 10 and month \u0026lt;= 12 then set result:=\u0026#39;第四季度\u0026#39;; 174 else set result:=\u0026#39;错误输入!\u0026#39;; 175 end case; 176 select concat(\u0026#39;输入的月份为\u0026#39;, month, \u0026#39;, 它所属的季度为: \u0026#39;, result); 177end; 178call p6(4); 179 180-- while循环: 有条件的循环, 满足条件才循环 181# while 条件 DO 182# sql...; 183# end while; 184-- 计算1累加到n 185create procedure p7(in count int) 186begin 187 declare i int default 1; 188 declare res int default 0; 189 while i \u0026lt;= count do 190 set res := res + i; 191 set i := i + 1; 192 end while; 193 select res; 194end; 195 196create procedure p7(in count int) 197begin 198 declare res int default 0; 199 while count \u0026gt; 0 do 200 set res := res + count; 201 set count := count - 1; 202 end while; 203 select res; 204end; 205drop procedure p7; 206call p7(100); 207 208-- repeat循环: 满足循环退出 209# repeat 210# sql...; 211# until 条件; -- 当条件为真,退出循环 212# end repeat; 213-- 1加到n 214create procedure p8(in count int) 215begin 216 declare res int default 0; 217 repeat 218 set res:=res+count; 219 set count:=count-1; 220 until count \u0026lt;0 end repeat; 221 select res; 222end; 223call p8(10); 224 225-- loop循环: 简单循环, 如果不增加退出循环条件那么就是死循环, 它配合leave和iterate使用 226-- leave: 退出循环 227-- iterate: 必须用在循环中, 作用是跳过当前循环剩下语句进入下循环 228# [begin_label:] loop -- 指定标识label 229# sql...; 230# leave label; -- 退出循环 231# iterate label; -- 跳到下次循环 232# end loop [end_label]; 233-- 实现1累加n 234create procedure p9(in count int) 235begin 236 declare res int default 0; 237 loop_label: loop 238 set res := res + count; 239 set count := count - 1; 240 if count \u0026lt;= 0 then 241 leave loop_label; 242 end if; 243 end loop loop_label; 244 select res; 245end; 246call p9(100); 247-- 计算1-n的偶数累加 248create procedure p10(in count int) 249begin 250 declare res int default 0; 251 if count % 2 = 1 then 252 set count:= count -1; 253 end if; 254 odd_sum:loop 255 set res := res + count; 256 set count := count - 2; 257 if count \u0026lt;= 0 then 258 leave odd_sum; 259 end if; 260 end loop odd_sum; 261 select res; 262end; 263 264create procedure p10(in count int) 265begin 266 declare res int default 0; 267 odd_sum: loop 268 if count \u0026lt;= 0 then 269 leave odd_sum; 270 end if; 271 if count % 2 = 1 then 272 set count := count - 1; 273 iterate odd_sum; 274 end if; 275 set res := res + count; 276 set count := count - 1; 277 end loop odd_sum; 278 select res; 279end; 280 281drop procedure p10; 282call p10(10); 283 284 285-- 游标: 存储查询结果集的数据类型, 在存储过程和函数中可以使用游标对结果集进行循环处理 286-- 声明游标: declare 游标名称 cursor for 查询语句; 287-- 打开游标: open 游标名称; 288-- 获取游标记录: fetch 游标名称 into 变量[,变量]; 289-- 关闭游标: close 游标名称; 290-- 案例: 根据传入的参数uage, 查询用户表中所有年龄小于uage的用户姓名name和专业profession, 然后将name和profession插入新表 291create procedure p11(in uage int) 292begin 293 declare uname varchar(100); 294 declare ugender char(1); 295 declare u_cursor cursor for select name, gender from learndatabase.user where age \u0026lt;= uage; 296 297 drop table if exists tb_user_gender; 298 create table if not exists tb_user_gender( 299 id int primary key auto_increment, 300 name varchar(100), 301 gender char(1) 302 ); 303 open u_cursor; 304 while true do -- 这里不知道什么时候结束 305 fetch u_cursor into uname, ugender; 306 insert into tb_user_gender values (null, uname, ugender); 307 end while; 308 close u_cursor; 309 310end; 311 312-- 条件处理程序(异常): 定义在流程控制结构执行过程中遇到的问题时相应的处理步骤 313-- declare handler_action handler for condition_value[,condition_value] ... statement; 314-- handler_action: continue:继续执行当前程序, exit:终止执行当前程序 315-- condition_value: sqlstate sqlstate_value: 状态码, 如02000 316-- sqlwarning: 所有以01开头的sqlstate代码的简写 317-- not found: 所有以02开头的sqlstate代码的简写 318-- sqlexception: 所有没有被sqlwarning和not found捕获的sqlstate代码的简写 319create procedure p11(in uage int) 320begin 321 declare uname varchar(100); 322 declare ugender char(1); 323 declare u_cursor cursor for select name, gender from learndatabase.user where age \u0026lt;= uage; 324 declare exit handler for sqlstate \u0026#39;02000\u0026#39; close u_cursor; -- 满足状态码为02000触发退出, 退出时将游标关闭 325 -- declare exit handler for not found close u_cursor; 326 327 drop table if exists tb_user_gender; 328 create table if not exists tb_user_gender( 329 id int primary key auto_increment, 330 name varchar(100), 331 gender char(1) 332 ); 333 open u_cursor; 334 while true do -- 现在最后一次循环后, 下面的语句会报错, 被handler抓取退出. 335 fetch u_cursor into uname, ugender; 336 insert into tb_user_gender values (null, uname, ugender); 337 end while; 338 close u_cursor; 339 340end; 341call p11(30); 342 343 344-- 存储函数: 有返回值的存储过程, 参数只能是in类型的. 345# create function 函数名称([参数列表]) 346# returns type [characteristic...] 347# begin 348# --sql 349# return ... ; 350# end; 351-- characteristic说明: 352-- determinstic:相同的输入总是产生相同的结果 353-- no sql:不包含sql语句 354-- reads sql data:包含读取sql的语句, 不包含写入数据的语句 355-- 案例: 1累加到n 356create function fun1(n int) 357returns int deterministic 358begin 359 declare res int default 0; 360 while n\u0026gt;0 do 361 set res:=res+n; 362 set n:=n-1; 363 end while; 364 return res; 365end; 366 367 368-- 触发器: 在insert/update/delete之前或之后, 触发并执行触发器中定义的sql语句集合 369-- 确保数据完整性, 日志记录, 数据校验等操作. 370-- 使用别名old和new来引用触发器中发生变化的记录内容 371-- insert触发器:new表示将要或已经新增的数据 372-- update触发器:old表示修改之前的数据, new表示将要或已经修改后的数据 373-- delete触发器:old表示将要或已经删除掉的数据 374-- 现在只支持行级触发器(每行触发一次), 不支持语句级触发器(不管影响多少行,只执行一次) 375 376-- 创建触发器 377# create trigger trigger_name 378# before/after insert/update/delete 379# on tbl_name for each row -- 行级触发器 380# begin 381# trigger_statement; 382# end; 383-- 查看 384show triggers ; 385-- 删除 386# drop trigger [schama_name.]trigger_name; -- 没有指定数据库名默认为当前数据库 387 388-- 需求, 记录tb_user表数据变更日志, 插入到日志表user_logs中, 包含增加,修改,删除 389create table user_logs( 390 id int(11) not null auto_increment, 391 operation varchar(20) not null , 392 operation_time datetime not null , 393 operation_id int(11) not null , 394 operation_params varchar(500) , 395 primary key (`id`) 396)engine =innodb default charset =utf8; 397 398-- 定义三个触发器 399--insert触发器 400create trigger insert_trigger 401 after insert on learndatabase.user for each row 402begin 403 insert into user_logs(id, operation, operation_time, operation_id, operation_params) values 404 (null, \u0026#39;insert\u0026#39;, now(), new.id, concat(\u0026#39;插入的数据内容: \u0026#39;, new.id, new.name, new.gender, new.gender)); 405end; 406show triggers ; 407drop trigger insert_trigger; 408insert into learndatabase.user values (null, \u0026#39;rurushu\u0026#39;, 38, 1, \u0026#39;男\u0026#39;, 3, 5); 409-- update触发器 410create trigger update_trigger 411 after insert on learndatabase.user for each row 412begin 413 insert into user_logs(id, operation, operation_time, operation_id, operation_params) values 414 (null, \u0026#39;update\u0026#39;, now(), new.id, concat(\u0026#39;更新前数据: \u0026#39;, old.id, old.name, old.gender, old.gender, 415 \u0026#39;更新后数据: \u0026#39;, new.id, new.name, new.gender, new.gender)); 416end; 417-- delete触发器 418create trigger delete_trigger 419 after insert on learndatabase.user for each row 420begin 421 insert into user_logs(id, operation, operation_time, operation_id, operation_params) values 422 (null, \u0026#39;delete\u0026#39;, now(), old.id, concat(\u0026#39;删除前数据: \u0026#39;, old.id, old.name, old.gender, old.gender)); 423end; 锁 分类: 全局锁, 表级锁, 行级锁.\n全局锁 全局锁: 对整个数据库实例加锁, 加锁后处于只读状态, 后续的DML写, DDL, 已经更新操作的事务提交语句都被阻塞\n使用场景: 做全库的逻辑备份 从而获取一致性视图, 保证数据完整性\u0026hellip;\n1flush tables with read lock ; 2mysqldump -uroot -proot learndatabase \u0026gt; learndatabase.sql 3unlock tables ; 特点:\n 主库备份, 备份期间不能执行更新操作, 业务基本停摆 从库备份, 备份期间不能执行主库同步过来的二进制日志, 导致主从延迟  Innodb中, 备份时加上参数\u0026ndash;single-transaction参数来完成不加锁的一致性数据备份(快照读实现)\n1mysqldump --single-transaction -uroot -proot learndatabase \u0026gt; learndatabase.sql 表级锁 表级锁: 发生锁冲突的概率最高, 并发度最低. 应用在MyISAM,Innodb,BDB等存储引擎\n分类: 表锁, 元数据锁, 意向锁\n表锁 表锁: 分为表共享读锁(read lock, 所有客户端只能读不能写), 表独占写锁(write lock, 只有自己能读能写, 别的客户端不能读不能写)\n1-- 加锁 2lock tables 表名... read/write 3-- 释放锁 4unlock tables 或者 客户端断开连接 元数据锁 元数据锁: 系统自动控制不需要显示使用, 访问一张表自动加上. 主要是维护表元数据的一致性,有活动事务时不可对元数据进行写入操作\n元数据大概就是表结构\n在MySQL5.5后, 对表进行增删改查,加MDL读锁(共享);当对表结构变更时,加MDL写锁(排它), 这两个锁是冲突的.\n比如两个终端,事务1使用了select加MDL读锁,那么事务2使用alter就会等待,因为这两个锁是排斥的,加不了MDL写锁.\n1-- 查看元数据锁 2select object_type, object_schema, object_name, lock_type, lock_duration from performance_schema.metadata_locks; 意向锁 意向锁: 为了避免DML在执行时加的行锁和表锁的冲突(不能同时加),Innodb中引入了意向锁, 使得表锁不用检查每行数据是否加锁,使用意向锁减少表锁的检查\n意向共享锁(IS):由select\u0026hellip; lock in share mode添加; 与表锁共享锁(read)兼容,与表锁排它锁(write)互斥.\n意向排它锁(IX):由insert,update,delete,select\u0026hellip;for update添加; 与表锁共享锁和表锁排它锁都互斥, 这样就可以保证数据一致性.\n意向锁之间不会互斥\n1-- 例子: 2select * from learndatabase.user lock in share mode ; -- 这句话加上行锁共享锁和意向共享锁 3lock tables learndatabase.user read; -- 这时可以加表共享读锁, 因为这两个锁兼容; 都可以读嘛 4lock tables learndatabase.user write; -- 这时不能加表独占写锁, 互斥的; 因为如果允许的话, 别个就可以改数据了,读的东西不一致. 1begin ; -- 客户端1开启事务 2update learndatabase.user set gender=\u0026#39;女\u0026#39; where id=1; -- 加上行锁和意向排它锁 3lock tables learndatabase.user read; -- 客户端2加锁, 不行 4lock tables learndatabase.user write; -- 客户端2加锁, 不行 1-- 查看意向锁及行锁的加锁情况 2select object_schema, object_name, index_name, lock_type, lock_mode, lock_data from performance_schema.data_locks; 行级锁 行级锁: 发生锁冲突的概率最低, 并发度最高, 应用在Innodb中.\nInnodb的数据是基于索引组织的, 行锁是往索引上的索引项加锁, 不是对记录加锁\n行级锁分为三类:\n 行锁(record lock): 锁定单行记录, 防止其他事务进行update, delete. 在rc(read committed),rr(repeatable read)隔离级别下都支持 间隙锁(gap lock): 锁定记录与记录之间的间隙(不含记录), 确保索引记录间隙不变, 防止其他事务在这个间隙insert,产生幻读, 在rr隔离级别下都支持. 临键锁(next-key lock): 行锁和间隙锁的组合, 同时锁住数据,并锁住数据前面的间隙gap.在rr隔离级别下支持, 防止幻读  这些锁和事务的隔离级别相辅相成.\n行锁 Innodb实现了两种类型行锁:\n 共享锁(s): 允许一个事务去读一行, 阻止其他事务获得相同数据集的排它锁, commit后就释放了(防不可重复读, 脏读) 排它锁(x): 允许获取排它锁的事务更新数据, 阻止其他事务获得相同数据集的共享锁和排它锁.  1-- insert, update, delete 获得排它锁, 系统自动加锁不需要控制 2-- select 不加任何锁 3-- select ... lock in share mode 共享锁 4-- select ... for update 排它锁 5select * from learndatabase.user where id=1; -- id=1这一行的共享锁, 那么其他事务对这一行数据不能获得排它锁 6update stu set name=\u0026#39;lei\u0026#39; where id=1; -- 排它锁 针对唯一索引进行检索时, 对已存在的记录进行等值匹配, 将会自动优化为行锁.\nInnodb的行锁是针对索引加的锁, 不通过索引条件检索数据, 那么Innodb将对表的所有记录加锁, 行锁升级为表锁.\nupdate优化的原理就是这个:\n1update stu set name =\u0026#39;lei\u0026#39; where name=\u0026#39;lily\u0026#39;; -- 事务1,第8行数据. 加的表锁.因为此时name没有索引,没有走索引 2update stu set name=\u0026#39;lei\u0026#39; where id=1; -- 事务2, 即便是第一行数据也不能更改, 因为这时已经是表锁了. 1-- 查询行锁 2select object_schema, object_name, index_name, lock_type, lock_mode, lock_data from performance_schema.data_locks; 间隙锁/临键锁 1-- 1. 索引上给等值查询(唯一索引), 给不存在的记录加锁, 优化为间隙锁 2update stu set age = 10 where id = 5; -- 事务1 表中只有3和8,之间没有数据, 这时加间隙锁, 锁住(3.8]这个空隙 3insert into stu values (7,\u0026#39;lili\u0026#39;, 8); -- 事务2 这时再往里插入, 插入不了被锁住了. 4 5-- 2. 索引上的等值查询(普通索引), 向右遍历时最后一个值不满足查询条件时, next-key lock退化为间隙 6-- 这里age字段就不是唯一索引可能有多个相同的值, 那么它会加11及后面17之间的锁(11后就是17) 7create index index_idx_stu_age on stu(age); 8select * from stu where age = 11 lock in share mode ; -- 事务1, 首先对3记录加共享行锁S,其次还要对17加临键锁,锁住本身和其间隙, 防止幻读 9 10-- 3. 索引上的范围查询(唯一索引), 会访问到不满足条件的第一个值为止. 11select * form stu where id \u0026gt; 30; -- 唯一索引范围查询. 假设查出来的有31 50 ,那么会给31加S锁, 还会给50加临键锁, 还会将50到正无穷也加S锁 12-- 间隙锁的目的是防止其他事务插入间隙, 间隙锁可以共存, 一个事务采用的间隙锁不会阻止另一个事务在同一间隙采用间隙锁. Innodb引擎/事务原理/MVCC 1-- Innodb引擎 2-- 逻辑存储结构 3-- 表空间tablespace: ibd文件, 一个mysql实例可以对应多个表空间, 用于存储记录, 索引等数据. 4-- 段segment: 分为数据段, 索引段, 回滚段. Innodb是索引组织表, 数据段就是B+Tree的叶子结点, 索引段即为B+Tree的非叶子节点. 段用来管理多个Extent区 5-- 区extent: 表空间的单元结构, 每个区的大小为1m, 默认情况下, Innodb存储引擎页大小为16k, 即一个区中一共有64个连续的页. 6-- 页page: 是Innodb存储引擎磁盘管理的最小单元, 每个页的大小默认是16kb. 为了保证页的连续性, Innodb存储引擎每次从磁盘申请4-5个区 7-- 行row: Innodb存储引擎数据是按行进行存放的. 行的数据结构: 8-- Trx_id: 每次对每条记录进行改动时, 都会把对应的事务id赋值给trx_id隐藏列 9-- Roll_pointer: 每次对每条记录进行改动时, 都会把旧的版本写入到undo日志中, 然后这个隐藏列就相当于一个指针, 可以用它找到该记录修改前的信息 10-- col1, col2, ... 11 12 13-- 架构 14-- 内存架构 15-- 1.buffer pool: 缓冲池是主内存的一个区域, 里面可以缓存磁盘上经常操作的真实数据, 在执行增删改查操作时, 先操作缓冲池中的数据(没有数据就从磁盘加载并缓存) 16-- 然后再以一定频率刷新到磁盘, 从而减少磁盘io, 加快处理速度. 17-- 缓冲池以页page为单位, 底层采用链表数据结构管理page, page分为三类: 18-- free page: 空闲page, 没有使用过 19-- clean page: 被使用page, 数据没有被修改过 20-- dirty page: 脏页, 被使用page, 数据被修改过, 页中数据与磁盘数据产生了不一致 21-- 2.change buffer: 更改缓冲区(针对非唯一二级索引页), 在执行DML语句时, 如果这些数据page没有在buffer pool中, 不会直接操作磁盘, 而会将数据变更 22-- 存在更改缓冲区change buffer中, 在未来数据被读取时, 再将数据合并恢复到buffer pool中, 然后再将合并后的数据刷新到磁盘中 23-- 好处: 与聚集索引不同, 二级索引通常是非唯一的, 并且以相对随机的顺序插入二级索引. 同样删除和更新可能会影响索引树种不相邻的二级索引页, 如果每次都 24-- 操作磁盘, 会造成大量磁盘io, 有了change buffer之后, 我们可以在缓冲池中进行合并处理, 减少磁盘io 25-- 3.adaptive hash index: 自适应哈希索引, 用于优化对buffer pool数据的查询. Innodb存储引擎会监控对表上各索引页的查询, 如果观察到hash索引可以 26-- 提升速度, 则建立hash索引, 称之为自适应hash索引. 27-- 自适应哈希索引, 无需人工干预, 是系统根据情况自动完成 28-- 参数adaptive_hash_index 29-- 4.log buffer: 日志缓冲区, 用来保存要写入到磁盘中的log日志数据(redo log, undo log), 默认大小16MB, 日志缓存区的日志会定期刷新到磁盘中. 如果 30-- 需要更新,插入,删除许多行的事务, 增加日志缓冲区的大小可以节省磁盘io 31-- 参数innodb_log_buffer_size: 缓冲区大小, innodb_flush_log_at_trx_commit: 日志刷新到磁盘的时机(0:每秒将日志写入并刷新到磁盘; 1:日志在每次事务提交时写入并刷新到磁盘; 2:日志在每次事务提交后写入,并每秒刷新到磁盘一次) 32 33 34-- 磁盘架构 35-- 这些文件系统里面都可以找得到. 36-- System tablespace: 系统表空间是更改缓冲区的存储区域, 如果表是在系统表空间而不是每一个表文件或通用表空间中创建的, 它也可能包含表和索引数据 37-- 参数:innodb_data_file_path 38-- File-per-table tablespace: 每个表的文件表空间包含单个Innodb表的数据和索引, 并存储在文件系统上的单个数据文件中. 39-- 参数:innodb_file_per_table 40-- general tablespace: 通用表空间, 需要通过create tablespace语法创建通用表空间, 在创建表时, 可以指定该表空间. 41create tablespace ts_name add datafile \u0026#39;file_name.ibd\u0026#39; engine =innodb; 42create table a(id int primary key auto_increment, name varchar(10))engine =innodb tablespace ts_name; 43-- undo tablespace: 撤销表空间, mysql实例在初始化时会自动创建两个默认的undo表空间(undo_001,undo_002)初始大小为16M, 用于存储undo log日志. 44-- temporary tablespace: 临时表空间, Innodb使用会话临时表空间和全局临时表空间,存储用户创建的临时表等数据. 45-- doublewirte buffer files: 双写缓冲区, Innodb将数据页从buffer pool刷新到磁盘前, 为了保证数据安全, 先将数据写入双写缓冲区文件中, 便于系统异常时恢复数据. 46-- redo log: 重做日志, 用来实现事务持久性. 该日志由两部分组成:重做日志缓冲(redo log buffer, 内存中), 重做日志文件(redo log, 磁盘中, ib_logfile0, ib_logfile1), 47-- 当事务提交之后会把所有修改信息都会存到该日志中, 用于在刷新脏页到磁盘时发生错误进行数据恢复. 这文件循环写, 事务提交里面的数据没有意义了 48 49 50-- 后台线程 51-- 1. master thread: 核心后台线程, 负责调度其他线程, 还负责将缓冲池中的数据异步刷新到磁盘中, 保持数据一致性, 还包括脏页的刷新, 合并插入缓存, undo页的回收 52-- 2. io thread: Innodb引擎中大量使用了aio来处理io请求, 可以极大提升数据库性能, 而io thread主要负责这些io请求的回调. 53-- read thread: 默认4个, 负责读操作 54-- write thread: 默认4个, 负责写操作 55-- log thread: 默认1个, 负责将日志缓冲区刷新到磁盘 56-- insert buffer thread: 默认1个, 负责将写缓冲区的内容刷新到磁盘 57-- 查看Innodb引擎的状态信息, 里面有线程信息 58show engine innodb status ; 59-- 3. purge thread: 用于回收事务已经提交的undo log. 事务提交后undo log可能不用了,用它回收. 60-- 4. page cleaner thread: 协助master thread刷新脏页到磁盘的线程, 减轻master thread的压力, 减少阻塞. 61 62 63-- 事务原理 64-- 事务的原子性, 一致性, 持久性由redo log和undo log保证 65-- 事务的隔离性由锁和MVCC(多版本并发控制)保证 66 67-- redo log(保证持久性) 68-- redo log: 重做日志, 记录的是事务提交时数据页的物理修改, 用来实现事务持久性. 该日志由两部分组成:重做日志缓冲(redo log buffer, 内存中), 重做日志文件(redo log, 磁盘中), 69-- 当事务提交之后会把所有修改信息都会存到该日志中, 用于在刷新脏页到磁盘时发生错误进行数据恢复. 这文件循环写, 事务提交, 里面的数据没有意义了 70-- 流程: 对缓冲区buffer pool数据进行增删改, 这时页面变成脏页, 同时将增删改的数据记录在redolog buffer记录数据页物理变化, 事务提交时将log buffer刷新到磁盘文件中ib_logfile0/1 71-- 之后脏页刷新到磁盘. 如果脏页刷新到磁盘失败了, 可以通过redo log恢复 72 73-- undo log(保证原子性) 74-- 回滚日志, 用于记录数据被修改前的信息, 作用包含两个:提供回滚和MVCC 75-- undo log和redo log记录物理日志不一样, 它是逻辑日志. 可以认为当delete一条记录时, undo log中会记录一条对应的insert记录, 反制一番, 当update一条记录时, 76-- 它记录一条对应相反的update记录. 当执行rollback时, 就可以从undo log中逻辑记录读取到相应的内容并进行回滚 77-- undo log销毁: undo log在事务执行时产生, 事务提交时, 并不会立即删除undo log, 因为这些日志可能还用于mvcc 78-- undo log存储: undo log采用段的方式进行管理和记录, 存放在rollback segment回滚段中, 内部包含1024个undo log segment 79 80 81 82-- MVCC 83-- 基本概念 84-- 当前读: 读取的是记录的最新版本, 读取时还要保证其他并发事务不能修改当前记录, 会对读取的记录进行加锁. 85-- 如select ... lock in share mode(共享锁), select ... for update , update, insert, delete(排它锁)都是一种当前读 86begin; 87select * from learndatabase.user; -- 在别的事务commit之前和之后去读到的都是同样的数据, 可重复读 88select * from learndatabase.user lock in share mode ; -- 别的事务commit之后可以读取到最新的数据. 89-- 快照读: 简单的select(不加锁)就是快照读, 快照读, 读取的是记录数据的可见版本, 有可能是历史数据, 不加锁, 是非阻塞读 90begin; 91select * from learndatabase.user; -- 在别的事务commit之前去读,生成一个快照 92select * from learndatabase.user; -- 在别的事务commit之后读, 依旧读的是之前的快照 93-- read committed: 每次select都生成一个快照读 94-- repeatable read: 开启事务后第一个select语句才是快照读的地方. 95-- serializable: 快照读退化成当前读, 每次读取都会加锁. 96-- MVCC: 维护一个数据的多个版本, 使得读写操作没有冲突, 快照读为mysql实现MVCC提供了一个非阻塞读功能, 还需要依赖与数据库记录中的三个隐式字段, undo log日志, readview. 97 98 99-- 实现原理 100-- 记录中的隐藏字段 101-- 1.DB_TRX_ID: 最近修改事务ID. 记录插入这条记录或最后一次修改该记录的事务ID(事务ID是从1自增的) 102-- 2.DB_ROLL_PTR: 回滚指针. 指向这条记录的上一个版本, 用于配合undo log, 指向上个版本. 103-- 3.DB_ROW_ID: 隐藏主键. 当表结构没有指定主键时会生成该隐藏字段. 104-- 查看隐藏字段 105ibd2sdi user.ibd 106 107-- uodo log: 回滚日志, 在insert, update, delete的时候产生的便于数据回滚的日志 108-- 当insert时, 产生的undo log只在回滚时需要, 在事务提交后便被立即删除 109-- 当update, delete时, undo log不止在回滚时需要, 在快照读时也需要, 不会被立刻删除 110 111-- undo log版本链 112-- 不同事务或相同事务对同一条记录进行修改, 会导致该记录的undo log生成一条记录版本链表, 头部是最新的旧记录, 尾部是最早的旧记录. 113-- undo log记得是旧记录的所有东西, 里面就包括了DB_ROLL_PTR指针, 所以旧记录的该字段指向的是下一条旧记录 114 115-- readview: 读视图. 是快照读sql执行的MVCC提取数据的依据, 记录并维护系统当前活跃的事务(未提交的)id 116-- 包含四个核心字段: 117-- 1.m_ids:当前活跃的事物ID集合(没有commit的事务id) 118-- 2.min_trx_id: 最小活跃事物ID(m_ids中的最小值) 119-- 3.max_trx_id: 预分配事务ID, 当前最大事务ID+1(事务是自增的, 下一个就是+1) 120-- 4.creator_trx_id: readview创建者的事务ID. 121-- 版本链数据访问规则: (trx_id代表当前这条记录对应的事务的id, 就是db_trx_id) 122-- 1. trx_id == creatr_trx_id时 可以访问该版本. (说明数据是当前事务更改的) 123-- 2. trx_id \u0026lt; min_trx_id时 可以访问该版本 (说明事务已经提交了) 124-- 3. trx_id \u0026gt; max_trx_id时 不可以访问该版本. (说明该事务是在readview生成后才开启, 这里感觉可以取等) 125-- 4. min_trx_id \u0026lt;= trx_id \u0026lt;= max_trx_id且trx_id不在m_ids中 可以访问该版本 (说明数据已经提交) 126-- 不同的隔离级别, 生成readview的时机不同: 127-- read committed: 在事务中每次执行快照读时生成readview 128-- repeatable read: 仅在事务第一次执行快照读时生成readview, 后续复用该readview 129 130-- 原理分析(rc级别) 131-- read committed: 在事务中每次执行快照读时生成readview 132-- 简单来说就沿着undo log日志, 从新往旧每一条记录的db_trx_id去和规则作对比, 如果都不能访问则沿着版本链往下继续找直到满足条件为止. 133-- 原理分析(rr级别) 134-- 与rr唯一不同就是两次查询的readview不同罢了. 所以rc两次查询可能不同, rr都是一样的. 可重复读嘛 ","date":"2024-05-25","permalink":"/posts/tech/java-2-mysql/","series":["Java"],"tags":["","",""],"title":"MySQL学习笔记"},{"categories":["计算机"],"content":"说明 这里记录不需要在代码中记录\u0026amp;已经存在的笔记的知识点.\n代码的知识点已经打包:\n同时还有一份在线文档:\n需要复习的时候三个部分同时查阅.\nMybatisPlus 实现基本的CRUD 为了简化单表CRUD，MybatisPlus提供了一个基础的BaseMapper接口，其中已经实现了单表的CRUD. 就是mapper中什么都不需要写, 就已经可以进行基本的CRUD了.\n1public interface UserMapper extends BaseMapper\u0026lt;User\u0026gt; { 2} 1\t@Test 2 void testInsert() { 3 User user = new User(); 4 user.setId(5L); 5 user.setUsername(\u0026#34;Lucy\u0026#34;); 6 user.setPassword(\u0026#34;123\u0026#34;); 7 user.setPhone(\u0026#34;18688990011\u0026#34;); 8 user.setBalance(200); 9 user.setInfo(\u0026#34;{\\\u0026#34;age\\\u0026#34;: 24, \\\u0026#34;intro\\\u0026#34;: \\\u0026#34;英文老师\\\u0026#34;, \\\u0026#34;gender\\\u0026#34;: \\\u0026#34;female\\\u0026#34;}\u0026#34;); 10 user.setCreateTime(LocalDateTime.now()); 11 user.setUpdateTime(LocalDateTime.now()); 12 userMapper.insert(user); 13 } 只需要继承BaseMapper就能省去所有的单表CRUD\nUserMapper在继承BaseMapper的时候指定了一个泛型, 泛型中的User就是与数据库对应的PO.\nMybatisPlus就是根据PO实体的信息来推断出表的信息，从而生成SQL的。默认情况下：\n MybatisPlus会把PO实体的类名驼峰转下划线作为表名 MybatisPlus会把PO实体的所有变量名驼峰转下划线作为表的字段名，并根据变量类型推断字段类型 MybatisPlus会把名为id的字段作为主键  常见注解 如果默认的实现与实际场景不符，MybatisPlus提供了一些注解便于我们声明表信息。\n@TableName  描述：表名注解，标识实体类对应的表 使用位置：实体类  还可以指定一些属性, 其中autoResultMap适用于类与类嵌套时, 自动结果集映射.\n@TableId  描述：主键注解，标识实体类中的主键字段 使用位置：实体类的主键字段  支持两个属性：\n   属性 类型 必须指定 默认值 描述     value String 否 \u0026quot;\u0026quot; 表名   type Enum 否 IdType.NONE 指定主键类型    IdType比较常见的有三种：\n AUTO：利用数据库的id自增长 INPUT：手动生成id ASSIGN_ID：雪花算法生成Long类型的全局唯一id，这是默认的ID策略  @TableField  描述：普通字段注解  一般情况下我们并不需要给字段添加@TableField注解，一些特殊情况除外：\n 成员变量名与数据库字段名不一致 成员变量是以isXXX命名，按照JavaBean的规范，MybatisPlus识别字段时会把is去除，这就导致与数据库不符。 成员变量名与数据库一致，但是与数据库的关键字冲突。使用@TableField注解给字段名添加转义字符：``  例:\n1mybatisplus通过扫描实体类, 并基于反射获取实体类信息作为数据库表信息 2实现CRUD数据库表信息的约定: 31. 类名驼峰转下划线作为数据库表名, 如userName的类对应的数据库就是user_name 42. 名为id的字段作为主键 53. 变量名驼峰转下划线违表的字段名, 如createTime字段在数据库表中的字段就是create_time 6 7符合约定的不用配置直接用, 不符合约定需自定义表名和字段名, 通过注解: 8@TableName指定表名 @TableId指定主键 @TableField指定字段 9 10这个在pojo中定义, 如 11@TableName(\u0026#34;tb_user\u0026#34;) 12public class User { 13// idtype枚举中代表了主键的三种类型: 14// 1. AUTO: 自增长 15// 2. INPUT: 通过set方法自动输入 16// 3. ASSIGN_ID: 分配ID,mp提供的IdentifierGenerator的nextID生成id, 不需要手动提供. 这是默认策略 17 @TableId(value = \u0026#34;index\u0026#34;, type = IdType.AUTO) 18 private Long id; 19// 使用@TableField的场景 20// 1. 成员变量名与数据库的字段名不一致 21// 2. 成员变量以is开头且是布尔值, 如is_married会被解析为married 22// 3. 成员变量名与数据库关键字冲突, order就是关键字 23// 4. 成员变量不是数据库字段, 下面的address字段数据库中没有. 24 @TableField(\u0026#34;username\u0026#34;) 25 private String name; 26 @TableField(\u0026#34;is_married\u0026#34;) 27 private Boolean isMarried; 28 @TableField(\u0026#34;`order`\u0026#34;) 29 private Integer order; 30 @TableField(exist = false) 31 private String address; 32} 核心功能 为了实现复杂的SQL需要用到核心功能.\n条件构造器 是为了代替where语句. BaseMapper中提供的相关方法除了以id作为where条件以外，还支持更加复杂的where条件。这些方法中的参数中的Wrapper就是条件构造的抽象类. Wrapper的子类AbstractWrapper提供了where中包含的所有条件构造方法, 而QueryWrapper在AbstractWrapper的基础上拓展了一个select方法，允许指定查询字段, UpdateWrapper在AbstractWrapper的基础上拓展了一个set方法，允许指定SQL中的SET部分. 所以我们根据需要选择不同的wrapper实现类.\n条件构造器wrapper: 主键的查询无法满足要求, 需要用wrapper满足更复杂的sql需求, 定义where条件等.\n queryWrapper来代替select, delete, update中的where部分 updateWrapper通常在set语句比较特殊才使用 lambda的wrapper支持lambda  queryWrapper(应对复杂的where) 查询名字带o的, 存款大于等于1000的人的id,名字, 信息, 收入\nselect id,username,info,balance from user where username like ? and balance \u0026gt;= ?\n1 @Test 2 void testQueryWrapper(){ 3// 1. 构建查询条件 4 QueryWrapper\u0026lt;User\u0026gt; wrapper = new QueryWrapper\u0026lt;User\u0026gt;() 5 .select(\u0026#34;id\u0026#34;, \u0026#34;username\u0026#34;, \u0026#34;info\u0026#34;, \u0026#34;balance\u0026#34;) 6 .like(\u0026#34;username\u0026#34;, \u0026#34;o\u0026#34;) 7 .ge(\u0026#34;balance\u0026#34;, 1000); 8// 2. 查询 9 List\u0026lt;User\u0026gt; users = userMapper.selectList(wrapper); 10 users.forEach(System.out::println); 11 } 12// eq是等于, ne不等于, gt大于, ge大于等于, lt小于, le小于等于 更新时使用queryWrapper\n将名字为jack的人的存款设置为2000\nupdate user set balance=2000 where username=\u0026ldquo;jack\u0026rdquo;\n1 @Test 2 void testUpdateByQueryWrapper(){ 3// 1. 要更新的数据, user中非null字段都会作为set语句 4 User user = new User(); 5 user.setBalance(2000); 6// 2.更新的条件 7 QueryWrapper\u0026lt;User\u0026gt; wrapper = new QueryWrapper\u0026lt;User\u0026gt;().eq(\u0026#34;username\u0026#34;, \u0026#34;jack\u0026#34;); 8// 3.执行更新 9 userMapper.update(user, wrapper); 10 } UpdateWrapper(应对复杂的set) 基于BaseMapper中的update方法更新时只能直接赋值，对于一些复杂的需求就难以实现。\n将id为1,2,4的用户余额减200\nupdate user set balance = balance - 200 where id in (1,2,4)\nSET的赋值结果是基于字段现有值的，这个时候就要利用UpdateWrapper中的setSql功能了\n1 void testUpdateWrapper(){ 2 List\u0026lt;Long\u0026gt; ids = List.of(1L,2L,4L); 3 UpdateWrapper\u0026lt;User\u0026gt; wrapper = new UpdateWrapper\u0026lt;User\u0026gt;() 4 .setSql(\u0026#34;balance = balance - 200\u0026#34;) 5 .in(\u0026#34;id\u0026#34;, ids); 6 userMapper.update(null, wrapper); 7 } LambdaWrapper(为了解字符串魔法值) 无论是QueryWrapper还是UpdateWrapper在构造条件的时候都需要写死字段名称，会出现字符串魔法值(“字符串魔法值”通常指的是硬编码在代码中的字符串常量，这些常量没有明确的意义或者上下文，可能难以理解和维护)。这在编程规范中显然是不推荐的。\n其中一种办法是基于变量的gettter方法结合反射技术。因此我们只要将条件对应的字段的getter方法传递给MybatisPlus，它就能计算出对应的变量名了。而传递方法可以使用JDK8中的方法引用和Lambda表达式。\n因此MybatisPlus又提供了一套基于Lambda的Wrapper，包含两个：\n  LambdaQueryWrapper\n  LambdaUpdateWrapper\n  分别对应QueryWrapper和UpdateWrapper\n1// 使用Lambda的wrapper来接触硬编码模式, 这样里面没有字符串了 2 3 void testLambdaQueryWrapper(){ 4// 1. 构建查询条件 5 LambdaQueryWrapper\u0026lt;User\u0026gt; wrapper = new LambdaQueryWrapper\u0026lt;User\u0026gt;() 6 .select(User::getId, User::getUsername, User::getInfo, User::getBalance) 7 .like(User::getUsername, \u0026#34;o\u0026#34;) 8 .ge(User::getBalance, 1000); 9// 2. 查询 10 List\u0026lt;User\u0026gt; users = userMapper.selectList(wrapper); 11 users.forEach(System.out::println); 12 } 自定义SQL 语句\n1UpdateWrapper\u0026lt;User\u0026gt; wrapper = new UpdateWrapper\u0026lt;User\u0026gt;() 2 .setSql(\u0026#34;balance = balance - 200\u0026#34;) 3 .in(\u0026#34;id\u0026#34;, ids); 中, 这种写法在某些企业也是不允许的，因为SQL语句最好都维护在持久层，而不是业务层。就当前案例来说，由于条件是in语句，只能将SQL写在Mapper.xml文件，利用foreach来生成动态SQL。 这实在是太麻烦了。假如查询条件更复杂，动态SQL的编写也会更加复杂。\n所以，MybatisPlus提供了自定义SQL功能，可以让我们利用Wrapper生成查询条件，再结合Mapper.xml编写SQL\n基本用法 利用mp的wrapper构建复杂的where条件, 然后自己定义sql语句中剩下的部分\n  基于wrapper构建where条件\n  在mapper接口方法参数中用param注解声明变量名称, 必须是ew\n  自定义sql, 并使用wrapper条件(这个可以在xml中, 也可以在接口中用注解写) 使用${ew.customSqlSegment}调用mp的where条件\n  这样做是为了满足不在业务层编写sql, 同时享受mp生成sql条件这种便利, 上面的sql是在业务层写sql了.\n1@Test 2 void testCustomSqlUpdate(){ 3// 1.更新条件 4 List\u0026lt;Long\u0026gt; ids = List.of(1L, 2L, 4L); 5 int amount = 200; 6// 2.定义条件 7 QueryWrapper\u0026lt;User\u0026gt; wrapper = new QueryWrapper\u0026lt;User\u0026gt;().in(\u0026#34;id\u0026#34;, ids); 8// 3. 调用自定义sql方法 9 userMapper.updateBalanceByIds(wrapper, amount); 10 } 1public interface UserMapper extends BaseMapper\u0026lt;User\u0026gt; { 2 @Select(\u0026#34;UPDATE user SET balance = balance - #{money} ${ew.customSqlSegment}\u0026#34;) 3 void deductBalanceByIds(@Param(\u0026#34;money\u0026#34;) int money, @Param(\u0026#34;ew\u0026#34;) QueryWrapper\u0026lt;User\u0026gt; wrapper); 4} 或者\n1\u0026lt;update id=\u0026#34;updateBalanceByIds\u0026#34;\u0026gt; 2 UPDATE user SET balance = balance - #{amount} ${ew.customSqlSegment} 3\u0026lt;/update\u0026gt; 多表查询 理论上来讲MyBatisPlus是不支持多表查询的，不过我们可以利用Wrapper中自定义条件结合自定义SQL来实现多表查询的效果。 例如，我们要查询出所有收货地址在北京的并且用户id在1、2、4之中的用户 要是自己基于mybatis实现SQL，大概是这样的：\n1\u0026lt;select id=\u0026#34;queryUserByIdAndAddr\u0026#34; resultType=\u0026#34;com.itheima.mp.domain.po.User\u0026#34;\u0026gt; 2 SELECT * 3 FROM user u 4 INNER JOIN address a ON u.id = a.user_id 5 WHERE u.id 6 \u0026lt;foreach collection=\u0026#34;ids\u0026#34; separator=\u0026#34;,\u0026#34; item=\u0026#34;id\u0026#34; open=\u0026#34;IN (\u0026#34; close=\u0026#34;)\u0026#34;\u0026gt; 7 #{id} 8 \u0026lt;/foreach\u0026gt; 9 AND a.city = #{city} 10 \u0026lt;/select\u0026gt; 可以看出其中最复杂的就是WHERE条件的编写，如果业务复杂一些，这里的SQL会更变态。\n但是基于自定义SQL结合Wrapper的玩法，我们就可以利用Wrapper来构建查询条件，然后手写SELECT及FROM部分，实现多表查询。\n查询条件这样来构建：\n1@Test 2void testCustomJoinWrapper() { 3 // 1.准备自定义查询条件 4 QueryWrapper\u0026lt;User\u0026gt; wrapper = new QueryWrapper\u0026lt;User\u0026gt;() 5 .in(\u0026#34;u.id\u0026#34;, List.of(1L, 2L, 4L)) 6 .eq(\u0026#34;a.city\u0026#34;, \u0026#34;北京\u0026#34;); 7 8 // 2.调用mapper的自定义方法 9 List\u0026lt;User\u0026gt; users = userMapper.queryUserByWrapper(wrapper); 10 11 users.forEach(System.out::println); 12} 然后在UserMapper中自定义方法：\n1@Select(\u0026#34;SELECT u.* FROM user u INNER JOIN address a ON u.id = a.user_id ${ew.customSqlSegment}\u0026#34;) 2List\u0026lt;User\u0026gt; queryUserByWrapper(@Param(\u0026#34;ew\u0026#34;)QueryWrapper\u0026lt;User\u0026gt; wrapper); 当然，也可以在UserMapper.xml中写SQL：\n1\u0026lt;select id=\u0026#34;queryUserByIdAndAddr\u0026#34; resultType=\u0026#34;com.itheima.mp.domain.po.User\u0026#34;\u0026gt; 2 SELECT * FROM user u INNER JOIN address a ON u.id = a.user_id ${ew.customSqlSegment} 3\u0026lt;/select\u0026gt; Service接口 MybatisPlus不仅提供了BaseMapper，还提供了通用的Service接口及默认实现，封装了一些常用的service模板方法。 通用接口为IService，默认实现为ServiceImpl\nCRUD 新增:\n save是新增单个元素 saveBatch是批量新增 saveOrUpdate是根据id判断，如果数据存在就更新，不存在则新增 saveOrUpdateBatch是批量的新增或修改  删除:\n removeById：根据id删除 removeByIds：根据id批量删除 removeByMap：根据Map中的键值对为条件删除 remove(Wrapper\u0026lt;T\u0026gt;)：根据Wrapper条件删除 ~~removeBatchByIds~~：暂不支持  修改:\n updateById：根据id修改 update(Wrapper\u0026lt;T\u0026gt;)：根据UpdateWrapper修改，Wrapper中包含set和where部分 update(T，Wrapper\u0026lt;T\u0026gt;)：按照T内的数据修改与Wrapper匹配到的数据 updateBatchById：根据id批量修改  查询一条Get:\n getById：根据id查询1条数据 getOne(Wrapper\u0026lt;T\u0026gt;)：根据Wrapper查询1条数据 getBaseMapper：获取Service内的BaseMapper实现，某些时候需要直接调用Mapper内的自定义SQL时可以用这个方法获取到Mapper  查询多条List:\n listByIds：根据id批量查询 list(Wrapper\u0026lt;T\u0026gt;)：根据Wrapper条件查询多条数据 list()：查询所有  计数Count:\n count()：统计所有数量 count(Wrapper\u0026lt;T\u0026gt;)：统计符合Wrapper条件的数据数量  getBaseMapper：\n当我们在service中要调用Mapper中自定义SQL时，就必须获取service对应的Mapper，就可以通过这个方法\n基本用法 ①由于Service中经常需要定义与业务有关的自定义方法，因此我们不能直接使用IService，而是自定义Service接口，然后继承IService以拓展方法。同时，让自定义的Service实现类继承ServiceImpl，这样就不用自己实现IService中的接口了。\n1.首先，定义IUserService，继承IService：\n1package com.itheima.mp.service; 2 3public interface IUserService extends IService\u0026lt;User\u0026gt; { 4 // 拓展自定义方法 5} 2.然后，编写UserServiceImpl类，继承ServiceImpl，实现UserService：\n1package com.itheima.mp.service.impl; 2 3@Service 4public class UserServiceImpl extends ServiceImpl\u0026lt;UserMapper, User\u0026gt; 5 implements IUserService { 6} ②快速实现下面4个接口：\n   编号 接口 请求方式 请求路径 请求参数 返回值     1 新增用户 POST /users 用户表单实体 无   2 删除用户 DELETE /users/{id} 用户id 无   3 根据id查询用户 GET /users/{id} 用户id 用户VO   4 根据id批量查询 GET /users 用户id集合 用户VO集合    1@Api(tags = \u0026#34;用户管理接口\u0026#34;) 2@RequestMapping(\u0026#34;/users\u0026#34;) 3@RestController 4@RequiredArgsConstructor 5public class UserController { 6 7// 这里spring不推荐自动注入, 我们用构造函数代替, 将字段设置为final然后再类上加注解@RequiredArgsConstructor就可以自动生成了 8// @Autowired 9// private IUserService userService; 10 private final IUserService userService; 11 12// 对于简单的逻辑, 直接调用原生的service方法就行了, 对于复杂的业务逻辑需要自定义service, 对于复杂的sql需要自定义mapper并调用 13 @ApiOperation(\u0026#34;新增用户接口\u0026#34;) 14 @PostMapping 15 public void saveUser(@RequestBody UserFormDTO userDTO){ 16// 1. 利用hutu工具中的BeanUtil将DTO拷贝到PO 17 User user = BeanUtil.copyProperties(userDTO, User.class); 18// 2.新增 19 userService.save(user); 20 } 21 22 @ApiOperation(\u0026#34;删除用户接口\u0026#34;) 23 @DeleteMapping(\u0026#34;{id}\u0026#34;) 24 public void deleteUserById(@ApiParam(\u0026#34;用户id\u0026#34;) @PathVariable(\u0026#34;id\u0026#34;) Long id){ 25 userService.removeById(id); 26 } 27 28 @ApiOperation(\u0026#34;根据id查询用户接口\u0026#34;) 29 @GetMapping(\u0026#34;{id}\u0026#34;) 30 public UserVO queryUserById(@ApiParam(\u0026#34;用户id\u0026#34;) @PathVariable(\u0026#34;id\u0026#34;) Long id){ 31// User user = userService.getById(id); 32//// 将po拷贝到vo 33// return BeanUtil.copyProperties(user, UserVO.class); 34 return userService.queryUserAndAddressById(id); 35 } 36 37 @ApiOperation(\u0026#34;根据ids批量查询用户接口\u0026#34;) 38 @GetMapping 39 public List\u0026lt;UserVO\u0026gt; queryUserByIds(@ApiParam(\u0026#34;用户id集合\u0026#34;) @RequestParam(\u0026#34;ids\u0026#34;) List\u0026lt;Long\u0026gt; ids){ 40// List\u0026lt;User\u0026gt; user = userService.listByIds(ids); 41//// 将po拷贝到vo 42// return BeanUtil.copyToList(user, UserVO.class); 43 return userService.queryUserAndAddressByIds(ids); 44 } 45} ③不过，一些带有业务逻辑的接口则需要在service中自定义实现了。例如下面的需求：\n 根据id扣减用户余额  这看起来是个简单修改功能，只要修改用户余额即可。但这个业务包含一些业务逻辑处理：\n 判断用户状态是否正常 判断用户余额是否充足  这些业务逻辑都要在service层来做，另外更新余额需要自定义SQL，要在mapper中来实现。因此，我们除了要编写controller以外，具体的业务还要在service和mapper中编写。\n首先在UserController中定义一个方法：\n1@ApiOperation(\u0026#34;根据id扣减用户余额\u0026#34;) 2@PutMapping(\u0026#34;/{id}/document/{money}\u0026#34;) 3public void deductMoneyById( 4 @ApiParam(\u0026#34;用户id\u0026#34;) @PathVariable(\u0026#34;id\u0026#34;) Long id, 5 @ApiParam(\u0026#34;扣减的金额\u0026#34;) @PathVariable(\u0026#34;money\u0026#34;) Integer money){ 6 userService.deductBalance(id, money); 7} 然后是UserService接口：\n1public interface IUserService extends IService\u0026lt;User\u0026gt; { 2 void deductBalance(Long id, Integer money); 3} 最后是UserServiceImpl实现类：\n1//我们的service接口继承IService, 然后我们service接口实现类继承IService接口的实现类ServiceImpl, 这样就不需要一一实现就可以用了 2@Service 3public class IUserServiceImpl extends ServiceImpl\u0026lt;UserMapper, User\u0026gt; implements IUserService { 4 5 @Override 6 public void deductBalance(Long id, Integer money) { 7 //1.查询用户 8 //调用的方法, 自己就是service不需要注入额外的service. 9// User user = this.getById(id); 10 User user = getById(id); 11 //2.校验用户状态 12 //反向校验保证不会出现if嵌套 13 if(user == null || user.getStatus() == UserStatus.FROZEN){ 14 throw new RuntimeException(\u0026#34;用户状态异常\u0026#34;); 15 } 16 //3.校验余额是否充足 17 if(user.getBalance() \u0026lt; money){ 18 throw new RuntimeException(\u0026#34;用户余额不足\u0026#34;); 19 } 20 //4.扣减余额 update user set balance = balance - money where id = id; 21 //service不写sql, 去mapper中写. 22 //如果要使用mapper在父类serviceimpl中已经注入base mapper了可以直接用 23 baseMapper.deductBalance(id, money); 24 } 25} 最后是mapper：\n1public interface UserMapper extends BaseMapper\u0026lt;User\u0026gt; { 2 @Update(\u0026#34;update user set balance = balance - #{money} where id = #{id}\u0026#34;) 3 void deductBalance(@Param(\u0026#34;id\u0026#34;) Long id, @Param(\u0026#34;money\u0026#34;) Integer money); 4} Lambda(结合服务层与wrapper) IService中还提供了Lambda功能来简化我们的复杂查询及更新功能。\n案例一：实现一个根据复杂条件查询用户的接口，查询条件如下：\n name：用户名关键字，可以为空 status：用户状态，可以为空 minBalance：最小余额，可以为空 maxBalance：最大余额，可以为空  在UserController中定义一个controller方法：\n1@GetMapping(\u0026#34;/list\u0026#34;) 2@ApiOperation(\u0026#34;根据id集合查询用户\u0026#34;) 3public List\u0026lt;UserVO\u0026gt; queryUsers(UserQuery query){ 4 // 1.组织条件 5 String username = query.getName(); 6 Integer status = query.getStatus(); 7 Integer minBalance = query.getMinBalance(); 8 Integer maxBalance = query.getMaxBalance(); 9 LambdaQueryWrapper\u0026lt;User\u0026gt; wrapper = new QueryWrapper\u0026lt;User\u0026gt;().lambda() 10 .like(username != null, User::getUsername, username) 11 .eq(status != null, User::getStatus, status) 12 .ge(minBalance != null, User::getBalance, minBalance) 13 .le(maxBalance != null, User::getBalance, maxBalance); 14 // 2.查询用户 15 List\u0026lt;User\u0026gt; users = userService.list(wrapper); 16 // 3.处理vo 17 return BeanUtil.copyToList(users, UserVO.class); 18} 在组织查询条件的时候，我们加入了 username != null 这样的参数，意思就是当条件成立时才会添加这个查询条件，类似Mybatis的mapper.xml文件中的\u0026lt;if\u0026gt;标签。这样就实现了动态查询条件效果了。\n不过，上述条件构建的代码太麻烦了。 因此Service中对LambdaQueryWrapper和LambdaUpdateWrapper的用法进一步做了简化。我们无需自己通过new的方式来创建Wrapper，而是直接调用lambdaQuery和lambdaUpdate方法：\n基于Lambda查询：\n1@ApiOperation(\u0026#34;根据复杂条件批量查询用户接口\u0026#34;) 2 @GetMapping(\u0026#34;/list\u0026#34;) 3 public List\u0026lt;UserVO\u0026gt; queryUsers(UserQuery query){ 4 List\u0026lt;User\u0026gt; user = userService.queryUsers( 5 query.getName(), query.getStatus(), query.getMinBalance(), query.getMaxBalance()); 6// 将po拷贝到vo 7 return BeanUtil.copyToList(user, UserVO.class); 8 } 1//查询用户姓名, 状态, 存款余额介于最大和最小之间的用户 2 @Override 3 public List\u0026lt;User\u0026gt; queryUsers(String name, Integer status, Integer minBalance, Integer maxBalance) { 4 //IService的lambda查询, 这个查询条件替代mapper中的复杂的语句, 当条件满足时才去添加对应的sql语句 5 //lambdaQuery,直接将wrapper和查询一步到位.不需要单独new wrapper. 6 return lambdaQuery() 7 .like(name != null, User::getUsername, name) 8 .eq(status != null, User::getStatus, status) 9 .ge(minBalance != null, User::getBalance, minBalance) 10 .le(maxBalance != null, User::getBalance, maxBalance) 11 .list(); // 相应返回一个就写one(),分页写page(),数目写count(),列表写list() 12 } IService中的lambdaUpdate方法可以非常方便的实现复杂更新业务。\n案例二:\n改造根据id修改用户余额的接口，要求如下\n 如果扣减后余额为0，则将用户status修改为冻结状态（2）  也就是说我们在扣减用户余额时，需要对用户剩余余额做出判断，如果发现剩余余额为0，则应该将status修改为2，这就是说update语句的set部分是动态的。\n1//修改用户余额接口, 要求对用户状态校验, 用户余额校验, 如果扣减口为0了则修改状态为冻结状态(2) 2 @Override 3 @Transactional 4 public void deductBalance(Long id, Integer money) { 5 //1.查询用户 6 //调用的方法, 自己就是service不需要注入额外的service. 7// User user = this.getById(id); 8 User user = getById(id); 9 //2.校验用户状态 10 //反向校验保证不会出现if嵌套 11 if(user == null || user.getStatus() == UserStatus.FROZEN){ 12 throw new RuntimeException(\u0026#34;用户状态异常\u0026#34;); 13 } 14 //3.校验余额是否充足 15 if(user.getBalance() \u0026lt; money){ 16 throw new RuntimeException(\u0026#34;用户余额不足\u0026#34;); 17 } 18 //4.扣减余额 update user set balance = balance - money where id = id; 19 //service不写sql, 去mapper中写. 20 //如果要使用mapper在父类serviceimpl中已经注入base mapper了可以直接用 21 //baseMapper.deductBalance(id, money); 22 int remainBalance = user.getBalance() - money; 23 lambdaUpdate() 24 .set(User::getBalance, remainBalance) 25 .set(remainBalance == 0, User::getStatus, UserStatus.FROZEN) 26 .eq(User::getId, id) 27 // 构建条件 28 .eq(User::getBalance, user.getBalance()) //乐观锁. 有并发安全风险, 当最后查到的余额等于用户的余额才update 29 .update(); // 最后执行update 30 } 优化批量新增(批处理功能) 测试逐条插入数据和MybatisPlus的批处理(saveBatch):\n1//普通的for循环添加10万条数据 2//相对于10万次网络请求, 很慢 3@Test 4void testSaveOneByOne(){ 5 long b = System.currentTimeMillis(); 6 for (int i = 0; i \u0026lt; 100000; i++) { 7 userService.save(buildUser(i)); 8 } 9 long e = System.currentTimeMillis(); 10 System.out.println(\u0026#34;cost time: \u0026#34; + (e-b)); 11} 12//使用IService添加10万数据 13//预编译成1000条sql语句, 一次性提交1000条, 相对于100次网络请求 14//但是1000条sql还是慢了,想办法变成一条sql, 只需要添加一条mysql配置,让引擎来完成:rewriteBatchedStatements=true 15//拼接到yaml配置jdbcurl后面. 16@Test 17void testSaveBatch(){ 18 //每次批量插入1000条 19 ArrayList\u0026lt;User\u0026gt; users = new ArrayList\u0026lt;\u0026gt;(1000); 20 long b = System.currentTimeMillis(); 21 for (int i = 0; i \u0026lt; 100000; i++) { 22 users.add(buildUser(i)); 23 if(i%1000 == 0){ 24 userService.saveBatch(users); 25 users.clear(); 26 } 27 } 28} 可以看到使用了批处理以后，比逐条新增效率提高了10倍左右，性能还是不错的。\nMybatisPlus的批处理是基于PrepareStatement的预编译模式，然后批量提交，最终在数据库执行时还是会有多条insert语句，逐条插入数据。如果想要得到最佳性能，最好是将多条SQL合并为一条:\n1Preparing: INSERT INTO user ( username, password, phone, info, balance, create_time, update_time ) VALUES ( ?, ?, ?, ?, ?, ?, ? ) 2Parameters: user_1, 123, 18688190001, \u0026#34;\u0026#34;, 2000, 2023-07-01, 2023-07-01 3Parameters: user_2, 123, 18688190002, \u0026#34;\u0026#34;, 2000, 2023-07-01, 2023-07-01 4Parameters: user_3, 123, 18688190003, \u0026#34;\u0026#34;, 2000, 2023-07-01, 2023-07-01 5 6 7INSERT INTO user ( username, password, phone, info, balance, create_time, update_time ) 8VALUES 9(user_1, 123, 18688190001, \u0026#34;\u0026#34;, 2000, 2023-07-01, 2023-07-01), 10(user_2, 123, 18688190002, \u0026#34;\u0026#34;, 2000, 2023-07-01, 2023-07-01), 11(user_3, 123, 18688190003, \u0026#34;\u0026#34;, 2000, 2023-07-01, 2023-07-01), 12(user_4, 123, 18688190004, \u0026#34;\u0026#34;, 2000, 2023-07-01, 2023-07-01); MySQL的客户端连接参数中有这样的一个参数：rewriteBatchedStatements。顾名思义，就是重写批处理的statement语句。\n这个参数的默认值是false，我们需要修改连接参数，将其配置为true\n修改项目中的application.yml文件，在jdbc的url后面添加参数\u0026amp;rewriteBatchedStatements=true:\n1spring:2datasource:3url:jdbc:mysql://127.0.0.1:3306/mp?useUnicode=true\u0026amp;characterEncoding=UTF-8\u0026amp;autoReconnect=true\u0026amp;serverTimezone=Asia/Shanghai\u0026amp;rewriteBatchedStatements=true4driver-class-name:com.mysql.cj.jdbc.Driver5username:root6password:MySQL123再次测试插入10万条数据，可以发现速度有非常明显的提升.\n在ClientPreparedStatement的executeBatchInternal中，有判断rewriteBatchedStatements值是否为true并重写SQL的功能\n扩展功能 代码生成(解决重复性工作) 在使用MybatisPlus以后，基础的Mapper、Service、PO代码相对固定，重复编写也比较麻烦。因此MybatisPlus官方提供了代码生成器根据数据库表结构生成PO、Mapper、Service等相关代码。只不过代码生成器同样要编码使用，也很麻烦。\n在Idea的plugins市场中搜索并安装MyBatisPlus插件, 然后重启你的Idea即可使用。\n刚好数据库中还有一张address表尚未生成对应的实体和mapper等基础代码。我们利用插件生成一下。 首先需要配置数据库地址，在Idea顶部菜单中，找到other，选择Config Database, 在弹出的窗口中填写数据库连接的基本信息\n点击OK保存。然后再次点击Idea顶部菜单中的other，然后选择Code Generator\n在弹出的表单中填写信息：\n\r最终，代码自动生成到指定的位置了\n静态工具(预防循环依赖) 有的时候Service之间也会相互调用，为了避免出现循环依赖问题，MybatisPlus提供一个静态工具类：Db，其中的一些静态方法与IService中方法签名基本一致，也可以帮助我们实现CRUD功能.\n需求：改造根据id用户查询的接口，查询用户的同时返回用户收货地址列表\n1//根据用户id查询用户,还要查询address表上对应用户的地址列表 2@Override 3public UserVO queryUserAndAddressById(Long id) { 4 //1.查询用户 5 User user = getById(id); 6 if(user == null || user.getStatus() == UserStatus.FROZEN){ 7 throw new RuntimeException(\u0026#34;用户状态异常\u0026#34;); 8 } 9 //2.查询地址 10 //使用静态方法查询. 因为如果userService注入addressService,之后addressService也会因为需求注入userService,会出现循环依赖 11 //为了解决循环依赖, 使用静态方法Db完成需求 12 List\u0026lt;Address\u0026gt; addresses = Db.lambdaQuery(Address.class) //添加需要查询类的字节码 13 .eq(Address::getUserId, id).list();//多个地址用list()返回多个. 14 //3.封装po成vo 15 //3.1先将user po装维vo 16 UserVO userVO = BeanUtil.copyProperties(user, UserVO.class); 17 //3.2转地址vo 18 if(CollUtil.isNotEmpty(addresses)){ 19 userVO.setAddresses(BeanUtil.copyToList(addresses, AddressVO.class)); 20 } 21 return userVO; 22} 在查询地址时，我们采用了Db的静态方法，因此避免了注入AddressService，减少了循环依赖的风险。\n逻辑删除 对于一些比较重要的数据，我们往往会采用逻辑删除的方案，即：\n 在表中添加一个字段标记数据是否被删除 当删除数据时把标记置为true 查询时过滤掉标记为true的数据  一旦采用了逻辑删除，所有的查询和删除逻辑都要跟着变化，非常麻烦。\n为了解决这个问题，MybatisPlus就添加了对逻辑删除的支持。\n注意，只有MybatisPlus生成的SQL语句才支持自动的逻辑删除，自定义SQL需要自己手动处理逻辑删除。\n配置逻辑删除字段：\n1mybatis-plus:2global-config:3db-config:4logic-delete-field:deleted#全局逻辑删除的实体的字段名,字段类型可以是boolean,integer.指定数据表里有的字段5logic-delete-value:1#逻辑已删除值(默认1)6logic-not-delete-value:0#逻辑未删除值(默认0)测试： 我们执行一个删除操作：\n1@Test 2void testDeleteByLogic() { 3 // 删除方法与以前没有区别 4 addressService.removeById(59L); 5} 方法与普通删除一模一样，但是底层的SQL逻辑变为update. 查询也会附加where条件.\n通用枚举 User类中有一个用户状态字段, 像这种字段我们一般会定义一个枚举，做业务判断的时候就可以直接基于枚举做比较。但是我们数据库采用的是int类型，对应的PO也是Integer。因此业务操作时必须手动把枚举与Integer转换，非常麻烦。\n因此，MybatisPlus提供了一个处理枚举的类型转换器，可以帮我们把枚举类型与数据库类型自动转换。\n定义枚举 1package com.itheima.mp.enums; 2 3import com.baomidou.mybatisplus.annotation.EnumValue; 4import lombok.Getter; 5 6@Getter 7public enum UserStatus { 8 NORMAL(1, \u0026#34;正常\u0026#34;), 9 FREEZE(2, \u0026#34;冻结\u0026#34;) 10 ; 11 private final int value; 12 private final String desc; 13 14 UserStatus(int value, String desc) { 15 this.value = value; 16 this.desc = desc; 17 } 18} 然后把User类中的status字段从Integer改为UserStatus 类型.\n要让MybatisPlus处理枚举与数据库类型自动转换，我们必须告诉MybatisPlus，枚举中的哪个字段的值作为数据库值。 MybatisPlus提供了@EnumValue注解来标记枚举属性\n1@Getter //getter注解加get方法 2public enum UserStatus { 3 NORMAL(1,\u0026#34;正常\u0026#34;), 4 FROZEN(2,\u0026#34;冻结\u0026#34;), 5 ; 6 @EnumValue //enumValue注解,标明枚举类型中与数据表对应的字段的属性. 这样对于Po的枚举类型变量和数据表字段就可以转化了. 7 private final int value; 8 //前端返回是SpringMVC中Jackson处理的 9 @JsonValue //这个注解是用作前端返回的,. 于是返回的是正常或冻结.这样前端返回这个字段的时候就会返回对应的desc信息 10 private final String desc; 11 12 UserStatus(int value, String desc) { 13 this.value = value; 14 this.desc = desc; 15 } 16} 配置枚举处理器 在application.yaml文件中添加配置：\n1mybatis-plus:2configuration:3default-enum-type-handler:com.baomidou.mybatisplus.core.handlers.MybatisEnumTypeHandler定义枚举的展示字段 为了使页面查询结果也是枚举格式，我们需要修改UserVO中的status属性为UserStatus\n并且，在UserStatus枚举中通过@JsonValue注解标记JSON序列化时展示的字段.\nJSON类型处理器(实体类与数据库字符串的转化) MybatisPlus提供了很多特殊类型字段的类型处理器，解决特殊字段类型与数据库类型转换的问题。例如处理JSON就可以使用JacksonTypeHandler处理器。\n创建实体 1@Data 2@NoArgsConstructor //无参构造 3@AllArgsConstructor(staticName = \u0026#34;of\u0026#34;) //有参构造, 提供静态方法of,这样可以类名+静态方法名构造类. 4public class UserInfo { 5 private Integer age; 6 private String intro; 7 private String gender; 8} 使用类型处理器 就是在需要的字段上面添加注解@TableField并制定类型处理器.\n1@TableField(typeHandler = JacksonTypeHandler.class) //自定义类型处理器, 在需要的字段添加. 这样就可以实现json数据和类的转化 2private UserInfo info; 这样, 传过来的字符串会被正确处理为对象.\n插件功能 MybatisPlus提供了很多的插件功能，进一步拓展其功能。目前已有的插件有：\n PaginationInnerInterceptor：自动分页 TenantLineInnerInterceptor：多租户 DynamicTableNameInnerInterceptor：动态表名 OptimisticLockerInnerInterceptor：乐观锁 IllegalSQLInnerInterceptor：sql 性能规范 BlockAttackInnerInterceptor：防止全表更新与删除  注意： 使用多个分页插件的时候需要注意插件定义顺序，建议使用顺序如下：\n 多租户,动态表名 分页,乐观锁 sql 性能规范,防止全表更新与删除  分页插件 在未引入分页插件的情况下，MybatisPlus是不支持分页功能的，IService和BaseMapper中的分页方法都无法正常起效。 所以，我们必须配置分页插件。\n配置分页插件 新建一个配置类\n1@Configuration 2public class MyBatisConfig { 3 4 @Bean 5 public MybatisPlusInterceptor mybatisPlusInterceptor(){ 6 MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); 7 //1.创建分页插件 8 PaginationInnerInterceptor paginationInnerInterceptor = new PaginationInnerInterceptor(DbType.MYSQL); 9 //1.1配置最大查询数目 10 paginationInnerInterceptor.setMaxLimit(1000L); 11 //2.添加插件 12 interceptor.addInnerInterceptor(paginationInnerInterceptor); 13 return interceptor; 14 } 15} 使用分页API 1//分页查询测试 2 @Test 3 void testPageQuery(){ 4 int pageNo = 1, pageSize=2; //从1开始, 每次查2条 5 //1.准备分页条件 6 //1.1分页条件 7 Page\u0026lt;User\u0026gt; page = Page.of(pageNo, pageSize); 8 //1.2排序条件 9 page.addOrder(new OrderItem(\u0026#34;balance\u0026#34;, true)); 10 page.addOrder(new OrderItem(\u0026#34;id\u0026#34;, true)); 11 //2.查询 12 Page\u0026lt;User\u0026gt; p = userService.page(page); 13 //3.解析结果 14 long total = p.getTotal();//总条数 15 System.out.println(\u0026#34;total: \u0026#34; + total); 16 long pages = p.getPages();//总页数 17 System.out.println(\u0026#34;pages: \u0026#34; + pages); 18 List\u0026lt;User\u0026gt; records = p.getRecords(); //记录 19 records.forEach(System.out::println); 20 21 22 } 通用分页实体 实体 分页条件不仅仅用户分页查询需要，以后其它业务也都有分页查询的需求。因此建议将分页查询条件单独定义为一个PageQuery实体, 让我们的UserQuery继承这个实体, 这样其他业务需要分页查询只需要继承PageQuery实体, 然后新增自己需要的字段.\nPageQuery:\n1@Data 2@ApiModel(description = \u0026#34;分页查询实体\u0026#34;) 3public class PageQuery { 4 @ApiModelProperty(\u0026#34;页码\u0026#34;) 5 private Integer pageNo = 1; 6 7 @ApiModelProperty(\u0026#34;页码\u0026#34;) 8 private Integer pageSize = 5; 9 10 @ApiModelProperty(\u0026#34;排序字段\u0026#34;) 11 private String sortBy ; 12 13 @ApiModelProperty(\u0026#34;是否升序\u0026#34;) 14 private Boolean isAsc = true; 15 16 //封装service层的构建分页查询条件的代码.前面这个\u0026lt;T\u0026gt;是定义的,因为用不了对象的泛型 17 public \u0026lt;T\u0026gt; Page\u0026lt;T\u0026gt; toMpPage(OrderItem ... items){ 18 //1.分页条件 19 Page\u0026lt;T\u0026gt; page = Page.of(pageNo, pageSize) ; 20 //1.排序条件 21 if(StrUtil.isNotBlank(sortBy)){ 22 //用户给出了需要排序的字段 23 page.addOrder(new OrderItem(sortBy, isAsc)); 24 }else if(items != null){ 25 //没有给出, 则默认按更新时间排序 26 page.addOrder(items) ; 27 } 28 return page; 29 } 30 31 //再补充一个默认的方法,直接就用create_time默认排序 32 public \u0026lt;T\u0026gt; Page\u0026lt;T\u0026gt; toMpPageDefaultSortByCreate(){ 33 return toMpPage(new OrderItem(\u0026#34;create_time\u0026#34;, isAsc)); 34 } 35 36 //再补充一个默认的方法,直接就用update_time默认排序 37 public \u0026lt;T\u0026gt; Page\u0026lt;T\u0026gt; toMpPageDefaultSortByUpdate(){ 38 return toMpPage(new OrderItem(\u0026#34;update_time\u0026#34;, isAsc)); 39 } 40 41 //直接只需要传递排序字段和升序降序. 42 public \u0026lt;T\u0026gt; Page\u0026lt;T\u0026gt; toMpPage(String defaultSortBy, Boolean defaultAsc){ 43 return toMpPage(new OrderItem(defaultSortBy, defaultAsc)); 44 } 45} UserQuery:\n1//@EqualsAndHashCode 注解用于自动生成 equals 和 hashCode 方法。 2@EqualsAndHashCode(callSuper = true) 3@Data 4@ApiModel(description = \u0026#34;用户查询条件实体\u0026#34;) 5public class UserQuery extends PageQuery{ 6 @ApiModelProperty(\u0026#34;用户名关键字\u0026#34;) 7 private String name; 8 @ApiModelProperty(\u0026#34;用户状态：1-正常，2-冻结\u0026#34;) 9 private Integer status; 10 @ApiModelProperty(\u0026#34;余额最小值\u0026#34;) 11 private Integer minBalance; 12 @ApiModelProperty(\u0026#34;余额最大值\u0026#34;) 13 private Integer maxBalance; 14} 分页实体PageDTO, 用来装返回的结果:\n1@Data 2@ApiModel(description = \u0026#34;分页结果\u0026#34;) 3public class PageDTO\u0026lt;T\u0026gt; { 4 @ApiModelProperty(\u0026#34;总条数\u0026#34;) 5 private Long total; 6 @ApiModelProperty(\u0026#34;总页数\u0026#34;) 7 private Long pages; 8 @ApiModelProperty(\u0026#34;集合\u0026#34;) 9 private List\u0026lt;T\u0026gt; list; 10 11 //构建自己,使用static直接调用 12 //类的泛型只能对象用, 需要定义泛型 13 //这个方法使用的前提是转化的对象字段名一样, 可以少但是要一样,因为它使用了BeanUtil.copyToList. 14 //不一样只能自己完成PO到VO的转化, 于是提供一个函数式接口Function\u0026lt;PO,VO\u0026gt; convertor, 前一个是接受参数,后一个是返回参数 15 public static \u0026lt;PO,VO\u0026gt; PageDTO\u0026lt;VO\u0026gt; of(Page\u0026lt;PO\u0026gt; p, Function\u0026lt;PO,VO\u0026gt; convertor){ 16 PageDTO\u0026lt;VO\u0026gt; dto = new PageDTO\u0026lt;\u0026gt;(); 17 //3.1总条数 18 dto.setTotal(p.getTotal()); 19 //3.2总页数 20 dto.setPages(p.getPages()); 21 //3.3当前数据 22 List\u0026lt;PO\u0026gt; records = p.getRecords(); 23 if(CollUtil.isEmpty(records)){ 24 //空的就放空列表 25 dto.setList(Collections.emptyList()); 26 return dto; 27 } 28 //3.4拷贝User的VO 29// dto.setList(BeanUtil.copyToList(records, clazz)); //参数列表加Class\u0026lt;VO\u0026gt; clazz 30 dto.setList(records.stream().map(convertor).collect(Collectors.toList())); 31 //4.返回 32 return dto; 33 } 34} 开发接口 Controller:\n1@ApiOperation(\u0026#34;根据条件分页批量查询用户接口\u0026#34;) 2 @GetMapping(\u0026#34;/page\u0026#34;) 3 public PageDTO\u0026lt;UserVO\u0026gt; queryUsersPages(UserQuery query){ 4 return userService.queryUsersPage(query); 5 } service:\n1//分页查询复杂条件的用户.定义了多个实体: PageDTO返回的, PageQuery查询实体,UserQuery继承了PageQuery.这样不管是什么分页查询很多代码可以复用 2 @Override 3 public PageDTO\u0026lt;UserVO\u0026gt; queryUsersPage(UserQuery query) { 4 String name = query.getName(); 5 Integer status = query.getStatus(); 6 //1.构建查询条件 7 Page\u0026lt;User\u0026gt; page = query.toMpPageDefaultSortByUpdate(); 8// //下面的代码封装到PageQuery里(将和业务关系不大的代码封装) 9// //1.1分页条件 10// Page\u0026lt;User\u0026gt; page = Page.of(query.getPageNo(), query.getPageSize()) ; 11// //1.2排序条件 12// if(StrUtil.isNotBlank(query.getSortBy())){ 13// //用户给出了需要排序的字段 14// page.addOrder(new OrderItem(query.getSortBy(), query.getIsAsc())); 15// }else { 16// //没有给出, 则默认按更新时间排序 17// page.addOrder(new OrderItem(\u0026#34;update_time\u0026#34;, query.getIsAsc())); 18// } 19 20 //2.分页查询 21 Page\u0026lt;User\u0026gt; p = lambdaQuery() 22 .like(name != null, User::getUsername, name) 23 .eq(status != null, User::getStatus, status) 24 .page(page); 25 26 //3.封装VO结果 27// return PageDTO.of(p, user -\u0026gt; BeanUtil.copyProperties(user, UserVO.class)); 28 return PageDTO.of(p, user -\u0026gt; { 29 //对于PO和VO字段不一致的情况作处理 30 //1.拷贝基础属性 31 UserVO vo = BeanUtil.copyProperties(user, UserVO.class); 32 //2.处理特殊逻辑 33 vo.setUsername(vo.getUsername().substring(0,vo.getUsername().length()-2) + \u0026#34;**\u0026#34;); //隐藏用户名后两位 34 return vo; 35 }); 36// 封装将po转vo的代码到PageDTO并抽象能够通用. 37// PageDTO\u0026lt;UserVO\u0026gt; dto = new PageDTO\u0026lt;\u0026gt;(); 38// //3.1总条数 39// dto.setTotal(p.getTotal()); 40// //3.2总页数 41// dto.setPages(p.getPages()); 42// //3.3当前数据 43// List\u0026lt;User\u0026gt; records = p.getRecords(); 44// if(CollUtil.isEmpty(records)){ 45// //空的就放空列表 46// dto.setList(Collections.emptyList()); 47// return dto; 48// } 49// //3.4拷贝User的VO 50// dto.setList(BeanUtil.copyToList(records, UserVO.class)); 51// //4.返回 52// return dto; 53 } Docker 常见命令 文档: docs.docker.com\n1docker pull #从镜像仓库将镜像拉取到本地仓库,名字后面跟版本号, 不跟就是latest. 2docker puth #将本地仓库的镜像上传到镜像仓库/私服 3docker images #查看镜像 4docker rmi #删除镜像(remove image) 5docker build #构建镜像 6docker save #保存镜像到文件 7docker load #加载文件中的镜像 8docker run #根据镜像开启容器 9docker inspect #查看容器详情 10docker stop #停止容器 11docker start #启动容器 12docker ps #查看现存容器(process status) 13docker rm #删除容器 14docker logs #查看日志 15docker exec #进入容器环境执行命令 案例:\n1docker pull nginx #拉取nginx镜像 2docker images #查看镜像 3docker save -o nginx.tar nginx:latest 4docker rmi nginx:latest 5docker load -i nginx.tar 6docker run -d --name nginx -p 80:80 nginx #-d后台,-p端口映射前面是本机后面是容器,最后跟上镜像名 7docker stop nginx 8docker start nginx 9docker logs -f nginx #-f持续输出日志 10docker exec -it nginx bash #-it可交互终端  11exit 12docker exec -it mysql mysql -uroot -p 13docker rm nginx -f #-f强制删除,不然需要先stop再删除. 14 数据卷挂载 直接进入容器内修改是不可能的, 没有很多命令.于是产生了需求.\n数据卷(volume)是虚拟目录, 映射容器目录和主机目录. 创建数据卷, 那么docker会在/var/lib/docker/volumes下创建文件.这样容器内的文件通过数据卷和主机的文件绑定起来了, docker进行双向绑定.\n1docker volume create #创建数据卷 2docker volume ls #查看所有数据卷 3docker volume rm #删除指定数据卷 4docker volume inspect #查看某个数据卷详情 5docker volume prune #清除所有未使用的数据卷 案例1: 修改nginx的文件, 将静态资源部署到nginx的html目录\n 执行docker run命令时, 使用-v 数据卷:容器内目录 可以完成数据卷挂载\n 1docker run -d --name nginx -p 80:80 -v html:/usr/share/nginx/html nginx 2docker volume ls 3docker volume inspect html 4cd /var/lib/docker/volumes/html/_data 5ll 6#修改html文件,可以成功修改容器内文件. 7#上传静态文件, 容器内也有了这个文件 本地目录挂载 案例2: 查看mysql容器, 看看是否有数据卷挂载(是,匿名卷); 基于宿主机目录实现mysql数据目录,配置文件,初始化脚本的挂载\n 挂载/root/mysql/data 到容器内的/var/lib/mysql 挂载/root/mysql/init到容器内的/docker-entrypoint-initdb.d目录.携带课前准备的sql脚本 挂载/root/mysql/conf到容器内的/etc/mysql/conf.d目录,携带课前准备的配置文件.   执行docker run命令时, 使用 -v 本地目录:容器内目录 可以完成本地目录挂载\n本地目录必须以/ or ./开头. 这是为了区分数据卷\n 1docker run -d\\ 2 --name mysql \\ 3 -p 3306:3306 \\ 4 -e TZ=Asia/Shanghai \\ 5 -v /root/mysql/data:/var/lib/mysql 6 -v /root/mysql/init:/docker-entrypoint-initdb.d 7 -v /root/mysql/conf:/etc/mysql/conf.d 8 mysql 即便删掉了容器, 数据依然存在, 实现了数据的持久保存, 下次创建容器时只需要直接指定挂载便实现了数据迁移. 而默认的匿名卷模式目录太深, 容器删除后数据卷在那里, 但是重新创建后又会生成新的匿名卷, 迁移还需要手动转移.\n自定义镜像Dockerfile 参考资料\n网络 默认情况下, 所有容器都是以bridge方式连接到Docker的一个虚拟网桥上. 但是这样Ip地址可能会变动\n加入自定义网络才可以通过容器名互相访问, Docker的网络操作命令如下:\n   命令 说明     docker network create 创建一个网络   docker network ls 查看所有网络   docker network rm 删除指定网络   docker network prune 清除未使用的网络   docker network connect 使指定容器连接加入某网络   docker network disconnect 使指定容器连接离开某网络   docker network inspect 查看网络详细信息    1docker network create heima 2docker network connect heima mysql 3docker network connect heima dd 4docker run -d --name mysql -p 3306:3306 --network heima mysql #创建时加入网络 5docker exec -it dd bash 6ping mysql #可以直接用容器名ping 部署项目 部署Java应用 1docker build -t hmall . 2docker images 3docker run -d --name hm -p 80:80 --network heima hmall 4docker ps 5docker logs -f hm 部署前端 创建额nginx容器, 将提供的nginx.conf, html目录和容器挂载\n1docker run -d \\ 2\t--name nginx \\ 3\t-p 18080:18080 \\ 4\t-p 18081:18081 \\ 5\t-v /root/nginx/html:/usr/share/nginx/html \\ 6\t-v /root/nginx/nginx.conf:/etc/ngnix.conf \\ 7\t--network heima 8\tnginx DockerCompose Docker Compose通过一个单独的docker-compose.yml 模板文件（YAML 格式）来定义一组相关联的应用容器，帮助我们实现多个相互关联的Docker容器的快速部署。\n1version:\u0026#34;3.8\u0026#34;23services:4mysql:5image:mysql6container_name:mysql7ports:8- \u0026#34;3306:3306\u0026#34;9environment:10TZ:Asia/Shanghai11MYSQL_ROOT_PASSWORD:12312volumes:13- \u0026#34;./mysql/conf:/etc/mysql/conf.d\u0026#34;14- \u0026#34;./mysql/data:/var/lib/mysql\u0026#34;15- \u0026#34;./mysql/init:/docker-entrypoint-initdb.d\u0026#34;16networks:17- hm-net18hmall:19build:20context:.21dockerfile:Dockerfile22container_name:hmall23ports:24- \u0026#34;8080:8080\u0026#34;25networks:26- hm-net27depends_on:28- mysql29nginx:30image:nginx31container_name:nginx32ports:33- \u0026#34;18080:18080\u0026#34;34- \u0026#34;18081:18081\u0026#34;35volumes:36- \u0026#34;./nginx/nginx.conf:/etc/nginx/nginx.conf\u0026#34;37- \u0026#34;./nginx/html:/usr/share/nginx/html\u0026#34;38depends_on:39- hmall40networks:41- hm-net42networks:43hm-net:44name:hmall   参数 说明     -f 指定compose文件的路径和名称   -p 指定project名称   up 创建并启动所有service容器   down 停止并移除所有容器、网络   ps 列出所有启动的容器   logs 查看指定容器的日志   stop 停止容器   start 启动容器   restart 重启容器   top 查看运行的进程   exec 在指定的运行中容器中执行命令    1docker compose up -d #就在本目录, 则不需要-f指定文件 2docker compose down #全部都给移除了, 干干净净. 微服务 普通地服务调用 购物车业务中需要查询商品信息，但商品信息查询的逻辑全部迁移到了item-service服务，导致我们无法查询。想解决这个问题，我们就必须把原本本地方法调用，改造成跨微服务的远程调用（RPC，即Remote Produce Call）。\nRestTemplate Spring给我们提供了一个RestTemplate的API，可以方便的实现Http请求的发送。RestTemplate提供了常见的Get、Post、Put、Delete请求都支持，如果请求参数比较复杂，还可以使用exchange方法来构造请求。\n编写配置类, 将RestTemplate注册为一个Bean:\n1package com.hmall.cart.config; 2 3import org.springframework.context.annotation.Bean; 4import org.springframework.context.annotation.Configuration; 5import org.springframework.web.client.RestTemplate; 6 7@Configuration 8public class RemoteCallConfig { 9 10 @Bean 11 public RestTemplate restTemplate() { 12 return new RestTemplate(); 13 } 14} 远程调用 1private void handleCartItems(List\u0026lt;CartVO\u0026gt; vos) { 2 // TODO 1.获取商品id 3 Set\u0026lt;Long\u0026gt; itemIds = vos.stream().map(CartVO::getItemId).collect(Collectors.toSet()); 4 // 2.查询商品 5 // List\u0026lt;ItemDTO\u0026gt; items = itemService.queryItemByIds(itemIds); 6 // 2.1.利用RestTemplate发起http请求，得到http的响应 7 ResponseEntity\u0026lt;List\u0026lt;ItemDTO\u0026gt;\u0026gt; response = restTemplate.exchange( 8 \u0026#34;http://localhost:8081/items?ids={ids}\u0026#34;, 9 HttpMethod.GET, 10 null, 11 new ParameterizedTypeReference\u0026lt;List\u0026lt;ItemDTO\u0026gt;\u0026gt;() { 12 }, //利用反射获取字节码, List\u0026lt;ItemDTO\u0026gt;.class是不行的, 泛型会被擦除 13 Map.of(\u0026#34;ids\u0026#34;, CollUtil.join(itemIds, \u0026#34;,\u0026#34;)) //将集合转字符串, 通过逗号拼接, 满足输入参数要求 14 ); 15 // 2.2.解析响应 16 if(!response.getStatusCode().is2xxSuccessful()){ 17 // 查询失败，直接结束 18 return; 19 } 20 List\u0026lt;ItemDTO\u0026gt; items = response.getBody(); 21 if (CollUtils.isEmpty(items)) { 22 return; 23 } 24 // 3.转为 id 到 item的map 25 Map\u0026lt;Long, ItemDTO\u0026gt; itemMap = items.stream().collect(Collectors.toMap(ItemDTO::getId, Function.identity())); 26 // 4.写入vo 27 for (CartVO v : vos) { 28 ItemDTO item = itemMap.get(v.getItemId()); 29 if (item == null) { 30 continue; 31 } 32 v.setNewPrice(item.getPrice()); 33 v.setStatus(item.getStatus()); 34 v.setStock(item.getStock()); 35 } 36} 服务注册和发现(解决多个实例地址不一样如何调用的问题) 注册中心对服务提供者提供心跳检测, 注册服务. 向服务消费者推送变更, 调用者可以从注册中心订阅想要的服务，获取服务对应的实例列表.\nNacos注册中心 服务注册 微服务提供者需要将服务注册到注册中心, 步骤如下：\n  微服务中引入依赖\n1\u0026lt;!--nacos 服务注册发现--\u0026gt; 2\u0026lt;dependency\u0026gt; 3 \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; 4 \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-nacos-discovery\u0026lt;/artifactId\u0026gt; 5\u0026lt;/dependency\u0026gt;   配置Nacos地址\n1spring:2application:3name:item-service# 服务名称4cloud:5nacos:6server-addr:192.168.150.101:8848# nacos地址  重启程序\n  访问nacos控制台，可以发现服务注册成功.\n服务发现 服务的消费者要去nacos订阅服务，这个过程就是服务发现，步骤如下：\n  引入依赖\n服务发现除了要引入nacos依赖以外，由于还需要负载均衡，因此要引入SpringCloud提供的LoadBalancer依赖。\n1\u0026lt;!--nacos 服务注册发现--\u0026gt; 2\u0026lt;dependency\u0026gt; 3 \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; 4 \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-nacos-discovery\u0026lt;/artifactId\u0026gt; 5\u0026lt;/dependency\u0026gt; 这里Nacos的依赖于服务注册时一致，这个依赖中同时包含了服务注册和发现的功能。因为任何一个微服务可以是调用者，也可以是提供者。\n  配置Nacos地址\n1spring:2cloud:3nacos:4server-addr:192.168.150.101:8848  发现并调用服务\n微服务有多个实例, 服务调用者必须利用负载均衡的算法，从多个实例中挑选一个去访问。常见的负载均衡算法有：\n 随机 轮询 IP的hash 最近最少访问 \u0026hellip;  这里我们可以选择最简单的随机负载均衡。\n服务发现需要用到一个工具，DiscoveryClient，SpringCloud已经帮我们自动装配，我们可以直接注入使用.\n1 private void handleCartItems(List\u0026lt;CartVO\u0026gt; vos) { 2 //这边依赖ItemService, 通过网络远程请求来完成, 使用spring的restTemplate 3 // 1.获取商品id 4 Set\u0026lt;Long\u0026gt; itemIds = vos.stream().map(CartVO::getItemId).collect(Collectors.toSet()); 5 //2.查询商品 6 List\u0026lt;ItemDTO\u0026gt; items = itemService.queryItemByIds(itemIds); 7 //2.1根据服务名称获取服务的实例列表 8 List\u0026lt;ServiceInstance\u0026gt; instances = discoveryClient.getInstances(\u0026#34;item-service\u0026#34;); 9 if(CollUtil.isEmpty(instances)){ 10 return; 11 } 12 //2.2手写负载均衡, 从实例列表中挑选实例 13 ServiceInstance instance = instances.get(RandomUtil.randomInt(instances.size())); 14 //2.3利用RestTemplate发起http请求,得到http响应 15 ResponseEntity\u0026lt;List\u0026lt;ItemDTO\u0026gt;\u0026gt; response = restTemplate.exchange( 16 instance.getUri()+\u0026#34;/items?ids={ids}\u0026#34;, 17// \u0026#34;http://localhost:8081/items?ids={ids}\u0026#34;, 18 HttpMethod.GET, 19 null, 20 new ParameterizedTypeReference\u0026lt;List\u0026lt;ItemDTO\u0026gt;\u0026gt;() { 21 }, //利用反射获取字节码, List\u0026lt;ItemDTO\u0026gt;.class是不行的, 泛型会被擦除 22 Map.of(\u0026#34;ids\u0026#34;, CollUtil.join(itemIds, \u0026#34;,\u0026#34;)) //将集合转字符串, 通过逗号拼接, 满足输入参数要求 23 ); 24 //2.4解析结果 25 if(!response.getStatusCode().is2xxSuccessful()){ 26 //查询失败 27 return; 28 } 29 List\u0026lt;ItemDTO\u0026gt; items = response.getBody(); 30 if (CollUtils.isEmpty(items)) { 31 return; 32 } 33 // 3.转为 id 到 item的map 34 Map\u0026lt;Long, ItemDTO\u0026gt; itemMap = items.stream().collect(Collectors.toMap(ItemDTO::getId, Function.identity())); 35 // 4.写入vo 36 for (CartVO v : vos) { 37 ItemDTO item = itemMap.get(v.getItemId()); 38 if (item == null) { 39 continue; 40 } 41 v.setNewPrice(item.getPrice()); 42 v.setStatus(item.getStatus()); 43 v.setStock(item.getStock()); 44 } 45 }   OpenFeign(实现更简单) 利用RestTemplate实现的远程调用的代码太复杂了, 想让远程调用像本地方法调用一样简单这就要用到OpenFeign组件了.\n快速入门(通过client构造请求, feign完成负载均衡和请求) 1.服务调用者引入依赖:\n1 \u0026lt;!--openFeign--\u0026gt; 2 \u0026lt;dependency\u0026gt; 3 \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; 4 \u0026lt;artifactId\u0026gt;spring-cloud-starter-openfeign\u0026lt;/artifactId\u0026gt; 5 \u0026lt;/dependency\u0026gt; 6 \u0026lt;!--负载均衡器--\u0026gt; 7 \u0026lt;dependency\u0026gt; 8 \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; 9 \u0026lt;artifactId\u0026gt;spring-cloud-starter-loadbalancer\u0026lt;/artifactId\u0026gt; 10 \u0026lt;/dependency\u0026gt; 2.启用OpenFeign. 在微服务调用者cart-service的启动类CartApplication上添加注解@EnableFeignClients，启动OpenFeign功能：\n1@EnableFeignClients 2@MapperScan(\u0026#34;com.hmall.cart.mapper\u0026#34;) 3@SpringBootApplication 4public class CartApplication { 5 public static void main(String[] args) { 6 SpringApplication.run(CartApplication.class, args); 7 } 8} 3.编写OpenFeign客户端. 在微服务调用者中, 新定义接口, 编写Feign客户端:\n1package com.hmall.cart.client; 2 3import com.hmall.cart.domain.dto.ItemDTO; 4import org.springframework.cloud.openfeign.FeignClient; 5import org.springframework.web.bind.annotation.GetMapping; 6import org.springframework.web.bind.annotation.RequestParam; 7 8import java.util.List; 9 10@FeignClient(\u0026#34;item-service\u0026#34;) 11public interface ItemClient { 12 13 @GetMapping(\u0026#34;/items\u0026#34;) 14 List\u0026lt;ItemDTO\u0026gt; queryItemByIds(@RequestParam(\u0026#34;ids\u0026#34;) Collection\u0026lt;Long\u0026gt; ids); 15} 这里只需要声明接口，无需实现方法。接口中的几个关键信息：\n @FeignClient(\u0026quot;item-service\u0026quot;) ：声明服务名称 @GetMapping ：声明请求方式 @GetMapping(\u0026quot;/items\u0026quot;) ：声明请求路径 @RequestParam(\u0026quot;ids\u0026quot;) Collection\u0026lt;Long\u0026gt; ids ：声明请求参数 List\u0026lt;ItemDTO\u0026gt; ：返回值类型  有了上述信息，OpenFeign就可以利用动态代理帮我们实现这个方法，并且向http://item-service/items发送一个GET请求，携带ids为请求参数，并自动将返回值处理为List\u0026lt;ItemDTO\u0026gt;。\n我们只需要直接调用这个方法，即可实现远程调用了。\n4.使用FeignClient\nfeign替我们完成了服务拉取、负载均衡、发送http请求的所有工作, 我们不再需要RestTemplate了，还省去了RestTemplate的注册.\n1private void handleCartItems(List\u0026lt;CartVO\u0026gt; vos) { 2 //这边依赖ItemService, 通过网络远程请求来完成, 使用spring的restTemplate 3 // 1.获取商品id 4 Set\u0026lt;Long\u0026gt; itemIds = vos.stream().map(CartVO::getItemId).collect(Collectors.toSet()); 5 // 2.查询商品 6// List\u0026lt;ItemDTO\u0026gt; items = itemService.queryItemByIds(itemIds); 7// //2.1根据服务名称获取服务的实例列表 8// List\u0026lt;ServiceInstance\u0026gt; instances = discoveryClient.getInstances(\u0026#34;item-service\u0026#34;); 9// if(CollUtil.isEmpty(instances)){ 10// return; 11// } 12// //2.2手写负载均衡, 从实例列表中挑选实例 13// ServiceInstance instance = instances.get(RandomUtil.randomInt(instances.size())); 14// //2.3利用RestTemplate发起http请求,得到http响应 15// ResponseEntity\u0026lt;List\u0026lt;ItemDTO\u0026gt;\u0026gt; response = restTemplate.exchange( 16// instance.getUri()+\u0026#34;/items?ids={ids}\u0026#34;, 17//// \u0026#34;http://localhost:8081/items?ids={ids}\u0026#34;, 18// HttpMethod.GET, 19// null, 20// new ParameterizedTypeReference\u0026lt;List\u0026lt;ItemDTO\u0026gt;\u0026gt;() { 21// }, //利用反射获取字节码, List\u0026lt;ItemDTO\u0026gt;.class是不行的, 泛型会被擦除 22// Map.of(\u0026#34;ids\u0026#34;, CollUtil.join(itemIds, \u0026#34;,\u0026#34;)) //将集合转字符串, 通过逗号拼接, 满足输入参数要求 23// ); 24 //2.4解析结果 25// if(!response.getStatusCode().is2xxSuccessful()){ 26// //查询失败 27// return; 28// } 29// List\u0026lt;ItemDTO\u0026gt; items = response.getBody(); 30// if (CollUtils.isEmpty(items)) { 31// return; 32// } 33 //使用了Open Feign上面的就不需要了, 别人帮做了 34 //itemClient注入得到 35 List\u0026lt;ItemDTO\u0026gt; items = itemClient.queryItemByIds(itemIds); 36 // 3.转为 id 到 item的map 37 Map\u0026lt;Long, ItemDTO\u0026gt; itemMap = items.stream().collect(Collectors.toMap(ItemDTO::getId, Function.identity())); 38 // 4.写入vo 39 for (CartVO v : vos) { 40 ItemDTO item = itemMap.get(v.getItemId()); 41 if (item == null) { 42 continue; 43 } 44 v.setNewPrice(item.getPrice()); 45 v.setStatus(item.getStatus()); 46 v.setStock(item.getStock()); 47 } 48 } 连接池 Feign底层发起http请求，依赖于其它的框架。其底层支持的http客户端实现包括：\n HttpURLConnection：默认实现，不支持连接池 Apache HttpClient ：支持连接池 OKHttp：支持连接池  因此我们通常会使用带有连接池的客户端来代替默认的HttpURLConnection。比如，我们使用OK Http.\n1.微服务中引入依赖\n1\u0026lt;!--OK http 的依赖 --\u0026gt; 2\u0026lt;dependency\u0026gt; 3 \u0026lt;groupId\u0026gt;io.github.openfeign\u0026lt;/groupId\u0026gt; 4 \u0026lt;artifactId\u0026gt;feign-okhttp\u0026lt;/artifactId\u0026gt; 5\u0026lt;/dependency\u0026gt; 2.微服务中开启连接池\n1feign:2okhttp:3enabled:true# 开启OKHttp功能重启服务，连接池就生效了。\n最佳实践 需要在每个微服务调用者中再次定义微服务提供者的Client接口，这不是重复编码吗？ 有什么办法能加避免重复编码呢？避免重复编码的办法就是抽取. 这里有两种抽取思路：\n 思路1：抽取到微服务之外的公共module 思路2：每个微服务自己抽取一个module(每个微服务都有个api模块)  方案1抽取更加简单，工程结构也比较清晰，但缺点是整个项目耦合度偏高。\n方案2抽取相对麻烦，工程结构相对更复杂，但服务之间耦合度降低。\n由于item-service已经创建好，无法继续拆分，因此这里我们采用方案1.\n抽取Feign客户端 在hmall下定义一个新的module，命名为hm-api, 将client和需要的类复制过来. 现在，任何微服务要调用item-service中的接口，只需要引入hm-api模块依赖即可，无需自己编写Feign客户端了。\n引入 在微服务调用者的pom.xml中引入hm-api模块：\n1 \u0026lt;!--feign模块--\u0026gt; 2 \u0026lt;dependency\u0026gt; 3 \u0026lt;groupId\u0026gt;com.heima\u0026lt;/groupId\u0026gt; 4 \u0026lt;artifactId\u0026gt;hm-api\u0026lt;/artifactId\u0026gt; 5 \u0026lt;version\u0026gt;1.0.0\u0026lt;/version\u0026gt; 6 \u0026lt;/dependency\u0026gt; 删除调用者与api模块已经重复的类之后报错了, 因为ItemClient现在定义到了com.hmall.api.client包下，而cart-service的启动类定义在com.hmall.cart包下，扫描不到ItemClient(pom引入的api包)，所以报错了。\n解决办法很简单，在cart-service的启动类上添加声明即可，两种方式：\n  方式1：声明扫描包：\n1//basePackages指定远程包的位置, 这样才能被SpringBootApplication扫描到, 才能用这些FeignClient. 2@EnableFeignClients(basePackages = \u0026#34;com.hmall.api.client\u0026#34;) 3@MapperScan(\u0026#34;com.hmall.cart.mapper\u0026#34;) 4@SpringBootApplication 5public class CartApplication { 6 public static void main(String[] args) { 7 SpringApplication.run(CartApplication.class, args); 8 } 9}   方式2：声明要用的FeignClient\n1@EnableFeignClients(client = {ItemClient.class}) 2@MapperScan(\u0026#34;com.hmall.cart.mapper\u0026#34;) 3@SpringBootApplication 4public class CartApplication { 5 public static void main(String[] args) { 6 SpringApplication.run(CartApplication.class, args); 7 } 8}   日志配置 OpenFeign只会在FeignClient所在包的日志级别为DEBUG时，才会输出日志。而且其日志级别有4级：\n NONE：不记录任何日志信息，这是默认值。 BASIC：仅记录请求的方法，URL以及响应状态码和执行时间 HEADERS：在BASIC的基础上，额外记录了请求和响应的头信息 FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据。  1.定义日志级别\n在hm-api模块下新建一个配置类，定义Feign的日志级别：\n1package com.hmall.api.config; 2 3import feign.Logger; 4import org.springframework.context.annotation.Bean; 5 6public class DefaultFeignConfig { 7 @Bean 8 public Logger.Level feignLogLevel(){ 9 return Logger.Level.FULL; 10 } 11} 2.配置\n接下来，要让日志级别生效，还需要配置这个类。有两种方式：\n  局部生效：在某个FeignClient中配置，只对当前FeignClient生效\n1@FeignClient(value = \u0026#34;item-service\u0026#34;, configuration = DefaultFeignConfig.class)   全局生效：在@EnableFeignClients中配置，针对所有FeignClient生效。\n1@EnableFeignClients(defaultConfiguration = DefaultFeignConfig.class)   网关路由 网关就是网络的关口。数据在网络间传输，从一个网络传输到另一网络时就需要经过网关来做数据的路由和转发以及数据安全的校验。\n前端请求不能直接访问微服务，而是要请求网关：\n 网关可以做安全控制，也就是登录身份校验，校验通过才放行 通过认证后，网关再根据请求判断应该访问哪个微服务，将请求转发过去  快速入门 创建项目hm-gateway并引入依赖:\n1\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; 2\u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; 3 xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; 4 xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; 5 \u0026lt;parent\u0026gt; 6 \u0026lt;artifactId\u0026gt;hmall\u0026lt;/artifactId\u0026gt; 7 \u0026lt;groupId\u0026gt;com.heima\u0026lt;/groupId\u0026gt; 8 \u0026lt;version\u0026gt;1.0.0\u0026lt;/version\u0026gt; 9 \u0026lt;/parent\u0026gt; 10 \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; 11 12 \u0026lt;artifactId\u0026gt;hm-gateway\u0026lt;/artifactId\u0026gt; 13 14 \u0026lt;properties\u0026gt; 15 \u0026lt;maven.compiler.source\u0026gt;11\u0026lt;/maven.compiler.source\u0026gt; 16 \u0026lt;maven.compiler.target\u0026gt;11\u0026lt;/maven.compiler.target\u0026gt; 17 \u0026lt;/properties\u0026gt; 18 \u0026lt;dependencies\u0026gt; 19 \u0026lt;!--common--\u0026gt; 20 \u0026lt;dependency\u0026gt; 21 \u0026lt;groupId\u0026gt;com.heima\u0026lt;/groupId\u0026gt; 22 \u0026lt;artifactId\u0026gt;hm-common\u0026lt;/artifactId\u0026gt; 23 \u0026lt;version\u0026gt;1.0.0\u0026lt;/version\u0026gt; 24 \u0026lt;/dependency\u0026gt; 25 \u0026lt;!--网关--\u0026gt; 26 \u0026lt;dependency\u0026gt; 27 \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; 28 \u0026lt;artifactId\u0026gt;spring-cloud-starter-gateway\u0026lt;/artifactId\u0026gt; 29 \u0026lt;/dependency\u0026gt; 30 \u0026lt;!--nacos discovery--\u0026gt; 31 \u0026lt;dependency\u0026gt; 32 \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; 33 \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-nacos-discovery\u0026lt;/artifactId\u0026gt; 34 \u0026lt;/dependency\u0026gt; 35 \u0026lt;!--负载均衡--\u0026gt; 36 \u0026lt;dependency\u0026gt; 37 \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; 38 \u0026lt;artifactId\u0026gt;spring-cloud-starter-loadbalancer\u0026lt;/artifactId\u0026gt; 39 \u0026lt;/dependency\u0026gt; 40 \u0026lt;/dependencies\u0026gt; 41 \u0026lt;build\u0026gt; 42 \u0026lt;finalName\u0026gt;${project.artifactId}\u0026lt;/finalName\u0026gt; 43 \u0026lt;plugins\u0026gt; 44 \u0026lt;plugin\u0026gt; 45 \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; 46 \u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt; 47 \u0026lt;/plugin\u0026gt; 48 \u0026lt;/plugins\u0026gt; 49 \u0026lt;/build\u0026gt; 50\u0026lt;/project\u0026gt; 创建启动类:\n1package com.hmall.gateway; 2 3import org.springframework.boot.SpringApplication; 4import org.springframework.boot.autoconfigure.SpringBootApplication; 5 6@SpringBootApplication 7public class GatewayApplication { 8 public static void main(String[] args) { 9 SpringApplication.run(GatewayApplication.class, args); 10 } 11} 配置路由 在hm-gateway模块的resources目录新建一个application.yaml文件，内容如下：\n1server:2port:80803spring:4application:5name:gateway6cloud:7nacos:8server-addr:192.168.170.128:88489gateway:10routes:11- id:item-service# 路由规则id，自定义，唯一12uri:lb://item-service# 路由的目标服务，lb代表负载均衡，会从注册中心拉取服务列表13predicates:# 路由断言，判断当前请求是否符合当前规则，符合则路由到目标服务14- Path=/items/** # 这里是以请求路径作为判断规则15- Path=/search/**16filters:17- AddRequestHeader=Truth, anyone workhard will be rich#添加请求头的过滤器18- id:user-service19uri:lb://user-service20predicates:21- Path=/users/**,/addresses/**22- id:pay-service23uri:lb://pay-service24predicates:25- Path=/pay-orders/**26- id:trade-service27uri:lb://trade-service28predicates:29- Path=/orders/**30- id:cart-service31uri:lb://cart-service32predicates:33- Path=/carts/**uri中需要是微服务名称, predicates中填入路径, 这样对应路径的请求就会被转发至响应的微服务.\n访问http://localhost:8080/items/page?pageNo=1\u0026amp;pageSize=1, 实际上被转发到item-service微服务中.\n路由过滤 路由规则的定义语法如下：\n1spring:2cloud:3gateway:4routes:5- id:item6uri:lb://item-service7predicates:8- Path=/items/**,/search/**其中routes对应的类型是GatewayProperties类,\n1@ConfigurationProperties(\u0026#34;spring.cloud.gateway\u0026#34;) 2@Validated 3public class GatewayProperties { 4 public static final String PREFIX = \u0026#34;spring.cloud.gateway\u0026#34;; 5 private final Log logger = LogFactory.getLog(this.getClass()); 6 @NotNull 7 @Valid 8 private List\u0026lt;RouteDefinition\u0026gt; routes = new ArrayList(); 是一个集合，也就是说可以定义很多路由规则。集合中的RouteDefinition就是具体的路由规则定义，其中常见的属性如下：\n1@Validated 2public class RouteDefinition { 3 private String id; 4 @NotEmpty 5 @Valid 6 private List\u0026lt;PredicateDefinition\u0026gt; predicates = new ArrayList(); 7 @Valid 8 private List\u0026lt;FilterDefinition\u0026gt; filters = new ArrayList(); 9 @NotNull 10 private URI uri; 四个属性含义如下：\n id：路由的唯一标示 predicates：路由断言，其实就是匹配条件 filters：路由过滤条件，后面讲 uri：路由目标地址，lb://代表负载均衡，从注册中心获取目标微服务的实例列表，并且负载均衡选择一个访问。  predicates，也就是路由断言。SpringCloudGateway中支持的断言类型有很多：\n   名称 说明 示例     After 是某个时间点后的请求 - After=2037-01-20T17:42:47.789-07:00[America/Denver]   Before 是某个时间点之前的请求 - Before=2031-04-13T15:14:47.433+08:00[Asia/Shanghai]   Between 是某两个时间点之前的请求 - Between=2037-01-20T17:42:47.789-07:00[America/Denver], 2037-01-21T17:42:47.789-07:00[America/Denver]   Cookie 请求必须包含某些cookie - Cookie=chocolate, ch.p   Header 请求必须包含某些header - Header=X-Request-Id, \\d+   Host 请求必须是访问某个host（域名） - Host=.somehost.org,.anotherhost.org   Method 请求方式必须是指定方式 - Method=GET,POST   Path 请求路径必须符合指定规则 - Path=/red/{segment},/blue/**   Query 请求参数必须包含指定参数 - Query=name, Jack或者- Query=name   RemoteAddr 请求者的ip必须是指定范围 - RemoteAddr=192.168.1.1/24   weight 权重处理     网关登录校验 我们的登录是基于JWT来实现的，校验JWT的算法复杂，而且需要用到秘钥。如果每个微服务都去做登录校验，这就存在着两大问题：\n 每个微服务都需要知道JWT的秘钥，不安全 每个微服务重复编写登录校验代码、权限校验代码，麻烦  既然网关是所有微服务的入口，一切请求都需要先经过网关。我们：\n 只需要在网关和用户服务保存秘钥 只需要在网关开发登录校验功能  网关过滤器 想在请求转发之前做登录校验，就必须了解Gateway内部工作的基本原理。\n 客户端请求进入网关后由HandlerMapping对请求做判断，找到与当前请求匹配的路由规则（Route），然后将请求交给WebHandler去处理。 WebHandler则会加载当前路由下需要执行的过滤器链（Filter chain），然后按照顺序逐一执行过滤器（后面称为**Filter**）。 Filter分为两部分，是因为Filter内部的逻辑分为pre和post两部分，分别会在请求路由到微服务之前和之后被执行。 只有所有Filter的pre逻辑都依次顺序执行通过后，请求才会被路由到微服务。 微服务返回结果后，再倒序执行Filter的post逻辑。 最终把响应结果返回。  最终请求转发是有一个名为NettyRoutingFilter的过滤器来执行的，而且这个过滤器是整个过滤器链中顺序最靠后的一个。如果我们能够定义一个过滤器，在其中实现登录校验逻辑，并且将过滤器执行顺序定义到NettyRoutingFilter之前，这就符合我们的需求了\n那么，该如何实现一个网关过滤器呢？\n网关过滤器链中的过滤器有两种：\n GatewayFilter：路由过滤器，作用范围比较灵活，可以是任意指定的路由Route. GlobalFilter：全局过滤器，作用范围是所有路由，不可配置。  GatewayFilter和GlobalFilter这两种过滤器的方法签名完全一致：\n1/** 2* 处理请求并将其传递给下一个过滤器 3* @param exchange 当前请求的上下文，其中包含request、response等各种数据 4* @param chain 过滤器链，基于它向下传递请求 5* @return 根据返回值标记当前请求是否被完成或拦截，chain.filter(exchange)就放行了。 6*/ 7Mono\u0026lt;Void\u0026gt; filter(ServerWebExchange exchange, GatewayFilterChain chain); Gateway内置的GatewayFilter过滤器使用起来非常简单，无需编码，只要在yaml文件中简单配置即可。而且其作用范围也很灵活，配置在哪个Route下，就作用于哪个Route.\n例如，有一个过滤器叫做AddRequestHeaderGatewayFilterFacotry，顾明思议，就是添加请求头的过滤器，可以给请求添加一个请求头并传递到下游微服务。\n使用的使用只需要在application.yaml中这样配置：\n1spring:2cloud:3gateway:4routes:5- id:test_route6uri:lb://test-service7predicates:8-Path=/test/**9filters:10- AddRequestHeader=key, value# 逗号之前是请求头的key，逗号之后是value如果想要让过滤器作用于所有的路由，则可以这样配置：\n1spring:2cloud:3gateway:4default-filters:# default-filters下的过滤器可以作用于所有路由5- AddRequestHeader=key, value6routes:7- id:test_route8uri:lb://test-service9predicates:10-Path=/test/**自定义过滤器 无论是GatewayFilter还是GlobalFilter都支持自定义，只不过编码方式、使用方式略有差别。\n自定义过滤器过滤器还可以支持动态配置参数，不过实现起来比较复杂，示例：\n1 2@Component 3public class PrintAnyGatewayFilterFactory // 父类泛型是内部类的Config类型 4 extends AbstractGatewayFilterFactory\u0026lt;PrintAnyGatewayFilterFactory.Config\u0026gt; { 5 6 @Override 7 public GatewayFilter apply(Config config) { 8 // OrderedGatewayFilter是GatewayFilter的子类，包含两个参数： 9 // - GatewayFilter：过滤器 10 // - int order值：值越小，过滤器执行优先级越高 11 return new OrderedGatewayFilter(new GatewayFilter() { 12 @Override 13 public Mono\u0026lt;Void\u0026gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) { 14 // 获取config值 15 String a = config.getA(); 16 String b = config.getB(); 17 String c = config.getC(); 18 // 编写过滤器逻辑 19 System.out.println(\u0026#34;a = \u0026#34; + a); 20 System.out.println(\u0026#34;b = \u0026#34; + b); 21 System.out.println(\u0026#34;c = \u0026#34; + c); 22 // 放行 23 return chain.filter(exchange); 24 } 25 }, 100); 26 } 27 28 // 自定义配置属性，成员变量名称很重要，下面会用到 29 @Data 30 static class Config{ 31 private String a; 32 private String b; 33 private String c; 34 } 35 // 将变量名称依次返回，顺序很重要，将来读取参数时需要按顺序获取 36 @Override 37 public List\u0026lt;String\u0026gt; shortcutFieldOrder() { 38 return List.of(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;); 39 } 40 // 返回当前配置类的类型，也就是内部的Config 41 @Override 42 public Class\u0026lt;Config\u0026gt; getConfigClass() { 43 return Config.class; 44 } 45 46} 然后在yaml文件中使用：\n1spring:2cloud:3gateway:4default-filters:5- PrintAny=1,2,3# 注意，这里多个参数以\u0026#34;,\u0026#34;隔开，将来会按照shortcutFieldOrder()方法返回的参数顺序依次复制上面这种配置方式参数必须严格按照shortcutFieldOrder()方法的返回参数名顺序来赋值。\n还有一种用法，无需按照这个顺序，就是手动指定参数名：\n1spring:2cloud:3gateway:4default-filters:5- name:PrintAny6args:# 手动指定参数名，无需按照参数顺序7a:18b:29c:3自定义GlobalFilter 自定义GlobalFilter则简单很多，直接实现GlobalFilter即可，而且也无法设置动态参数：\n1@Component 2public class PrintAnyGlobalFilter implements GlobalFilter, Ordered { 3 @Override 4 public Mono\u0026lt;Void\u0026gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) { 5 // 编写过滤器逻辑 6 System.out.println(\u0026#34;未登录，无法访问\u0026#34;); 7 // 放行 8 // return chain.filter(exchange); 9 10 // 拦截 11 ServerHttpResponse response = exchange.getResponse(); 12 response.setRawStatusCode(401); 13 return response.setComplete(); 14 } 15 16 @Override 17 public int getOrder() { 18 // 过滤器执行顺序，值越小，优先级越高 19 return 0; 20 } 21} 登录校验 服务保护和分布式事务 微服务保护 微服务保护的方案有很多，比如：\n 请求限流: 限制或控制接口访问的并发流量，避免服务因流量激增而出现故障。 线程隔离: 当一个业务接口响应时间长，而且并发高时，就可能耗尽服务器的线程资源，导致服务内的其它接口受到影响。所以我们必须把这种影响降低，或者缩减影响的范围 服务熔断: 线程隔离虽然避免了雪崩问题，但故障服务依然会拖慢购物车服务的接口响应速度。我们需编写服务降级逻辑, 统计服务提供方的异常比例，当比例过高表明该接口会影响到其它服务，应该拒绝调用该接口，而是直接走降级逻辑。  微服务保护的技术有很多，但在目前国内使用较多的还是Sentinel\n分布式事务 出现以下情况之一就可能产生分布式事务问题：\n 业务跨多个服务实现 业务跨多个数据源实现  Seata 解决分布式事务的思想非常简单：\n就是找一个统一的事务协调者，与多个分支事务通信，检测每个分支事务的执行状态，保证全局事务下的每一个分支事务同时成功或失败即可。大多数的分布式事务框架都是基于这个理论来实现的。\nSeata也不例外，在Seata的事务管理中有三个重要的角色：\n TC **(Transaction Coordinator) - 事务协调者：**维护全局和分支事务的状态，协调全局事务提交或回滚。 TM (Transaction Manager) - **事务管理器：**定义全局事务的范围、开始全局事务、提交或回滚全局事务。 RM (Resource Manager) - **资源管理器：**管理分支事务，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。  XA模式 原始模式 一阶段：\n 事务协调者通知每个事务参与者执行本地事务 本地事务执行完成后报告事务执行状态给事务协调者，此时事务不提交，继续持有数据库锁  二阶段：\n 事务协调者基于一阶段的报告来判断下一步操作 如果一阶段都成功，则通知所有事务参与者，提交事务 如果一阶段任意一个参与者失败，则通知所有事务参与者回滚事务  Seata的XA模型 RM一阶段的工作：\n 注册分支事务到TC 执行分支业务sql但不提交 报告执行状态到TC  TC二阶段的工作：\n TC检测各分支事务执行状态 如果都成功，通知所有RM提交事务 如果有失败，通知所有RM回滚事务  RM二阶段的工作：\n 接收TC指令，提交或回滚事务  优缺点 XA模式的优点是什么？\n 事务的强一致性，满足ACID原则 常用数据库都支持，实现简单，并且没有代码侵入  XA模式的缺点是什么？\n 因为一阶段需要锁定数据库资源，等待二阶段结束才释放，性能较差 依赖关系型数据库实现事务  AT模式 AT模式同样是分阶段提交的事务模型，不过缺弥补了XA模型中资源锁定周期过长的缺陷。\nSeata的AT模型 阶段一RM的工作：\n 注册分支事务 记录undo-log（数据快照） 执行业务sql并提交 报告事务状态  阶段二提交时RM的工作：\n 删除undo-log即可  阶段二回滚时RM的工作：\n 根据undo-log恢复数据到更新前  AT模式下，当前分支事务执行流程如下：\n一阶段：\n TM发起并注册全局事务到TC TM调用分支事务 分支事务准备执行业务SQL RM拦截业务SQL，根据where条件查询原始数据，形成快照。 RM执行业务SQL，提交本地事务，释放数据库锁。此时 money = 90 RM报告本地事务状态给TC  二阶段：\n TM通知TC事务结束 TC检查分支事务状态  如果都成功，则立即删除快照 如果有分支事务失败，需要回滚。读取快照数据（{\u0026ldquo;id\u0026rdquo;: 1, \u0026ldquo;money\u0026rdquo;: 100}），将快照恢复到数据库。此时数据库再次恢复为100    AT与XA的区别 简述AT模式与XA模式最大的区别是什么？\n XA模式一阶段不提交事务，锁定资源；AT模式一阶段直接提交，不锁定资源。 XA模式依赖数据库机制实现回滚；AT模式利用数据快照实现数据回滚。 XA模式强一致；AT模式最终一致  可见，AT模式使用起来更加简单，无业务侵入，性能更好。因此企业90%的分布式事务都可以用AT模式来解决。\nMQ 微服务一旦拆分，必然涉及到服务之间的相互调用，目前我们服务之间调用采用的都是基于OpenFeign的调用。这种调用中，调用者发起请求后需要等待服务提供者执行业务返回结果后，才能继续执行后面的业务。也就是说调用者在调用过程中处于阻塞状态，因此我们称这种调用方式为同步调用，也可以叫同步通讯。如果我们的业务需要实时得到服务提供方的响应，则应该选择同步通讯（同步调用）。而如果我们追求更高的效率，并且不需要实时响应，则应该选择异步通讯（异步调用）。\n异步调用的优势包括：\n 耦合度更低 性能更好 业务拓展性强 故障隔离，避免级联失败  几种常见MQ的对比：\n追求可用性：Kafka、 RocketMQ 、RabbitMQ\n追求可靠性：RabbitMQ、RocketMQ\n追求吞吐能力：RocketMQ、Kafka\n追求消息低延迟：RabbitMQ、Kafka\nRabbitMQ  publisher：生产者，也就是发送消息的一方 consumer：消费者，也就是消费消息的一方 queue：队列，存储消息。生产者投递的消息会暂存在消息队列中，等待消费者处理 exchange：交换机，负责消息路由。生产者发送的消息由交换机决定投递到哪个队列。 virtual host：虚拟主机，起到数据隔离的作用。每个虚拟主机相互独立，有各自的exchange、queue  \rSpringAMQP 由于RabbitMQ采用了AMQP协议，因此它具备跨语言的特性。任何语言只要遵循AMQP协议收发消息，都可以与RabbitMQ交互。Spring的官方刚好基于RabbitMQ提供了这样一套消息收发的模板工具：SpringAMQP。并且还基于SpringBoot对其实现了自动装配，使用起来非常方便。\nSpringAMQP提供了三个功能：\n 自动声明队列、交换机及其绑定关系 基于注解的监听器模式，异步接收消息 封装了RabbitTemplate工具，用于发送消息  消息发送 rabbitTemplate.convertAndSend(queueName, message);\n1package com.itheima.publisher.amqp; 2 3import org.junit.jupiter.api.Test; 4import org.springframework.amqp.rabbit.core.RabbitTemplate; 5import org.springframework.beans.factory.annotation.Autowired; 6import org.springframework.boot.test.context.SpringBootTest; 7 8@SpringBootTest 9public class SpringAmqpTest { 10 11 @Autowired 12 private RabbitTemplate rabbitTemplate; 13 14 @Test 15 public void testSimpleQueue() { 16 // 队列名称 17 String queueName = \u0026#34;simple.queue\u0026#34;; 18 // 消息 19 String message = \u0026#34;hello, spring amqp!\u0026#34;; 20 // 发送消息 21 rabbitTemplate.convertAndSend(queueName, message); 22 } 23} 消息接收 @RabbitListener\n1package com.itheima.consumer.listener; 2 3import org.springframework.amqp.rabbit.annotation.RabbitListener; 4import org.springframework.stereotype.Component; 5 6@Component 7public class SpringRabbitListener { 8 // 利用RabbitListener来声明要监听的队列信息 9 // 将来一旦监听的队列中有了消息，就会推送给当前服务，调用当前方法，处理消息。 10 // 可以看到方法体中接收的就是消息体的内容 11 @RabbitListener(queues = \u0026#34;simple.queue\u0026#34;) 12 public void listenSimpleQueueMessage(String msg) throws InterruptedException { 13 System.out.println(\u0026#34;spring 消费者接收到消息：【\u0026#34; + msg + \u0026#34;】\u0026#34;); 14 } 15} WorkQueues模型 简单来说就是让多个消费者绑定到一个队列，共同消费队列中的消息。\n当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。\n此时就可以使用work 模型，多个消费者共同处理消息处理，消息处理的速度就能大大提高了。\n1@RabbitListener(queues = \u0026#34;work.queue\u0026#34;) 2public void listenWorkQueue1(String msg) throws InterruptedException { 3 System.out.println(\u0026#34;消费者1接收到消息：【\u0026#34; + msg + \u0026#34;】\u0026#34; + LocalTime.now()); 4 Thread.sleep(20); 5} 6 7@RabbitListener(queues = \u0026#34;work.queue\u0026#34;) 8public void listenWorkQueue2(String msg) throws InterruptedException { 9 System.err.println(\u0026#34;消费者2........接收到消息：【\u0026#34; + msg + \u0026#34;】\u0026#34; + LocalTime.now()); 10 Thread.sleep(200); 11} 消息是平均分配给每个消费者，并没有考虑到消费者的处理能力。导致1个消费者空闲，另一个消费者忙的不可开交。\n能者多劳 在spring中有一个简单的配置，可以解决这个问题。我们修改consumer服务的application.yml文件，添加配置：\n1spring:2rabbitmq:3listener:4simple:5prefetch:1# 每次只能获取一条消息，处理完成才能获取下一个消息可以发现，由于消费者1处理速度较快，所以处理了更多的消息；消费者2处理速度较慢，只处理了6条消息。而最终总的执行耗时也在1秒左右，大大提升。\n交换机类型 在订阅模型中，多了一个exchange角色，而且过程略有变化：\n Publisher：生产者，不再发送消息到队列中，而是发给交换机 Exchange：交换机，一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。 Queue：消息队列也与以前一样，接收消息、缓存消息。不过队列一定要与交换机绑定。 Consumer：消费者，与以前一样，订阅队列，没有变化  Exchange（交换机）只负责转发消息，不具备存储消息的能力，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！\n交换机的类型有四种：\n Fanout：广播，将消息交给所有绑定到交换机的队列。我们最早在控制台使用的正是Fanout交换机 Direct：订阅，基于RoutingKey（路由key）发送给订阅了消息的队列 Topic：通配符订阅，与Direct类似，只不过RoutingKey可以使用通配符 Headers：头匹配，基于MQ的消息头匹配，用的较少。  Fanout交换机 Fanout，英文翻译是扇出，我觉得在MQ中叫广播更合适。\n 1） 可以有多个队列 2） 每个队列都要绑定到Exchange（交换机） 3） 生产者发送的消息，只能发送到交换机 4） 交换机把消息发送给绑定过的所有队列 5） 订阅队列的消费者都能拿到消息  Direct交换机 在Fanout模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。\n在Direct模型下：\n 队列与交换机的绑定，不能是任意绑定了，而是要指定一个RoutingKey（路由key） 消息的发送方在 向 Exchange发送消息时，也必须指定消息的 RoutingKey。 Exchange不再把消息交给每一个绑定的队列，而是根据消息的Routing Key进行判断，只有队列的Routingkey与消息的 Routing key完全一致，才会接收到消息  Topic交换机 Topic类型的Exchange与Direct相比，都是可以根据RoutingKey把消息路由到不同的队列。\n只不过Topic类型Exchange可以让队列在绑定BindingKey 的时候使用通配符！\nBindingKey一般都是有一个或多个单词组成，多个单词之间以.分割，例如： item.insert\n通配符规则：\n #：匹配一个或多个词 *：匹配不多不少恰好1个词  举例：\n item.#：能够匹配item.spu.insert 或者 item.spu item.*：只能匹配item.spu  声明队列和交换机 发送者的可靠性 生产者重试机制 生产者发送消息时，出现了网络故障，导致与MQ的连接中断。为了解决这个问题，SpringAMQP提供的消息发送时的重试机制。即：当RabbitTemplate与MQ连接超时后，多次重试。\n修改publisher模块的application.yaml文件，添加下面的内容：\n1spring:2rabbitmq:3connection-timeout:1s# 设置MQ的连接超时时间4template:5retry:6enabled:true# 开启超时重试机制7initial-interval:1000ms# 失败后的初始等待时间8multiplier:1# 失败后下次的等待时长倍数，下次等待时长 = initial-interval * multiplier9max-attempts:3# 最大重试次数10SpringAMQP提供的重试机制是阻塞式的重试，也就是说多次重试等待的过程中，当前线程是被阻塞的。\n如果对于业务性能有要求，建议禁用重试机制。如果一定要使用，请合理配置等待时长和重试次数，当然也可以考虑使用异步线程来执行发送消息的代码。\n生产者确认机制 一般情况下，只要生产者与MQ之间的网路连接顺畅，基本不会出现发送消息丢失的情况，因此大多数情况下我们无需考虑这种问题。\n不过，在少数情况下，也会出现消息发送到MQ之后丢失的现象，比如：\n MQ内部处理消息的进程发生了异常 生产者发送消息到达MQ后未找到Exchange 生产者发送消息到达MQ的Exchange后，未找到合适的Queue，因此无法路由  针对上述情况，RabbitMQ提供了生产者消息确认机制，包括Publisher Confirm和Publisher Return两种。在开启确认机制的情况下，当生产者发送消息给MQ后，MQ会根据消息处理的情况返回不同的回执。\n 当消息投递到MQ，但是路由失败时，通过Publisher Return返回异常信息，同时返回ack的确认信息，代表投递成功 临时消息投递到了MQ，并且入队成功，返回ACK，告知投递成功 持久消息投递到了MQ，并且入队完成持久化，返回ACK ，告知投递成功 其它情况都会返回NACK，告知投递失败  MQ的可靠性 数据持久化 为了提升性能，默认情况下MQ的数据都是在内存存储的临时数据，重启后就会消失。为了保证数据的可靠性，必须配置数据持久化，包括：\n 交换机持久化 队列持久化 消息持久化  LazyQueue 在默认情况下，RabbitMQ会将接收到的信息保存在内存中以降低消息收发的延迟。一旦出现消息堆积问题，RabbitMQ的内存占用就会越来越高，直到触发内存预警上限。此时RabbitMQ会将内存消息刷到磁盘上，这个行为成为PageOut. PageOut会耗费一段时间，并且会阻塞队列进程。因此在这个过程中RabbitMQ不会再处理新的消息，生产者的所有请求都会被阻塞。\n为了解决这个问题，从RabbitMQ的3.6.0版本开始，就增加了Lazy Queues的模式，也就是惰性队列。惰性队列的特征如下：\n 接收到消息后直接存入磁盘而非内存 消费者要消费消息时才会从磁盘中读取并加载到内存（也就是懒加载） 支持数百万条的消息存储  消费者的可靠性 当RabbitMQ向消费者投递消息以后，需要知道消费者的处理状态如何。因为消息投递给消费者并不代表就一定被正确消费了，可能出现的故障有很多，比如：\n 消息投递的过程中出现了网络故障 消费者接收到消息后突然宕机 消费者接收到消息后，因处理不当导致异常 \u0026hellip;  一旦发生上述情况，消息也会丢失。因此，RabbitMQ必须知道消费者的处理状态，一旦消息处理失败才能重新投递消息。\n消费者确认机制 为了确认消费者是否成功处理消息，RabbitMQ提供了消费者确认机制（Consumer Acknowledgement）。即：当消费者处理消息结束后，应该向RabbitMQ发送一个回执，告知RabbitMQ自己消息处理状态。回执有三种可选值：\n ack：成功处理消息，RabbitMQ从队列中删除该消息 nack：消息处理失败，RabbitMQ需要再次投递消息 reject：消息处理失败并拒绝该消息，RabbitMQ从队列中删除该消息  一般reject方式用的较少。因此大多数情况下我们需要将消息处理的代码通过try catch机制捕获，消息处理成功时返回ack，处理失败时返回nack.\n由于消息回执的处理代码比较统一，因此SpringAMQP帮我们实现了消息确认。并允许我们通过配置文件设置ACK处理方式，有三种模式：\n none：不处理。即消息投递给消费者后立刻ack，消息会立刻从MQ删除。非常不安全，不建议使用 manual：手动模式。需要自己在业务代码中调用api，发送ack或reject，存在业务入侵，但更灵活 auto：自动模式。SpringAMQP利用AOP对我们的消息处理逻辑做了环绕增强，当业务正常执行时则自动返回ack. 当业务出现异常时，根据异常判断返回不同结果：  如果是业务异常，会自动返回nack； 如果是消息处理或校验异常，自动返回reject;    1spring:2rabbitmq:3listener:4simple:5acknowledge-mode:none# 不做处理失败重试机制 当消费者出现异常后，消息会不断requeue（重入队）到队列，再重新发送给消费者。如果消费者再次执行依然出错，消息会再次requeue到队列，再次投递，直到消息处理成功为止。\n极端情况就是消费者一直无法执行成功，那么消息requeue就会无限循环，导致mq的消息处理飙升，带来不必要的压力\n为了应对上述情况Spring又提供了消费者失败重试机制：在消费者出现异常时利用本地重试，而不是无限制的requeue到mq队列。\n修改consumer服务的application.yml文件，添加内容：\n1spring:2rabbitmq:3listener:4simple:5retry:6enabled:true# 开启消费者失败重试7initial-interval:1000ms# 初识的失败等待时长为1秒8multiplier:1# 失败的等待时长倍数，下次等待时长 = multiplier * last-interval9max-attempts:3# 最大重试次数10stateless:true# true无状态；false有状态。如果业务中包含事务，这里改为false 开启本地重试时，消息处理过程中抛出异常，不会requeue到队列，而是在消费者本地重试 重试达到最大次数后，抛出了AmqpRejectAndDontRequeueException异常, Spring会返回reject，消息会被丢弃  失败处理策略 在之前的测试中，本地测试达到最大重试次数后，消息会被丢弃。这在某些对于消息可靠性要求较高的业务场景下，显然不太合适了。\n因此Spring允许我们自定义重试次数耗尽后的消息处理策略，这个策略是由MessageRecovery接口来定义的，它有3个不同实现：\n RejectAndDontRequeueRecoverer：重试耗尽后，直接reject，丢弃消息。默认就是这种方式 ImmediateRequeueMessageRecoverer：重试耗尽后，返回nack，消息重新入队 RepublishMessageRecoverer：重试耗尽后，将失败消息投递到指定的交换机  比较优雅的一种处理方案是RepublishMessageRecoverer，失败后将消息投递到一个指定的，专门存放异常消息的队列，后续由人工集中处理。\n1@Bean 2public MessageRecoverer republishMessageRecoverer(RabbitTemplate rabbitTemplate){ 3 return new RepublishMessageRecoverer(rabbitTemplate, \u0026#34;error.direct\u0026#34;, \u0026#34;error\u0026#34;); 4} 业务幂等性 在程序开发中，则是指同一个业务，执行一次或多次对业务状态的影响是一致的。例如：\n 根据id删除数据 查询数据 新增数据  数据的更新往往不是幂等的，如果重复执行可能造成不一样的后果。比如：\n 取消订单，恢复库存的业务。如果多次恢复就会出现库存重复增加的情况 退款业务。重复退款对商家而言会有经济损失。  所以，我们要尽可能避免业务被重复执行。\n因此，我们必须想办法保证消息处理的幂等性。这里给出两种方案：\n 唯一消息ID 业务状态判断  唯一消息ID:\n这个思路非常简单：\n 每一条消息都生成一个唯一的id，与消息一起投递给消费者。 消费者接收到消息后处理自己的业务，业务处理成功后将消息ID保存到数据库 如果下次又收到相同消息，去数据库查询判断是否存在，存在则为重复消息放弃处理。  我们该如何给消息添加唯一ID呢？\n其实很简单，SpringAMQP的MessageConverter自带了MessageID的功能，我们只要开启这个功能即可。\n以Jackson的消息转换器为例：\n1@Bean 2public MessageConverter messageConverter(){ 3 // 1.定义消息转换器 4 Jackson2JsonMessageConverter jjmc = new Jackson2JsonMessageConverter(); 5 // 2.配置自动创建消息id，用于识别不同消息，也可以在业务中基于ID判断是否是重复消息 6 jjmc.setCreateMessageIds(true); 7 return jjmc; 8} 业务判断:\n业务判断就是基于业务本身的逻辑或状态来判断是否是重复的请求或消息，不同的业务场景判断的思路也不一样。\n在极小概率下可能存在线程安全问题。\n兜底方案","date":"2024-05-25","permalink":"/posts/tech/java-3-spring-cloud/","series":["Java"],"tags":["","",""],"title":"SpringCloud学习笔记"},{"categories":["计算机"],"content":"黑马Java进阶教程，全面剖析Java多线程编程，含抢红包、抽奖实战案例 ,现对学习到的内容做一个总结.\n一.多线程的三种方式 1.继承Thread类 继承Thread类,重写run方法.这里重写构造方法是为了方便在初始化的时候快速地设置线程的名称,当然也可以在创建线程后使用setName方法.\n1package mythread1; 2 3public class MyThread extends Thread{ 4 public MyThread(String name) { 5 super(name); 6 } 7 8 public MyThread() { 9 super(); 10 } 11 12 @Override 13 public void run() { 14 //写线程执行的代码 15 for (int i = 0; i \u0026lt; 100; i++) { 16 System.out.println(getName() + \u0026#34;: Hello World\u0026#34;); 17 } 18 } 19} 20 使用线程的start方法启动线程.\n1package mythread1; 2 3public class Main { 4 public static void main(String[] args) throws InterruptedException { 5 /* 6多线程第一种启动方式 71.定义类继承Thread类 82.重写run方法 93.创建子类对象，并启动线程 10*/ 11 //利用构造方法设置名字 12 MyThread t1 = new MyThread(\u0026#34;one\u0026#34;); 13 MyThread t2 = new MyThread(\u0026#34;two\u0026#34;); 14 //通过setName显式设置名字 15 //不显示地设置名字，它自己也有名字。 16// t1.setName(\u0026#34;Thread 1\u0026#34;); 17// t2.setName(\u0026#34;Thread 2\u0026#34;); 18 //开启线程 19 t1.start(); 20 //本线程,就是执行这个方法的线程,也就是main 21// Thread.sleep(5000); 22// Thread main = Thread.currentThread(); 23 t2.start(); 24 25 } 26} 2.实现Runnable接口 自定义类实现Runnable接口,重写run方法\n1package mythread2; 2 3public class MyThread implements Runnable { 4 @Override 5 public void run() { 6 for (int i = 0; i \u0026lt; 100; i++) { 7 //当前线程的对象 8// Thread t = Thread.currentThread(); 9// System.out.println(Thread.currentThread().getName() + \u0026#34; :Hello World\u0026#34;); 10 System.out.println(Thread.currentThread().getName() + i); 11 } 12 } 13} 14 创建好自定义类后,放入Thread类构造线程\nsetPriority是设置线程优先级,数目越高优先级越高\n1package mythread2; 2 3public class Main { 4 public static void main(String[] args) { 5 /* 6多线程第二种启动方式： 71.自己定义类实现runable接口 82.重写run方法 93.创建自己的类对象 104.创建Thread类对象，开启线程 11*/ 12 13 //自己的类对象，其实就是多线程的任务 14 MyThread myThread = new MyThread(); 15 //Thread 16 Thread t1 = new Thread(myThread,\u0026#34;线程1\u0026#34;); 17 Thread t2 = new Thread(myThread,\u0026#34;线程2\u0026#34;); 18 //设置名字以区分，这是Thread类的方法 19// t1.setName(\u0026#34;Thread 1\u0026#34;); 20// t2.setName(\u0026#34;Thread 2\u0026#34;); 21 System.out.println(t1.getPriority()); 22 System.out.println(t2.getPriority()); 23 //设置优先级,越高越能抢到cpu,这只是概率. 24 t1.setPriority(1); 25 t2.setPriority(10); 26 27 //开启 28 t1.start(); 29 t2.start(); 30 } 31} 32 3.实现Callable接口 自定义类实现Callable接口,重写Call方法.这个Call方法是有返回值的.\n1package mythread3; 2 3import java.util.concurrent.Callable; 4 5public class MyCallable implements Callable\u0026lt;Integer\u0026gt; { 6 @Override 7 public Integer call() throws Exception { 8 int sum = 0; 9 for (int i = 0; i \u0026lt;= 100; i++) { 10 sum += i; 11 } 12 return sum; 13 } 14} 15 下面注释已经写得很清楚了,实例化实现Callable接口的类,然后放入FutureTask对象进行管理,再将FutureTask放入Thread进行初始化.\n这种方式可以获取线程执行的返回值.\n1package mythread3; 2 3import java.util.concurrent.ExecutionException; 4import java.util.concurrent.FutureTask; 5 6public class Main { 7 public static void main(String[] args) throws ExecutionException, InterruptedException { 8 /* 9多线程第三种实现方式： 10特点：可以获取到多线程运行的结果 111.创建类实现Callable接口 122.重写call，可以获取结果 133.创建实现接口的对象 144.创建FutureTask接口对象，管理多线程运行的结果 155.创建Thread对象 16*/ 17 MyCallable mc = new MyCallable(); 18 FutureTask\u0026lt;Integer\u0026gt; ft = new FutureTask\u0026lt;\u0026gt;(mc); 19 Thread t1 = new Thread(ft); 20 t1.start(); 21 22 //获取结果 23 System.out.println(ft.get()); 24 25 } 26} 27 二.守护线程,出让线程,插入线程 不太重要\n1package mythread4; 2 3 4public class Main { 5 public static void main(String[] args) throws InterruptedException { 6// MyThread1 myThread1 = new MyThread1(); 7// MyThread2 myThread2 = new MyThread2(); 8// myThread1.setName(\u0026#34;hime\u0026#34;); 9// myThread2.setName(\u0026#34;prince\u0026#34;); 10// 11// //设置守护线程,当其他非守护线程结束后,守护线程陆续结束 12// //就是它自己不会运行完,慢慢地结束了. 13// myThread2.setDaemon(true); 14// myThread1.start(); 15// myThread2.start(); 16 17// MyThread1 t1 = new MyThread1(); 18// MyThread1 t2 = new MyThread1(); 19// t1.setName(\u0026#34;线程1\u0026#34;); 20// t2.setName(\u0026#34;线程2\u0026#34;); 21// t1.start(); 22// t2.start(); 23 24 MyThread1 t1 = new MyThread1(); 25 t1.setName(\u0026#34;另一个线程\u0026#34;); 26 t1.start(); 27 //插入线程 28 //把t线程,插入到当前线程(main线程)之前 29 //t1全都执行完,才该main执行 30 t1.join(); 31 32 for (int i = 0; i \u0026lt; 10; i++) { 33 System.out.println(\u0026#34;main线程\u0026#34; + \u0026#34;@\u0026#34; + i); 34 } 35 36 } 37} 38 1package mythread4; 2 3public class MyThread1 extends Thread{ 4 @Override 5 public void run() { 6 for (int i = 0; i \u0026lt; 100; i++) { 7 System.out.println(getName() + \u0026#34;@\u0026#34; + i); 8 //出让线程 9 //出让cpu执行权,就是不会一直抢着,重写和其他线程继续抢夺,这样执行结果可能会均匀一点. 10// Thread.yield(); 11 } 12 } 13} 14 三.线程安全(线程同步) 同步代码块 同步代码块用synchronized包裹,再括号之后需要放入一个唯一的锁对象,可以使用static修饰,也可以放入当前类的字节码文件\n1package threadsafe; 2 3public class MyThread extends Thread{ 4 static int ticket = 0; 5 6 //锁对象,一定是唯一的 7// static Object object = new Object(); 8 9 public MyThread() { 10 super(); 11 } 12 13 public MyThread(String name) { 14 super(name); 15 } 16 17 @Override 18 public void run() { 19 while (true){ 20 //同步代码块 21 synchronized (MyThread.class){ 22 if (ticket \u0026lt;= 100){ 23 try { 24 Thread.sleep(100); 25 } catch (InterruptedException e) { 26 throw new RuntimeException(e); 27 } 28 ticket++; 29 System.out.println(getName() + \u0026#34;selling ticket \u0026#34; + ticket); 30 }else { 31 break; 32 } 33 } 34 } 35 } 36 37 38 39} 40 同步方法 也可以把同步代码块抽取出来形成一个方法,称为同步方法,其实就是用synchronized修饰的方法\n同步方法:非静态的时候锁对象是this;静态的时候锁对象是当前类字节码文件\n1package threadsafe; 2 3public class MyRunnable implements Runnable{ 4 //这里不需要设置静态变量,因为只有一个实例. 5 int ticket = 0; 6 7 @Override 8 public void run() { 9 while (true){ 10 if (method()) break; 11 } 12 } 13 14 //同步方法. 非静态的时候锁对象是this;静态的时候锁对象是当前类字节码文件 15 private synchronized boolean method() { 16 if (ticket \u0026lt; 100){ 17 try { 18 Thread.sleep(100); 19 } catch (InterruptedException e) { 20 throw new RuntimeException(e); 21 } 22 ticket++; 23 System.out.println(Thread.currentThread().getName() + \u0026#34; selling ticket \u0026#34; + ticket); 24 }else { 25 return true; 26 } 27 return false; 28 } 29} 30 lock锁 创建一把静态锁, 然后在需要同步的代码块上使用lock方法, 在代码块结束时使用unlock方法.\n1package threadsafe; 2 3import java.util.concurrent.locks.Lock; 4import java.util.concurrent.locks.ReentrantLock; 5 6public class MyLock extends Thread{ 7 static int ticket = 0; 8 9 //多个对象共享同一把锁,加static 10 static Lock lock = new ReentrantLock(); 11 12 //锁对象,一定是唯一的 13// static Object object = new Object(); 14 15 public MyLock() { 16 super(); 17 } 18 19 public MyLock(String name) { 20 super(name); 21 } 22 23 @Override 24 public void run() { 25 while (true){ 26 //同步代码块 27 //synchronized (MyLock.class){ 28 lock.lock(); 29 try { 30 if (ticket \u0026lt;= 100){ 31 Thread.sleep(100); 32 ticket++; 33 System.out.println(getName() + \u0026#34;selling ticket \u0026#34; + ticket); 34 }else { 35 break; 36 } 37 } catch (InterruptedException e) { 38 throw new RuntimeException(e); 39 } finally { 40 //锁一定会被释放 41 lock.unlock(); 42 } 43 //} 44 } 45 } 46} 四. 生产者-消费者机制 生产者消费者模式是一个经典的多线程协作模式.\n等待唤醒机制 桌子Desk.class(控制生产者消费者的执行):\n1package waitandnotify1; 2 3public class Desk { 4 /* 5控制生产者和消费者状态 6*/ 7 8 //桌子上是否有面条,0表示没有,1表示有 9 public static int foodFlag = 0; 10 11 //总个数 12 public static int count = 10; 13 14 //锁 15 public static Object lock = new Object(); 16} 17 消费者Foodie.class:\n1package waitandnotify1; 2 3public class Foodie extends Thread{ 4 @Override 5 public void run() { 6 /* 71.循环 82.同步代码块 93.判断共享数据是否到了末尾,到了末尾 104.没有到末尾,执行核心逻辑 11*/ 12 while (true){ 13 synchronized (Desk.lock){ 14 if (Desk.count == 0){ 15 break; 16 }else { 17 /* 18判断是否有面条 19没有则等待 20有,吃,然后唤醒厨师,吃的数目减一,修改桌子状态 21*/ 22 if(Desk.foodFlag == 0){ 23 try { 24 Desk.lock.wait(); //当前线程和锁绑定,方便唤醒 25 } catch (InterruptedException e) { 26 throw new RuntimeException(e); 27 } 28 }else { 29 Desk.count--; 30 System.out.println(\u0026#34;eating, left \u0026#34; + Desk.count + \u0026#34; bowl to eat\u0026#34;); 31 Desk.lock.notifyAll(); 32 Desk.foodFlag = 0; 33 } 34 } 35 } 36 } 37 } 38} 生产者Cook.class:\n1package waitandnotify1; 2 3public class Cook extends Thread{ 4 @Override 5 public void run() { 6 while (true){ 7 synchronized (Desk.lock){ 8 if (Desk.count == 0){ 9 break; 10 }else{ 11 if (Desk.foodFlag == 1){ 12 try { 13 Desk.lock.wait(); 14 } catch (InterruptedException e) { 15 throw new RuntimeException(e); 16 } 17 }else { 18 System.out.println(\u0026#34;Cooking, left \u0026#34; + Desk.count + \u0026#34; to cook\u0026#34;); 19 Desk.lock.notifyAll(); 20 Desk.foodFlag = 1; 21 } 22 } 23 } 24 } 25 } 26} 27 测试代码:\n1package waitandnotify1; 2 3public class ThreadDemo { 4 public static void main(String[] args) { 5 //等待唤醒机制完成生产者-消费者 6 Cook c = new Cook(); 7 Foodie f = new Foodie(); 8 c.setName(\u0026#34;Cooker\u0026#34;); 9 f.setName(\u0026#34;Foodie\u0026#34;); 10 c.start(); 11 f.start(); 12 } 13} 14 阻塞队列实现等待唤醒机制 生产者:\n1package waitandnotify2; 2 3import java.util.concurrent.ArrayBlockingQueue; 4 5public class Cook extends Thread{ 6 7 //成员变量 8 ArrayBlockingQueue\u0026lt;String\u0026gt; queue; 9 10 //构造方法 11 public Cook(ArrayBlockingQueue\u0026lt;String\u0026gt; queue) { 12 this.queue = queue; 13 } 14 15 @Override 16 public void run() { 17 while(true){ 18 try { 19 //自带锁,里面会判断当前队列是否是满的 20 queue.put(\u0026#34;noodle\u0026#34;); 21 System.out.println(\u0026#34;put noodle in queue\u0026#34;); 22 } catch (InterruptedException e) { 23 throw new RuntimeException(e); 24 } 25 26 } 27 28 } 29} 30 消费者:\n1package waitandnotify2; 2 3import java.util.concurrent.ArrayBlockingQueue; 4 5public class Foodie extends Thread{ 6 7 ArrayBlockingQueue\u0026lt;String\u0026gt; queue; 8 9 public Foodie(ArrayBlockingQueue\u0026lt;String\u0026gt; queue) { 10 this.queue = queue; 11 } 12 13 @Override 14 public void run() { 15 while(true){ 16 try { 17 String food = queue.take(); 18 System.out.println(\u0026#34;eating a bowl of noodle\u0026#34;); 19 } catch (InterruptedException e) { 20 throw new RuntimeException(e); 21 } 22 } 23 } 24} 25 测试(提供一个阻塞队列):\n1package waitandnotify2; 2 3import java.util.concurrent.ArrayBlockingQueue; 4 5 6 7public class ThreadDemo { 8 public static void main(String[] args) { 9 //阻塞队列完成生产者-消费者 10 11 //创建阻塞队列 12 ArrayBlockingQueue\u0026lt;String\u0026gt; queue = new ArrayBlockingQueue\u0026lt;\u0026gt;(1); 13 //创建线程对象,将阻塞队列传入 14 Cook cook = new Cook(queue); 15 Foodie foodie = new Foodie(queue); 16 //开启线程 17 cook.start(); 18 foodie.start(); 19 } 20} 21 五.线程的六种状态 \r线程状态:\n 新建new,创建线程对象 就绪runnable,start方法 阻塞blocked,无法获得锁对象 等待waiting,wait方法 计时等待timed_waiting,sleep方法 结束terminated,全部代码执行完毕.  作业代码就不贴了, 以后需要复习时重新写.\n","date":"2024-05-09","permalink":"/posts/tech/java-1-thread/","series":["Java"],"tags":["","",""],"title":"Java多线程"},{"categories":["计算机"],"content":"本篇对面试的作用微乎其微\n面试总结：问了我半个小时，一半多的重要的东西都答不上来，特别重要的是多线程，还有数据库。算是一场经历吧。\n本篇对面试的作用微乎其微, 这里面有很大部分不会被问到.\n面试需要的准备：\n 视频看两遍，第二遍总结 复习之前做过的Java项目 复习之前看过的spring视频和代码。  一、Java基础 1.JDK、JRE、JVM三者区别和联系 jdk是java开发工具，jre是java运行时环境，jvm是java虚拟机。\njdk包含jre，jre中的bin就是jvm，lib就是类库。\njavac编译成class文件，class文件是字节码文件，由jvm解释为对应系统的机器码。\n2.==和equals ==对比栈的值，基本类型是变量值，引用类型是堆中内存对象的地址。equals默认是采用==比较。String中已经重写了equals方法，不然由于String是不可变的原因会不一样。\n3.final final修饰变量，变量初始化后不可变；修饰类，类不可被继承；修饰方法，方法不能被子类覆盖，但是可以被重载。修饰引用类型，初始化后不能让其指向另一个对象，但引用值可以改变。\n局部内部类和匿名内部类只能访问局部final变量。这是因为外部类方法结束变量就会销毁，但是内部类对象可能还存在，所以复制一份局部变量供内部类使用，为了保证这两个变量一致，所以用final修饰。\n4.String、StringBuffer、StringBuilder String 是final修饰的，不可变，每次操作会产生新对象。\nStringBuffer和StringBuilder都是在原对象上操作。\nStringBuffer是线程安全的，StringBuilder是线程不安全的。但是StringBuilder性能要高些。\n经常需要改变字符串就使用后面两个。\n优先使用StringBuilder，多线程使用共享变量使用StringBuffer\n5.重载和重写 重载：在同一个类中，方法名相同，参数类型不同，个数不同，顺序不同，方法返回值，修饰符可以不同。发生在编译。\n重写：发生在父子类，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符大于等于父类；如果父类方法修饰符为private则子类不能重写该方法。\n6.接口和抽象类 抽象类可以存在普通成员函数，而接口只能存在public abstract方法。\n抽象类的成员变量可以是各种类型的，而接口中的成员变量只能说public static final类型的。\n抽象类只能继承一个，接口可以实现多个。\n接口是对类的行为进行约束，约束了行为的有无，不对如何实现进行限制。对行为的抽象。is a的关系\n抽象类是为了代码复用，不同的类有相同的行为，都可以派生一‘个抽象类。是对类本质的抽象。like a的关系\n7.List和Set List：有序，可以重复，按对象进入的顺序保存，允许多个null元素对象，使用迭代器遍历，还可以get（int index）\nSet：无序，不可重复，最多允许有一个null对象，取元素只能用迭代器。\n8.hashCode与equals hashCode获取散列码，是int型整数，用于确定对象在hash表的索引位置。HashSet检查重复元素，就是比较hashCode看对应位置是否有值，没有就假设对象没有重复出现；有值才会调用equals方法检查两个对象是否真的相同（相同的对象hash值可能不同），相同就不会让其加入成功，不同重新散列到其他为止，这大大减少了equals次数。\n 两个对象相等，hashcode相同，equals返回true 两个对象hashcode相同，他们不一定相等  9.ArrayList和LinkedList ArrayList：基于动态数组，连续内存存储，适合下标访问，扩容就是新建一个然后把原来的复制，插入数据会涉及到元素的移动。使用尾插法可以极大提高性能，比linkedlist快（创建node节点）。\nLinkedList：基于链表，存储在分散的内存，适合插入和删除不适合查询。遍历使用迭代器，get(i)需要对list遍历，indexof也是会遍历整个list。\n10.HashMap和HashTable 1.HashMap线程不安全，HashTable线程安全\n2.HashMap允许key value为空，HashTable不允许\nHashMap是数组+链表实现的。jdk8开始，数组长度超过64，链表高度超过8，链表转化为红黑树，元素以内部类Node节点存在。\n 计算key的hash值，再二次hash得到一个数，这个数对数组长度取模，于是得到一个数组下标。 如果没有产生hash冲突（对应下标位置没有元素），则直接创建Node存入数组 产生hash冲突，先equals比较，相同就取代，不同判断链表高度插入链表，链表高度达到8，并且数组长度到64就转红黑树，长度低于6转回链表。 key为null存在下标为0的位置  11.ConcurrentHashMap原理 线程安全版本的HashMap。\njdk7：ReentrantLock+Segment+HashEntry。一个segment是一个HashEntry数组，每一个HashEntry是链表。\n查询：第一次hash定位到segment，第二次hash定位到元素所在链表的头部\n锁：Segment分段锁，Segment继承了ReentrantLock，锁定操作的segment，其余的Segment不受影响。并发度为segment个数，数组扩容不会影响其他segment。\njdk8：\n12.如何实现IOC容器  配置文件，配置包扫描路径 定义注解，表示控制层，服务层，数据持久层，依赖注入层，配置文件注解 递归包路径获取class文件，将这些文件添加到set集合存储 遍历set，获取在类上有指定注解的类，定义一个安全map存储这些对象，反射，确定需要交给IOC管理的类 对需要注入的类进行依赖注入  13.字节码 在机器和编译程序中加入了一层抽象的虚拟的机器。这台虚拟的机器在任何平台上都提供给编译程序一个共同的接口。于是编译程序只需要面向虚拟机，生成虚拟机理解的代码，再由虚拟机的解释器将字节码转换为特定系统的机器码执行。\njava源代码-\u0026gt;编译器-\u0026gt;jvm可执行的字节码-\u0026gt;jvm-\u0026gt;jvm的解释器-\u0026gt;机器可执行的二进制机器码-\u0026gt;程序运行\n好处：一定程度上解决了传统解释型语言执行效率低的问题；保留了解释型语言可移植的特点。java文件无需重新编译便可在多种平台运行。\n14.Java类加载器 JDK自带三个类加载器：bootstrap classloader，ExtClassLoader，AppClassLoader\nbootstrap classloader是ExtClassLoader父类加载器（不是直接继承），默认加载java_home/lib下的jar包和class文件。\nExtClassLoader是AppClassLoader的父类加载器，负责加载java_home/lib/ext下的jar包和class文件\nAppClassLoader是自定义类加载器的父类，加载classpath的类文件。\n继承ClassLoader实现自定义加载器。\n15.双亲委派（委托）模型 AppClassLoader中如果没有缓存，就往上委派，都是查找缓存，缓存没有就继续委派。到了最顶层缓存还是没有，查找加载路径，没有向下查找，继续查找加载路径。到发起加载的加载器为止。\n好处：为了安全性，避免用户自己编写的类动态替换Java的一些核心类。同时避免了类重复加载，相同的class文件被不同的加载器加载就是不同的两个类。\n16.Java异常体系 所有异常来自顶级父类Throwable，Throwable有两个子类：exception和error。\nerror是程序无法处理的错误，一旦出现，程序被迫终止\nexception不会导致程序停止，又分为runtimeEception运行时异常（发生在程序运行过程中，导致程序当前线程执行失败）和checkedException检查异常（常常发生在程序编译过程中，导致程序编译不通过）。\n二、Spring 1.单例Bean是单例模式吗？ 但单例模式是指在一个JVM中，一个类只能构造出来一个对象\n单例Bean也是以一种单例模式，但是范围很小，只是一个beanName的范围，一个beanName对应一个Bean对象，不同的beanName对应不同的Bean对象（可以同一个类）。\n2.Bean的实例化和初始化有什么区别？ Spring创建Bean时，先创建一个对象，然后通过反射执行类构造方法得到一个Java对象，这个过程就是Bean的实例化。\n得到对象后进行依赖注入，之后就可以初始化了。Bean的初始化就是调用前面创建出来的Java对象中特定的方法，比如Java对象实现了InitializingBean接口，那么初始化就会执行Java对象的afterPropertiesSet()方法。\n3.Spring AOP如何实现？和AspectJ有什么区别？ AOP是利用的动态代理机制，如果Bean实现了接口，那么就会采用JDK动态代理来生成该接口的代理对象，如果一个Bean没有实现接口，就会采用CGLIB生成当前对象的代理对象。代理对象会代理原来的Bean对象，执行某个方法时会在原来的基础上增加一些切面逻辑，使得我们可以利用AOP来实现一些登录校验，权限控制等统一功能。\nAOP和AspectJ没有特别强的关系，AOP是面向切面编程，一种编程思想。AspectJ可以实现这种思想，它在编译器对类进行增强。而Spring AOP通过动态代理实现AOP，但底层实现和AspectJ不一样，只是注解的名字是相同的（before around after）\n4.Spring事务如何实现？  底层是基于数据库事务和AOP机制。 使用了@Transactional注解的Bean，会创建一个代理对象。调用代理对象的方法时，会先判断该方法是否加了@Transactional注解 加了的话，会利用事务管理器创建一个数据库连接，修改数据库连接的AutoCommit属性为false，禁止自动提交。 然后执行方法，执行方法中的sql 执行完后没有异常就提交 出现了异常，根据异常的类型是不是rollbackfor指定的，再选择是否回滚  Spring事务的隔离级别对应的就是数据库的隔离级别\n5.你是如何理解Spring事务的传播机制的？底层是如何实现的？ Spring事务的传播机制是Spring事务自己实现的（propagation）。这个传播机制是基于数据库连接的，新开一个事务就是新建一个数据库连接。\n6.那些情况会导致Spring事务失效？对应原因？   方法内自调用：因为事务是基于AOP的，使用代理对象调用方法时事务才能生效。而在一个方法中调用this.xx()这个this不是代理对象，事务就会失效。\n解决办法：a 把调用的方法拆到另一个bean中\n​\tb 自己注入自己\n​\tc\n  方法是private的：Spring事务会基于CGLIB进行AOP，而CGLIB会基于父子类生效。如果父类中的某个方法是private，子类就没有办法重写，也就没办法而外为其增加逻辑。\n  方法是final的，和上者原理一样，子类不能重写父类的final方法\n  单独的线程调用方法：如果不是同一个线程，就从ThreadLocal中拿不到数据库连接对象，这样自己只能新建一个，这个新建的的AutoCommit是true。\n  没加@Configuration注解：springboot基本没有这个问题。如果是spring的话，没有加注解会导致map中存的DataSource和Mybatis和JdbcTemplate中的DataSource不相等。又会自己去创建连接。\n  异常被吃掉：事务没有捕获到异常就不会回滚了\n  类没有被Spring管理\n  数据库不支持事务\n  7.Spring中Bean创建的生命周期  推断构造方法 实例化 依赖注入（填充属性） 处理Aware回调 初始化前，处理@PostConstruct 初始化，处理initializingBean接口 初始化后，进行AOP  8.Spring中Bean是线程安全的吗 这取决于Bean本身，Bean本身是无状态，就是线程安全；本身有状态，就是线程不安全。\n9.ApplicationContext和BeanFactory有什么区别 BeanFactory可以生成Bean，维护Bean。ApplicationContext继承自BeanFactory，有BeanFactory的特点，由于继承了其他接口，还有其他功能，如获取系统环境变量，国际化，事件发布等功能。\n10.Spring容器的启动流程是怎样的  扫描，得到所有的BeanDefinition对象，存在Map中。 筛选单例BeanDefinition创建Bean，对于多例Bean会在每次获取Bean时利用BeanDefinition去创建。 利用BeanDefinition创建Bean就是Bean的创建生命周期，包括推断构造，实例化，依赖注入，初始化前，初始化，初始化后（AOP） 单例Bean创建完了，Spring发布一个容器启动事件。 Spring启动结束  11.Spring为什么要用三级缓存来解决循环依赖 三、SpringBoot 1.@SpringBootApplication注解有什么用？ 它是一个复合注解，是@SpringBootConfiguration，@EnableAutoConfiguration，@ComponentScan三个注解的整合。\n@SpringBootConfiguration：相当于@Configuration，表示这是一个配置类\n@EnableAutoConfiguration：负责自动配置类的导入，将项目的自动配置类导入到Spring容器\n@ComponentScan：Spring容器会进行扫描，扫描路径为当前这个类所在的包路径\n2.spring.factories有什么作用？ spring.factories是SpringBoot SPI（扩展）机制实现的核心。\n在SpringBoot启动过程中，会找出项目中所有的spring.factories，从而向Spring容器添加各个spring.factories中指定的ApplicationListener，ApplicationContextInitializer，配置类。使得对SpringBoot做扩展非常容易。\n3.如何理解SpringBoot自动配置？ 在Spring中，通常需要配置很多的Bean，比如Mybatis的SqlSessionFactory；AOP的@EnableAspectJAutoProxy注解等\n在SpringBoot中，内置了很多配置类，叫做自动配置类。在依赖了spring-boot-starer-web后会间接依赖到spring-boot-autoconfigure这个jar，里面就有很多自动配置类。\n4.SpringBoot启动时做了哪些事？  判断当前应用的类型，如是不是web应用，是servlet还是webflux应用，不同类型后续会创建不同的Spring容器。 根据类型创建Spring容器 解析启动类，进行扫描，导入自动配置类并解析。 启动tomcat或者jetty 调用ApplicationRunner或CommandLineRunner  四、SpringMVC 1.SpringMVC的处理流程是什么？  启动Tomcat中，创建DispatcherServlet对象，执行初始化逻辑 DispatcherServlet初始化创建Spring容器，初始化中还要初始化HandlerMapping，HandlerAdapter等。 SpringMVC提供了好几个HandlerMapping，其中有一个为RequestMappingHandlerMapping，它去寻找Spring容器中哪些加了@RequestMapping的方法。 找到这些方法后，解析注解上指定的path，把path作为key，method作为value存到一个map中。 DispatcherServlet接收到请求后，RequestMappingHandlerMapping就会根据请求路径找到对应method。 解析各个参数，从请求中拿到对应值，执行method。 执行完得到方法返回值，SpringMVC进一步解析，如果加了@ResponseBody就直接返回值给浏览器，没有的话根据返回值找页面。 ","date":"2024-04-29","permalink":"/posts/tech/java-0-audition/","series":["Java"],"tags":[""],"title":"Java面试准备1"},{"categories":["二次元"],"content":" 好听，所以想唱出来。\n1.歌词  作词 : 秋田ひろむ\n作曲 : 秋田ひろむ\n编曲 : 出羽良彰\n僕が死のうと思ったのは ウミネコが桟橋[さんばし]で鳴[な]いたから\n曾经我也想过一了百了 因为有黑尾鸥在码头悲鸣\n波[なみ]の随意（まにま）に浮（う）かんで消える[きえる] 過去[かこ]も啄[つい]ばんで飛[と]んでいけ\n随着浪花起伏消没 叼啄着往昔飞离不见\n僕が死のうと思ったのは 誕生日に杏[あんず]の花が咲[さ]いたから\n曾经我也想过一了百了 因为生日那天杏花开放\nその木漏れ日[こもれび]でうたた寝したら 虫[むし]の死骸[しがい]と土[つち]になれるかな\n若是在那洒下的阳光里打盹 能否与虫之死骸一同化为尘土呢\n薄荷[はっか]飴[あめ] 漁港[ぎょこう]の灯台[とうだい] 錆[さ]びたアーチ橋（きょう） 捨（す）てた自転車（じてんしゃ）\n薄荷糖 渔港的灯塔 生锈的拱桥 丢弃的自行车\n木造（もくぞう）の駅（えき）のストーブの前（まえ）で どこにも旅立たびだ）てない心\n木造车站的暖炉前 无处可去的心灵\n今日はまるで昨日みたいだ 明日（あす）を変えるなら今日を変えなきゃ\n今天与昨天如此相像 想改变明天 必须改变今天\n分かってる 分かってる けれど\n我知道 我知道 但是\u0026hellip;\n僕が死のうと思ったのは 心が空っぽになったから\n曾经我也想过一了百了 因为心中已空无一物\n満（み）たされないと泣（な）いているのは きっと満たされたいと願（ねが）うから\n感到空虚而哭泣 一定是渴望得到充实\n僕が死のうと思ったのは 靴紐（くつひも）が解（ほど）けたから\n曾经我也想过一了百了 因为鞋带松开了\n結（むす）びなおすのは苦手（にがて）なんだよ 人との繋（つな）がりもまた然（しか）り\n不擅长重新系起 与人的牵绊亦是如此\n僕が死のうと思ったのは 少年（しょうねん）が僕を見（み）つめていたから\n曾经我也想过一了百了 因为少年深情凝视着我\nベッドの上で土下座（どげざ）してるよ あの日の僕にごめんなさいと\n抱膝跪在床上 向那天的我说抱歉\nパソコンの薄明（うすあ）かり 上階（じょうかい）の部屋（へや）の生活音（せいかつおん）\n屏幕的微光 楼上的噪音\nインターフォンのチャイムの音（おと） 耳（みみ）を塞（ふさ）ぐ鳥かごの少年\n电话的铃声 紧塞住双耳 那笼中的少年\n見えない敵（てき）と戦（たたか）ってる 六畳（ろくじょう）一間（ひとま）のドンキホーテ\n与看不见的敌人战斗着 六畳一间的堂吉诃德\nゴールはどうせ醜（みにく）いものさ\n反正目的也是一样丑陋\n僕が死のうと思ったのは 冷（つめ）たい人と言（い）われたから\n曾经我也想过一了百了 因为被说是个冷漠的人\n愛されたいと泣いているのは 人の温（ぬく）もりを知（し）ってしまったから\n想要被爱而哭泣 是因为尝到了人的温暖\n僕が死のうと思ったのは あなたが綺麗（きれい）に笑（わら）うから\n曾经我也想过一了百了 因为你灿烂的笑容\n死ぬことばかり考（かんが）えてしまうのは きっと生きる事（こと）に真面目（まじめ）すぎるから\n净考虑着死的事 一定是因为太过认真地活\n僕が死のうと思ったのは まだあなたに出会（であ）ってなかったから\n曾经我也想过一了百了 因为还未与你相遇\nあなたのような人が生（う）まれた 世界を少し好きになったよ\n因为有像你这样的人出现 我对世界稍微有了好感\nあなたのような人が生きてる 世界に少し期待するよ\n因为有像你这样的人活在这个世上 我对世界稍微有了期待\n 引用 僕（ぼく）が死（し）のうと思（おも）ったのは\nウミネコが桟桥（さんばし）で鸣（な）いたから 波（なみ）の随意（まにま）に浮（う）かんで消（き）える\n过去（かこ）も啄（つい）ばんで飞（と）んでいけ\n僕（ぼく）が死（し）のうと思（おも）ったのは\n诞生日（たんじょうび）に杏（あんず）の花（はな）が咲（さ）いたから その木漏（こも）れ日（び）でうたた寝（ね）したら\n虫（むし）の死骸（しがい）と土（つち）になれるかな\n薄荷饴（はっかあめ）\n渔港（ぎょこう）の灯台（とうだい）\n锖（さ）びたアーチ桥（きょう）\n舍（す）てた自転车（じてんしゃ） 木造（もくぞう）の駅（えき）のストーブの前（まえ）で\nどこにも旅立（たびだ）てない心（こころ） 今日（きょう）はまるで昨日（きのう）みたいだ\n明日（あす）を変（か）えるなら今日（きょう）を変（か）えなきゃ 分（わ）かってる　分（わ）かってる　けれど\n僕（ぼく）が死（し）のうと思（おも）ったのは\n心（こころ）が空（から）っぽになったから 満（み）たされないと泣（な）いているのは\nきっと満（み）たされたいと愿（ねが）うから\n僕（ぼく）が死（し）のうと思（おも）ったのは\n靴纽（くつひも）が解（ほど）けたから 结（むす）びなおすのは苦手（にがて）なんだよ\n人（ひと）との繋（つな）がりもまた然（しか）り\n僕（ぼく）が死（し）のうと思（おも）ったのは\n少年（しょうねん）が僕（ぼく）を见（み）つめていたから ベッドの上（うえ）で土下座（どげざ）してるよ\nあの日（ひ）の僕（ぼく）にごめんなさいと\nパソコンの薄明（うすあ）かり\n上阶（じょうかい）の部屋（へや）の生活音（せいかつおん） インターフォンのチャイムの音（おと）\n耳（みみ）を塞（ふさ）ぐ鸟（とり）かごの少年（しょうねん） 见（み）えない敌（てき）と戦（たたか）ってる\n六畳（ろくじょう）一间（ひとま）のドンキホーテ ゴールはどうせ丑（みにく）いものさ\n僕（ぼく）が死（し）のうと思（おも）ったのは\n冷（つめ）たい人（ひと）と言（い）われたから 爱（あい）されたいと泣（な）いているのは\n人（ひと）の温（ぬく）もりを知（し）ってしまったから\n僕（ぼく）が死（し）のうと思（おも）ったのは\nあなたが绮丽（きれい）に笑（わら）うから 死（し）ぬことばかり考（かんが）えてしまうのは\nきっと生（い）きる事（こと）に真面目（まじめ）すぎるから\n僕（ぼく）が死（し）のうと思（おも）ったのは\nまだあなたに出会（であ）ってなかったから あなたのような人（ひと）が生（う）まれた\n世界（せかい）を少（すこ）し好（す）きになったよ\nあなたのような人（ひと）が生（い）きてる\n世界（せかい）に少（すこ）し期待（きたい）するよ\n作者：残天大魔王 https://www.bilibili.com/read/cv10662266/ 出处：bilibili\n","date":"2023-10-16","permalink":"/posts/anime/bokugashinouto/","series":["动漫歌曲",""],"tags":["",""],"title":"僕が死のうと思ったのは"},{"categories":["计算机"],"content":"0x01 第一种方式：使用bash 新版Kali默认的shell是zsh，而常见添加环境变量的方式是通过/etc/profile中，最好再在~/.bashrc中source一下生效。为了使用bash，需要修改/etc/passwd文件中对应用户的默认shell，比如root用户将\n1root❌0:0:root:/root:/usr/bin/zsh 变为\n1root❌0:0:root:/root:/bin/bash 修改之后再用普通bash添加环境变量的方式就可以了。\n0x01 第二种方式：使用zsh 还是想用漂亮的zsh怎么办？那就在zsh中添加环境变量！\n只需要在~/.zshrc中末尾添加环境变量，这是不需要再source了：\n1N=\u0026#34;/usr/local/go/bin\u0026#34; 2export PATH=$PATH:$N 这是如果再在后面加上source ./zshrc的话，会循环使用这个文件。\n这里还有个问题，当使用sudo执行命令时，sudo命令为了安全考虑将PATH环境变量进行了重置，我们可以使用sudo visudo或者vim /etc/sudoers进行修改。具体关于su和sudo的区别可以参考下面这篇文章：\nhttps://blog.csdn.net/weixin_39490665/article/details/123130500\n0x03 引用 不得不说网络上东西错误有点多，搞了估计有3小时才解决。\n https://blog.csdn.net/qq_30895747/article/details/126872781 https://blog.csdn.net/weixin_51368459/article/details/127682963 https://blog.csdn.net/weixin_51368459/article/details/127682963 https://blog.csdn.net/xiaopang_love_study/article/details/127753262 ","date":"2023-04-07","permalink":"/posts/tech/env-var/","series":[],"tags":[""],"title":"Kali添加环境变量"},{"categories":["二次元"],"content":"寂寥的世界，空っぽの姿。\n 这首歌真的太寂寞了……故事最终空寂的结局。献给亲爱的世界。记11日雨。\n1.歌词  Silent Night\n寂静的夜\n降（ふ）り続（つづ）ける\n一直飘落着\n悲（かな）しみふりはらい\n抖落悲伤\nどんな\n无论\n言葉（ことば）でなら\n怎样的言语\n寄（よ）り添（そ）えるの\n能靠近的\n暁（あかつき）に流（なが）れ落（お）ちる星（ほし）\n拂晓时刻滑落的流星\n世界（せかい）が目覚（めざ）める\n世界从睡意中醒来\nあなたが歩（あゆ）む大地（だいち）に\n在你曾走过的大地上\n祈（いの）りを\nSilent heart\n静默的心\n触（ふ）れられない\n触碰不到的爱\n愛（あい）を嘆（なげ）かないで\n不必叹息\n願（ねが）い\n期望啊\n託（たく）す光\n托付这光辉\n星座（せいざ）になる\n化作星宿\n暁に染（そ）まる空（そら）の果（は）て\n破晓染红的苍穹尽头\nわたしを感（かん）じて\n冥冥中感到\nあなたと同（おな）じ景色（けしき）を\n看到了与你同样景色\n見（み）ている\n看见\nはじまりの\n初始的\n白（しろ）い夜明（よあ）けを\n黎明白光的熹微\nあなたと出会（であ）った\n与你相遇\n愛（いと）し世界（せかい）で\n在这令人倾慕的世界里\n信（しん）じる強（つよ）さ知（し）った\n更加坚信\n「I stay with your heart,\n我与你的心相依相偎\nso sweet.tight\n如此亲昵甜蜜\ndreaming in your heart,\n怀梦与你的心中\nhey yey haaaa\u0026hellip;」\n嘿嘿 哈哈哈啊\n暁（あかつき）に流（なが）れ落（お）ちる星（ほし）\n拂晓时刻滑落的流星\n世界（せかい）が目覚（めざ）める\n世界从睡意中醒来\nあなたが歩（あゆ）む大地（だいち）に\n在你曾走过的大地上\n祈（いの）りを\n祈求着\n捧（ささ）げ…\n献出（我的爱）\n","date":"2023-03-11","permalink":"/posts/anime/shinainaru/","series":["动漫歌曲","Galgame"],"tags":["",""],"title":" 親愛なる世界へ"},{"categories":["二次元"],"content":"suki！\n 歌词  作词 : 中島みゆき\n作曲 : 中島みゆき\n编曲 : 衣笠道雄\nマリコの部屋（へや）へ 電話をかけて\n拨出了麻里子家里的电话\n男と遊んでる芝居（しばい） 続（ずず）けてきたけれど\n虽然还假装自己正与男人愉快交往\nあの娘（むすめ）もわりと 忙しいようで\n但是她好像也是十分匆忙\nそうそうつきあわせても いられない\n草草挂断电话 甚至不肯听我多说几句\n土曜（どよう）でなけりゃ 映画（えいが）も早（はや）い\n今天并不是周六 电影院也早早散场\nホテルのロビーも\n一直呆在酒店的大厅\nいつまで居（い）られるわけもない\n恐怕也不是什么好主意\n帰れるあての あなたの部屋も\n本应该可以回到你的房间才对\n受話器（じゅわき）をはずしたままね 話し中（ちゅう）\n可是你的电话却一直占线 打不进去\n悪女になるなら 月夜（つきよ）はおよしよ\n如果一定要变成坏女人的话 请不要像明月之夜那样\n素直（すなお）になりすぎる\n一切都能够看得清清楚楚 我害怕变得这般率真\n隠（かく）しておいた言葉が ほろり\n埋藏在心中的话语也会一不小心\nこぼれてしまう 「行かないで」\n脱口而出 「求求你不要离开我」\n悪女になるなら\n如果一定要变成坏女人的话\n裸足（はだし）で 夜明（よあ）けの電車で泣（ない）いてから\n要先体会一下光脚站在清晨的首班车上\n涙（なみだ）ぽろぽろ ぽろぽろ\n眼泪哗啦哗啦 哗啦哗啦\n流（なが）れて 涸（か）れてから\n流个不停 最后干涸在脸颊的滋味\n女のつけぬ コロンを買（か）って\n买了一瓶男人才会用的古龙水\n深夜（しんや）のサ店（みせ）の鏡（かがみ）で うなじにつけたなら\n在深夜咖啡馆的镜子前涂抹在脖子上\n夜明（よあ）けを待って 一番電車\n无助地等待着天明的首班车\n凍（こご）えて帰れば わざと捨（す）てゼリフ\n倘若能拖着冻僵的身体回到家 我定会甩下一句愤怒的道别\n涙も捨（す）てて 情（せい）も捨てて\n丢掉眼泪 再丢掉温存\nあなたが早く私に 愛想（あいそ）を尽（つかす）かすまで\n最好能让你立刻变得讨厌着我\nあなたの隠（かく）す あの娘のもとへ\n这样我就能够尽快把你从我的心中\nあなたを早く 渡（わた）してしまうまで\n送到那个你一直瞒着我的女孩子身边了\n悪女になるなら 月夜（つきよ）はおよしよ\n如果一定要变成坏女人的话 请不要像明月之夜那样\n素直（すなお）になりすぎる\n一切都能够看得清清楚楚 我害怕变得这般率真\n隠（かく）しておいた言葉が ほろり\n埋藏在心中的话语也会一不小心\nこぼれてしまう 「行かないで」\n脱口而出 「求求你不要离开我」\n悪女になるなら\n如果一定要变成坏女人的话\n裸足（はだし）で 夜明（よあ）けの電車で泣いてから\n要先体会一下光脚站在清晨的首班车上\n涙ぽろぽろ ぽろぽろ\n眼泪哗啦哗啦 哗啦哗啦\n流（なが）れて 涸（か）れてから\n流个不停 最后干涸在脸颊的滋味\n 翻译","date":"2023-02-21","permalink":"/posts/anime/akujo/","series":["动漫歌曲","Galgame"],"tags":[""],"title":"悪女"},{"categories":["二次元"],"content":"不得不说雪莱唱歌真的太好听了，很喜欢，这都是2020年3月的记忆，现在整理。\n 歌词  小木曽雪菜 - 深愛\n作曲∶上松範康 (Elements Garden)\nTVアニメ『WHITE ALBUM2』挿入歌\n雪が舞（ま）い散（ち）る夜空（よぞら）\n雪花飞舞的夜空\n二人寄（よ）り添（そ）い見上（みあ）げた\n我们两人并肩仰望\n繋（つ）がる手と手の温（ぬく）もりは\n紧系著的手和手的温暖\nとても優しかった\n非常的和善\n淡（あわ）いオールドブルーの\n在淡薄蔚蓝的\n雲間（くもま）に消えて行（ゆ）くでしょう\n云彩间隙裏消逝了的吧\n永遠へと続（つず）くはずの あの約束（やくそく）\n本应该永远持续的 那个约定\nあなたの傍（そば）にいるだけで\n只要守候在你的身边\nただそれだけで良（よ）かった\n仅仅如此就心满意足了\nいつの間（ま）にか膨（ふく）らむ\n不知何时已膨胀起\n現実(いま)以上（いじょう）の夢に気付（きず）かずに\n穿越现实的梦而我却没有察觉\nどんな時（とき）もどこにいる時でも\n无论身处何时人在何方\n強く強く抱（だ）き締（し）めていて\n我们都能紧紧的互相拥抱\n情熱（じょうねつ）が日常（にちじょう）に染（そ）まるとしても\n尽管这份热情将生命映的火红\nあなたへのこの想いはすべて\n对於你的这个感情就是一切\n終わりなどないと信じている\n并坚信著不会有终结的一天\nあなただけずっと見つめているの\n仅仅只有你是我一直想要注视的\n交（か）わす言葉と時間\n交错的言词与时间\n姿（すがた）も変（か）えていくでしょう\n都会变换身姿的吧\n白い頬（ほほ）に解（と）けた それは月（つき）の涙（なみだ）\n从苍白的脸颊间满溢出的 那就是明月的泪水\n「行かないで、もう少しだけ」\n「请不要离开、在稍微留在我身边」\n何度も言（い）いかけては\n却多次欲言又止\n「また会えるよね？きっと 」\n「我们一定会再次相见的吧？」\n何度も自分に問（と）いかける\n已多次喃喃自语\n突然（とつぜん）走（は）り出（だ）した\n突然开始奔跑\n行（ゆ）く先（さき）の違（ちが）う二人 もう止（と）まらない\n目的地却不同的两人 已经不能再度止步了\n沈黙（ちんもく）が想像（そうぞう）を超（こ）え引（ひ）き裂（さ）いて\n沉默已将想像穿越撕裂\n一つだけ許（ゆる）される願（ねが）いがあるなら\n如果只有一个允许实现的愿望的话\n「ごめんね」と伝（つた）えたいよ\n只想将「抱歉」这句话传达给你而已哟\nいくら思っていても届かない\n不管怎样思考都传达不到\n声にしなきゃ 動（うご）き出（だ）さなきゃ\n难道必须要发出声音 必须要付出行动吗\n隠（かく）したままの二人の秘密\n隐藏了只属於两人的秘密\nこのまま忘れられてしまうの？\n这样下去就会被遗忘的吧？\nだから．．．ねぇ、早く今ココに来て．．．\n因此…呢、快点来到我的身边吧。。。\nあなたの傍にいるだけで\n只要守候在你的身边\nただそれだけで良かった\n仅仅如此就心满意足了\n今度（こんこ）めぐり会えたら\n下次再度与你相见的时候\nもっともっと笑い合（あ）えるかな．．．\n会有更多更多的互视而笑吗…\nどんな时もどこにいる时でも\n无论身处何时人在何方\n强く强く抱き缔めていて\n我们都能紧紧的互相拥抱\n情热（じょうねつ）よりアツイ体温（ねつ）で溶（と）かして\n尽管将比这份热情还要灼热的体温溶化了\nあなたへのこの想いはすべて\n对於你的这个感情就是一切\n终わりなどないと信じている\n并坚信著不会有终结的一天\nあなただけずっと见つめているの\n仅仅只有你是我一直想要注视的\n 翻译","date":"2023-02-21","permalink":"/posts/anime/shinai/","series":["动漫歌曲","Galgame"],"tags":[""],"title":"深愛"},{"categories":["二次元"],"content":"听到这首歌只有感动。\n 感動。\n1.歌词  作词 : 梶浦 由記\n作曲 : 梶浦 由記\nあたたかな風(かぜ)の中(なか)で\n在和煦的暖风中\n誰(だれ)かが呼(よ)んでる\n有谁在呼唤着\n暗闇(くらやみ)を惜(お)しむように\n惋惜这黑闇似的\n夜明(よあ)けが始(はじ)まる\n天色开始亮了\n明日(あした)はきっと\n明天一定\n綺麗(きれい)な空(そら)に\n绮丽的青空中\n銀色(ぎんいろ)の虹(にじ)がかかるでしょう\n也会映照着银色的彩虹吧\nこんなに哀(かな)しい景色(けしき)を\n如此哀伤的景色\n君(きみ)が光(ひかり)に変(か)えて行(い)く\n你将化作光芒\n小(ちい)さな涙(なみだ)の粒(つぶ)さえ\n小小的泪珠\n宝石(ほうせき)のように落(お)ちてく\n宛如宝石般落下\n未来(みらい)の中(なか)へ\n置于未来之中\n心(こころ)には秘密(ひみつ)がある\n心中仍有秘密\nそれでも触(ふ)れたくて\n就算如此也想触碰\n触(ふ)れ合(あ)えば壊(こわ)れて行(い)く\n明知一旦触碰便会崩坏\n躊躇(ためら)いは螺旋(らせん)の中(なか)へ\n踌躇中渐渐靠向螺旋\n橋(はし)を渡(わた)った河(がわ)の向(む)こうまで\n直到横月河川的桥樑\n明日(あした)はきっと……\n明天一定\n真昼(まひる)の中(なか)で\n在正午之时\n春(はる)は甘(あま)く深(ふか)く香(かお)るのでしょう\n春天发出甜又香的气味\n夢(ゆめ)から醒(さ)めて\n从梦中醒来\n人(ひと)は何(なに)を探(さが)すの\n人们在寻找着什麽呢\nこんなに明(あか)るい世界(せかい)へ\n如此明亮的世界\n君(きみ)が私(わたし)を連(つ)れて行(い)く\n你带着我一起前往\n眩(まぶ)しさにまだ立(た)ち竦(すく)む\n在耀眼而害怕中伫立\n背中(せなか)をそっと抱(だ)きしめる\n你悄悄紧抱我的背\n信(しん)じることの儚(はかな)さを\n深信没有结果的未来\n君(きみ)が光(ひかり)に変(か)えて行(い)く\n你将化成光芒\n目覚(めざ)めた朝(あさ)には涙(なみだ)が\n早晨清醒时流下了泪\n宝石(ほうせき)のように落(お)ちてく\n宛如宝石般落下\n未来(みらい)の中(なか)へ\n在未来之中\n 2.翻译 暖か [あたたか]【形容动词/ナ形容词】 1.暖和，不冷不热。 2.有钱，富足。 3.暖色。\n惜しむ [おしむ]【他动词・五段/一类】 1.珍惜；惋惜；吝惜。\n夜明け [よあけ]【名词】 1.天亮的时候，拂晓，天明。 2.（新时代的）黎明。\n触れ合え[ふれあう]【自动词・五段/一类】 1.互相接触，互相挨着。\n連れて連れて【接续词】 1.伴随着，随着，跟着。类似接续助词。\n立ち竦む[たちすくむ]【自动词・五段/一类】 1.惊呆，呆立不动。\n儚さ[はかなさ]【名词】 1.短暂、虚幻、无常。形容词「儚い」的体言化。\n3.乐谱","date":"2023-02-19","permalink":"/posts/anime/kimigahikarini/","series":["动漫歌曲"],"tags":["",""],"title":"君が光に変えて行く"},{"categories":["二次元"],"content":"经常会不自觉地哼起来的歌\n 歌词  \u0026hellip;\n\u0026hellip;\u0026hellip;\nすれ違う（ちがう）毎日が 増え（ふえ）てゆくけれど\n擦肩而过的每一天 虽然渐渐变得更多\nお互い（たがい）の気持ちはいつも 側にいるよ\n彼此之间的情意 总是一直相伴左右\n二人会え（あえ）なくても 平気（へいき）だなんて\n纵然你我无法相见 却也不曾觉得寂寞\n強がり言う（いう）けど 溜（た）め息（き）まじりね\n虽然可以强颜欢笑 其中却夹杂着叹息\n過ぎ（すぎ）てゆく季節に 置（お）いてきた宝物（たからもの）\n在逝去的季节中 遗失的宝藏\n大切なピースの欠（か）けた パズルだね\n是缺失一角的 珍贵拼图\n白い雪が街（まち）に 優しく積（つ）もるように\n就像白雪在街道上 温柔地堆积的样子\nアルバムの空白（くうはく）を全部（ぜんぶ） 埋（う）めてしまおう\n也将回忆相簿的空白 全部填满吧\n\u0026hellip;\n\u0026hellip;\u0026hellip;\n降り積（つ）もる寂しさに 負（ま）けてしまいそうで\n只盼可以不负于 心底堆积的寂寞\nただ独（ひと）り 不安な日々を過（す）ごしてても\n独自一人 送走不安的日子\n大丈夫だよって 肩（かた）をたたいて\n总会觉得没有问题 轻轻敲敲你的肩膀\nあなたは笑顔で 元気をくれるね\n因为还有你的笑容 便能给我无穷欢乐\nたとえ離（はな）れていても その言葉があるから\n纵然你我相隔万里 只要还有那句誓言\n心から幸せと言える 不思議（ふしぎ）だね\n心底就会感到无比幸福 这就是所谓的不可思议\n淡（あわ）い雪が私の ひそかな想い込（こ）めて\n淡淡白雪悄悄潜入 我无比纷乱的思绪\n純白（じゅんぱく）のアルバムの ページ染（そ）めてくれる\n那纯白的白色相簿 亦被染成雪的颜色\n\u0026hellip;\n\u0026hellip;\u0026hellip;\n過（す）ぎてゆく季節に 置（お）いてきた宝物\n在逝去的季节中 遗失的宝藏\n大切なピースの欠（か）けた パズルだね\n是缺失一角的 珍贵拼图\n白い雪が街に 優しく積（つ）もるように\n就像白雪在街道上 温柔地堆积的样子\nアルバムの空白（くうはく）を全部 埋（う）めてしまおう\n也将回忆相簿的空白 全部填满吧\n\u0026hellip;\nEND\n 翻译","date":"2023-02-18","permalink":"/posts/anime/white-album/","series":["动漫歌曲","Galgame"],"tags":[""],"title":"WHITE ALBUM"},{"categories":["普通类"],"content":"!还是不做了，同时做两件事情……不好。我还是等游戏玩完了再回忆吧。\n首先我要说游戏的部分cg和番剧的差别确实太大了，冬马酱……（可能是眼睛画法问题，冬马的眼睛和雪莱的眼睛不是一种类型，但是某些立绘突然将雪莱式眼睛画到了冬马上，就特别奇怪）。但是立绘的话，我觉得有种特别的风格，我同样很喜欢（顺带一提我特别喜欢21世纪交接的日本动漫gal的美术风格，那种画作，就如同写实和写意的区别一样，我喜欢能表现一个人性格神态的画像，并且如果都两者补全的话，我反而想抛弃外部的精美）。\n【贴图】\n由于长度的客观限制，游戏的小细节很多，而番剧不能顾全。即便是这样番剧也完成了出色的工作了，在时间和内容上作了最优解，我特别受感动的番剧，十足的艺术品。所以写区别的话，我也会将游戏中出现的动漫没有的细节补充上。\n雪莱在看到春希不强制她参加后立刻就撤回了，选择参加。可见游戏中雪莱一开始好感拉满。这一点我觉得番剧的处理棒一些。 冬马的样貌在游戏一开始就展现了。番剧是在看到弹琴的人是冬马后才开始叙述冬马的故事。我更喜欢番剧一些，这样的表现方式。“梦里不知秋已深，余情岂是为他人”，游戏开局就王炸暗示了暗线了。 冬马和春希在认识之前的合奏也有其他曲子，游戏里有原声。并且春希一开始练习，冬马立刻停下了音乐进行配合。感动…… KTV场景中雪莱唱的歌是《深爱》，番剧中并没有出现。 之后冬马和春希吵架后，钢琴弹的乐曲也暴躁风格了，快节奏，低音较多。 在冬马把窗户外面的春希救起来后，立刻进入了冬马之前交往场景的补充，描述了冬马“不想让别人触碰内心”的心理，之后春希和冬马一起挨批了，这些东西和动漫不同。 春希一开始对冬马的好感远大于雪莱，从春希和武也在天台上的交流可以看出春希“很不希望武也去追求冬马”。动漫中没有这部分内容。 在春希劝说冬马加入轻音同好会后又插入了一段过往（之后均是每隔一段时间插入以前与冬马回忆，就不多写了）。  ","date":"2023-02-18","permalink":"/bin/white-album-gal/","series":["Galgame"],"tags":[""],"title":"白色相簿2游戏ic和番剧的一些不同的地方"},{"categories":["二次元"],"content":" 这个寒假的记忆，喜欢りそな。歌词有着浓浓的gal味……但是这部作品让我喜欢上了这首歌。\n歌词  あなたの側に いつでも寄りそうから Happy!\n陪伴在你身边 不管什么时候都能这样 太开心了！\nワクワクするの 初恋の時みたい!!\n就好像初恋的时候 令人兴奋不已！！\n月夜の下で 見つめ誓い合うキミ キラリ…と!\n月夜之下 注视着许下誓言的你 一瞬间…呀！\nドキドキしよう 出会った あの日みたい!!\n就好像与你 邂逅的那一天 内心砰砰直跳！！\nHeartの行方\n我心所在\n未来に繋げて\n紧连未来\n過去は捨てるの\n抛弃过去\nさぁ…飛び込もう…!\n快…飞向未来！\nCutie キミだけの smileを見せて!\n对面的女孩看过来 让我欣赏你的笑容！\nAngel 僕だけに 煌めいた 笑顔!\n天使般的你 献给了我 灿烂的 笑容！\n思い出を 重ねて どこまでも 行きたい\n让我沉浸其中 不管在哪里 但愿与你同在\nわたしの側に 寄りそい支えるから いつでも!\n你在我的身旁 不管什么时候 都鼓励着我！\nキラキラしてる 瞳の奥の光…\n眨巴眨巴的双眼 炯炯有神…\n桜の下で 出会い別れあう時 またね…と!\n樱树之下 重逢之时却又分手 再见了…呀！\n悲しくいよう いつかの会える日まで…\n在没有你的日子里 我的内心饱受煎熬…\n涙の雫\n泪飘零\nポロリ…と溢れて\n一颗颗…满溢而出\n笑顔になろう\n笑一笑好不好\nねぇ…扉開けよう!\n乖啦…打开心扉吧！\nSmiley わたしにも 出来るかな? 笑顔…\n笑起来 我的话 也能够做到吗？笑容…\nHappy! はにかんで 輝きの 天使\n好开心！ 那羞答答的 耀眼的 天使\n空を見て 目を閉じ…\n面朝蓝天 闭上双眼…\nSweetie またいつか 会える日が来るよ\n亲爱的 总有一天 我们还会再次相遇\nCatch me その日まで 離さずにいてね!\n跟上我 那天来临之前 不要离开我身边！\nCutie キミだけの smileを見せて!\n对面的女孩看过来 让我欣赏你的笑容！\nAngel 僕だけに 煌めいた 笑顔!\n天使般的你 献给了我 灿烂的 笑容！\n思い出を 重ねて どこまでも 行きたい\n让我沉浸其中 不管在哪里 但愿与你同在\n 翻译","date":"2023-02-12","permalink":"/posts/anime/sweet-heart-cherry/","series":["动漫歌曲"],"tags":[""],"title":"Sweet Heart Cherry"},{"categories":["二次元"],"content":" 最近喜欢听的一首歌\n歌词  花は散りゆく季節はめぐる\n花朵凋零飘落 季节流转变迁\n涙ひとしずくこぼれ落ちる\n一滴眼泪夺眶而出\nいつか思い出に出来るかな\n何时才能让这变成回忆呢\n好きすぎるからもうサヨナラ\n因为太过喜欢 所以选择说出再见\nサヨナラ\n再见\nmiwa\n想いの果ては空の彼方へ\n思念的尽头去向无际的天空\n海の底よりも深いなんて\n比海底还要更深\nほんの少しの未来見えたって\n其实可以窥见到些许的未来\n淡い期待だけさせないで\n请不要让我有这样小小的期待\n想いの果ては空の彼方へ\n思念的尽头去向无际的天空\n悲しみに悲しみ重ねないで\n不要让悲伤继续重叠\nいつかきらいになるその前にもう\n在我变得讨厌你之前\nサヨナラ\n说出再见\n名前呼ぶ声がやさしいよね\n你呼唤我名字的声音是那么的温柔\nずっと続いてく気がしてた\n曾以为可以一直这样下去\nぬくもりは近くにあるのに\n温暖明明还在身旁\n私はどこかさみしかったの\n我却不由得寂寞起来\n花は散りゆく季節はめぐる\n花朵凋零飘落 季节流转变迁\n涙ひとしずくこぼれ落ちる\n一滴眼泪夺眶而出\n始まらない二人だから\n我们二人无法开始\nこんなに好きだけどサヨナラ\n即使如此喜欢 还是要说出再见\nサヨナラ　サヨナラ　サヨナラ　サヨナラ\n再见 再见 再见\nI don\u0026rsquo;t wanna say\n我并不想说啊\n過ぎ去りし日々は流れる雲\n逝去的时日仿佛流动的云朵\n形を変えて空に溶けても\n就算形状变幻 消逝于天空\n埋まらない心の隙間はなぜ\n无法填补的内心空隙\n二人を遠ざけてしまうの\n为何将我们二人疏远\n過ぎ去りし日々は流れる雲\n逝去的时日仿佛流动的云朵\nわかり合っていると信じてたの\n曾相信着我们能够互相理解\nいつか消えてしまうその前にもう\n在那信任消失之前\nサヨナラ\n说出再见\nなんていやだよ\n果然还是做不到\n抱き締める腕はあたたかくて\n紧抱着我的双臂是那么的温暖\nいつも幸せを感じてた\n总能让我沉浸于幸福之中\n信じるたびに強くなれた\n每当这样相信便能更加坚强\n求めてばかりで脆(もろ)くなった\n可一味渴求只能让这更加脆弱\n花は散りゆく想いはめぐる\n花朵凋零飘落 思念巡回流转\n涙ひとしずくこぼれ落ちる\n一滴眼泪夺眶而出\nこれ以上そばにいれないの\n我已不能再伴你身旁\n届かない背中にサヨナラ\n望着无法触及的背影 说出再见\nサヨナラ　サヨナラ　サヨナラ　サヨナラ\n再见 再见 再见\nI don\u0026rsquo;t wanna say\n我并不想说啊\n巡り逢えたこと　間違いじゃないよね\n我们的相遇 绝不是个错误\nだけどもう伝えられない\n但是思念已无法传达\nこんなにも好きなのに\n虽然明明如此喜欢\n花は散りゆく季節はめぐる\n花朵凋零飘落 季节流转变迁\n涙ひとしずくこぼれ落ちる\n一滴眼泪夺眶而出\nいつか思い出に出来るかな\n何时才能让这变成回忆呢\n好きすぎるからもうサヨナラ\n因为太过喜欢 所以说出再见\n名前呼ぶ声も　抱きしめる腕も\n呼唤我名字的声音 紧抱我的双臂\n二人の未来も　昨日までの思い出も\n你我二人的未来 到昨日为止的回忆\nI don\u0026rsquo;t wanna say\n我不想说再见\n想いの果ては空の彼方へ\n思念的尽头去向无际的天空\n想いの果ては空の彼方へ\n思念的尽头去向无际的天空\n 翻译","date":"2023-02-12","permalink":"/posts/anime/sayorana/","series":["动漫歌曲"],"tags":[""],"title":"サヨナラ"},{"categories":["二次元"],"content":" 同样是耳熟能详的歌曲，很好听，所以决定记录发音在这里。Lisa唱歌真好听啊。\n歌词  さよなら　ありがとう　声の限り\n声嘶力竭喊出道别与感谢\n悲しみよりもっと大事なこと\n这是比悲伤更加重要的事\n去りゆく背中に伝えたくて\n多想传递给你远去的背影\nぬくもりと痛みに間に合うように\n希望还能够体会你的冷暖\nこのまま続くと思っていた\n原以为会就这样延续下去\n僕らの明日を描いていた\n与你一起描绘美好的未来\n呼び合っていた光がまだ\n照亮我们彼此的那束光芒\n胸の奥に熱いのに\n令我的心一直炽热地跳动\n僕たちは燃え盛る旅の途中で出会い\n在焰火绽放的旅途中相遇\n手を取りそして離した　未来のために\n紧握的手最终被命运分开\n夢が一つ叶うたび　僕は君を想うだろう\n每实现一个梦想 我都会想起来你\n強くなりたいと願い　泣いた　決意を餞に\n痛哭着说要变强 以决意为你饯别\n懐かしい思いに囚われたり\n沉湎于对你的回忆和思念\n残酷な世界に泣き叫んで\n恸哭于这世界竟如此残酷\n大人になるほど増えて行く\n越长大我想获得的就越多\nもう何一つだって失いたくない\n可却不愿再忍受任何失去\n悲しみに飲まれ落ちてしまえば\n若让自己被悲伤吞噬殆尽\n痛みを感じなくなるけれど\n君の言葉　君の願い\n虽然会陷入麻木不再疼痛\nは守りぬくと誓ったんだ\n但你曾说过的话语和愿望\n音を立てて崩れ落ちて行く\n是我倾尽一生守护的誓言\n一つだけの\n发出巨大轰鸣逐渐崩塌的\nかけがえのない世界\n这个无法被替代的世界\n手を伸ばし抱き止めた激しい光の束\n伸手去抱住那道灼目的光\n輝いて消えてった　未来のために\n你闪耀光芒消失在了未来\n託された幸せと　約束を超えて行く\n超越托付于我的幸福约定\n振り返らずに進むから\n我将头也不回地继续前进\n前だけ向いて叫ぶから\n我会一往无前地发出呐喊\n心に炎を灯して\n燃烧我的心灵\n遠い未来まで……\n奔赴遥远未来\n 翻译","date":"2023-01-25","permalink":"/posts/anime/homura/","series":["动漫歌曲"],"tags":[""],"title":"炎"},{"categories":["二次元"],"content":"丸户史明真神。最平衡的三角关系，友情与爱情。\n 虽然是快四年前看过的作品，三年前也通过视频的方式通过了cc部分，但其中蕴含的感情始终忘不了，一接触到相关的东西（冬马の顔）便会涌上心头。白色相簿2的音乐，剧本，立绘，声优都很记忆深刻。丸户史明真神。作为白2代表之一的届恋，自然是集白2种种心绪为一体的，一听便会联想到很多很多，所以这样的歌曲，不会唱不行啊！ 歌词  孤独（こどく）なふりをしてるの？\n莫非你是在故作孤独？\nなぜだろう 気（き）になっていた\n为何心如此为你牵动\n気（き）づけば いつのまにか\n回过神来 不知不觉\n谁（だれ）より 惹（ひ）かれていた\n我已被你深深吸引\nどうすれば この心（こころ）は\n要怎样才能将我的心\n镜（かがみ）に映（うつ）るの？\n映在镜中让你看清？\n届（とど）かない恋（こい）をしていても\n即使是场终成奢望的爱恋\n映（うつ）しだす日（ひ）がくるかな\n是否也有映在镜中的一天\nぼやけた答（こた）えが 見（み）え始（はじ）めるまでは\n在能够看见隐约的曙光之前\n今（いま）もこの恋（こい）は 動（うご）き出（だ）せない\n这场爱恋如今依然寸步难行\n初（はじ）めて声（こえ）をかけたら\n当我第一次出声相唤\n振（ふ）り向（む）いてくれたあの日（ひ）\n当你第一次回首之时\nあなたは 眩（まぶ）しすぎて\n你的身影是那么耀眼\nまっすぐ見（み）れなかった\n让我不禁移开目光\nどうすれば その心（こころ）に\n要怎样才能将我的名\n私（わたし）を写（うつ）すの\n深深映在你的心中？\n叶（かな）わない恋（こい）をしていても\n即使是场没有结果的爱恋\n写（うつ）しだす日（ひ）がくるかな\n是否也有映在你心的一天\nぼやけた答（こた）えが 少（すこ）しでも見（み）えたら\n哪怕能看见一丝隐约的曙光\nきっとこの恋（こい）は 動（うご）き始（はじ）める\n这份爱恋一定能够开始转动\nどうすれば この心（こころ）は\n要怎样才能将我的心\n镜（かがみ）に映（うつ）るの？\n映在镜中让你看清？\n届（とど）かない恋（こい）をしていても\n即使是场终成奢望的爱恋\n映（うつ）しだす日（ひ）がくるかな\n是否也有映在镜中的一天\nぼやけた答（こた）えが 見（み）え始（はじ）めるまでは\n在能够看见隐约的曙光之前\n今（いま）もこの恋（こい）は 動（うご）き出（だ）せない\n这场爱恋如今依然寸步难行\n 翻译 ふり【名词】：假装，装出\n気づく[きづく]【自动词・五段/一类】：注意到，察觉，意识到，认识到。\nより【副词】：更\n惹かれる[ひかれる] 【自动词・一段/二类】：心被吸引了\n映る [うつる]【自动词・五段/一类】：反射。\n動き [うごき]【名词】：动，活动，移动。\n出せ[だす]【他动词・五段/一类】：出，发，使出发。\n振り向く[ふりむく]自动词・五段/一类】：回头。\n眩しい[まぶしい]【形容词/イ形容词】：晃眼，耀眼。\nまっすぐ 【副词・形容动词/ナ形容词】：正直；坦率；耿直。\n叶う [かなう]【自动词・五段/一类】：能实现，能如愿以偿。\n写し [うつし]【名词】：抄本，本，摹本，誊本。\nぼやけた：模糊的；不清楚的；污脏的；毛茸茸的；淡漠；眼花；茫昧；灰败；昏茫\nたら：要是，如果，……的话。\n","date":"2023-01-24","permalink":"/posts/anime/todokanaikoi/","series":["动漫歌曲","Galgame"],"tags":[""],"title":"届かない恋"},{"categories":["二次元"],"content":"温柔美好的未来。\n 素晴日中我最喜欢的音乐，不是夜の向日葵（よるのひまわり），夏の大三角（なつのだいさんかく），而是这首言葉と旋律（せんりつ）。我认为这首歌代表了游戏中所有人尤其是柘榴和间宫（三人）所向往的那个温柔美好的未来。音乐本身听起来很华丽，有种让人翩翩起舞的感觉，中途稍有起伏，让我确信这就是本应该的未来，柘榴间宫应该在那样的世界，或者他们的脑海中已经存在的世界。\n ［间宫］「西哈诺的话……有种让人情不自禁的感觉……」\n［柘榴］「嗯」\n［间宫］「精神正派的人都会从他的ｐａｎａｃｈｅ中得到勇气呢」\n［柘榴］「ｐａｎａｃｈｅ？」\n［间宫］「嗯，对，西哈诺在被亡魂带走的最后一幕中，喊过“勇气”吧」\n［柘榴］「嗯……“你们要抢走我的一切”」\n［间宫］「“……来，抢吧，尽管抢吧！但有一样东西，你们只能任凭我带进天堂！”」\n［柘榴］「“我一行礼就把蔚蓝的入口清扫得纤尘不染，这东西没有一丝皱褶，没有一个污点，你们只能任凭我把它带走”」\n［柘榴］「“那就是我的……勇气！”」\n［间宫］「记得很清楚嘛」\n［柘榴］「只是……多看了几次之后就……」\n［间宫］「顺便说一下，他最后想要带走的东西。Ｍｏｎ ｐａｎａｃｈｅ……就是羽饰」\n［柘榴］「羽饰？」\n［间宫］「是的，他帽子上的羽饰」\n［柘榴］「是么？」\n［间宫］「那好像可以引申为“男子汉的勇气”呢」\n［间宫］「所以，其他的译本在羽毛上面注解为“勇气”呢」\n［柘榴］「是这样啊」\n［间宫］「在夺走一切的死神面前，西哈诺最后留下的话语很精彩啊」\n［间宫］「特别是死时对着天空吼出Ｍｏｎ ｐａｎａｃｈｅ！……真让人陶醉」\n［间宫］「对这种勇气无动于衷的人……对这种行为莫名惊诧的人……」\n［间宫］「如果那种家伙是正常的话，那我觉得我还是奇怪点好」\n 我……想再次变回蝼蚁么？\n在镜中世界微微蠕动的……蝼蚁……\n不是我……是某个遥远的地方的蝼蚁……\n但又不是……\n镜中的蝼蚁……是我。\n不对，没有什么镜中世界……镜子只是映出我的样子而已……\n那是我。\n「所以……」\n映在镜中的……是我。\n蝼蚁的做法……\n我是蝼蚁……\n蝼蚁……\n但是……\n我是……剑士……我是诗人……我是哲学家……我是……我是……我是……\n我才不是什么蝼蚁……\n……\n我要改变……\n柘榴正如镜中的昆虫（looking-glass insects），一直观察着自己的所作所为，但却无法控制，就像没有自我意识一样（联想某些里番也有类似的降智人物），她软弱，随波逐流。如果再早一点遇见西哈诺？再多给一点时间成长？毕竟是极端的艺术形象（不否定现实这种事情也很多）。優しい世界でありますように。\n","date":"2023-01-24","permalink":"/posts/anime/kotoba/","series":["",""],"tags":[""],"title":"言葉と旋律"},{"categories":["二次元"],"content":"看空之境界中印象很深的一首歌。\n 今年的11月和12月，是TypeMoon的季节，看了空之境界玩了旧版月姬，再准备玩魔法使之夜。空之境界真的太好看了，十足的艺术品！翻译等考研结束再补充，先挖坑。\n1.歌词  子供[こども]の頃[ごろ]に置[お]いてきた\n独自一人默默忆起了\n夢を思い出[だ]した\n孩提时代早已尘封的梦想\n若[わか]草色[くさいろ]の哀しみを\n轻声细语、甜美地吟唱着\n細[ほそ]く甘く[あまく] 歌う my fairytale\n浸淫在浅绿中的悲伤\n何も終わることのない\n早已明白所谓\u0026quot;永远\u0026quot;\n永遠を知っていた\n只是个美丽的传说\nもう誰も語[かた]らない\n再也不会有人提起\n二人の物語[ものがたり]\n只属于你我的故事\nキスを一つ残[のこ]して\n留下淡淡吻痕\n君は何処[どこ]へ行く\n你将去向何方\n灯火[ともしび]一つ抱[だ]いて\n手握一盏明灯\n森[もり]に消えて行く\n逝于森林尽头\nずっと遠くへ歩いて[あるいて]\n一直向着远方行走\n懷かしい面影[おもかげ]\n那令人怀念的容貌\nずっと遠くが君の家\n远在他方的你的家\n辿り[たどり]着[つ]けはしない\n也许永远无法到达\n夢に見た永遠は閉[と]ざされたままで\n梦境中的永远（仍被紧紧封锁）\n過ち[あやまち]は深く[ふかく]隠[かく]されたままで\n往日里的过错（依旧深深匿藏）\n消えていく帰り道\n归途逐渐消逝\n君がもう見えない\n你亦踪迹难寻 ……再见了吧\n霧[きり]の森を抜け[ぬけ] て\n逃离迷雾之森\n君は何処へ行く[ゆく]\n你将去向何方\n一つだけ手を振[ふ] って\n挥手诀别昨日\n明日[あす] へ去[さ]って行く[ゆく]\n独自去往明天\n君を好きになって\n只因爱上了你\n永遠は終わる\n永远亦会终结\n生きて行く喜びと\n生存的喜悦与悲痛\n痛みが始まる in the light\n一切都已拉开序幕\n 2.翻译 頃 [ごろ]1.……时分，……前后，……左右。2.正好的时候，正合适的时候〔程度〕。\n置く[おく]【他动词・五段/一类】1.放；配置；设立；留下；丢下；掌握；间隔；保持；计算；作抵押；定；留在心里；下露水或霜；保持下去；表示预先做好某种事；暂时。\n若 [わか]【形容词/イ形容词】1.年轻的。2.少年。3.主要用于身份地位高的人家的男孩。\n草色 [くさいろ] 【名词】1.草绿色。\n細 [ほそ]1.与名词或形容词组成复合词。细的。窄的。弱的。2.以“ぼそ”的形式接在名词之后组成复合词。细的东西。\n甘く [あまく] 【形容词/イ形容词】1.（形容词甘い的连用形）甜。淡。姑息。\n語る[かたる]【他动词・五段/一类】1.谈，讲，讲述。2.说唱。\n残す [のこす]【他动词・五段/一类】1.留下；剩下；遗留；（相扑中顶住对方的攻击）站稳。\n抱く [だく]【他动词・五段/一类】1.抱；搂抱；怀抱。2.孵（卵）。3.男人和女人发生两性关系。\n面影 [おもかげ]【名词】1.心中浮现的面貌。2.令人想起旧时的痕迹。\n辿り [たどり]【名词】1.追溯，查找。2.探求事物本质及其能力。\n着く[つく]【自动词・五段/一类】1.达到；运到；到达，抵达。\n閉ざす [とざす]【他动词・五段/一类】1.关闭。2.封，封闭，封锁。3.封上，封住。4.憋在心里。5.同：鎖す\n過ち [あやまち]【名词】1.过错，过失，罪过。2.错误，错儿，失败。\n隠す[かくす]【他动词・五段/一类】1.隐藏，躲藏，遮掩，遮蔽。2.隐瞒，掩盖，掩饰。\n抜ける [ぬける]【自动词・一段/二类】1.脱落；掉落。2.漏掉。3.穿过，通过狭窄的地方到对面。4.偷偷溜走；逃走；退出。5.迟钝；（智力）低下。6.透彻；清澄。7.（布料因不结实）变薄。\n3.乐谱","date":"2022-12-10","permalink":"/posts/anime/fairytale/","series":["动漫歌曲"],"tags":["",""],"title":"fairytale"},{"categories":["二次元"],"content":"1.歌词  静(しず)けさから歩(ある)き出(だ)す\n我从寂静中迈步而出\nまだ见(み)ぬ爱(あい)の景色(けしき)へ\n走向未曾见过的爱情\nこの痛(いた)みを信(しん)じたいの\n为确认伤痛的真切\n夜(よる)を越(こ)えて\n我要穿越这片黑夜\n贵方(あなた)が触(ふ)れた胸(むね)に优(やさ)しい伤(きず)が一(ひと)つ\n你的手抚过我的胸口 留下一道浅浅的伤痕\n隠(かく)していた涙(なみだ)が红(くれない)に零(こぼ)れ落(お)ちて\n让我隐藏已久的泪水 化作鲜红的血珠滴落\n冷(つめ)たい肌(はだ)の上(うえ)にやっと灯(とも)した花(ばな)びら\n在我冰冷的肌肤之上 终于点亮了一朵鲜花\n私(わたし)がここにいる さいわいを歌(うた)うよ\n而此时此刻我在这里 为这份幸福而高歌\nもう梦(ゆめ)も终(お)わる\n当漫长梦境已然终结\n星(ほし)くずが消(き)える顷(ころ)\n繁星也将消失的时候\nねえ、生(い)きていると分(わ)かるほど抱(だ)きしめて\n为了感受生命的存在 请你将我紧拥在怀中\n静(しず)けさから生(う)まれて\n我从寂静中诞生于世\nまだぬくもりも知(し)らず\n未曾知晓温暖的感觉\nただいのちに届(とど)きたいの\n只为寻找到生命所在\n夜(よる)を越(こ)えて\n我要穿越这片黑夜\nなつかしいなつのあめ\n令人怀念的夏日细雨\n私(わたし)を见送(みおく)ってね\n仿佛在默默为我送行\n信(しん)じ合(あ)う始(はじ)まりへ\n愿我能带着泪水走向\n泣(な)きながら行(い)けるように\n尝试彼此信赖的开端\nよろこびもかなしみも\n无论是欣喜还是悲伤\n刻(きざ)みつけたい深(ふか)く\n都愿深深铭刻于心中\n贵方(あなた)とここにいる\n作为曾与你在此相伴\nさいわいの名残(なごり)に\n所留下的幸福痕迹\n星(ほし)くずが消(き)える顷(ころ)\n在繁星即将消失的时候\n初(はじ)めて见(み)る光(ひかり)の中(なか)で\n在初次见到的曙光之中\nその瞳(ひとみ)で くちづけで\n请用目光给我一个吻\n恋(こい)した迹(あと)を下(くだ)さい\n为我留下爱过的痕迹\n生(い)きることに贯(つらぬ)かれて泣(な)いてみたい\n让生命贯穿我的躯体 我愿试着去哭泣\n静(しず)けさから歩(ある)き出(だ)す\n我从寂静中迈步而出\nまだ见(み)ぬ远(とお)い夜明(よあ)けへ\n走向未知的遥远黎明\nただ愿(ねが)いを叶(かな)えたいの\n只为实现心中的愿望\n夜(よる)を越(こ)えて\n我要穿越这片黑夜\n 2.翻译 以后再补。\n3.乐谱","date":"2022-12-10","permalink":"/posts/anime/kizuato/","series":["动漫歌曲"],"tags":["",""],"title":"傷跡"},{"categories":[""],"content":"原句，部分词翻译（网络搜索，和整句翻译（来源于汉化组等）\n1.说明 片段选取标准源于我游戏时的体验，因人而异。游戏中有很多短的有趣的对话我就不放在这里了。我个人对剧情中的暴力场景无感（难受和厌恶），虽然它只是加强作用，但游戏展现的暴力并不比现实强多少。对于电波话语，有美的，也有恶心难受的，不求理解意思，只是各个词语组成的直观感受（将单个词语的几种意思，和所有词语综合起来的感受）。正因有了各种场景展现对比，游戏中关于哲学，戏剧等思考和交流才更加地耀眼和迷人，当然，音乐也是一绝。幸福地活下去吧！\n之后预期会做个人人物的语句摘录，和卓司控制人的技巧，心理学一些东西。当然都需要很长时间，不知道什么时候能做完。\n2.摘录片段 Down the rabbit Hole Down the rabbit Hole Ⅱ It\u0026rsquo;s my own Invention Looking-glass Insects Jabberwocky Which Dreamed It JabberwockyⅡ","date":"2022-11-13","permalink":"/bin/subarashikihibi-1/","series":[""],"tags":["",""],"title":"素晴日剧本片段"},{"categories":["计算机"],"content":"0. 前情 从9月开始，我的gal时间就是素晴日了，最近一口气在几天时间内完成了游戏的90%内容，三个结局，希实香线，HE线都全部通关了。我特别喜欢素晴日，而我表达喜欢的方式就是收集它相关的所以资源，各种cg立绘音乐cd特典什么的全都想要。而我去寻找cg时，发现那篇帖子的资源链接已经被百度封了，于是只得自己动手开干，这就是背景。\n1. 游戏解包\u0026amp;CG提取 从帖子中得知了解包用的软件是GARbro（这个名字我不忍吐槽，我还以为是我误看了pro），之后一切都非常顺利，成功从游戏中提取了图片，视频和音频。毕竟是10年前的游戏，就算是10周年特别版也没有修改底层系统，所以轻松提取了，全程傻瓜式操作。我发现这个系统和脏翅膀的系统是同一个。提取图片时我选择了转换格式为png，为的是最大的清晰度，当然文件体积也涨了好几倍。\n 2. 剧本提取 这一部是耗时最多的一步，原因在于剧本文件的编码。\n在游戏目录中arc的1开头的文件，正是游戏脚本文件，利用GARbro可以轻松提取出来，我尝试了很多编码，但无论用什么编码打开文本，浮现的始终是乱码。\n 这里推测可能性有两种，一是编码不对，二是编码大体是对的，但更重要的在于BGI系统自定义了许多的编码，或者是打乱了正常的编码。于是乎想要解决这个问题，我要么自己去核对推测编码自己破解，要么去找现成的轮子，别人已做的工作。我肯定选择后者，于是我开始了搜索，在汉化吧里面搜索“BGI”时我发现了线索，这将我引到了github，然后一下子找到了decoder。  这个是C#编写的，不过也不需要我理解除非我要看看它是怎么处理字符的。我用vscode编译了之后得到了docoder，就已经可以用了，但我还是瞥了眼代码。多么详细的注释啊！加上C#代码不是难理解和我编写小工具的经验，我觉得如果我想研究的话，我肯定看得懂！谢谢你，xupefei超人！！！你拯救了我的爱！\n 好了，现在问题来到了最后一步。游戏脚本文件是很多的，我总不可能一下一下每个文件去运行吧？于是我想到了bat批处理脚本。在我快速回顾遍历bat脚本后，我惊讶地发现我需要的bat脚本只需一行代码：for %%i in (.\\other\\*) do ( ScriptDecoder.exe %%i) ，当然还可以在后面加个重定向，更加舒服。问题就此解决了~我成功得到了游戏脚本。在我后续对脏翅膀提取剧本时，又出现日语编码问题了，待续未完。\n 3. 结尾 不可全部否定功利主义是我的结论，所以我将成果发到了贴吧上祈求别人表扬~但功利主义始终不是我的结果，我想要幸福地活下去！无论是艺术形而上也好，还是悲剧人生（目前我喜欢的哲学家可不是叔本华和尼采，而是康德。我之前一直觉得数学是唯一真神，超脱宇宙，而当我在阅读纯理性批判时，感受到了康德也是位非常像数学家的哲学家，先天分析判断是数学似的）。\n“我喜欢的人是……诗人……也是剑客……哲学家……还是空气力学的先驱者……” 我会写很多东西来纪念，表达我对素晴日的爱。最后附上我解包出来的图片吧。\n 谁不想要一个可爱的妹妹呢？ ","date":"2022-11-06","permalink":"/posts/tech/gal-extract/","series":["Galgame"],"tags":["",""],"title":"记第一次从gal中解包提取素材和剧本"},{"categories":[""],"content":"10月快见底了，想写写什么东西，但最近都在疯玩让自己好好休息，所以书没怎么读（没兴趣），歌曲也没有特别感触深的，于是决定随便聊聊来给10月划上句号。标题这两个话题算是我近期感触比较大的。\n阿西莫夫的小说 在9月读完《球状闪电》后，我继续读更多的科幻小说，这期间接触了两本阿西莫夫的小说《银河帝国》系列《神们自己》。但这两本我都读不懂，我总觉得废话太多了不对我口味，个人的心理活动太重了。我立马想到了唯物史观和唯心史观的区别，不知道是不是这种层面的差异导致我不喜欢这小说。\n虽然中间漫长的过程我不喜欢，但是这两本书的有些概念我是特别喜欢感兴趣的，比如“心理史学”“钨186”等，感兴趣的可以自己去看书。至于没看完的两部小说，等到我以后实在无聊了可能会重新拾起吧。\n简奥斯汀所处的时代 《傲慢与偏见》是我很早就看过的，最近想重新看一遍，就下载了一本电子版，这本电子版的导读非常精彩，译者对这本书的差评进行了种种说明和否定。让我感受到了时代对个人的引力是多么大，我们自己也始终是在历史中，同时个人的个性和主观批评又多么不重要trivial。我会这部分复制到文章末尾，有兴趣的可以读一读。\n","date":"2022-10-28","permalink":"/bin/free-talk/","series":[""],"tags":["",""],"title":"杂谈——阿西莫夫的小说\u0026简奥斯汀所处的时代\u00261984"},{"categories":["文字类"],"content":"有剧透，没看过原书建议不要点开。\n1.读后感 花了差不多两周断断续续将这本书读完了。我最喜欢这本书的地方在于刘慈欣将“电子，原子，量子效应 “夸张放大了，使我们能够在宏观现实中感受到这些粒子的物理效应，让我们能够看得见摸得着的电子，原子，与量子状态的物体和人，让我们能看到宏观尺度的量子现象而不是双缝实验的光！这些概念本身就很浪漫（如观察者），就像是意志能够真真切切地实际直接对现实影响，真正的“世界是我的表象和意志”！“我的心中永远有它的一席之地”。同时也让我回忆起在20世纪初，人们关于量子与上帝，宿命论和自由意识论的争论。和《三体》中的“永远一直走入黑洞奇点的数学家”一样的感觉~ 同时有些地方和《星际穿越》的黑洞中信息传递有点既视。整体这部作品我很喜欢。\n看这本书的时候没有用好软件的书签功能，下次写读后感，摘录书籍的时候就会全面些了。对于比较长的书籍，我会分几篇来摘录或者精简篇幅。下面是我喜欢的一部分片段。故事是一个整体，更多的好东西只有去读完才能知道。\n2.摘录片段 宏电子的解释  “我们之所以能看到空泡，是因为这一处弯曲的空间使经过它的光线弯曲，这形成了它可见的边缘。”丁仪继续解释道。\n“那你为什么认为它是电子，而不是质子或中子呢？”许大校问。\n“问得好，其实答案也很简单：空泡被闪电激发成球状闪电再恢复成空泡的过程，实际就是电子由低能级被激发成高能级，再跌回低能级的过程。在三种粒子中，只有电子能够被这样激发。”\n“也正因为它是电子，才能够沿着超导线传输，并在超导电池中像循环电流一样永不停息地运行。”林云恍然大悟地说。\n“可很奇怪的，它的直径与那节电池差不多。”\n“对于宏电子来说，波粒二象性中波的形态占很大比重，所以它的大小的意义与我们常识中的完全不同。它还有很多令人难以置信的特性，我们以后会慢慢看到的，我相信这会改变大家对世界的看法。不过现在，我们要先给这些大电子取一个名字，它们是宏观尺度的电子，就叫宏电子吧。”\n 量子态的物体  丁仪将电脑翻过来让我看，我看到在主板上，CPU和内存条的插槽全是空的。\n“当我观察的那一瞬间，量子波函数坍缩了。”丁仪将电脑轻轻放到桌子上，它的屏幕仍是黑的。\n“你是说，被烧毁的CPU和内存条也像宏电子那样处于量子态？”\n“是的，换句话说，在与宏电子发生物质波共振后，每一块芯片也转化成了宏量子，它们处于不确定状态，也就是同时处于两种状态：被烧毁和未被烧毁。刚才，在电脑启动的时候，它们处于后一状态，在那个时候，CPU和内存条完好无损地插在主板上的插槽中，而我的观察使它们的量子态又坍缩到被烧毁的状态了。其实，从本质上说，球状闪电的能量释放，就是它与目标的两团概率云的重叠或部分重叠。”\n“那么，在没有观察者的时候，那些芯片何时是处于完好状态的呢？”\n“这不确定，只是一个概率事件，你可以认为，这台电脑笼罩在那些芯片的概率云之中。”\n“那些被烧掉的试验动物，它们也处于量子态吗？”我紧张地问，预感到自己正在接近一个令人难以置信的真相。\n丁仪点点头。\n我实在没有勇气问出下一个问题，丁仪平静地看着我，显然早已知道我在想什么。\n“是的，还有人，所有死于球状闪电的人，都处于量子态，严格地说他们并没有真正死去，他们都是薛定谔的猫，在不确定中同时处于生和死两种状态。”丁仪站起身来踱到窗前，看着外面浓重的夜色，“对于他们，生存还是死亡，确实是个问题。”\n“我们能见到他们吗？”\n丁仪对着窗挥了一下手，像是要坚决赶走我脑子中的这个念头，“不可能，我们永远不可能见到他们，因为他们的坍缩态是死亡，他们只能在量子态中的某个概率上以生存状态存在，当我们作为观察者出现时，他们立刻坍缩到毁灭态，坍缩到他们的骨灰盒或坟墓中。”\n“你是说，他们活在另一个平行世界？”\n“不不，你理解有误，他们就活在我们的世界，他们的概率云可能覆盖着相当大的范围，也许，他们现在就站在这个房间中，站在你背后。”\n我的脊背一阵发冷。\n丁仪转过身来指着我的身后，“但当你回头看时，他们立刻坍缩到毁灭态。相信我，你或其他任何人永远不可能见到他们，包括摄像机在内的任何观察者也永远不可能探测到他们的存在。”\n“他们能在现实世界留下非量子态的痕迹吗？”\n“能，我想你已经见过这类痕迹了。”\n“那他们为什么不给我写信！”我失态地叫了起来，这时我说的他们只包括两个人了。\n“相对于芯片这类物体，有意识的量子态生物，特别是人类的行为要复杂得多，他们是如何与我们的非量子态现实世界互动的，仍是一个难以理解的谜，这中间有许多逻辑上甚至哲学上的陷阱。比如：他们也许写信了，但这些信有多大概率成为非量子态而被你觉察到呢？另外，现实世界在他们眼中是否也是量子态的？要是那样，他们在你的概率云中找到现在这个状态的你是很困难的，对于他们，回家的路一定漫长而渺茫……好了好了，这是些短时间内不可能想明白的事，牛角尖钻下去会把你弄垮的，以后再慢慢想吧。”\n我没说话，怎么可能不想呢？\n 一首诗  金黄色的树林里分出两条路，\n可惜我们不能同时去涉足，\n但我们却选择了，\n人迹罕至的那一条，\n这从此决定了\n我们的一生。\n林云喃喃地吟起了弗罗斯特的那首诗，声音像林间的清泉。\n 跨越空间的信息  丁仪没有再说什么，走到墓碑前，把自己带来的鲜花放到碑座上。放下花后，他好像被墓碑上的什么东西吸引了，迟迟没有直起腰来，后来索性蹲下来，仔细地察看着，脸几乎与碑面贴在一起。\n“天啊，这碑文是谁起草的？”他惊呼道。\n林云感到很奇怪，因为墓碑上除了张彬的名字和他的生卒日期外，没有别的什么，这也是张彬的遗愿，他觉得自己这一生没有什么值得总结的。林云走过去察看，立刻惊得目瞪口呆：除了那几个大字外，墓碑上还密密麻麻刻满了小字，这些小字甚至覆盖了碑顶和碑的背面，那些小字全是方程和计算公式。仿佛是这块墓碑被放到由方程和公式组成的液体中浸过一样。\n“啊，它们在变淡，在消失！”林云惊叫道。\n丁仪猛地推了一把林云，“转过身去！少一个观察者，它的坍缩就慢些！”\n林云转过身去，紧张地搓着双手，丁仪则伏在墓碑上，开始逐行读那些细密的碑文。\n“是什么？你看出什么来了吗？”\n“别说话！”丁仪大声说，同时目不转睛地读着。\n林云摸摸衣袋，“要不要到车上去找纸笔来？”\n“来不及了，别再打扰我！”丁仪说着，以惊人的速度读着碑文，他的双眼狠狠地盯着碑面，像要用目光将它刺穿似的。\n这时，西方的最后一线天光给墓碑群涂上了一层诡异的蓝色，周围的林地隐没于一片昏暗之中，刚刚出现的几颗晶莹的稀星一眨不眨地悬在苍穹上，时而有未落的树叶在微风中极轻的沙沙声，但旋即消失，仿佛被某种力量嘘着制止一样，寂静笼罩着一切，仿佛整个世界都在同丁仪一起全神贯注地读着那量子化的碑文。\n十分钟后，丁仪读完了正面，迅速扫视完碑顶和侧面，然后开始读背面。天已完全黑下来，他摸出打火机打着，借着火苗的微光疾读着。\n“我去拿手电！”林云说完，穿过排排墓碑间的小道向停车的地方跑去。当她拿着手电跑回来时，看到打火机的火苗已经消失了，她用手电照去，看到丁仪背靠着墓碑坐着，两腿平伸在地上，仰头看着星空。\n墓碑上，碑文已经消失得无影无踪，大理石光洁的平面像镜子似的反射着手电光。\n手电光也使丁仪如梦初醒般回过神来，他伸手拉住林云，拉着她转到墓碑后面，指着碑的根部说：“看这儿，留下了一行，非量子态的，也是碑文中唯一的一行汉字。”林云蹲下去，看到了墓碑根部那一行娟秀的刻字：\n彬，引起F的速度只有426.831米/秒，我好怕。\n“我认识这字体！”林云盯着那行字说，她曾不止一次看过张彬留下的那本被球状闪电隔页烧毁的笔记。\n“是的，是她。”\n“她都刻了些什么？”\n“一个数学模型，全面描述宏原子的数学模型。”\n 宏聚变  宏聚变是无声的，甚至照大多数目击者的说法，宏聚变时比平时都要安静，似乎大自然中的其他声音都被屏蔽了，整个过程都在不可思议的宁静中进行。按照一位目击者简洁的总结，整个宏聚变过程看上去就是一轮蓝太阳的升起和落下。首先是大篷中发出蓝光，很快人们就看到了那个还很小的蓝色光球，因为这时大篷正在变成透明的，仿佛是一张悬在光球上方的大玻璃纸，它很快像熔化似的坍塌了，奇怪的是，坍塌时大篷的各个部分都向着聚变中心收拢，整座大篷就像被吸入一个旋涡似的被吸进了光球之中，在周围没有留下任何残余和痕迹。大篷消失后，光球继续扩大，很快便以一个蓝太阳的形象出现在戈壁滩上，当它停止膨胀时，半径达到二百米，这正好是丁仪预言的距离，只有在这个距离之外，宏聚变的能量才呈现选择性，而在这距离之内，由于极大的能量密度，一切都将被毁灭。\n蓝太阳在最大的状态维持了约半分钟，这期间它很稳定，加上此时笼罩一切的诡异的宁静，它居然在这短暂的时间给人一种永恒感，仿佛自世界诞生之日起就在那里似的。蓝太阳使西边已落下去一半的夕阳黯然失色，整个戈壁都淹没在它的蓝光中，使这个世界变得陌生而怪异。这是一个冷太阳，人们即使在近处也感觉不到它的任何热量。\n这时，最不可思议的奇观出现了：在蓝太阳那幽深的内部，有许多璀璨的小星星放射状地飞了出来，那些星星一飞出光球的边界，立刻变成一个个物体，大小不一，当人们看出那些飞散的物体是什么时极为震惊：那是一个个的大篷！这些从蓝太阳中飞出的大篷看上去很有质感，绝不是幻影。它们大小不一，最大的比毁灭前的原物还大，成为天空中飘浮的一个巨大的黑影；小的则像一块碎片，细看去还是完整的大篷，仿佛是它的一个精致的模型。这些处于量子叠加态的大篷，在观察者的目光中迅速坍缩为毁灭态，纷纷拖着一个由自己映像叠成的尾迹消失在空中，但量子态的大篷仍不断地从光球中心飞出，这是一个大篷的概率云，它在向空中弥漫，蓝太阳也笼罩于概率云中，只有观察者才能抑制云的膨胀。\n终于有声音打破了宁静，这轻微的噼啪声从桌上的电脑里发出，从人们身上的手机中发出——是电子芯片被毁灭的声音。与此同时，人们看到有许多小碎片穿过电脑完好无损的外壳四下飞散，细看发现，那些碎片竟是一个个完整的CPU、内存条和其他芯片，每一个量子叠加态的芯片都同时出现于很多个位置，所以飞散的芯片数量巨大，一时间办公楼笼罩在芯片的稠密的概率云之中，但人们的目光像一把把无形的扫帚，将芯片扫回毁灭态，它们纷纷拖着尾迹消失，坍缩为机箱中的灰烬，空气中很快变得空无一物了。\n更大的声音出现了，它是空中传来的一声巨响，人们看到天空中出现了一团大火球，那是来袭的导弹。当它内部的所有芯片都被烧毁时，先是打着旋下坠，然后临空爆炸了。\n之后，宁静又恢复了，蓝太阳开始急剧缩小，最后在地表附近缩为一点消失了，一分钟前，就是在那一点，从“桥”上飞出的两个宏原子核以五百米每秒的相对速度相撞，两根由奇点构成的弦瞬间缠绕在一起，从此，在大得无法想象的宏宇宙中，两个氢原子消失了，一个新的原子诞生了，这个事件不可能被宏世界的任何观察者觉察。与我们的世界一样，只有当一亿亿对弦同时缠绕在一起时，才能产生一起能够被他们称之为事件的事件。\n 量子玫瑰  她与一群孩子在一起。\n她站在孩子们中间，仍穿着整洁的少校军装，脸上浮现着灿烂的笑容，从未有过的美丽动人。再看她周围的孩子们，我立刻认出是核电厂事件中与恐怖分子一起被球状闪电毁灭的那群孩子，他们同样笑得很甜，显然都处于快乐之中。我特别注意到林云一手紧紧搂着的一个小女孩儿，那是一个漂亮可爱的孩子，笑得双眼眯成了一条缝，但吸引我注意力的是那个孩子的左手。\n她没有左手。\n林云和孩子们是在一片修剪得很好的绿草坪上，上面有几只白色的小动物。在她们的后面，我看到了那幢熟悉的建筑，就是那间由大库房改建的宏电子激发实验室，我们就是在那里听到过量子态的羊叫声。但在照片上，库房宽大的外墙上画着色彩鲜艳的卡通动物，还有气球鲜花什么的，在这绚丽的色彩中，整座建筑像一个巨大的玩具。\n林云从照片中动人地微笑着看我，从她那清澈的目光中，我读出了许多她生前没有的东西：一种幸福的归宿感，一种来自心灵深处的宁静，让我想到了一个遥远的被遗忘的幽静港湾中，停泊着一片小小的孤帆。\n 我靠在椅子上闭起双眼，就这么什么也不想地坐着。每天的深夜我都这么坐一会，这是一天中最宁静的时刻，整个世界上仿佛只有我一个人还醒着。\n我闻到了一阵清香。\n这是一种去除了所有甜分的香，有一种令人舒适的微苦，令我联想到暴雨后初晴阳光中的青草地，想到了万里晴空中的最后一抹淡云，想到了幽深空谷中转瞬即逝的铃声……只是这时它更加缥缈，当我注意到它的存在时它就消失了，但当我将注意力从嗅觉上转移开来时它又出现了。\n喜欢这香水吗？\n啊……哦，部队上不是不让用香水吗？\n有时也可以。\n“是你吗？”我轻声问，没有睁开眼睛。\n没有回音。\n“我知道是你。”我又说，还是闭着眼睛，\n仍然没有回音，万籁俱静。\n我猛地睁开双眼，就在书桌上的紫水晶花瓶上，出现了一朵蓝色的玫瑰，但玫瑰在我看到它的瞬间就消失了，只剩空花瓶静静地立在那里。但那朵玫瑰的每一个细节都印在我的脑海中，它充满了生机，透出一种冰雪的灵气。\n我闭上眼睛又睁开，玫瑰没有再出现，但我知道它就在那里，就插在紫水晶花瓶上。\n “我知道你没骗我，那里真的有一朵玫瑰嘛，蓝色的玫瑰。”我说。\n以后，妻子再也没有提起过这事，任那个花瓶放在那里，有时，她还会小心地擦擦它，擦的时候一直竖着，像是怕里面的玫瑰掉下来，她还几次为瓶里添上蒸发掉的水。\n我以后再也没有看到蓝色玫瑰，但知道它在那里就够了。有时夜深人静，我就将水晶花瓶移到窗前，然后背对着它站着，这时我往往能闻到缥缈的花香，就知道它肯定已经在那里了，心灵的眼睛能看清它的每一个细节。我用心来抚摸着它的每一个花瓣，看它在来自窗外的夜风中微微摇曳……它是一朵我只能用心来看的花。\n不过，我还是希望在此生再用自己的眼睛看到一次蓝色玫瑰，据丁仪说，从量子力学的角度来讲，人的死亡过程就是由一个强观察者变为弱观察者再变为非观察者的过程，当我变成弱观察者时，玫瑰的概率云向毁灭态的坍缩速度就会慢一些，我就有希望看到它。\n当我走到人生的尽头，当我在弥留之际最后一次睁开眼睛，那时我所有的知性和记忆都消失在过去的深渊中，又回到童年纯真的感觉和梦幻之中，那就是量子玫瑰向我微笑的时候。\n 刘慈溪后语——浪漫又有趣的球状闪电解释  创造一个在所有细节上都栩栩如生的想象世界是十分困难的，需要深刻的思想，需要在宏观和微观上都强劲有力、游刃有余的想象力，需要从虚无中创世纪的造物主的气魄，而后面两项，恰恰是我们的文化所缺乏的。但如果我们一时还无力创造整个世界，是否能退而求其次，先创造其中的一个东西呢？这就是我写这部小说的目的。\n球状闪电至今还是一个科学之谜，但现在已经能在实验室中产生它（虽然平均七千次实验才能产生一个），而彻底揭开这个谜也指日可待，到那时有一点可以肯定：你会发现球状闪电完全不是小说中描述的那种东西。搞清球状闪电真的是什么，不是科幻的事，也不是科幻能做到的，我们所能做到的，只是描述自己的想象，创造一个科幻形象，与主流文学不同，这个形象不是人。\n自从目击球状闪电之后，近二十年来，我不由自主地对它产生了多种想象，这部小说描述了这些想象中的一种，不是我觉得最接近真实的那一种，而是最有趣最浪漫的那一种。它只是一个想象的造物：一个充盈着能量的弯曲的空间，一个似有似无的空泡，一个足球大小的电子。小说中的世界是灰色的现实世界，是我们熟悉的灰色的天空和云，灰色的山水和大海，灰色的人和生活，但就在这灰色的现实世界之中，不为人注意地飘浮着这么一个超现实的小东西，仿佛梦之乡溢出的一粒灰尘，暗示着宇宙的博大和神秘，暗示着这宇宙中可能存在的与我们的现实完全不同的其他世界……\n","date":"2022-09-16","permalink":"/posts/literature/lighting-ball/","series":[],"tags":["",""],"title":"《球状闪电》"},{"categories":["二次元"],"content":"我比较喜欢这种感觉的歌。\n1.歌词 来源于网易云歌词，歌曲在这里 。\n歌手：中恵光城 所属专辑：ASTRO=FILMS  夜[よる]はここにある\n夜于此处\n輝きを増す[ます]ほどに\n光芒愈盛\n影[かげ]は広[ひろ]がって\n暗影愈广\n身[み]も焼き[やき]焦がす[こがす]シリウス\n浑身烧灼的西利乌斯\n何よりも輝いて\n其光明灼耀绝伦\n気[け]高く強く\n其威压极盛难敌\n答え[こたえ]求[もと]められて 何時しか\n我问道 是何时起呢\n誰にも触れ[ふれ]られない\n绝对无人能触其肉身\n孤独[こどく]となった\n那和陷入孤独的我\n私と同じ傷痕\n一般的伤痕[きずあと]\n隣[となり]に居[い]てあげる\n我来待在你的身边\n痛いなら 撫で[なで]てあげる\n如果疼痛 就由我来抚慰\nだけど気づかない\n但还是没有人注意到我\n誰か私を見て\n谁来看着我\n空を揺蕩[たゆた]えば\n如果摇荡起整个苍穹\n数え[かぞえ]きれないほどの\n那不可胜数的\n星物語[ものがたり]が\n群星的故事\n生まれ[うまれ]ていくのが見える\n就会浮现于眼前\n何一つ触[さわ]らずに\n触碰不到任何一个\nシリウスのように\n如同西利乌斯一般\nいつか燃え尽き[もえつき]てしまうなら\n若终有一日燃尽成尘\n最後に一つだけ\n请让我许下\n願いがある\n最后一个愿望\n私を見つけて欲しい\n希望有人能找到我\n空っぽ[からっぽ]の器[うつわ]が\n这副空虚的躯壳\nそれだけを求め[もとめ]ている\n不过追求这一点\nだからここに来[き]て\n所以请来到这里\n誰か声を聞[き]いて\n谁来听听我的声音\n誰か私に\n谁来告诉我\n心を教えて\n心的含义\n見つけて\n请找到我\n 2.翻译 焦がす [こがす]【他动词・五段/一类】1.烧糊。2.使心情焦急。\n気 [け]【名词】1.迹象，苗头，先兆；本体散发的气；气氛。\n求める [もとめる]【他动词・一段/二类】1.要求，征求。2.招，惹，招致。（恶果等）。3.买，购买。4.渴望，希望，盼望。5.寻求，找。\n触れる [ふれる]【他动词・一段/二类】1.碰，触；宣扬。【自动词・一段/二类】1.触碰；（耳、目等）感觉；言及；遇到；冒犯；体验。\n隣[となり] 【名词】1.邻居，邻家，邻人；旁边，隔壁，邻室；邻邦，邻国；\n居る[いる]【自动词・一段/二类】1.有，在；在，居住，呆，逗留；始终停留（在……），保持……；表示动作、作用正在进行之中；表示动作结果继续存在；表示目前的状态；表示曾做过某事。经历过某事；表示某个动作习惯性的反复出现；现在的。\n撫でる[なでる]【他动词・一段/二类】1.抚摸。2.拂，抚摸。比喻柔软的物体或风轻轻掠过身体。3.梳拢。用梳子整理头发。\n揺蕩う [たゆたう]【自动词・五段/一类】1.摇动，晃荡，漂浮。2.犹豫不决。\n数える [かぞえる]【他动词・一段/二类】1.数数，算账。2.列举，枚举。3.算数。4.确认范围内的数量。\n生まれる [うまれる]【自动词・一段/二类】1.生。分娩。2.诞生，产生。3.产生某种想法。\n触る[さわる]【自动词・五段/一类】1.触摸；接触。2.有关联，有关系。3.触怒，伤害情绪。\n燃え尽きる[もえつきる]【自动词・五段/一类】1.烧完，烧尽。\n空っぽ [からっぽ]【名・形容动词/ナ形容词】1.没人；空的。\n器 [うつわ]【名词】1.容器，器皿；器具。2.才干，人才。\n3.乐谱 暂无待补（可能很长时间不会补）\n\n \n想做《命运石之门》的歌，但主题歌曲我都不太感冒，以后也不会做了；而《素晴らしき日々》的有词的歌也不太感冒，纯音乐倒是很好，于是选来选去做这首。关于《素晴らしき日々》，我以后一定会做一些东西的，因为我很喜欢这部作品！它让我对文学有了冲动兴趣。而且是很与众不同的作品！\n——2022.09.11中秋节。\n","date":"2022-09-11","permalink":"/posts/anime/shiriusunoyuuenn/","series":["","动漫歌曲"],"tags":[""],"title":"シリウスの遊園 -Hacka-"},{"categories":["二次元"],"content":"歌的链接：空種 -そらたね-  1.歌词  まっすぐに羽を伸ばし 傷痕[きずあと] 愈し[いやし]続け[つづ]るたび\n我的双翼会一直张开 每当持续治疗之时\n私はそれでもいい 誰かの為に\n即便如此我也愿意 因为这是为了人们\n飛び[とび]立て[たて]ることに もう少し 喜び感じ[かんじ]でいたいから\n也因为我希望能稍微飞翔起来而感觉到高兴\nあなたとここで出会[であ]えたこと 奇跡[きせき]と 呼[よ]ばせてください\n请你把我们的相遇称呼为奇迹\nOverthesky 遠くを見つめてる\n飞越天空 遥望远方\nその目に 光が指す[さす]ように\n双眼如同指向光芒一样\nOpenthemind 世界を\n敞开心怀 世界必定能改变\nきっと変え[かえ]てゆく そして 空へ\n然后再次飞向天空\n時々[ときどき]不安[ふあん]になる 私に何ができるのだろう\n有时候我会感觉到担心 我究竟能够做什么？\n時間は無限[むげん]じゃない そんな中で\n时间并非无限 而我正在此间\n生きできた時間の中には 忘れたいこともあるけど\n在我所生活过的时光里有我很想忘却掉的痛苦经历\n誰かとは立ち[たち‐]会えるのなら 記憶は 輝き始める\n但如果能和谁一起分享我的经历 这份记忆将会开始闪闪发光\nOverthesky 全てが終わる時\n飞越天空 当一切结束后\nその手で 強く抱きしめて[だきしめて]\n请用那双手紧紧拥抱着我\nOpenthemind 真実\n敞开心怀\n分かる日が来ても ずっと\n即使明白了真相 也要追寻永恒\n突然[とつぜん] 見つけた希望\n突然找到的希望\n偶然[ぐうぜん] 舞い[まい]降りできた夢\n偶然降落在了我们身上\nOverthesky 遠くを見つめてる\n飞越天空 遥望远方\nその目は 光が満ち[みち]でいる\n双眼充满了希望之光\nOpenthemind 世界をきっと変えてゆく そして\n敞开心怀 世界必定能改变 然后…\nOverthesky 遥か[はるか]な物語[ものがたり]\n飞越天空 追寻遥远的故事\nまだ見ぬ景色[けしき]が呼んでる\n那里还有更多未知的景色呼唤着我们\nOpenthemind 世界に光が差す[さす]とき\n敞开心怀 当世界充满光芒的时候\n笑ってどこかで 見ているから\n我一定会微笑着在某处注视着你\n 2.翻译 続く[つづく]【自动词・五段/一类】1.持续，连绵；（同样的事情一个接一个地）发生；紧连着；坚持，维持住。\n立て [たて]【接头/接尾】1.刚。（…したばかり。〕2.连败。〔連敗。〕3.最高级，首席，头目。（第一。）\n出会う[であう]【自动词・五段/一类】1.偶然相遇，遇见，碰见。2.意外地遭受到，遇到，遭到。\n呼ぶ [よぶ]【他动词・五段/一类】1.喊，叫；叫来；请来；邀请；掀起，引起；叫做。\n時々 [ときどき]【名词】1.每个季节；一时一时。【副词】1.时常，时时， 有时。\n立ち [たち‐]【接头/接尾】1.加强语气。\n抱きしめる [だきしめる]【他动词・一段/二类】1.死守；紧抱。2.相拥；拥抱。\n物語 [ものがたり]【名词】1.故事。2.传说。\n差す [さす]【自他・五段/一类】1.上涨，浸润。2.照射。3.透露，泛出，呈现。4.发生，起。5.打，撑，举。\n","date":"2022-07-31","permalink":"/posts/anime/soratane/","series":["动漫歌曲","Galgame"],"tags":["",""],"title":" 空種 -そらたね-"},{"categories":["二次元"],"content":"今年二月的坑填了。\n歌的链接：Asphodelus  1.歌词 来源于网易云歌词。   囚(とら）われた絶望[ぜつぼう]の淵(ふち）で\n身陷绝望的牢狱深渊\nわたしを抱きしめて[だきしめて]ください\n多么希望你能将我紧紧拥抱\n静寂[せいじゃく]に埋(う）め尽[づ]くされ\n这份渴求却无人回应\nひとりで凍(こご）えてる\n在冷寂中独自一人宛若冰雕\n崩れ[くずれ]墮(お）ちてゆく楽園[らくえん]の果て[はて]で\n在崩毁堕落的乐园边境\n忘れられた祈りが響[ひびき]いてる\n远远回响着那已被忘却的祷词\n支配[しはい]する闇[やみ]の中でも涸(か）れない\n祈求那份黑暗中也未曾枯涸的爱\n愛よ目覚め[めざめ]よ永遠(とわ）に\n在此觉醒 永不止息\n無限に降る孤独[こどく]を\n请伸出指尖\nその指[ゆび]で染め[そめ] てください\n沾染我深邃莫及的孤独吧\n叫ぶ[さけぶ]この心が\n这颗喧骚的心灵\n悲しみを愛せるように\n若能够包容那份悲伤\nまだ見ぬあの光の景色[けしき] へ\n无论多么渺茫的光明景致 我也愿前往\n亂(みだ）れ咲く花より深く[ふかく]\n此生既已绽放胜似芳华灿烂\n優しく口づけ[くちづけ]てください\n何不赐我以深情一吻\n躊躇(ためら）いの吐息(といき）さえも\n即便是你唇边踌躇着的气息\n命(いのち）を燈(とも）してく\n也足以点亮我的生命\n滲(にじ）む幻[まぼろし]に祝宴(しゅくえん）の鍾[かね]を\n沉溺于幻梦的喜宴之钟\nその温もり[ぬくもり] 素肌(すはだ）に伝う[つたう]まで\n如阵阵暖流游曳在每一寸肌肤\n迸(ほとばし）る岚[あらし]の中も\n祈求那份在骤雨狂风中飘摇的爱\n止まない[やまない]愛よ目覚めよ\n在此觉醒 永不止息\n抗[あらが]えぬ願いを\n请睁开双眼\nその瞳(め）で迎え[むかえ]てください\n接受我难以抗拒的心愿吧\n出逢[であ]えた喜びに\n这颗赤诚的心灵\n震え[ふるえ]てる裸(はだか）の心で\n若能体味相逢的喜悦\nもとめるあの殘酷[ざんこく]の彼方[かなた]へ\n无论多么残酷的一方土地 我也愿前往\n零れ[こぼれ]散る[ちる]涙[なみだ]が\n当凋零泪花\nきらきらと風に舞う[まう]頃[ごろ]\n随风的舞步画出闪烁光晕\n絆[きずな]を痛みをください永遠に消え[きえ]ないように\n请将羁绊与痛楚托付于我 让它们永存\n無限に降る孤独を\n请敞开心胸\nわたしに預(あず）けてください\n将你深邃的孤独送给我吧\n喚び[よび]合[あ]えた心が\n若两人心声共鸣\n扉[とびら]を放ち[はなち]羽ばたく\n一定能敲开那扇门扉\n近づく[ちかづく]あのはじまりの天空へ\n向着那片万物初始的天空 执着地飞翔\n 2.翻译 果て [はて]【名词】1.［境界的］边，边际；尽头。2.最后，末了，结局；下场。\n響 [ひびき]响。音响。余音。\n支配 [しはい]【名・他动词・サ变/三类】1.指使，支配，左右。2.控制，管理；统治，管辖。\n闇 [やみ]【名词】1.黑暗。暗夜。2.黑市；黑市交易；黑货。3.（心中）糊涂。迷惑。\n目覚め [めざめ]【名词】1.睡醒。2.萌动。3.觉醒。\n叫ぶ [さけぶ] 【自动词・五段/一类】1.大声叫。2.向社会呼吁。\n口づけ [くちづけ]【自动词・サ变/三类】1.接吻。亲嘴。2.口头禅。\n伝う [つたう]【自动词・五段/一类】1.沿着某物移动。2.一点点地移动。\n嵐 [あらし]【名词】1.暴风雨，风暴，风雨。\n迎え [むかえ]【名词】1.迎，迎接；迎接的人。〔迎えること。迎えの人。〕2.死期，大限。〔死期。〕3.接，请。〔請う。〕\n震え [ふるえ]【名词】1.颤抖，哆嗦，发抖。\n零れ [こぼれ] 【名词】1.洒落的东西，溢出。\n散る [ちる]【自动词・五段/一类】1.凋谢；分散；不专一；（热度和肿块等）消退；牺牲；（墨汁、墨水等）扩散而渗；（云、雾等被）吹散消失。\n頃 [ごろ]1.……时分，……前后，……左右。（…ごろ。）2.正好的时候，正合适的时候〔程度〕。（ちょうどよい。）\n近づく [ちかづく]【自动词・五段/一类】1.（地点、时期等）临近，靠近。2.亲近，接近，交往，来往。\n3.乐谱 暂无待补\n","date":"2022-07-31","permalink":"/posts/anime/asphodelus/","series":["Galgame","动漫歌曲"],"tags":[""],"title":"Asphodelus"},{"categories":["二次元"],"content":"kalafina的歌都好好听，现场的演出堪称完美，这首歌是我目前最喜欢的。\n  1.歌词  静かに瞬く[またたく]\n静寂天空\n星たちの散り[ちり]逝く[ゆく]空\n群星闪烁消散而去\n届[とど]かぬ祈り[いのり]が\n无法传达的祈愿\n天[てん]と地[ち]を満[み]たしてた\n满溢在这天地之间\n细い[ほそい]枝[えだ]に光るのは\n未曾绽放的未来\n咲き忘れた未来\n在细枝上闪着微光\nまた名残[なごり]惜[お]しそうに蕾[つぼみ]を落[お]とした\n将尚存依恋的花蕾落下\nほら、もう时は満[み]ちて\n看啊，时光满溢之时\n実る[みのる]黄金[きん]の果実[かじつ]\n结出金黄的果实\nその手で摘み[つみ]取る[とる]だけで\n只需伸手去摘的话\n世界は终わるから\n世界便会迎来终结\n戯[たわ]れぬものとして降る雪の白さは\n无暇飘落的洁白雪花\n温[ぬく]もりを知れば消[き]えてしまうの\n触碰到温暖的瞬间便会消融而去\n綺麗な梦だけが贵方を切[き] り裂[さ]いた\n仅是绮丽的梦境就将你切裂开来\n冷たい瞳[ひとみ]の优しさと真実[しんじつ]\n冰冷的眼眸仅存些许温柔与真实\n激しく[はげしく]瞬く星たちは天に背[せ]いて\n激烈闪烁的星辰背驰天地\n仇[あだ]なす祈りが\n偕同仇恨的祈愿\nこの空を坠とす[おとす] まで\n向着撕落苍穹而去\n私を吊う[とむらう]为の\n无需任何\n花束[はなたば]はいらない\n为我吊唁的花束\n心が溃え[ついえ]ぬうちに愿い[ねがい]を叶え[かなえ]て\n只要心灵尚未溃败 愿望便可达成\n见届け[みとどけ]てみたい\n还想去见证\n人の望み[のぞみ]が\n人们的希望\n灿々[さんさん]と光に満ちる[みちる]时を\n满溢着璀璨光芒之时\n翼[つばさ]を欲しがって谁もが泣い[ない]ていた\n幻想双翼的人们眼含泪水\n命[いのち]が奏でる[かなでる]\n以满天的合唱\n満天のコーラス\n奏响生命的乐章\n焼け焦げ[やけこげ]た愿いが\n当烧焦的愿望\n空を抉じ开ける[こじあける]顷[ごろ]に\n撕裂苍穹的那刻\n懐かしい故郷[ふるさと]は\n怀念的故乡\nきっと花の盛り[さかり]でしょう\n也一定会开满鲜花吧\n激しく瞬く星たちの梦の迹[あと]\n激烈闪烁的星辰 划出梦想的轨迹\n安らぎ[やすらぎ]のあると人の言う[いう]\n直到人们常说的\n最果て[さいはて]まで\n安乐和平存在的尽头\n月影[つきかげ]优しく\n还请温柔的月影\n行く路[みち]を教ぇ[おしえ]てよ\n指明前行的道路吧\n静かに瞬く星たちの\n星辰静寂闪烁的\n祈りの空\n祈愿的天空\n贵方の叫び[さけび]で\n以你的呼喊\nこの梦が终わるまで\n直抵这梦的终焉\n 2.翻译 瞬く[またたく]【自动词・五段/一类】1.眨眼。2.闪烁，明灭。\n散り[ちり]1.四散；离散，分散。\n逝く [ゆく]【自动词・五段/一类】1.逝世，死去。（死ぬ。）2.一去不复返。（行って帰らない。）\n届く[とどく]【自动词・五段/一类】1.送达，收到，发出的物件到达对方处。2.达到，够上，够到。3.周到，注意到，顾到。4.达到愿望，心情与想法传至对方，并被接受。\n祈り [いのり]【名词】1.祈祷，祷告。（祈ること。祈祷。）2.同：祷り\n満たす [みたす]【他动词・五段/一类】1.满足。2.充满；填满；装满。\n細い [ほそい]【形容词/イ形容词】1.细，纤细。2.狭窄，窄。3.微细，低小。\n名残 [なごり]【名词】1.惜别，依恋。2.余音，余韵。\n蕾 [つぼみ]【名词】1.未成年（的人）。2.花骨朵，花蕾，蓓蕾。\n落とす [おとす]【他动词・五段/一类】1.（从高处）扔下。使落下。使降落。2.遗漏。漏掉。丢失。失落。\n満ちる [みちる]【自动词・一段/二类】1.充满。2.涨潮。3.期满。4.完整。\n実る [みのる]【自动词・五段/一类】1.有成果，有成绩，结果实。2.结实；成熟。\n果実 [かじつ]【名词】1.果实，果子。2.水果。3.〈法〉果实；收益；收获。\n戯れる [たわむれる]【自动词・一段/二类】1.游戏，玩耍。2.说说笑笑，耍笑，闹着玩儿。3.调戏；挑逗。\n切り裂く [きりさく]【他动词・五段/一类】1.切开；劈开。\n瞳 [ひとみ]【名词】1.瞳孔，瞳仁儿；眼珠子，眼睛。\n激しく [はげしく]【副词】1.激烈地；猛烈地。\n仇 [あだ]【名词】1.仇人，仇敌。（かたき。）2.仇恨；复仇。（うらみ、怨恨）3.危害；报复；毁灭。（害悪、害をなすもの。）\n坠とす（落とす）[おとす]1.（从高处）扔下。使落下。使降落。\n吊う[とむらう]【他动词・五段/一类】1.吊丧，吊唁，吊慰。2.祭奠，祭祀，为死者祈冥福。\n花束 [はなたば]【名词】1.花束，花把。\n潰え [ついえ]【名词】1.衰败;溃败(同つかれくるしむ;よわる)\n叶う[かなう]【自动词・五段/一类】1.能实现，能如愿以偿。\n見届ける [みとどける]【他动词・一段/二类】1.看到，看准，看清；一直看到最后，结束，用眼看，确认。\n望み [のぞみ]【名词】1.希望，愿望，期望；要求。 奏でる [かなでる]他动词・一段/二类】1.奏，演奏，特指演奏弦乐器。\n抉じ開ける [こじあける]【他动词・一段/二类】1.撬开。\n頃 [ごろ]1.……时分，……前后，……左右。（…ごろ。）2.正好的时候，正合适的时候〔程度〕。（ちょうどよい。）\n盛り [さかり]【名词】1.全盛时期。2.壮年。3.动物发情。4.表示最\u0026hellip;的时候。\n安らぎ [やすらぎ]【名词】1.安乐，平静，安稳。\n言う [いう]【自他・五段/一类】称为，叫做。\n最果て [さいはて]【名词】1.最终，最边远，尽头。\n3.乐谱","date":"2022-07-09","permalink":"/posts/anime/the-whole-sky/","series":["动漫歌曲"],"tags":["",""],"title":"満天"},{"categories":["二次元"],"content":"这首歌有种“希望”和“时间流逝”的感觉。\n 1.歌词 来源于网易云歌词，但是错误很多，通过对比百度的改了一下。\n歌曲链接：Continued Story 注意下面的视频可能含有剧透！！   God bless our king,\n天佑吾王，\nit is a bright light day\n光明之日即将到来，\nLet us worship in your triumph\n让吾等沐浴您荣光凯旋。\nAnd this story is mine,\n这是因我而生的故事，\nand this moment is mine.\n这是尽归于我的时刻。\nCan I steal your pain\n能让我带走你的伤痛\nand shadows away?\n并将之消弭吗？\nTo have made this way,\n为了避免这些苦难，\nto have found this name.\n为了追寻这些真名，\nCan you show me the name of your way?\n我能替你分担这些痛苦吗？\nAnd this story is mine,\n这是因我而生的故事，\nand this moment is mine.\n这是尽归于我的时刻。\nCan I steal your pain\n能让我带走你的伤痛\nand shadows away?\n并将之消弭吗？\nTo have made this way,\n为了避免这些苦难，\nto have found this name.\n为了追寻这些真名，\nCan you show me\n我能替你分担这些痛苦吗？\nthe name of your way?\n\nLalalalalalalalala\nLalalalalalalalala\nDrive your day in my year\n只属于我的时代即将到来，\nLalalalalalalalala\nLalalalalalalalala\nDrive your day in my year\n我梦想中的国度终将建成。\nTowards the light,\n行向光明，\nand this story is mine.\n此乃因我而生的故事。\nCan I steal your pain\n能让我带走你的伤痛，\nand shadows away?\n并将之消弭吗？\nTowards the light,\n行向光明，\nand this story is mine.\n此乃尽归于我的时刻。\nCan I steal your pain\n能让我带走你的伤痛，\nand shadows away?\n并将之消弭吗？\nI miss her\n这是我的过错。\nその一粒（ひとつぶ）のしずくでさえも\n或许只要一滴露水，\n花を守る（まもる）かもしれない\n便可以守住花儿的娇颜。\nその笑い颜ただそれだけで\n或许只要一张笑脸，\n差し（さし）伸べる（のべる）手にもなれる\n便可以给他人带去帮助。\nその震え（ふるえ）てる声集め（あつめ）れば\n若是可以集起微弱的呼唤，\n风を起こす（おこす）かもしれない\n或许也可以唤来呼啸的狂风。\nその命（いのち）というはかなき明かり（あかり）\n若是可以点燃生命的灯火，\n灯し（ともし）て足を进めよう\n或许也可以照亮前进的道路。\nラララララララララン\nLalalalalalalalala\nいつかまた会（あ）おう\n愿我们下次再见。\nラララララララララン\nLalalalalalalalala\n生きてる限り（かぎり）\n只要还未到生命的大限。\n时を超え（こえ）捕らえ（とらえ）られてる\n超越时间来到我心间，\nあふれるこの想いは何?\n这满溢的思念又为何人？\n優しさが目尻（めじり）に似合う（にあう）\n犹记那满目温柔的面容，\nあの人たちは今どこに居る（いる）の?\n那样的人如今又在何处？\nGod bless our king,\n天佑吾王，\nit is a bright light day\n光明之日即将到来，\nLet us worship in your triumph\n让吾等沐浴您荣光凯旋。\n隣り（となり）には新しい席（せき）\n邻座又来了一位新同学，\n未来のためにまた出会う（であう）\n为了迎接未来大家又在此汇聚。\n飾（かざ）らないまま出来る（できる）だけ\n不再掩饰彼此的真心，\n生きてみよう今日という日（ひ）\n只为走好今后的人生。\n悲しくて人は切ない（せつない）\n尽管悲伤依旧难忘，\nそれでもどこまでも道はつづく\n人生之路依然延续。\nラララララララララン\nLalalalalalalalala\nいつかまた会おう\n愿我们下次再见。\nラララララララララン\nLalalalalalalalala\n生きてる限り\n只要还未到生命的大限。\nラララララララララン\nLalalalalalalalala\n風が運ぶ（はこぶ）もの\n那场风所带来的礼物，\nラララララララララン\nLalalalalalalalala\n明日（あす）をくメロディ\n正是开启明日的旋律。\nラララララララララン\nLalalalalalalalala\nいつかまた会おう\n愿我们下次再见。\nラララララララララン\nLalalalalalalalala\n生きてる限り\n只要还未到生命的大限。\nラララララララララン\nLalalalalalalalala\n風が運ぶもの\n那场风所带来的礼物，\nラララララララララン\nLalalalalalalalala\n明日をくメロディ\n正是开启明日的旋律。\n 2.翻译 守る[まもる]：【他动词・五段/一类】守卫，保卫，防守，保护。\n差し伸べる[さしのべる]：【他动词・一段/二类】伸出。\n震え [ふるえ]：【名词】颤抖，哆嗦，发抖。\n集める[あつめる]：【他动词・一段/二类】集合，收集，集中。\n起こす[おこす]：【他动词・五段/一类】立起，扶起；唤醒。\n明かり [あかり] ：【名词】光，光亮。灯，灯光。\n灯す[ともす]：【他动词・五段/一类】点，点亮，点燃。\n限り[かぎり]：【名词】在……的范围内，除非……就……。限，限度，极限，止境。\n超える [こえる]：【自动词・一段/二类】超出，超过。超过，多于。\n捕らえる[とらえる]：捉住，逮住；逮捕。陷入。\n目尻 [めじり]：【名词】外眼角，眼梢。眼睛靠近耳朵的一端。\n似合う [にあう]：【自动词・五段/一类】适称，合适，配合，般配。\n隣り[となり]：【名词】邻居，隔壁，旁边，邻近，附近。\n出会う [であう]：【自动词・五段/一类】偶然相遇，遇见，碰见。意外地遭受到，遇到，遭到。\n飾る[かざる]：【他动词・五段/一类】装饰。装点。粉饰。只装饰表面。\n出来るだけ[できるだけ]：【副词】尽量地；尽可能地。\n切ない [せつない] ：【形容词/イ形容词】难受的，苦闷的，（因悲伤而感到）憋得慌的，难过的。身体感觉）难受的，痛苦的。\n運ぶ [はこぶ] ：【他动词・五段/一类】搬运，运送。开展，进行，推进。运用（工具）。\n3.乐谱 虫虫钢琴有哈，我不搬了，感兴趣自取。\n","date":"2022-06-19","permalink":"/posts/anime/continued-story/","series":["动漫歌曲"],"tags":[""],"title":"Continued Story"},{"categories":["数学类"],"content":"一、Stolz定理[1] 1.$\\frac{0}{0}$型Stolz定理 设{$a_n$}和{$b_n$}都是无穷小量，其中{$a_n$}还是严格单调减少数列，又存在 $$ \\lim_{n\\rightarrow \\infty }\\frac{b_{n+1}-b_{n}}{a_{n+1}-a{n}}=l $$ （其中$l$为有限或$\\pm \\infty$），则有 $$ \\lim_{n\\rightarrow \\infty } \\frac{b_{n}}{a_{n}}=l $$\n 证：只对有限的$l$作证明.根据条件对$\\varepsilon \u0026gt; 0$存在$N$，使得当$n\u0026gt;N$时成立 $$ \\left | \\frac{b_{n}-b_{n+1}}{a_{n}-a_{n+1}}-l \\right | \u0026lt;\\varepsilon $$ 由于对每个$n$都有$a_{n}\u0026gt;a_{n+1}$，这样就有 $$ (l-\\varepsilon)(a_{n}-a_{n+1})\u0026lt;b_{n}-b_{n+1}\u0026lt;(l+\\varepsilon)(a_{n}-a_{n+1}) $$ 任取$m\u0026gt;n$，并且将上述不等式中的$n$换成$n+1$，$n+2$，$\\cdots $，直到$m-1$，然后将左右这些不等式相加，就得到 $$ (l-\\varepsilon)(a_{n}-a_{m})\u0026lt;b_{n}-b_{m}\u0026lt;(l+\\varepsilon)(a_{n}-a_{n+1}) $$ 即 $$ \\left| \\frac{b_{n}-b_{m}}{a_{n}-a_{m}}-l \\right|\u0026lt;\\varepsilon $$ 令$m\\rightarrow \\infty$，并利用条件$\\lim \\limits_{n \\rightarrow \\infty } a_{m}=\\lim \\limits_{n \\rightarrow \\infty } b_{m}=0$，就知道当$n\u0026gt;N$时成立 $$ \\left| \\frac{b_n}{a_n}-l\\right| \\leq \\varepsilon $$\n2.$\\frac{*}{\\infty}$型Stolz定理 设数列{$a_n$}是严格单调增加的无穷大量，又存在 $$ \\lim_{n\\rightarrow \\infty }\\frac{b_{n+1}-b_{n}}{a_{n+1}-a{n}}=l $$ （其中$l$为有限或$\\pm \\infty$），则有 $$ \\lim_{n\\rightarrow \\infty } \\frac{b_{n}}{a_{n}}=l $$\n 证：只对$l$为有限的情况写出证明。对$\\varepsilon\u0026gt;0$存在$N$，使得当$n\u0026gt;N$时成立 $$ \\left | \\frac{b_{n+1}-b_{n}}{a_{n+1}-a_{n}}-l \\right | \u0026lt;\\varepsilon $$ 由于对每个$n$有$a_{n+1}\u0026gt;a_{n}$，这样就有 $$ (l-\\varepsilon)(a_{n+1}-a_{n})\u0026lt;b_{n+1}-b_{n}\u0026lt;(l+\\varepsilon)(a_{n+1}-a_{n}) $$ 取定$N$，并且将上述不等式中的$n$换成$N$,$N+1$,$\\cdots$,直到$n-1$，然后将所有这些不等式相加，就得到 $$ (l-\\varepsilon)(a_{n}-a_{N})\u0026lt;b_{n}-b_{N}\u0026lt;(l+\\varepsilon)(a_{n}-a_{N}) $$ 即 $$ \\left| \\frac{b_{n}-b_{N}}{a_{n}-a_{N}}-l \\right|\u0026lt;\\varepsilon $$ 为了进一步得到关于$\\left| \\frac{b_n}{a_n}-l \\right|$的估计，可以利用恒等式 $$ \\frac{b_n}{a_n}-l=(1-\\frac{a_N}{a_n})\\cdot(\\frac{b_n-b_N}{a_n-a_N}-l)+\\frac{b_N-la_N}{a_n} $$ 由于$\\lim \\limits_{n \\rightarrow \\infty } a_{n}=+\\infty$，存在$N_1$，使得当$n\u0026gt;N_1$时成立 $$ 0\u0026lt;1-\\frac{a_N}{a_n}\u0026lt;2\\quad和\\quad\\left|\\frac{b_N-la_N}{a_n} \\right|\u0026lt;\\varepsilon $$ 则在$n \u0026gt; max \\left \\{N,N_1\\right \\}$时就得到 $$ \\left|\\frac{b_n}{a_n}-l \\right|\u0026lt;3\\varepsilon $$ **两类Stolz定理对$l$为有限或者$\\pm \\infty$的情况成立，但是对不带符号的无穷大量$\\infty$不成立。且定理的逆命题不成立。**\n\n二、一道例题 设已知$\\lim \\limits_{n \\rightarrow \\infty } a_{n}=a$，证明：$\\lim \\limits_{n \\rightarrow \\infty } \\frac{1}{2^n} \\sum \\limits_{k=0}^{n} \\binom{n}{k}a_k=a$ 证明方法直接利用极限定义分步法即可。\n ①证明过程中注意 $$ \\frac{1}{2^n} \\sum \\limits_{k=0}^{N} \\binom{n}{k}\\left| a_k-a \\right|\u0026lt;\\frac{M(1+n+\\cdots+n^N)}{2^n}\u0026lt;\\varepsilon $$ 中利用了$\\binom{n}{k}\u0026lt;n^k$。可以这样观察这个式子： $$ \\begin{aligned}\\binom{n}{k} = \\frac{n!}{k!(n-k)!}\u0026amp;=\\frac{(n-k+1)(n-k+2)\\cdots(n)}{k!}\\ \u0026amp;=\\frac{(n+1-k)(n+1-k-1)\\cdots n}{k\\cdot(k-1)\\cdots1}\u0026lt;n^k\\end{aligned} $$ 对于每个单项可以发现$n\u0026gt;\\frac{n+1-k-i}{k-i}$。\n②关于组合数有以下公式参考：\n $2^n=(1+1)^n=\\binom{n}{0}+\\binom{n}{1}+\\cdots+\\binom{n}{n}=\\sum \\limits_{k=0}^{n}\\binom{n}{k}$ $0=(1-1)^n=\\binom{n}{0}-\\binom{n}{1}+\\binom{n}{2}-\\binom{n}{3}+\\cdots$ $\\frac{1}{2}\\cdot2^n = 1+\\binom{n}{2}+\\binom{n}{4}+\\cdots$ $cosm\\alpha = 2^{m-1}cos^m\\alpha -(\\binom{m}{2}+2\\binom{m}{4}+\\cdots)cos^{m-2}\\alpha +\\cdots$  第4条公式[2]是通过$cosm\\alpha+isinm\\alpha = (cos\\alpha+isin\\alpha)^m$计算后分虚实部得来的，利用这个公式可以导出常用的二倍角三倍角公式，在高中我们通常是用三角恒等式变换得到这些公式的。\n这个部分其余的证明方法想不出来，反正必须要$ \\sum \\limits_{k=0}^{N}\\binom{n}{k}$部分放缩到是$2^n$的无穷小量即可，当然我们知道这是肯定的。\n 1.尝试Stolz 注意到 $$ \\begin{aligned}\\frac{1}{2^n} \\sum \\limits_{k=0}^{n} \\binom{n}{k}a_k \u0026amp;= \\frac{\\sum \\limits_{k=0}^{n}\\binom{n}{k}a_k}{\\sum \\limits_{k=0}^{n}\\binom{n}{k}} \\\\ \u0026amp;=\\frac{\\binom{n}{0}a_0+\\binom{n}{1}+a_1+\\cdots+\\binom{n}{n}a_n}{\\binom{n}{0}+\\binom{n}{1}+\\cdots+\\binom{n}{n}}=\\frac{p_n}{q_n} \\end{aligned} $$ 但这是如果应用Stolz定理会发现不能简化问题： $$ \\frac{p_{n+1}-p_{n}}{q_{n+1}-q_{n}}=\\frac{a_1+\\binom{n}{1}a_2+\\binom{n}{2}a_3+\\cdots+\\binom{n}{n-2}a_{n-1}+\\binom{n}{n-1}a_n+a_{n+1}}{\\binom{n}{0}+\\binom{n}{1}+\\cdots+\\binom{n}{n}}\\qquad \\left[\\binom{n+1}{i}=\\binom{n}{i-1}+\\binom{n}{i}\\right] $$ 2.一些联想 根据这个例题可以立刻联想到一种简单形式：\n设{$x_n$}收敛于$l$，如果$a_n\\in R$，则有： $$ \\lim_{n\\rightarrow \\infty }\\frac{a_1x_1+a_2x_2+\\cdots+a_nx_n}{a_1+a_2+\\cdots+a_n}=l $$ 可以通过极限定义证明是成立的。\n那能不能有一个更一般的定理解决上面的例题呢？比如： 设{$x_n$}收敛于$l$，如果$a_k=f(n,k)$，则有： $$ \\lim_{n\\rightarrow \\infty }\\frac{a_1x_1+a_2x_2+\\cdots+a_nx_n}{a_1+a_2+\\cdots+a_n}=l $$ 这个问题我思考不了，暂且留在这里，或者用一个更具体的$a_n$可能可以解决问题，这里的题目是组合数，比如： $$ \\lim_{n\\rightarrow \\infty }\\frac{\\sum\\binom{n}{k}A^{k}B^{n-k}a_k}{\\sum\\binom{n}{k}A^{k}B^{n-k}}=l $$ 但是这样就已经是正确的结论了。\n三、Cauchy命题和一些变形 利用Stolz定理可以推出Cauchy命题，当然极限定义也可以证明之：\n(Cauchy命题)设{$x_n$}收敛于$l$，则它的前$n$项的算术平均值所成的数列也收敛于$l$，既有 $$ \\lim_{n\\rightarrow \\infty }\\frac{x_1+x_2+\\cdots+x_n}{n}=l $$ 其他形式：\n 若$\\lim \\limits_{n\\rightarrow \\infty }(a_n-a_{n-1})=d$，则$\\lim \\limits_{n\\rightarrow \\infty }\\frac{a_n}{n}=d$ 设${a_n}$为正数列，且收敛于$A$，则$\\lim \\limits_{n\\rightarrow \\infty }(a_1a_2\\cdots a_n)^{\\frac{1}{n}}=A$ 设${a_n}$为正数列，且存在极限$\\lim \\limits_{n\\rightarrow \\infty }\\frac{a_{n+1}}{a_n}=l$，则$\\lim \\limits_{n\\rightarrow \\infty }\\sqrt[n]{a_n}=l$  第一个是等价命题，2和3是推论。后面如果发现有有价值相关联的Cauchy命题的东西的话会补充到这里。\n[1]谢惠民,恽自求. 数学分析习题课讲义. 北京: 高等教育出版社, 2018.\n[2]丘维声. 高等代数学习指导书.上册. 北京: 清华大学出版社, 2017.\n","date":"2022-06-17","permalink":"/posts/math/stolz/","series":[""],"tags":["",""],"title":"Stolz定理和一道例题"},{"categories":[""],"content":"（我已经厌烦了这种重复抄写笔记的方式，所以没有笔记2了——2022.11.13）\n第一单元 语法    中文 日语     ~是~ [名] は [名] です   ~不是~ [名]は[名]では（じゃ）　ありません   ~是~吗？ [名] は[名]ですか   回答 はい、そうです・いいえ、ちがいます・分（わ）かりません   ~的~ [名表从属] の[名]   这个/那个是~ これ/それ/あれは[名]です   ~是~？ それは何ですか / あの人は**誰（だれ）**ですか（礼：どなた）   这个~是~ この/その/あの [名] は [名] です   （三个以上）~是哪一个/哪一个[名]？ ～はどれ/どの机ですか。   这里/那里是~ ここ/そこ/あそこ は [名] です（礼：こちらそちらあちら）   ~东西存在于~地方 ～は　[名表场所] です   ~东西在哪里？ ～はどこですか（礼：どちら）   ~也是~ [名]も　[名]です   （询问多种可能答案）~是~，还是~ [名]は　[名]ですか、 [名]ですか   ~多少钱？ [名]は　いくらですか   ~地方有~东西 [场所]に [物人]が あります/います（不具有意志）   ~东西在~地方 [物人]は [场所]に あります/います   ~东西在哪里？ [物人]は どこに ありますか/いますか   ~和~ [名]と[名]   谁都不在，什么都没有（全面否定） 誰もいません　何もありません（疑问词+も+动否定）    注意\n ～です是谓语部分，有时表示“是”，有时表示“在”；～は提示主语 日语中问句不使用“？” これそれあれ・このそこあの・ここそこあそこ使用相同。两人面对面时ko对应说话人近，so对应听话人近，a对应都比较远；两人同一地方时ko是较近，so是较远，a是更远。  表达和词语  わたし・あなた・あの人对应第一第二第三人称。あなた只在不知道姓名有需要称呼时用，不礼貌。 姓+さん，不分男女，不用于自己；名字+ちゃん用于对小孩的称呼；君（くん）用于与自己年龄相当或比自己年轻的男性。 请多关照：どうぞよろしくお願いします，省略：どうぞよろしく/よろしくお願いします。，更加礼貌：おねがいいたします，回答：こちらこそ 会社員（かいしゃいん）：强调在公司工作的人，不关注什么公司。社員（しゃいん）：强调具体属于某一个公司的人。 方（かた）：用于长辈，上司或者初次见面见面不多的人。あの方は田中さんです。 询问年龄：何歳（なんさい）ですか。礼貌（什么年龄都可以）：おいくつですか。对小孩：いくつ ええ表示对提问的肯定。是はい比较随便的说法。 非常感谢：どうもありがとうございました，普通感谢：ありがとうございます。，略表谢意：どうも 询问来自那个国家：お国（くに）はどちらですか，询问公司地址或者那个公司：会社はどちらです。意思需要自己判断 パソコン个人电脑是パーソナルコンピューター的缩写。   上（うえ）　下（した）　：上表示范围比中文小，只表示垂直上方。墙上是壁に而不是壁の上（墙上方的天花板） 前（まえ）　後ろ（うしろ）　 中（なか）　外（そと）　：里面外面 隣（となり）：旁边   ご家族　ご兄弟　ご両親指别人的，去掉ご才是指自己的。 兄弟（きょうだい）可以指兄妹姐弟姐妹兄弟。 离开家人一个人生活：一人暮らし（ひとりぐらし） おじいさん　おばあさん指祖母祖父　おじさん　おばさん指伯伯伯母叔叔婶婶舅舅姑姑等。   0-10：れい/ゼロ　いち　に　さん　し/よん　ご　ろく　しち/なな　はち　く/きゅう　じゅう 14、17、19两种写法都可以；40、70、90是よんじゅう　ななじゅう　きゅうじゅう 100：ひゃく；300、600、800的读音有变化：さんびゃく　ろっぴゃく　はっぴゃく。400、700、900继承407090。 1000：せん；千中只有3000读音有变化さんぜん，60008000不变。400070009000同样继承407090。 一万：いちまん 。十万：じゅうまん 。一百万：ひゃくまん 。一千万：いっせんまん。一亿：いちおく。 注意一百一千十万百万前面是没有“いち”的，一万一千万一亿都有“いち” 0.1：れいてんいち 。2/3：さんぶんのに。    第二单元 语法 动词ます形    ~ます ~ません ~ました ~ませんでした     肯定地叙述现在的习惯性动作、状态以及未来的动作状态 是ます的否定形式 肯定地叙述过去的动作，这是ます变为ました 是ました的否定形式   休みます 休みません 休みました 休みませんでした   起きます 起きません 起きました 起きませんでした   寝ます 寝ません 寝ました 寝ませんでした       中文 日语     现在是~点~分钟 今（いま）～時（じ）～分（ふん）です   ~时间发生了什么事情 名[时间]　に　动   从~到~期间发生了什么事情 名[时间]から名[时间]まで 动（kara和made可以单独使用）   什么时候干什么 いつ/何時（なんじ）/何曜日（なんようび）/何日（なんにち）动ますか   什么时候开始干什么/什么时候结束什么 いつから始まりますか？　何曜日まで休みますか？   去什么地方，回什么地方 名[场所]へ 动 （へ表示移动行为的目的地）   从什么地方来 名[场所]から 动（北京からきました）   和什么人一起做什么事 名[人] と动（私は友達と帰りました）   通过什么交通工具去哪里 名[交通工具] で名[地点]へ动（歩いでアパートへ帰りました）   从什么地方开始到什么地方终点 名[场所] から 名[场所] まで 动（駅からアパートまで歩いて帰りました：从车站走回公寓）   动+名（吃东西，看电视等等） 名 を 动（コーヒーを飲みます　何を食べますか）   什么地方干什么 名[场所] で 动（図書館で勉強します）   什么或者什么 名 か 名（パンかお粥を食べます：吃面包或者稀饭）   用什么手段/材料做了什么 名[工具] で 动（日本語で手紙を書きます：用日语写信）   什么人给什么人什么东西 人1 は 人2に 物3を あげます（私は小野さんに：我给小野，小野さんは森さんに。物品以“第一人称-\u0026gt;第二人称-\u0026gt;第三人称”或者“第三人称-\u0026gt;第三人称\u0026quot;转移）   什么人从什么人那里得到了什么东西 人1は 人2に 物3を もらいます（私はおのさんに：我从小野那里得到了。物品按照三二一或者三三移动）   见到了什么人 名[人]に会（あ）います（森さんに会いました）    注意：\n 表达现在的时间时，30分钟（三十分さんじゅっぷん）可以用半（はん）来代替。 表达具体时间的词前面还可以加上午前（ごぜん）午後（ごご）。今午前七時半です（现在是上午7点半） 表达动作发生的时间（时间に动）时，今（いま）、昨日（きのう）、明日（あした）、毎日（まいにち）、去年（きょねん）、来年（らいねん）等词后面不能加に：私は明日休みます（我明天休息） 什么东西在什么地方（[物人]は [场所]に あります/います）和什么地方干什么（名[场所] で 动）中文都是“在”，但在日语一个是に，一个是で。 什么人从什么人那里得到了什么东西（人1は 人2に 物3を もらいます）中，赠送者如果是人，后面可用に/から，多用に；如果是组织或者团体，用から：父は会社から記念品（きねんひん）をもらいました。 给东西直接说あげます会给人单方面强加于人的印象，可以用どうぞ/どうですか:李さん、これ、どうぞ（小李，吃吃点心）  表达和词语  两个名词都表示时间，且前面的名词包含毎（まい）时，两个名词之间不加の；当前面的名词不包括毎まい时，可以加也可以不加の。毎朝何時に起きますか？　来週（の）日曜日に働きます。 表示时间的大概，左右：ごろ。如一時ごろ、三十分ごろ。而ごろ后面一般不加に：十二時半ごろ寝ました（12点半左右睡觉） 家有两种表达：家（いえ）うち。家意指建筑物，着重家人时一般用うち。うち本身有“我的家”的意思，家表达我的家时需要”私の家”。 まっすぐ帰りました：直接回家。まっすぐ表示笔直的意思。 お先（さき）に失礼します。（我先走了）お疲れ様でした。（辛苦了） 何的读法有两种：なに、なん。基本读法是なに，在助词の和量词前读なん；在で前两种读法都可以。（何の本です？何時にきますか？何で会社へいきますか？何を食べますか？何がありますか？nan nan nan/nani nani nani） 离现在很近的过去：さっき、たった、今。离现在非常近用たった今，稍前用さっき。 ","date":"2022-05-31","permalink":"/bin/japanese-study-1/","series":[""],"tags":["",""],"title":"日语笔记1"},{"categories":["计算机"],"content":"0x00 前情 在4月中旬的时候，我看我一个op5二手机一直没人用，想送给别人，最终决定送给一个刚刚高中上完的亲戚使用。本着传教的目的，想着给手机root了再送出去，于是就了这么个简短的救砖的经历。我玩机的时间也不是太多，很多知识不懂，这次救砖也是我第一次经历。\n0x01 变成砖 在昨年5月份，我人生的第一次root是通过别人提供的工具箱一键root的，虽然在这之前通过magisk的官方教程尝试过root，但是因为手机是vivo，bl锁解不了，所以没有root成功，这也是二手机的由来。\n于是这次，我为了图方便还是使用了那个工具箱，全然忘机了我为什么丢掉了root（直接升级了系统到安卓10），而工具箱root只支持安卓8和9，结果就是手机就变成了砖，具体表现是手机开机后进入不了系统，黑屏状态，但是可以进入fastboot。recovery也是进入不了。\n0x02 救砖 由于已经过了半个月了记忆模糊了，我只是把整个流程叙述一遍，至于过程，反反复复搞了4个多小时吧，都是一步一步边搜索边操作的。\nrecovery方面，我分别尝试了官方rec和twrp。官方rec每次利用usb修复的时候中途都会失败，原因不明，因而使用了twrp。twrp刷入时使用了\u0026rsquo;fastboot flash recovery'，但是每次重启时却又没安装成功，于是只能使用低版本的twrp，recovery到这里就解决了，可以顺利进入twrp。\n接下来就是使用sideload线刷第三方rom了，这一部分比较顺利，但是sideload总会出错，查了一下发现是好像传的东西超过2gb的话就会有问题，于是只能委曲求全找比较小的第三方rom，最终成功刷入miui。\n0x03 官方方法root 成功救砖后我就安装官方教程进行root了，这一部分我之前做过，所以很顺利。安装magisk，去除rom的boot.img用magisk修补，利用adb pull这个img取到电脑上，fastboot flash boot。顺利的话很快的。root成功后就进行一些常用软件的安装，先弄zygisk，然后shamiko，lsposed，scene安上，再弄点什么模块什么的给他玩玩……其余的就等他自己探索，如果他有兴趣的话……没兴趣也无所谓，反正手机已经给他了……\n0x04 尾 回看其实发现过程不怎么难，但我觉得还是有点意思。希望后面会越来越好玩~\n","date":"2022-05-01","permalink":"/posts/tech/phone-root/","series":[],"tags":[""],"title":"记一次简单的救砖经历"},{"categories":["文字类"],"content":" 1.盎格鲁–萨克逊王国与维京人入侵  维京人摧毁了大部分撒克逊王国的实力后，剩下的英格兰国王、伯爵、大乡绅都奋起反击，大家联手对付维京人。在北方，皮克特人和达尔里亚塔（Dal Riata）本来互不相让，现在出现了前所未有的局面：貌似结成联盟来抗衡一个共同敌人。在北方20年的争斗后，皮克特国王君士坦丁一世刻意给自己起了第一个罗马基督教皇帝的名字，打败了达尔里亚塔，在811年，在北方建立了一个联合王国。\n同样，在剩下的非维京人占领的英格兰地区，统治者们面临无法改变的共同灾难时，摒弃前嫌，团结到单一的全英格兰国王旗下。要拢得住这种史无前例的忠诚，这人必定非同凡响，而阿尔弗雷德正是合适人选。都铎家族认为他非常具有号召力，愿意把不同于所有前辈的“大帝”称号封给他以示敬意，这称号直接将他和查理曼大帝相提并论。而且在所有关于阿尔弗雷德的神话中，也不能说它们错了。盎格鲁–撒克逊叫他英格兰的牧羊人，英格兰的宝贝。\n维京人摧毁了大部分撒克逊王国的实力后，剩下的英格兰国王、伯爵、大乡绅都奋起反击，大家联手对付维京人。在北方，皮克特人和达尔里亚塔（Dal Riata）本来互不相让，现在出现了前所未有的局面：貌似结成联盟来抗衡一个共同敌人。在北方20年的争斗后，皮克特国王君士坦丁一世刻意给自己起了第一个罗马基督教皇帝的名字，打败了达尔里亚塔，在811年，在北方建立了一个联合王国。\n同样，在剩下的非维京人占领的英格兰地区，统治者们面临无法改变的共同灾难时，摒弃前嫌，团结到单一的全英格兰国王旗下。要拢得住这种史无前例的忠诚，这人必定非同凡响，而阿尔弗雷德正是合适人选。都铎家族认为他非常具有号召力，愿意把不同于所有前辈的“大帝”称号封给他以示敬意，这称号直接将他和查理曼大帝相提并论。而且在所有关于阿尔弗雷德的神话中，也不能说它们错了。盎格鲁–撒克逊叫他英格兰的牧羊人，英格兰的宝贝。\n阿尔弗雷德于849年生于万蒂奇（Wantage），是威塞克斯国王埃塞尔沃夫（Aethelwulf）的小儿子，埃格伯特（Egbert）的孙子。塞克斯王国通过常见的战争和联姻结合的方法，取代了中央地带的麦西亚（Mercia）王国，成为最重要的撒克逊王国。马背上的强盗维京人那时还只是被大家当作一时的困扰，他们从圣陵和繁忙的撒克逊市场城镇比如哈姆威克［Hamwic，现代南安普顿（Southampton）的前身］大肆偷盗，然后假慈悲地离去享用赃物。但是后来船队的规模越来越大——每次30—35条船——而且维京人停留的时间越来越长，危害加大。到850年，他们整个冬天都待在肯特的萨内特和谢佩（Sheppey）。据《盎格鲁–撒克逊编年史》记载，850年，一支船队，整整350条船，袭击掠夺坎特伯雷和伦敦，废黜了麦西亚人国王伯赫特沃夫（Berhrtwulf）。白银也不再能保证维京人不杀到跟前，864年，肯特贵族已经依约支付钱财，但维京人仍然不顾一切，决定在这里大开杀戒。接着在865—866年的这一年间，伟大的基督教王国诺森伯兰被毁，这是不列颠到当时为止见过的规模最大的维京船队所为，867年约克沦陷。到876年，诺森伯兰的土地被维京人主要头领们瓜分。869年，这次轮到东盎格利亚国王埃德蒙，往常他都是花钱消灾，这次他却厌倦了，转而奋起反抗，却遭到斩首，身体被刺穿。很明显，对威塞克斯国王埃塞雷德（Aethelred）和他仅存的弟弟阿尔弗雷德来说，用不了多久，他们也将不可避免地直接面对维京人。\n今天我们知道的大部分关于阿尔弗雷德的故事都来自威尔士僧侣阿塞（Asser）所写的传记，阿塞应邀来到威塞克斯宫廷，毫无疑问热情地大唱赞歌。理想化地去看，阿塞所作的记述还是有一部分真实内容，阿尔弗雷德还是个孩子的时候就很好学，最有名的神童故事就是母亲给阿尔弗雷德一本绘图本盎格鲁–撒克逊诗集，这孩子就无师自通地全读懂了。不消说，阿尔弗雷德记住了诗歌，还大声地背给妈妈听，一个自大的小书呆子。\n可是，那年头容不得书生气。868年，维京人在麦西亚人诺丁汉过冬。阿尔弗雷德已经结婚，那明显是战略联姻，他娶了埃勒斯维斯（Eahlswith），岳母是麦西亚王室一员。到870年，丹麦人驻扎在雷丁（Reading），直接威胁到了威塞克斯王国。871年，埃塞雷德与阿尔弗雷德哥俩打了好多仗，高潮是阿什当（Ashdown）大捷。但还没来得及初尝胜利的喜悦，埃塞雷德就死了，留下阿尔弗雷德独自支撑威塞克斯王国。消息传来，第二支庞大的维京队伍已来到雷丁，可不让人省心，威塞克斯沦陷指日可待，整个盎格鲁–撒克逊英格兰看来要重蹈罗马–不列颠的覆辙。\n但就在这时，一些小的奇迹起了干扰作用。维京人的杀戮机器本来令人印象深刻，但其失败之处在于他们庆祝胜利的方式是自我分裂；他们分头去打劫不如征服之后分裂来得多。这都是因为维京人过于自信，以为没人能抵抗他们，在865年和871年，强大的维京人异教徒队伍都分头各自行动。在874年，865年来过的同一批上层维京人返回挪威，剩余的在诺森伯兰长住下来。871年来的一批，在维京人中属于低级阶层，领头的叫古德龙（Guthrum），安营在剑桥，而威塞克斯位于剑桥南边和西边，自然古德龙这帮人对威塞克斯构成两面威胁，维京人已视为威塞克斯囊中之物。当古德龙继续向格洛切斯特开拔时，眼看他的如意算盘就要成真了。\n一时之间，阿尔弗雷德只得暂且避其锋芒，撤退并且和古德龙交换人质，想使维京人离开威塞克斯进入麦西亚。尽管要和古德龙这样的异教徒盟誓，这种策略看起来短时间里能奏效，但阿尔弗雷德心里肯定是悲观的。果然，878年1月的寒冬，在第十二夜，阿尔弗雷德这样的基督徒庆祝显圣节（Epiphany），维京人知道对手的注意力肯定会分散，就对威塞克斯皇城奇彭纳姆（Chippenham）发动突然袭击，他们的计划当然包括俘虏国王，这差一点点就得手了。在当时实际上无力防守的情况下，阿尔弗雷德只能走为上计。\n接下来发生的事就是阿尔弗雷德传奇的重心，阿泰尔尼（Athelney）沼泽地里的莎草没过人头，这个逃亡者利用泥沼容易陷入作为有利条件，开始扭转大势抗敌。阿塞给我们描绘了一个游击队战士原型：“在萨默赛特的树林和沼泽里，过着极其失落的生活，没有生活资料，除了能靠突然袭击中找到的东西。”阿尔弗雷德被迫屈尊向农民乞讨施舍，包括养猪人的妻子，他烤焦了她的蛋糕时，对方使他非常难堪。无论在当时还是后来，这些故事都带着一种经文的调子（或者最起码有短文的影子）：尊贵的国王不幸沦落潦倒却仍然坚忍谦恭（特别是面对愤怒的妇人斥责时）；接着，时运不济，但得到神灵感应，阿尔弗雷德把握住了自己和王国的命运。后来，很多关于四处逃亡的国王故事中，有一种说法是圣卡斯伯特（除了他，还有谁？）现身，要求分享食物，阿尔弗雷德听从了他给他食物；来人随即消失，一会儿又穿上圣者的全副行头出现，应许他最终胜利。并且圣卡斯伯特和吉迪恩一样，敦促阿尔弗雷德相信上帝，吹响战斗号角，召集朋友们。\n到878年春天，阿尔弗雷德成功地召集起临时的抵抗联盟，依靠国王埃格伯特之石，在威尔特郡和萨默赛特（Somerset）边界，领导一支部队，两天后，他们在埃丁顿（Edington）打败了古德龙的维京人，一路追赶到奇彭纳姆，围困两周后，维京头领投降，阿尔弗雷德大获全胜，这可不是一般意义上的投降。古德龙被阿尔弗雷德的战神力量深深打动，他决定立即和他的30名武士加入基督徒战士之列。他在萨默赛特的阿莱（Aller）教堂受洗。阿尔弗雷德作为他的教父，将他从洗礼盆里托起。从前凶猛的异教徒维京贵族不再是穿戴盔甲，而是从头到脚裹着柔软的改宗白布。庄重的仪式结束后，他们受洗时的穿着送去威德莫尔（Wedmore）的阿尔弗雷德皇宫领地，因此这是战场和精神的双重胜利。阿尔弗雷德使古德龙相信了自己，还接纳他加入英格兰教会团体。这样，现在有可能签订神圣的有约束力的条约了（至少阿尔弗雷德是这么想的）。古德龙同意满足于在自己的东盎格利亚称王，再也不袭击威塞克斯、麦西亚或埃塞克斯和肯特的地面，后二者也完全属于威塞克斯统治。后来的事情大抵也就如此了，古德龙退到萨塞克斯的哈德利（Hadleigh），也许在那里过着田园牧歌式的隐居生活，悠游自在，不再像维京人那样给谁带来伤害。\n阿尔弗雷德很聪明，并没有被胜利冲昏头脑。这只是打败了一个强盗和他的队伍，可不是全英格兰的维京人武力。到9世纪末，诺斯人作为殖民者很明显要在不列颠岛长期盘踞，不再做打家劫舍的海盗。阿尔弗雷德的最大愿望就是控制局面，与皈依基督教从而相对温和的维京人邻国妥协。尽管埃丁顿一役不太算得上历史传奇，但它的确使维京人国王暂停了在不列颠岛上的扫荡，给了阿尔弗雷德宝贵的14年喘息时间。在这期间，他修建了30座坚固城堡，组成环状防御带，称作“伯赫”[10]，长期驻防守军，他的战略工事建筑在历代先祖的军事智慧积累之上：利用了铁器时代的山丘堡垒、罗马帝国的大道、撒克逊的低石墙和沟渠。他的民兵（fyrd）非职业军队，由高级领主属下的大乡绅筹建，配上马匹，实行轮值制。这样，不管维京人在何时何地出现，都要面对顽强的抵抗。正如阿尔弗雷德所预计的，在9世纪90年代，维京人真的卷土重来了，但不再像9世纪中叶维京人劫掠的全盛时期那样能够恣意妄为。阿尔弗雷德的措施迫使维京人不得不在小半个国家范围内活动，在丹麦人和撒克逊人的英格兰之间，从东盎格利亚，麦西亚东部到诺森伯兰划定了一道强大的边境防线。\n而这充其量是一种隔离状态。在886年，阿尔弗雷德进入伦敦时［他在罗马旧址上恢复了伦敦，而不是麦西亚–撒克逊人的伦敦（Lundenwic），那个更靠近今天的奥德维奇（Aldwych）和斯特兰德街区（the Strand）］，发生了一些具有重大意义的事件。阿塞写道，他被称为“不臣属于丹麦人的全体英格兰人”的君主。也是从此开始，他被叫作“盎格鲁–撒克逊的国王”。有的故事说得更进一步，称呼他“英吉利之王”（Rex Anglorum），927年，他的孙子倒确实是以这个头衔加冕。因此，毫无疑问在阿尔弗雷德生前，一个联合的英格兰王国已成形，甚至也已有预期。在阿泰尔尼（Athelney）不远处出土的精美“阿尔弗雷德珠宝”（Alfred Jewel），它非凡的祖母绿头面，和富勒（Fuller）胸针有点儿像，圆睁的双眼象征远见和智慧，它的品质完全适合用来赞美一个博学的君主。阿尔弗雷德珠宝侧面刻着传奇的“阿尔弗雷德让我制作”。也可以说是他复活了英格兰君主制。\n 2.阿尔弗雷德与英格兰中的罗马统治典范  的确，盎格鲁–撒克逊的英格兰王国尚在缓慢形成中，同时在苏格兰肯尼斯一世（Kenneth I）统治下的麦克·埃尔平（Mac Ailpin）王国也是这样。但是，当阿尔弗雷德故去的时候，他已经缔造了国王的头衔，以前它只是一个武士头领，颁赏指环者（阿尔弗雷德也被认为是其中最伟大的武士），到这时候已经是制度的建立者和天授王权之人。作为赞美诗翻译者的国王肯定想过自喻为新大卫王或所罗门（Solomon）。和大卫王一样，他是基督教会的左臂右膀——在阿宾顿（Abingdon）出土的一柄剑说明他如何郑重其事地看待自己的职责。和所罗门一样，阿尔弗雷德认为王权的基础应该是正义，而不是武力调停。因此他把众多法律条文和惩罚条例合并，整理出成为单一明晰的完整法律，让人编写、翻译成文，他是第一个这么做的国王。那么他的子民（至少那一半自由的臣民，我们得记住撒克逊英格兰是个奴隶社会）能把得到皇家的裁决视为当然，还有，阿尔弗雷德提供的司法裁决明确限定在现实主义范围内。阿尔弗雷德深知宣布世家仇杀违法的实际作用不大，所以他只坚持国王应该控制这种行为，给予一定的宽限期，例如，让受袭击一方在受攻击前能妥协。维京人烧毁修道院图书馆的痛苦令人记忆犹新，阿尔弗雷德还自认国王要成为教育者。在翻译波伊提乌（Boethius）《哲学的安慰》（De consolatione philosophiae）一书时，他给予智慧最高的赞美，而阿尔弗雷德关于教育的承诺从实际出发。他不仅为自家和宫廷，同时也为全体贵族开办学校，这么做的目的是告诉那些想称王的人，首先要成为识文断字受过教育的人，而不是靠武力和掠夺。\n阿尔弗雷德最热忱最坚定的信念是，动用武力的先决条件是拥有知识。这是远见卓识，不列颠地面上的统治者里还有多少人能如此？\n撒克逊国王经历了长久的转变，才从杀人不见血的异教徒、挥舞斧子的冒险家变成了图书馆的建造者！自然这幅和平好学的盎格鲁–撒克逊威塞克斯图景，更像是一种高贵理想而不是眼前的现实。大半个国家处在维京人的严重威胁下，到10世纪，以威塞克斯国王统治为基础的英格兰已经把国境扩展到特威德河；这片依靠维京人统领的“丹麦法”（Danelaw）统领的地区能享有充分自治。到10世纪末，第二波凶猛的维京人强盗，再一次试图深入盎格鲁–撒克逊英格兰腹地侵略。11世纪初，丹麦的一个国王克努特（Cnut）统治了整个哈德良长城以南的国土，但他的统治更多是受益于阿尔弗雷德及其继任者们奠基的盎格鲁–撒克逊政府。\n经过历年磨难，威塞克斯王家的朝廷后来被摧毁、血洗，甚至常常到了被彻底清洗的边缘。但英格兰国王的范式在阿尔弗雷德的坚持下，像水晶一样纯化了，在最里层植入了撒克逊文化的中心即罗马帝国的统治典范；而通常认为是撒克逊人埋葬了这一古典传统；这是早期不列颠历史上最具讽刺性的事实之一。在特威德河以北，这种情况同样存在。阿尔巴（Alba，900年后他们这么称呼旧的皮克特人国土）国王们轮流用盖尔语和拉丁文名字给他们的儿子们取名，一个叫安格斯（Oengus）王子，他的兄弟叫康斯坦丁王子。从许多方面来看，阿尔弗雷德是撒克逊人中最罗马化的。853年，还在他孩提的时候，他的父亲埃塞尔沃夫送他去罗马执行一项特殊使命，在那里，教皇利奥九世（Pope Leo IV）给小家伙穿上罗马执政官的皇家紫袍，给他腰里围上罗马基督教武士的剑带。公元854—855年，阿尔弗雷德和父亲一起在罗马待了一整年，甚至去了帕拉丁山（Palatine）的废墟，这对于一个盎格鲁–撒克逊人来说，绝对是没齿难忘的经历。成年后阿尔弗雷德学习拉丁语，翻译教皇格列高利的《神职关怀》（Pastoral Care）一书，使他热切的基督教罗马化过程画上圆满的句号。教皇马克西姆斯二世（Maximus II）在任期间，阿尔弗雷德的一个做法后来成了传统，每年给英格兰四分之一的城市免税，返还税款作为国王的救济金，送英格兰人民去罗马游学，这个传统直到亨利八世（Henry VIII）改革才终止。\n当然，阿尔弗雷德忠于的这个罗马，早已不是克劳狄和哈德良派遣军团上岛进而缔造了不列坦尼亚的那个异教徒帝国，而是新的罗马基督教帝国。假如说阿尔弗雷德心中有他自己关于王权的崇高目标，那一定是查理曼大帝。阿尔弗雷德让有学识的宗教人士进入宫廷的政策，看上去就是直接仿效法兰克皇帝。同样，973年，当他的曾孙埃德加（Edgar）先后加冕两次时，邓斯坦（Dunstan）为他设计典礼如下：坎特伯雷大主教（必定懂得古迹的人）——直到今天仍然是英格兰加冕的仪式核心——涂抹圣油、拿起王冠上带十字架的小球和节杖、欢呼“国王万岁！天佑吾王！”——这些来自罗马也来自法兰克传统。那么那两次加冕又是在什么地方举行的呢？就是英格兰这两个罗马和古不列颠融合最彻底的地方：巴斯和切斯特（Chester）。\n不管他还懂得什么其他的，埃德加已经足够聪明，他知道如果要存活下来，英格兰国王决不能心胸狭隘。\n ","date":"2022-04-28","permalink":"/posts/literature/british-history-2/","series":[],"tags":["",""],"title":"威塞克斯与维京人"},{"categories":["文字类"],"content":"第一段：\n 罗马帝国东部前线灾难连连，野蛮人的军队侵入帝国腹地。与之相比，不列颠至少表面上来看稳如磐石。卡劳修斯完善了哈德良长城防线，他加筑了九座“撒克逊海岸要塞”，从诺福克的布兰卡斯特（Brancaster）到汉普郡的博奇斯特（Portchester），战略性地排列在东南沿岸，但由于人力匮乏，帝国军队大批抽调回防，因为欧洲大陆战事吃紧。罗马的敌人对这样的损耗当然不会不知情，公元367年，毫无先兆地发生了三股不同的入侵者合力侵入。盎格鲁–撒克逊（Anglo-Saxon）人从北海来，突破了撒克逊海岸要塞，杀死了守将。向来屈服在罗马统治下的武士，即苏格兰中北部的皮克特人和来自爱尔兰的达尔里亚塔盖尔人（Gaelic Dal Riata，更常见的也更混淆视听的说法是“斯科蒂人”[6]），在陆地上攻破一直认为固若金汤的其他要塞，别墅被洗劫一空然后放火焚毁，城镇被包围，没有给养补充或援军。编年史学家阿米亚努斯（Ammianus）写到伦敦被围困时，记载了匪徒们沿路驱赶劫掠的群众和牲畜。\n这只是不列颠暂时的情形。两年后，令人震惊的野蛮人入侵过后，罗马的法制和秩序恢复了，守卫加强了。但无可否认，危机到4世纪末出现了。具有讽刺意味的是，这个国家在面对外部袭击时在有些方面束手无策，是因为它太适应罗马政府了。足够的守备是保证位于罗马帝国这个系统中心的城市生活延续不断的先决条件。但是，由职业军人和外国雇佣军加本地人辅助担当的防卫力量这时候不再可靠（不管帝国做什么许诺都没用）。失去了这种保护后，最罗马化的不列颠省一时间无法想象临时组织自卫，更别提做点别的什么了。在不列颠那些城市化程度较低的外围地区——威尔士、德文和康沃尔，在较远的北方，例如，那些旧的不列颠准罗马武士阶层较少融入罗马当局的地区——反倒能组织起一些由本地强人领头的自卫，山区丘陵地形对他们也有利，有一个地方甚至收复了哈德良长城上废弃的博得斯瓦德（Birdoswald）罗马要塞作为军事总部。军事劣势导致了经济危机。在罗马–不列颠的中心地带，农民因为给城市里的市场提供农作物，世世代代因此生活富足。但这时野蛮人袭击市场，城乡之间的重要纽带被切断，很多乡下人只好重新变成游牧民。留下的居民也看不到有什么理由要特别忠于罗马–不列颠当局，他们已经没人保护，怎么还能在乎谁在统治着不列颠？对没有自由的村民来说，痛苦的只是不断变换一拨拨主人。公元410年，接到不列颠请求援助的信时，霍诺里乌斯（Honorius）给不列颠领头的市民回信说，从此以后，他们得设法自卫，指望罗马帝国的庇护已经不再可能。\n 第二段：\n 吉尔达斯认为公元5、6世纪的灾难——饥荒、小规模暴政、“一头野蛮人中的‘雌狮’率领一批‘幼崽’带来的蹂躏”——是因为倔强傲慢的罗马–不列颠人甚至基督徒不遵守神的意旨，招致神的惩罚；基督徒“本来应该是全体人民的模范榜样，但事实上他们大部分喝得烂醉如泥”。为了使不列颠历史事件听起来更像《旧约》（Old Testament）经文里的灾难，也为了带着点所谓诗意——“破碎的尸体表面是一层鲜血凝结成的紫色外壳，可怕得好像一些葡萄压碎了混在其中。”——吉尔达斯夸大了崩坍的范围和速度。野蛮人武士即使在最“高潮”也不过是分散的小股势力，稀稀落落地驻足（如果他们也算驻扎的话）在不列颠的东部和南部。当然，他们蛮横无理而极具威胁，但在公元6世纪，罗马–不列颠人在总人口上占压倒性多数，野蛮人可以说势单力薄。这种数量上的不均衡使得某些抵抗行动即刻远近闻名，比如在圣奥尔本斯（St Albans）即维鲁拉米亚姆（Verulamium）临时发动的行动，圣日耳玛纽斯（Saint Germannus）最有力的战争武器就是高喊“哈里路亚（Hallelujah）”而取胜；或者在不列颠北部或苏格兰南部的战斗，在诗人阿贝林（Aneirin）创作的威尔士史诗《葛德丁》（The Gododdin）里，不列颠三王坎里克（Cynri）、塞农（Cynon）与辛瑞恩（Cynrhain）及其300武士，“戴着金环”，骑在300匹威猛的公马上，迎战撒克逊人。其中最著名的是可能发生在公元516年的巴东山（Mount Badon）之战，这个地方有时被认为是在巴斯周围某座小山上。后来，公元8世纪的僧侣历史学家南尼厄斯（Nennius），想象巴东山之战的胜利者不是别人，正是亚瑟，最后一个罗马–基督教武士，挺身而出反抗黑暗蛮族；但是凯尔特智者给予卡米洛（Camelot）一种圣地氛围和神授王命，这一抹诗意，照亮了这个在编年史中几乎无从寻觅，也难以准确纪年的时代。但更有可能的情况是，巴东山之战的英雄是吉尔达斯描述的某个罗马贵族，或许是前执政官安布罗修斯·奥里利厄斯（Ambrosius Aurelianus），他的名字第二部分就有金环的含义。\n尽管这些传奇带着史诗的光辉，但事实上公元5—6世纪不列颠岛一蹶不振时，并非就只有光明与黑暗激烈交战。随着罗马–不列颠土崩瓦解，紧接着盎格鲁–撒克逊的英格兰骤变转型，不列颠历史上割据浪潮风起云涌，但它们和不列颠绝大部分居民的个人经历没有关系，当然，罗马行省的统治机构确实瓦解了，可是在前几批撒克逊雇佣军和海盗上岸后很长一段时间里，罗马–不列颠的社会活动、文化乃至古不列颠的语言大部分都保留了下来。很可能罗马–不列颠人和北海武士们不是死敌，倒是世代比邻而居。因为撒克逊人、朱特人（Jutes）和盎格鲁人需要成熟的有人耕种的土地（因为他们自己根本不想屈尊种地），同时，无自由的村民唯一的兴趣是算计哪个领主能提供更多的安全保护。这样，新旧势力之间很容易达成合作。\n","date":"2022-04-20","permalink":"/posts/literature/british-history-1/","series":[],"tags":["",""],"title":"罗马-不列颠到盎格鲁-撒克逊"},{"categories":[""],"content":"24/12/19 flash\n24/4/8 24/3/23 23/9/27 事情按照我预想地发展，我确实越来越好了，我现在更坚信自己能够变得很厉害，给老婆和周围人一个美好的人生\n23/9/8 女朋友的几个关键词：可爱，纯真，饱受痛苦。我要一直守护她。\n23/9/1 我的人生在8月发生了翻天覆地的变化。遇到了喜欢的人……希望能够长久下去；然后我的病希望能够稳步恢复。\n23/7/30 23/7/24 从今天开始挑战五个月除了吃住只花200元！\n23/7/3 我发觉阅读网安文章更看文献差不多，看文献不可能将所有每一篇文章全部总结一下吧？留个印象即可。所以我感觉目前这样还是算了，重新整理一下网站。\n23/6/10 有时会有那种“目前正在经历的事好像以前做梦梦到过”的感觉，每往前走一步都是一种验证重复。不知道是不是梦的理念和现实重合了。\n23/6/01 我是那种人，在外人不熟悉我的时候拼命表现自己的好想讨好别人，但当亲近之后却又恐惧地将人拒之门外。我真是矛盾啊。\n23/5/26 最终我还是不准备走正规路线。其实做出决定的最大原因在于自身的不安全感，因为是个不正常的人，世上大部分高学历的路线都必须要进入公司等机构工作，而是我所恐惧的，我恐惧我离开了组织机构我会失去一切。为了能随时离开，我决定学习黑客技术。至于其他的，有经济基础有兴趣去学吧。\n23/5/21 突然好想做人工智能的工作……怎么办。我看看我这想法会持续多久吧，如果持续了一个月，那我可能真的要考虑考虑了。\n23/5/12 答辩顺利过关，没想到离上次写的过了这么多天，我也马上准备离开雅安了。我觉得以理想的思考铲除理性就如试图提着自己拉开地面一样困难（不可能），非理性的探索任重道远。\n23/5/02 被自己菜晕。我觉得我应该找好自己的定位……我不过是虫子中稍微突出的虫子罢了，我梦想的光景大概有点形象了，追求安稳，我设想我在普通的维修点普通地过日子，追求技术。我说这些只是提醒自己不要做天命以外的事，我依旧可以努力，但我总会遇到一个永远也达不到的地方，所以不要给自己太大压力了。我是从辣条，游戏厅，烟雾缭绕的网吧中来的，我始终是个喜欢到处玩耍的野小孩。\n23/4/28 想成立开锁王\u0026amp;保安俱乐部……\n23/4/20 其实除了工作挣钱和休息时间，人生所剩的自由时间已经没有多少了。珍惜时间学习阅读自己想要的吧。当然可以浪费时间，但是所浪费的时间都是从学习，接触了解美好有趣的事物的时间中扣除了，时间本身是矛盾的，做了这件事做不了那件事。损失的是遇见美好事物的可能，我很痛心。什么美好事物呢？听一听魔法使之夜的音乐，独自品品茶便知道了。\n我还想学习和接触更多的事物，但我不知道我还能活多久。但对于这种艺术类的品赏还是得看时机，很多时候是静不下心来感受的，可遇不可求的存在。\n23/4/18 为了入侵系统而学的知识瞬间魅力大增，有很多东西等待着学也是种幸福。\n23/4/17 难于启齿，我最近一直梦到拉shit的场景……回想起我小时候到初中时期经常憋着，我觉得我人的问题可能很大程度和这个有关。我开始看梦的解析了，希望能从潜意识角度入手这个问题，多看看弗洛伊德等相关作品。听说黑格尔哲学也比较玄乎意识流，我也准备看看。\n23/4/15 我的家人们根本不关心我的实际情况，我只能欺骗他们了。我最清楚我的情况，但我对我的病一无所知。\n23/4/14 一遍说“钱不好挣啊，得省钱”，一遍又疯狂地买几百的游戏账号……我都懒得吐槽我自己了。\n我现在将这个页面隐藏了，我估计能看到这个页面的不超过两位数。Fastjson漏洞真难学啊……我觉得还需要更多时间，这东西看一会不想看了。\n关于情绪，我觉得失落悲伤的情绪好过浮躁焦虑的情绪，第二种情绪真的非常难受，什么都做不了。伤心低气压嘛至少可以看看剧，漫画。\n2023-04-05 经过一番思考，我不想读研了，但这几天还是先准备准备复试，暂时把拟录取拿到再说。我对数学不再充满热爱了，目前只是将数学当做工具，并且只想思考实际的事。按照最坏的情况来说，应用数学出来后貌似只有当老师比较合适一点，与其打工还不如现在开始。（好了，这下复试都不用准备了，可以摆了，只能说考研失败的经历还是很痛苦的，学坏了身体，却得不到什么东西。）\n2023-04-02 あしゅみ这名字我太喜欢了，又是お趣味又是あすみ的。卡哇伊！\n2023-03-30 老是想一步登天不可用哟，dame。\n2023-03-27 我时而感到自己一无所有，时而感到什么都能有；时而要求低到网络搬砖工，时而又想自己能很厉害；时而想做应用，时而想做理论。感觉现实很割裂呢，不太清楚很多事，什么事情都是忽高忽低的，矛盾体的集合，，此消彼长，此起彼伏，半升半降，繰り返す。\n嘛，普通事情就是看个熟悉，又不是叫你研究什么大成果。一遍看不懂看第二遍，又看不懂看第三遍，直到熟悉为止。一次不成功就又来。自己熟悉时就会觉得自己又行了。至于自己能想达到什么程度，能达到什么程度，想怎么幻想怎么幻想。\n2023-03-25 最近在听重金属，感觉挺适合我的，还以为很伤耳朵，结果没啥感觉，每天早上下午听几小时。为什么突然听重金属了，主要还是因为最近的飘忽不定，加上看了2019万圣节滑板的视频。有种将所有事物都摧毁的想法，抱着这种摆子想法听歌。\n2023-03-24 何が悪いの？意义是自己赋予的。\n2023-03-22 高情商：我觉得决定一个人的不是学校而是能力。\n低情商：你考上的是垃圾学校，但仍未来可期。\n2023-03-19 不得不说我这个博客已经全是歌词了……主要原因还是写其他东西太费精力了，还有最近也没有学啥新知识~\n2023-03-10 青空下的加缪……我决定下一个推的gal是这个！(来自未来的自己：玩了一段有点无聊，暂时算了)\n2023-02-28 最近在看《夏日重现》，我觉得他们那个方言真的好可爱啊，我都非常想去学了！但目前又不知道，或许查一查就知道了やん！\nhttps://www.bilibili.com/read/cv18879462\n2023-02-19 昨天晚上加了个评论系统，其中还可以统计文章访问次数，鉴于明知道流量很少的情况下，我还是不打开了…… 另外虽然我每首歌低下都写了个乐谱，但真是心有力而余不足，我这时期学不了那么多了，如果可能我活到40岁，那时候我觉得合适了。\n车子被偷真的大大地打乱了我的计划，现在回乡非常非常麻烦，但是我觉得应该走之前再回去一次。\n2023-02-17 我好喜欢布琉艾特……声音太好听了~ 然后我去查了一下，发现声优居然是前职业拳击手！！！另外我也需要提一下，代表她的音乐同样很喜欢，非常有活力轻盈，同SP中的空门苍一样！。\n另外我发现这个博客的目录系统不是很明显，我又想换一个博客了……但是不知道迁移得了不。\n2023-02-14 遭遇南宁周某（窃格拉瓦） 车被偷啦！好心疼。为什么选我的车！一晚上就不见了……然后就是第一次报警，第一次去派出所，警察还给我一支烟。反正这电车是大概率要不回来了。默哀……\n2023-02-01 这次又是我一个人在家里了。我要尽量在回学校前消耗完所有家里的东西！而不是什么生存模式。我得做很多关于大葱的菜才能将家里面的大葱消耗完。 做饭真的挺解压的~不过一定至少做出来能吃。做饭也是种生活态度，如果在心情不好时也愿意用心做菜煮饭的话，那一定很不错。 另外以后一些简短的分享就在这上面写了。自己有些时候确实有冲动想发点东西，但是感觉都不合适。所以最终还是决定在这写动态类分享了。唯一的问题就是没有和文章区分。\n2022-06-23 今天是艾伦图灵（Alan Mathison Turing，1912年6月23日—1954年6月7日）的生日，恰好是北回归线的日子。祝图灵110岁生日快乐！\n以下选自《图灵传》：\n 对艾伦来说，这个问题的意义是，它展示了怎样由有理数推出无理数。因此，用类似的方法，通过一条对角线的证明，可计算也可以推出不可计算。当艾伦想到这里时，他马上就知道了希尔伯特问题的答案——不。不可能存在一种“机械的过程”来解决所有数学问题，每一个不可计算数都是活生生的例子。\n  2022-04-13 最近读到的：\n In an image-centered and pleasure-driven world, there is no place for rational thinking, because you simply cannot think with images. It is text that enables us to \u0026ldquo;uncover lies, confusions and overgeneralizations, and to detect abuses of logic and common sense. It also means to weigh ideas, to compare and contrast assertions, to connect one generalization to another.\u0026rdquo;\n That\u0026rsquo;s Why I love TeXT. 回到固有的生动活泼的思考。\n 2022-03-31 1.日记代替 这学期开始考研了，我用日记代替了平常思考记录的电子笔记，所以很多东西都不会发在这了。以前的就作纪念吧（不过我偷偷删了你们也不会知道）。\n2.最近 3月份很忙碌，三级考试还有毕业设计。普通日子除了学习就是玩。不过我已经找到了最重要的东西了，我现在在慢慢理解并行动，这是我理解的“知行合一”，不知道原意是什么。\n一个人租房子真的太舒服了，所以我以后一定好好挣钱争取有自己的一席之地，自己单独的位置。\n最近看的番剧：进击的巨人，幸运星。进击的巨人看到第二季快结束了便不想再看了，我觉得这番编剧是个很肤浅的人，只知道愤怒和视觉冲击还有无脑的信念，整部番剧很没意思。幸运星非常好看，强推！\n最近玩的游戏：国际象棋和刺客信条。lichess里面的每日残局经常下，非常好玩~刺客信条也很好玩（这就是大作嘛？），另外“万物皆虚万物皆允”我也觉得很有意思，和我的目前的人生信条有点相似。\n 最后还是唱起那旋律：#432165454~ 未来加油~ 我永远喜欢Eustia和L.L.\nAdds:关闭上学期做的Java智能问答系统 这样就结束了。最后想说一句：学校的项目不配我用心做。我那天就像失恋被甩了一样很难受（这句话槽点慢慢草www）。\n","date":"2022-02-17","permalink":"/tweet/essay2/","series":[""],"tags":["",""],"title":"随记合集2022.3-"},{"categories":["二次元"],"content":"1.歌词 来源于网易云歌词。   交(か)わした約束(やくそく)忘れないよ\n交换过的约定我一直记得\n目(め)を閉(と)じ確(たし)かめる\n闭上眼仔细确认\n押(お)し寄(よ)せた闇(やみ)\n驱散压迫而来的黑暗\n振(ふ)り払(はら)って進(すす)むよ\n向前进发\nいつになったらなくした未来を\n我在这里是否还能看见\n私ここでまた見ることできるの\n那早已失落的未来\n溢(あふ)れ出(だ)した不安(ふあん)の影(かげ)を\n那溢出来的不安的影子\n何度(なんど)でも裂(さ)いて\n无数次撕裂\nこの世界歩(あゆ)んでこう\n在这世上仔细前进\nとめどなく刻(きざ)まれた\n不停刻画着的时光\n時(とき)は今始まり告(つ)げ\n如今正式宣告一切的开始\n変わらない思いをのせ\n我带着不变的信念\n閉(と)ざされた扉(とびら)開(あ)けよう\n打开尘封已久的门\n目覚(めざ)めた心は走(はし)り\n觉醒的心为了描绘未来\n出(だ)した未来を描(えが)くため\n开始奔走\n難(むずか)しい道\nで立(た)ち止(ど)まっても\n前路充满险阻\n空はきれいな青(あお)さでいつも\n但天空永远蔚蓝\n待っててくれる\n如永恒般 在那里等待着我\nだから怖くない\n所以我无所畏惧\nもうなにがあっても\n无论发生什么\n挫(くじ)けない\n也不会再感到受伤\n振り返れば仲間(なかま)がいて\n回头时也有朋友陪伴\n気がつけば優しく包(つつ)まれてた\n大家的温柔将我包裹\nなにもかもが歪(ゆが)んだ世界で\n在一切都被颠倒的世界里\n唯一(ゆいつ)信じれるここが\n我唯一确信的\n救(すく)いだった\n只有最初的救赎\n喜(よろこ)びも悲しみもわけあえば\n若将喜悦和悲伤一同分享\n強まる想い\n心灵就能变得坚强\nこの声が届くのなら\n这声音如果能够传达\nきっと奇跡はおこせるだろう\n奇迹就一定会发生\n交わした約束忘れないよ\n交换过的约定我一直记得\n目を閉(と)じ確かめる\n闭上眼仔细确认\n押(お)し寄(よ)せた闇(やみ)\n驱散压迫而来的黑暗\n振り払(はら)って進むよ\n向前进发\nどんなに大きな\n无论前路\n壁(かべ)があっても\n存在着多么大的阻碍\n越(こ)えてみせるからきっと\n也一定能跨越\n明日信じて祈(いの)って\n我相信着明天如此祈愿\n壊れた世界で\n在这崩溃的世界中\n彷徨(さまよ)ってわたしは\n彷徨着的我\n引(ひ)き寄(よ)せられるように\n如受到启示一般\n辿(たど)り着(つ)いた\n最后还是来到了这里\n目覚(めざ)めた心は走り出した\n觉醒的心为了描绘未来\n未来を描くため\n开始奔走\n難しい道で立(た)ち止(ど)まっても\n前路充满险阻\n空はきれいな青さでいつも\n但天空永远蔚蓝\n待っててくれる\n如永恒般 在那里等待着我\nだから怖くない\n所以我无所畏惧\nもうなにがあっても\n无论发生什么\n挫けない\n也不会再感到受伤\nずっと明日待って\n永远等待明天的到来\n 2.翻译 暂无待补\n3.乐谱 暂无待补\n","date":"2022-02-11","permalink":"/posts/anime/connect/","series":["动漫歌曲"],"tags":[""],"title":"コネクト(TV动画《魔法少女小圆》片头曲)"},{"categories":["二次元"],"content":"1.歌词 来源于网易云歌词。   「それじゃ またね」って手を振(ふ)って\n向你挥着手说“那就再见啦”\n無理に笑って さみしくなって\n勉强地笑着 变得空虚起来\n歩道橋(ほどうきょう) 自転車抱(かか)えて登(のぼ)る人\n过街天桥上 推着自行车攀登的人\nコンピニ 誰かのウワサ話(うわさばなし)\n便利店里 讨论着某人的流言\n交差点(こうさてん) 信号(しんごう)\n十字路口 红绿灯\n遠くのクラクション\n从远处传来的汽车鸣笛声\n知らない誰かの笑い合(あ)う声\n不知是谁和谁的欢声笑语\n今日は独りで歩(ある)く\n今天一个人漫步\n通(かよ)い慣(な)れた街(まち)\n即使在这熟悉的街道上\nでもいつもよりもなんだか\n不知怎么地比平时还觉得\n自分(じぶん)がちょっと 小(ちい)さく思えるよ\n自己更加渺小了\n「それじゃ またね」って手を振って\n向你挥着手说“那就再见啦”\n笑顔作(つく)って さみしくなって\n强作笑脸 变得空虚起来\nホントはまだ話(はな)し足(た)りないけど\n其实我明明还没有和你聊够\n「それじゃ またね」って言葉で\n“那就再见啦”这句话\nまた会(あ)えるって ウソをついて\n说着“还能再见”的谎言\nいつも通(とお)りの笑顔で言(い)うよ\n就像平时那样微笑着说吧\n「また あした」\n“那就再见啦”\n独りには慣(な)れてる フリをしてるけど\n虽然假装着自己已经习惯独自一人\nホントはそんなに強くないし\n但其实也并没有那么坚强\nいつもと同(おな)じ景色 いつもと同じ街(まじ)\n一如过往的风景 一如过往的街道\nなにも変わらないハズなのに\n明明周围什么也没有改变\n自分だけが小さく思えるよ\n只是觉得自己很渺小\n「それじゃ またね」じゃなくって\n不是说什么“那就再见啦”\n「あと少(すこ)し」って言えば良(よ)かった\n要是能说“再待一会儿”的话就好了\n気が付(つ)いて欲しくて期待(きたい)していたけど\n虽然这样期待着 想让你察觉到这份心情\n「それじゃ またね」って言葉で\n用“那就再见啦”这样的话\nまた自分に ウソをついて\n再次对自己撒谎\nいつも通りの笑顔で隠(かく)すこの気持ち\n如同以往 用微笑隐藏着这份心情吧\n「それじゃ またね」って手を振って\n向你挥着手说“那就再见啦”\n笑顔作って さみしくなって\n强作笑脸 变得空虚起来\nホントはまだ話し足(た)りないけど\n其实我明明还没有和你聊够\n「それじゃ またね」って声さえ\n连“那就再见啦”这句话\n届(とど)かないほど 近(ちか)くて遠い\n好像都无法传达 这么近又那么远\nいつも通りに あと１度(いちど)だけ言(い)わせて\n一如往常 一次就好 让我说出\n「また あした」\n“明天 再见”\n 2.翻译 暂无待补\n3.乐谱 暂无待补\n","date":"2022-02-09","permalink":"/posts/anime/mataashita/","series":["动漫歌曲"],"tags":[""],"title":"また あした"},{"categories":["二次元"],"content":"1.歌词 来源于网易云歌词。   いつか君が瞳(ひとみ)に灯(とも)す愛の光が\n曾在你眼中点亮的爱之光\n時(とき)を超(こ)えて\n超越了时空\n滅(ほろ)び急(いそ)ぐ世界(せかい)の夢(ゆめ)を\n急剧消逝着的世界的梦\n確(たし)かに一(ひと)つ壊(こわ)すだろう\n此刻确实面临着毁灭\n躊躇(ためら)いを飲(の)み干(ほ)して\n饮尽所有的踌躇之后\n君が望(のぞ)むモノは何?\n你要索求的到底是什么？\nこんな欲深(よくふか)い憧れの行方(ゆくえ)に\n在如此深切渴望着的应许之地中\n儚(はかな)い明日はあるの?\n存在的是否只是虚无缥缈的明天？\n子供(こども)の頃(ころ)夢に見てた\n用那如同儿时梦见的\n古(いにしえ)の魔法(まほう)のように\n能像远古魔法一般\n闇(やみ)さえ砕(くだ)く力(ちから)で\n粉碎黑暗的力量\n微笑(ほほえ)む君に会(あ)いたい\n去与微笑的你相逢\n怯(おび)えるこの手(て)の中には\n这颤栗的手中\n手折(たお)られた花の勇気(ゆうき)\n有着残花的勇气\n想いだけが頼(たよ)る全(すべ)て\n能够依赖的只有信念\n光を呼(よ)び覚(さ)ます\n这呼唤光明到来的\n願(ねが)い\n信念\nいつか君も誰かの為(ため)に\n你终有一天会为了谁\n強い力を望(のぞ)むのだろう\n去祈求强大的力量\n愛が胸(むね)を捉(とら)えた夜(よる)に\n心灵为爱所困的夜里\n未知(みち)の言葉(ことば)が生(う)まれて来(く)る\n你会脱口而出从未说过的话语\n迷(まよ)わずに行けるなら\n只要我能扫清疑虑\n心が砕(くだ)けてもいいわ\n心灵变得破碎也无妨\nいつも目(め)の前の哀(かな)しみに\n我衷心渴望着的\n立(た)ち向(む)かう為(ため)の\n是那句能与眼前的悲哀\n呪文(じゅもん)が欲しい\n作斗争的神秘咒语\n君はまだ夢見(ゆめみ)る記憶(きおく)\n你是残留梦中的记忆\n私は眠(ねむ)らない明日\n我是无法入眠的明天\n二人が出会(であ)う奇跡(きせき)を\n为争取能让我们相遇的奇迹\n勝(か)ち取(と)る為に進(すす)むわ\n向前进发\n怯(おび)えるこの手の中には\n这颤栗的手中\n手折(たお)られた花の刃(やいば)\n有着残花的刀刃\n想いだけが生きる全て\n最终幸存的只有信念\n心に振(ふ)りかざす\n这舞动于心中的\n願い\n信念\n囚(とら)われた太陽(たいよう)の輝く\n在被囚禁的太阳的光辉下\n不思議(ふしぎ)の国(くに)の本が好きだった頃(ころ)\n欣赏不可思议的国度的书本时\n願いはきっと叶(かな)うと\n愿望必定会实现\n教(おし)えるお伽噺(とぎばなし)を\n我相信着\n信じた\n被人如此教导的童话\n(光と影の中\u0026hellip;)\n（在这光影中\u0026hellip;）\n静(しず)かに咲(さ)き乱(みだ)れていた\n有声音告诉我 能用静谧的、\n古(いにしえ)の魔法優(やさ)しく\n纷乱绽放于世的远古魔法\n世界を変(か)える力が\n将世界轻轻改变的力量\nその手にあると囁(ささや)く\n就在这手中\n終わらない夢を見よう\n去看看这永无止境的梦境吧\n君と行く時の中で\n在与你同行的时光中\n想いだけが生きる全て\n最终幸存的只有信念\n命(いのち)を作(つく)るのは\n这创造了生命的\n願い\n信念\n 2.翻译 暂无待补\n3.乐谱 暂无（口琴吹这个可能不好听）\n","date":"2022-02-08","permalink":"/posts/anime/magia/","series":["动漫歌曲"],"tags":[""],"title":"Magia(TV动画《魔法少女小圆》片尾曲2)"},{"categories":["二次元"],"content":"1.歌词 转载来源：百度 作了一点排版修改。   锖付（さびつ）いた心（こころ)、音（おと）も无（な）い世界（せかい）\nSabitsuita kokoro, otomonai sekai,\n锈迹斑斑的心灵,寂静无比的世界,\n何（なに）を见（み）てるの\nnani o miteruno?\n你到底看见了什么？\nまたねを言（い）える颜（かお）を探（さが）すよ\nMatanewo ieru kao o sagasuyo\n寻找着能将再见说出口的表情,\nそれを缲（く）り返（かえ）すだけ\nsore o kurikaesu dake\n只是不断将此重复罢了\n気付（きつ）けばそこには，\nKizukeba soko niwa\n回神之时伫立于此,\n一人(ひとり)きりで泣（な）く后（うし）ろ姿（すがた）\nhitorikiri de naku ushiro sugata\n只剩下孤单哭泣的背影\n辛（つら）いような、寂（さび）しいような　场所（ばしょ）、\nTsurai youna, sabishii youna basho\n在这个好似艰辛,又好似寂寞的 地方,\n手（て）を繋（つな）いでいたいんだ\nte o tsunaide itainda\n我想与你一同牵手走下去\n何度（なんど）目（め）の気持（きも）ちだろう\nNandome no kimochi darou\n这到底是第几回的心情了呢,\nここにある温（ぬく）もりは\nkoko ni aru nukumori wa\n而存在于此的温暖\n间违（まちが）いでも构（かま）わない、傍（そば）にいること\nMachigai demo kamawanai, soba ni iru koto\n就算是误会也无妨 只要彼此相伴\n涙（なみだ）の音（おと） ため息（いき）の色（いろ）\nNamida no oto , tameiki no iro\n眼泪的音色 叹息的色彩\n今（いま）、确（たし）かめる现在地（げんざいち）\nima, tashikameru genzaichi\n现在 确认于此的现居地\n冗谈（じょうだん）みたいな毎日（まいにち）\nJoudan mitai na mainichi\n仿若玩笑般的每一天,\n见（み）たい 见（み）たい 未来（みらい）\nmitai, mitai, mirai\n好想要预见的 好想要预见 那未来\n强（つよ）がりの声（こえ）も掠（かす）れたな、\nTsuyogari no koe mo kasureta na,\n逞强的声音也终究声嘶力竭,\nと梦（ゆめ）に落（お）ちるの\nto yume ni ochiru no\n堕落于梦境之中\n抱（かか）えた膝（ひざ）、\nKakaeta hiza,\n一旦抱紧双膝\n目（め）を落（お）とすと\nme o otosu to\n闭上双眼,\nすぐに崩（くず）れてしまいそうで\nsugu ni kuzurete shimai soude\n仿佛立刻就要崩坏一般\nこのまま、このまま\nKonomama, konomama\n就像这样 就像这样,\n二人（ふたり）きり駆（か）け込（こ）む远（とお）い出口（でぐち）\nfutarikiri kakekomu tooi deguchi\n你我两人跑向遥远的出口\nまだ 期待（きたい）しているの。\nMada, kitai shiteiru no.\n还抱有着希望呢 ,\nさぁ 笑（わら）って见（み）つめ合（あ）うんだ\nSaa waratte mitsume aunda\n来吧 相视而笑吧\n単纯(たんじゅん）で无邪気（むじゃき）な颜（かお）\nTanjun de mujaki na kao\n单纯天真的脸庞,\nくしゃくしゃの思（おも）い抱（だ）いて\nkushakusha no omoi daite\n拥抱着混乱不堪的思念\n迷（まよ）い込（こ）んだ场所（ばしょ）さえ优（やさ）しすぎて\nMayoikonda basho sae yasashi sugite\n就连迷路的地点 都无比温柔\n何度（なんど）でも名前（なまえ）を呼（よ）ぶよ\nNando demo namae o yobu yo\n无论几次都会呼喊你的名字,\n不确（ふたし）かな未来（みらい）でも\nfutashika na mirai demo\n就算面对不可确定的未来\n离（はな）せないもの 思（おも）うだけ心（こころ）が痛（いた）いよ\nHanasenai mono, omou dake kokoro ga itai yo\n只要想起那些不愿放手的东西就会心痛\nここにいるよ\nKoko ni iru yo\n我就在这里哦\nここにいるよ\nKoko ni iru yo\n我就在这里哦\n帰（かえ）る场所（ばしょ）はここだよ\nkaeru basho wa koko da yo?\n你的归所不是就在这里哟?\nいつだって変（か）わらない\nItsudatte kawaranai\n无论何时都不会改变,\n思（おも）いを残（のこ）すの\nomoi o nokosu no\n留下永恒的思念.\n 自己也手抄了一份（书写在练了在练了，我的中文书写一样差）：\n 我不会好好写的！我也写不好~  2.部分词语翻译 錆付く：【自动・一类】金属类物品因生锈而与其他物品黏在一起，锈在一起。或者是指金属物品完全生锈了。（这里动词活用た型表过去）\n繰り返す：【他动词・五段/一类】反复；重复。\n気付く（気づけば）：【自动词・五段/一类】发觉，注意到。\nきり：【副词】只，仅，就，终于。\n後ろ：【名词】后，后面，后方。\n姿：【名词】1.姿态2.态度，举止；装束，打扮3.身影4.姿势,形象\nような ：【助动词】1.よう为样态助动词，在连接名词时＋な　2.像，类似。3.例如。4.某种样子。\nつなぐ（つないで） ：【他动词・五段/一类】1.接上，连上。2.系，栓。3.拘禁。4.维系。\n何度：【名词】多少次，几次。\n温もり：【名词】温和，温暖，暖和气儿，暖气儿。\n間違い：【名词】错误，有误，不正确。\n構わない ：【接续词】没关系，不要紧，不在乎。\nため息 ：【名词】叹；惋；惋叹\n確かめる ：【他动词・一段/二类】弄清，查明。\nみたい ：【助动词】像……那样，像……一样。\n強がり ：【名词】逞强，装硬汉。\n掠れる：【自动词・一段/二类】嘶哑。\n落ちる：【自动词・一段/二类】落下，降落，掉下来，坠落。\n抱え：【接头/接尾】抱，搂。表示两臂搂抱所及的大小。\n落とす ：【他动词・五段/一类】\n崩れる ：【自动词・一段/二类】崩溃，坍塌，倒塌。\nまま ：【接续助词】由于，因而。\nきり：\u0026lt;接续\u0026gt;　名词+きり\n駆け込む：【自动词・五段/一类】跑进，跑入里面\n見つめ合う：互相对视，相互凝视\nくしゃくしゃ：【形容动词/ナ形容词】杂乱无章『成』，乱七八糟『成』，蓬乱。心情纠结成一团的样子。\n込む：【自动词・五段/一类】彻底；深　某种状态的持续。复杂。精致。精巧。 [込む]是[込んだ]的原形形式\nさえ：【副助词】连。甚至。\n離す：【他动词・五段/一类】放，放开，放掉，撒开\n残す：【他动词・五段/一类】留下；剩下；遗留\n3.乐谱 暂时没有找。\n","date":"2022-01-24","permalink":"/posts/anime/andimhome/","series":["动漫歌曲"],"tags":[""],"title":"And I`m home（杏子沙耶香合唱角色歌)"},{"categories":["普通类"],"content":"今年是Eustia的一年。\n有个博客，我也可以学别人写写年终总结了~因为博客显然比较正式，相比于社交媒体来说。\n一、音乐方面 其实我就是因为网易云音乐的年终总结才想起来可以写一个同主题博客的，所以第一个就贴里面总结的一些截图了。我非常惊讶的是我听初音的歌听了那么多次，居然打败了99%的人。年终歌曲空種そらたね是没有任何问题的，我直到现在还依然非常喜欢这首歌和Eustia，而且我是在2021年1月1日遇见这首歌的，所以，对于我来说，今年是Eustia和初音的一年。\n \u0026emsp; 二、2021年流水账 回忆一下这一年的大概内容。\n1月：复习，回家后在学计算机技术（网络安全，C++貌似），当时头发留得很长，我现在都还有照片，我觉得那时候我的样子很酷，但是头发很难打理（因为太长了）\n2月：过年，玩，剃掉头发，学英文版抽象代数。\n3月：回校，继续学英文数学，并且尝试用英文做数学题，发布到网上记录，还在学密码学。那个时候还在玩原神，并且疯狂地买原神账号。和同学一起报名数学建模。\n4月：继续学习网络安全和密码学。准备数学建模竞赛。重新看鬼灭之刃（有个很喜欢的小女孩，我贴个图）。结束了gal魔女的夜宴学姐线。初步尝试俄语字母学习。\n 5月：在劳动节假期初步创建了博客，购买Unzybaryl.xyz.com域名。对手机root进行了学习和尝试（最后发现vivo手机bl是解不了的，所以之后买了个二手机root）。继续数学建模，继续密码学和网络安全学习。玩Summer pockets。\n6月：日语继续学习（我的日语学习总是很断断续续）。开始准备期末考试。结束Summer pockets和脏翅膀游戏。 7月：考试，回家。一个人生活自己学习做菜做饭。学习网络安全，学习日语。追番寒蝉鸣泣之时。\n8月：和7月差不多，因为是暑假期间。学习口琴。\n9月：回校。学习网络安全和密码学。重新看了一些传记（乔布斯，图灵）。尝试解决病情（时机已成熟Time has come）。读了一些闲书（圣经，博弈，宗教史，禅，西方哲学，都没读完）。购买了一台Linux云服务器。追番赤瞳。特别的离散数学我非常喜欢。学校周边网吧上网。\n10月：国庆暗黑破坏神重置版。复习数分。准备java大作业。自由的概念（自由是自律的自由，自由不能以牺牲自由为代价）。看一些闲书（中医，克莱因）。\n11月：数学史，数学学习。尝试和各种游戏（崩坏3，音游，赛尔号）。Java大作业2天完成。网站换域Eustia.me。\n12月：Java“答辩”效果良好。学习数学，复习考试。\n三、总结 今年过得也是有点混乱，什么地方都学了一下，但是很多都没学完，就是缺少一个明确的计划和目标，但是我相信这个问题明年就会得到解决。大概掌握了Web的基本知识（处于即将挖洞的阶段），学了一点逆向的知识，数学学了一大半抽象代数，一大半密码学。生活方面有了一点点的进步，慢慢学会怎么休息，但是现在还没完全学会；我之前一直没有自我意识的，现在也在慢慢培养。主要的是这一年我终于理解了我的心理病的根源，我现在终于可以慢慢改正了。\n因为昨年没有写2021年的愿望，所以愿望实现部分就不写了，但是2022年的总结一定会有一部分的。\n四、明年愿望 目标越上面越重要，我不一定完成全部目标，完成一件就很满意了。\n抽象方面：\n 考研不留遗憾 极大程度地解决病情 学会休息 学会分配爱好和工作的时间（学会合理规划时间，安排事物） 学会如何生活  具体方面：\n 成功考试（准备过程和考试过程）并准备好面试 数学竞赛国奖 日语N2及以上 音乐可以达到任何曲子都可以练习的基础并可以吹出来（口琴） 英语持续学习  五、尾巴 新年快乐~祝看到这段文字的人愿望实现~\n","date":"2021-12-30","permalink":"/posts/other/2021/","series":[],"tags":[""],"title":"2021年的总结"},{"categories":[""],"content":"随便写写最近所看到的数学。\n最近在读数学史，终于发现了喜欢的东西了，就是无穷级数。之前一直对分析不是很感兴趣（但是也不讨厌），所以有了点兴趣让我也很开心。今天（其实结果写了几天）随便写一点无穷级数（就是写写书上的东西），就突出一个词：“随便”。毕竟我今后是想做数学事业的，所以我还是想多花点时间在数学上……\n背景在17，18世纪……人物挺多，最耀眼的当然是Euler。\n顺序就不谈了，我随便写写，没有什么提纲顺序的。生成的文章右边小栏上有目录可以看看。\n开始\u0026amp;一般 1360 Oresme $$ 级数:\\frac{1} {2} + \\frac{1}{2} + ( \\frac{1}{4} + \\frac{1}{4}) + ( \\frac{1}{8} + \\frac{1}{8} + \\frac{1}{8} + \\frac{1}{8} )+\\cdots 发散 $$ 于是比以上大的调和级数: $$ 1+\\frac{1}{2}+\\frac{1}{3}+\\frac{1}{4}+\\frac{1}{5}+\\cdots发散 $$ Mercator, Newton $$ log(1+x) = x - \\frac{1}{2}x^{2} + \\frac{1}{3}x^{3}+\\cdots $$ 在$x=2$时右边的级数为无穷，而它应该为$log(3)$。 $$ 2 +(-2+\\frac{8}{3}) + (-4 + \\frac{32}{5})+\\cdots $$ 1671 Collins $$ \\begin{aligned} \u0026amp;\\tan x = x+\\frac{x^3}{3}+\\frac{2}{15}x^{5}+\\frac{17}{315}x^7+\\cdots \\\\ \u0026amp;\\sec x = 1+\\frac{x^2}{2}+\\frac{5}{24}x^4 + \\frac{61}{720}x^6+\\cdots \\end{aligned} $$ 1675 Leibniz $$ \\frac{\\pi}{4} = 1-\\frac{1}{3}+\\frac{1}{5}-\\frac{1}{7}+\\cdots $$ 1668 James Gregory 收敛得较快的级数，在计算中更有用。 $$ \\frac{1}{2}log\\frac{(1+z)}{(1-z)} = z+\\frac{1}{3}z^3+\\frac{1}{5}z^5+\\cdots $$ 推理\u0026amp;计算 James Bernoulli\u0026amp;John Bernoulli ① 从级数 $$ N = \\frac{a}{c}+\\frac{a}{2c}+\\frac{a}{3c}+\\cdots $$ 得到（注意级数是发散的）。 $$ N - \\frac{a}{c}= +\\frac{a}{2c}+\\frac{a}{3c}+\\cdots $$ 将以上两式相减得： $$ \\frac{a}{c} = \\frac{a}{1\\cdot 2c}+\\frac{a}{2\\cdot 3c}+\\frac{a}{3\\cdot 4c}+\\cdots $$ James说这样的做法是有问题的，如果不慎重是不能用的（级数发散的原因）。\n②","date":"2021-12-11","permalink":"/bin/math_history_1/","series":[""],"tags":["",""],"title":"一些无穷级数"},{"categories":["二次元"],"content":"预告一下这个系列，回忆一下这部作品，里面的很多台词都引我深思。\n主要采取截取台词的形式吧，并且简单地写一下我的感受，重头游玩一下这部作品。\n","date":"2021-12-09","permalink":"/posts/anime/eustia_1/","series":["Galgame"],"tags":[""],"title":"【预告】穢翼のユースティア游戏回顾"},{"categories":[""],"content":"以前没写完的，写作日期为2021-05-07。\n  先说一下，以前没写完的，现在对这个也没什么兴趣了，主要还是因为自己能力不足吧，本意是想建模，公理化进行推理来构建的。发现写不出来，加上那时也快考试了，就无了。\n当时主要想解决网络争吵的事情，感觉非常地“空”，现在看来也确实如此。发出来只是记录下想法。\n  根据代数学，墙纸中的二维晶体限制种类(2D Crystallographic Restriction)只有17种（rotation，reflection，glide的组合），墙纸的样式无论再多，它也只能属于17种的一种。数学超越人的感官，能更深刻地认识事物。我一直在想如果能对一个事物构建出基本体系，创建公理，那么就可以推理出人类感官以外的结论。这种想法持续了很久，也一直没去继续想下去，只是个模模糊糊的东西，但是小站新开张，于是将一些思考写下来，记录下来，作为小站的礼物纪念。\n更新记录：\n 2021-05-07 11:14:56创建文件  说明 正如简介说的，这是我目前的对数学的粗浅的理解。一个公认规律是，学得越深，理解也越深，描述观察得越准确。只不过目前不想学太多数学了。关于世界理解，我的想法是这样的，打个比方：初中生对世界的理解就像单元函数，事物的原因只有一个主要的；高中生同样是单元函数，只不过扩充到了更复杂的如指数，对数变化，就像是从$N$变化为了$N\\log N$，更加细致，精密了；大学生认识到事物的原因有很多，变成了多元函数，对事物以群类分，环等；之后嘛就测度论，更加更加深刻的认识。\n并且我还想有些东西也许也炒菜一样，将各种东西看作调料，魔法般地调整比例，制作自己心爱的东西。\n其实有一些例子供我参考的，目前我所了解的比如信息论，欧几里得几何原本，皮诺亚公理的相容性，图灵的可计算数，抽象计算机，抽象代数的开始（Galois，Abel，群，环），大刘的关于黑暗森林的推理。我都没仔细了解，之后闲暇时间慢慢了解，补充到这里，顺便给我启示。\n❗这篇记叙可能不会太认真，而且也可能不会有结果，但是有新想法会更新，并且会随着自己理解增加不断地修改内容与细节。\n❗自身水平有限，客观上错误会有很多​，有心的话可以讨论讨论。\n❗纯粹写着玩的，颇有点民科的味道😰。。。。\n❗尽量避开社会学，哲学等模糊不清地方。我不太会用专业名词，只是作为一个观察者将观察到的现实描述下来。我感觉这些东西比数学还复制难懂。\n观察/Observe ❗ 这部分会根据真实情况不断修正，世界所有的活动就是样本，只要不满足任意一种现实情况，就是错误的\n网络社交空间分为网络与社交，所以先需要对现实社交进行观察。观察现象如下：\n普通社交  人们通过语言等信息载体交流，传递信息，而任何事物都可以作为信息，如石头，墙体，人的皮肤碎屑。这里我们只讨论以语言为载体，并且是实时或短间时的对称交流。（①短间时如传纸条，情书，email，qq，社交论坛，视频评论区，并且时间间隔小于一个量，如传纸条的最大时间间隔除特殊情况外不超过一节课的时间，而网络社区的时间间隔24h左右都行，这是一个相对量。②交流主体都是平等的，对称的；像老师对一群学生就是不对称的，而学生学生之间，或者单个老师与单个学生之间是对称的。） 表达是人类正常的生理需求，本能冲动，日常生活中主要通过社交完成。每个人从小时候就开始叽喳学语，本能地想表达传递信息；即使是十分沉默自闭的人，不通过语言，也会通过其他方式表达，如画画，跳舞，运动，唱歌等。 社交的目的是为了自己，在有些特殊情况有些不同。人类是群居动物，人类是自私的，本能下首先会考虑自己的利益，人与人的交往建立在共赢或者互损（互相伤害）的基础上，并且有时候会相互转化，而其他情况属于不稳定情况。在家族，爱人，知己等等情况会有所不同，毕竟我们见闻过牺牲自己求对方的事情等，那类非常真心真诚的事情。 自身面临的事件类型处在大大小小不同圈子的时候，社交行为会发生一定变化。如亲戚圈，同学圈，同事圈，老乡圈，同专业圈，同性别圈，同比赛阵营圈，同国家圈，同游戏圈，同爱好圈。共同特征是别人与自己具有一定的相似性，无论是内在还是外在的，一般来说，内在圈相比外在圈的行为变化幅度会更大。和排外性一样，人们不希望被anti自身的事物干扰打搅。 人类个体综合属性（表面身体，精神与性格等）是不同的，在相对封闭的环境下形成了奇妙的社交集合。同样的，如果自身综合属性改变，社交集合也会慢慢改变。人类的社交集合随着自身处于的环境的变动而改变，并且通常情况下随着时间流逝慢慢完成更新，变为稳定。当当前相对封闭环境中如果个体的社交集合有数量不够，比例失调等问题的话，会向外补足，寻找替代品。（异地恋容易失败也是这个原因） 每个人交往的对象数量是有限制的，交往越深，数量越少。这是个普遍规律，在很多事物中都有体现，如一个人的爱好，食物链，正态分布。 在社交过程中，信息存在着非常大的损耗和变化，这与对象之间的理解能力，表达能力的差值和对象属于的社交集合有关，很多时候都不在一个频道上。脑袋是自己的脑袋，所见之事是自己眼睛见到的，是自己在想自己的事情。如一位母亲见到了一名陌生的环卫工人，教导孩子以后好好学习。而那名环卫工人是家人呢？第一反应应该不是这样。 社交内容限制 社交博弈 ","date":"2021-12-01","permalink":"/bin/internet-social-space-1/","series":[""],"tags":["",""],"title":"【废案/想法】网络社交空间"},{"categories":["计算机"],"content":"(多图警告！）给一些需要的朋友，互联网本身也有很多教程，反正有疑问的地方可以通过网站给出的链接询问~\nPERFACE 1.教程方向 尽量简单易懂 有问题反馈后会进行补充。\n2.顺序结构 按照Hugo，GIthub Page和Git，域名的顺序来写。由Hugo的基本操作，选择Theme后生成博客；通过Git上传博客内容至Github仓库，在仓库中设置Github page，最后的域名购买可绑定是可选择的。最后还会介绍一些需要使用的东西，如Md文档样式，hugo theme文件格式。\n一、Hugo Hugo是由Go语言实现的静态网站生成器。可以快速生成静态网站。\n1.Hugo的下载和安装 Hugo下载地址：Hugo 0.89.2 下载了好后解压把文件放在一个位置，如我放在了D:\\目录下（www3不用管）：\n  接下来配置环境变量，win和R键一起按，调出运行窗口，在其中输入“systempropertiesadvanced”回车：\n  出现系统属性窗口，点击右下角的“环境变量”，双击系统变量中的“Path”：\n  点击右边的新建，将你下载解压的hugo地址填上去：\n  检查是否安装成功，win+R键打开运行窗口，输入“cmd”回车，在命令提示符中输入“hugo -help”查看是否有以下信息出现，出现则安装成功：\n  在命令行窗口中输入“hugo new site 路径/名字” 就可以建立一个站点，例如以我的环境，输入\u0026quot;hugo new site D:\\hugo_0.82.1_Windows-64bit\\www3\u0026quot;。我上面的www3文件夹也是这么来的，文件夹名字可以随便取，我取的就是“www3”啦。\n  2.Hugo Theme下载和安装 安装好了Hugo，还需要安装一个主题，主题就是你搭建博客的style样式。主题地址：https://themes.gohugo.io/ ：\n  这里有非常非常多的主题，你喜欢哪款就点击进去，点击左下角的“Download”按钮，跳转到对应的github仓库，在绿色的code按钮下，点击“Download zip”就可以下载啦：\n  之前我们用hugo new site命令创建了一个站点，现在将下载的Theme放入站点中的theme文件夹，我这里已经放了3个theme了：\n  接下来导入theme的配置文件，这里不同的theme表现有些不同，先去下载theme的examplesite找一下，我遇到的有两种可能：\n①存在一个config.toml，那么就把这个文件复制到站点根目录下去：\n  ②没有config.toml而是一整个config文件夹，那么把这个文件夹复制到站点根目录下：\n  反正不管怎么样，这个东西或者文件夹就是配置文件了。这里面的设置都挺重要的，并且还有一些theme作者提供的额外功能，一般来说theme里面有教程，我这里附上我以前的配置，里面包含了url，网站语言，HTML title，使用的主体文件夹名等等，这个就自己探索吧。里面的配置随着主题的不同有很大的不同，一般来说作者会给出教程的，在下载主题文件夹里面找找。\n  3.Hugo创建和写作文章 首先需要在之前生成site的那个文件夹内打开cmd窗口，先打开那个文件夹，然后在文件夹上方的那个地址栏中输入”cmd“即可实现：\n  之后我们就可以用命令来生成空文章了，在cmd中输入：\n1hugo new xxx.md 就在站点目录的content中生成了一个叫\u0026quot;xxx.md\u0026quot;的文件。有些站点的文章目录结构有些不同，像我的站点content里面还有文件夹，如我想在content\\posts\\文件夹里面生成空文章的话，可以输入：\n1hugo new posts\\new.md 其他的目录就依次类推了。\n  打开自动生成的空文章，最上面就是生成空文章的一些信息，title表示文章标题，date表示发布日期，draft代表是否是草稿，如果文章是操作，在之后的生成过程中这篇文章是不会被生成的。当然这里不同主题的表现可能也有些不同，下面是图，这个就自己探索了，如果有疑问可以通过站内给出的联系方式问我。\n  之后就可以用md文档写文章了，md文章还是有很多样式的，并且可以插入HTML代码，之后的附录里会给一些md文章写作技巧。\n4.调试站点和生成站点 写好文章以后，还是在站点根目录的cmd窗口中输入hugo server或者hugo server --buildDraft来调试站点。其中第二个指的是将draft设置为true的站点也生成。\n  默认地在浏览器中输入localhost:1313就可以看到你的站点啦~之后在网站的各个地方修改并且保存后，它会检测到改动，并且快速地重构站点，你可以立刻就看到改动后的样子。我现在写这篇文章就是这样做的哦！注意如果源代码出错了hugo server也是会构建不了的，需要重新再输入一次上面的指令。\n  站点调试完成后，觉得差不多了想要上传，还是在站点根目录的cmd的窗口中输入：\n1hugo 就会生成站点啦。站点生成在站点根目录的“public”文件夹下面：\n  二、Github Page 静态站点的源代码hugo已经帮我们弄好了，现在怎么才能变成可以访问到呢？Github Page给我们提供了个非常方便的服务，可以将网站源代码上传至github仓库，设置好Github Page以后我们网站可以由github提供的域名：“username.github.io”访问到了，并且还可以绑定上自己买的域名。\n1.Git 首先需要注册个github账号，之后嘛……给你个链接：GIt使用 配置好SSH key，把站点public文件上传到Github仓库就算成功啦。下面给出我站点仓库的截图，里面的东西和之前用hugo指令生成在public文件夹的东西是一模一样的，所以这部就是把public的东西搬过来。\n  每次写完文章，用hugo生成了之后，都需要上传至Github仓库，这里我把我上传的过程写一下：\n首先在网站public目录中打开Git，然后4条指令就搞定：\n1git add . 2git commit -m \u0026#34;注释\u0026#34; 3git pull 4git push origin master 2.Github Page 在网站仓库的“settings”中倒数第二个“Pages”中设置，启用了之后自动就给一个域名，可以直接访问。\n三、域名购买和绑定Github Page 续待未完。\n四、附录 1.Md文章写作 2.Hugo主题自定义","date":"2021-11-27","permalink":"/posts/tech/blog_instruct/","series":[],"tags":[""],"title":"我的Hugo+Github page搭建博客教程"},{"categories":["二次元"],"content":"所谓既视感，就是既视感。\n这部番是一位友人推荐的，据说他被这部番伤得很深。。但是我看完还好。在前期看的过程中发现好多和尤斯蒂娅的一些类似的地方，无聊写一下。有些有图片，有些没图片，懒得截图了，后面看到了也许会补上。\n补：现在马上快的12点，我再慢慢补图……（补完了已经快一点了……）\n1.中世纪风格 服装，建筑等各种地方。其实我也不确定是不是中世纪，只是和之前看罗马纪录片那些人物服装的风格有些相似……特别是图二的艾莉丝的服饰非常有纪录片中康茂德妻子服饰的感觉。赤红之瞳NPC的服装也大概感觉是这样，但是主角们的服装就有些不一样的特点了。（嗯……都是用的冷兵器，差不多吧……）\n ユースティア 服饰1    ユースティア 服饰2    ユースティア 建筑1    赤红之瞳 服饰1  2.上层建筑 这两部作品都分有类似于「阶级」的概念，刚好对应上层的建筑挺类似的。通俗的讲就是“人上人”等富裕和统治阶级居住的地方。都有那种很高的很漂亮的天桥的建筑，也都是白色调子的，图一的天桥已经垮了……\n  ユースティア 上层1    ユースティア 上层2    赤红之瞳 上层1  3.一位女性角色 羽狩和使用生物性帝具的反派，她们两位都是出场开始属于上层阵营的，但是，越到后面差别越大，菲奥奈在和主角相处的过程中看到了真相，发觉到上层在欺骗底层民众；而塞琉一直维持着“变态”的正义感，直到她死亡。赤瞳表现反派人物真是有些夸张……有那种蜜汁立绘。另外说起来我还特别喜欢菲奥奈，她非常正直，单纯的感觉。\n  ユースティア 菲奥奈立绘    ユースティア 菲奥奈游戏截图    赤红之瞳 赛琉  4.革命 这里只放尤斯蒂亚游戏内的图片啦，关系大概也仅仅就革命而已，就是下层因为一些矛盾推翻上层统治的过程，尤斯蒂娅中是因为不断的“崩落”，下层民众的生存之地不断减少，整天活的提心吊胆；赤瞳中就很平常的是因为上层的腐败，对人们剥削严重。结局可能有些不同，比较尤斯蒂娅是gal，有多分支结局。\n  ユースティア 革命1  大概写完啦，没什么好总结的，尤斯蒂亚是今年6、7月份玩的，刚刚好开学后补完了赤红之瞳。我是非常喜欢尤斯蒂亚这部gal的，特别是和圣女的那一幕，引起了我很多思考，可以说是伴随着我的心理的转变，我之后也会好好记录这部gal的。对于赤红之瞳没有太大的感觉，可能是因为人物都死得太快了吧😂，对于艾斯德斯，黑瞳，和那位粉红色的化妆帝具的人物挺有印象，有些人物死得有些奇怪，只能说死于话多了……\n好了我回去了，悄悄说一下，现在的1:41我还在黑灯瞎火的教学楼，就在刚刚出现了不明来路的光线……我还是赶快寝室睡觉吧。真的有点恐怖。。。吓死我了，虽然我也没干什么不好的事情。（来自第二天的我）\n","date":"2021-11-25","permalink":"/posts/anime/akame/","series":[],"tags":[""],"title":"《斩！赤红之瞳》与《穢翼のユースティア》类似的地方"},{"categories":[""],"content":"随便写点什么。\n我真的就是随便写了，没啥时间排版，画图和构思。所以写下的内容可能没什么逻辑条理。还是想看就看吧，不想看就不看。\n之前暑假看番剧《寒蝉鸣泣之时》，里面的人物得了一种综合征，触发条件疯起来就会非常可怕地伤害人。其中一个条件就是“不信任，猜疑”。但是结合我自己的事例来说，我觉得即使没有得那种综合征，人因极度的猜疑和恐惧，确实是可以发生非常离谱的事件的，如杀人等。当然可能还需要一些条件，如我来说就是经历事物太少，见识不多，所以认识事物非常抽象，只停留在表面，追寻神秘主义。\n还有另一个相关的东西就是猜疑链，三体小说中出现的。我想猜疑本身就是一种刺激，当猜疑本身的事件出现便会给猜疑人出现巨大的冲击，使得猜疑的事物权重上升，眼中于是便只有猜疑，而且真的是越看越像，越觉得真实，事情本身虽然是不确定的，但是猜疑人心中越来越相信是真实的了。整个过程开始于猜疑，然后不断地由于猜疑本身而发生正反馈，所以越来越疯狂，在外人看起来就像是疯了一样，我自己本身也曾当面骂过老师，但我想事情的最终答案应该是这个，所以我好了之后还要找时间去和老师道个歉。。。极端的猜疑和恐惧导致的自我相信的现实是非常真实的（我现在也是，但我在勇敢地突破），但是事情的真相终究是不确定的，越到后来越会觉得离谱，最终达到平衡，猜疑人的世界分裂了，不知道那边是真实，一直犹豫仿徨，不过最终肯定会选择一边的，因为这是个相信的世界，很多东西是不确定的，所以决定因素是自己，自己相信，那就是那样的。\n综合看来猜疑成神经病这种结构，其实是很脆弱的，因为真相只有一个，真相永远不会变化，真相是什么就是什么，但是由于猜疑人强烈的猜疑和恐惧这种强大的动力才变成这样的。先猜疑，后恐惧；因为恐惧，所以猜疑；互相加强。真是魔鬼。。破坏这种结构可以破坏猜疑本身，这是个人因素，也可以破坏反馈——发现真相。可能还有其他的方法，隐藏在逻辑中。哪种方法都不容易，发现真相的过程中缺会因为恐惧而更加反馈也说不定，这一点在动画中也有体现。\n个人感觉很多事物都和这个有关，除了以上的《寒蝉》、猜疑链。如社交生活中，特别是网络社交生活中，在自己猜疑别人是怀着什么心态时可以注意一下，看自己是不是已经相信了某种自认定的事实，然后在过程中寻找蛛丝马迹。想起来还有一例就是看到新闻之前一个算卦觉得有一个人天性“克”他，于是过了一段时间他就把别人给杀了，也是很有意思的事情。\n所有这些事情的共性我觉得还有一个更深的层次，就是“痒”的感觉，这一点也在《寒蝉》中有体现。我之前也是脖子等各种地方痒。痒代表了很多东西，欲望，急躁等情绪，这一点就请后面的时间了。\n总之，克服这种东西需要拿出足够的勇气，长时间的坚持和乐观的发现真理的信念。Wir mussen Wissen. Wir serden Wissen.祝君加油。\n2021/11/28 基于以上的观点，我发现现实中很大部分的事物我们永远都认识不了真相。并且很多东西都有种“套娃”的结构：“我们在认识事物的时候本身就被影响着，不能脱离这种影响来认识事物（除了数学物理等科学）”，这种结构我目前没有找到解决办法，并且如果是这种结构，依据我浅薄的毕生所学的实验知识，它是永远不能满足“单一变量”的条件的，所以所有都是错误的。怎么说呢，活得开心就算成功，不要一直被瘴气缠绕，不要多想地做自己想做的事。\n下面附上之前读书读到的一段话，我就把原文打在这里，是关于笛卡尔的，就以这段话结尾吧：\n ​\t如果Descartes把周围的一切看做只是由运动的物质构成的，那么，他怎样解释味道、气味、颜色和声音的质量呢？这里他采用了古希腊关于第一性和第二性的学说，依照Democritus，这个学说主张“甜与苦、冷与热以及颜色等东西，只在意念中存在，在实际中不存在，真正存在的是不变的粒子，原子以及它们在空的空间中的运动.”第一性的东西，即物质与运动，存在于物理世界中；第二性的东西，仅仅是当外界原子冲击到人的感官时，第一性的东西产生这些感官上的效果.\n​\t因此，在Descartes看来，有两个世界：一个是巨大的协调地设计出来的数学机器，存在于空间和时间中，另一个是思维的世界，第一世界的元素作用在第二世界上的效果就产生出物质的非数学性质或次要的性质.此外，Descartes肯定了自然界定律的不变性，因为这些定律只是预先规定的数学图案的一部分，就是上帝，也不能改动这不变的自然界，在这里，Descartes否认了通行的信条：上帝不断地干预着宇宙的活动.\n","date":"2021-11-05","permalink":"/bin/suspect-discuss/","series":[],"tags":[""],"title":"聊聊猜疑"},{"categories":["文字类"],"content":"百年孤独中阿玛兰妲的全部片段。\nPreface 阿玛兰旭也是个非常奇怪的人，和丽贝卡一样，她所表现的行为可能就是孤独吧。另外我之前一直把阿玛兰妲认成阿玛兰旭了……\n我之前和阿玛兰妲的内核大概是一样的吧，这也就是说我现在慢慢不这样了。\n阿玛兰妲 阿玛兰妲出生 　一月里一个星期四的凌晨两点，阿玛兰妲出生了。在其他人进入房间之前，乌尔苏拉先把她浑身上下细细检查了一遍。她又轻又湿像条蜥蜴，不过身体所有部位都属于人类无疑。\n阿玛兰妲童年时期 　乌尔苏拉出去打听吉卜赛人是从哪里走的，按照别人的指引边走边问，相信还来得及追上。她离村子越来越远，等发觉时已经走出太远，便索性不再回头。何塞·阿尔卡蒂奥·布恩迪亚直到晚上八点听到小阿玛兰妲哭得声音沙哑，把材料留在粪床上加热，过去一看才发现妻子失踪了。几小时后他聚集起一支整装待发的队伍，把阿玛兰妲托付给一位自愿喂奶的妇女，随后上路四处追寻乌尔苏拉的踪迹。奥雷里亚诺也跟了去。黎明时分，几个操着陌生语言的土著渔夫打着手势告诉他们，不曾见到有人经过。徒劳寻索三天之后，他们回了村。\n　此后几个星期，何塞·阿尔卡蒂奥·布恩迪亚陷入沮丧当中。他担负起母亲的职责照料小阿玛兰妲，给她洗澡换衣服，一天四次送去哺乳，晚上甚至为她唱起乌尔苏拉从来不会唱的摇篮曲。\n（母亲乌尔苏拉去找何塞阿尔卡迪奥了）\n　时间使一切恢复了原样。何塞·阿尔卡蒂奥·布恩迪亚和儿子不知从何时起又回到了实验室，他们抖落尘埃，点起炉灶，拾起已经在粪床上沉睡了数月的材料，又一次耐心地操作起来。连躺在柳条小筐里的阿玛兰妲，也好奇地观看父兄在水银蒸气弥漫的小屋里入神地工作。架子上被遗忘多日的一个空瓶忽然重得挪不动。工作台上的一锅水未经加热便沸腾了半个小时，直到完全蒸发。何塞·阿尔卡蒂奥·布恩迪亚和儿子看着这一切又恐惧又欢喜，他们无法解释，只是将其视作新材料要诞生的预兆。一天阿玛兰妲的小筐自行移动起来，在房间里兜了个圈。奥雷里亚诺大吃一惊，连忙去拦下它。做父亲的却没有惊慌，他把小筐放回去，固定在桌腿上，坚信期待已久的事情即将发生。就在那时，奥雷里亚诺听见他说： “就算你不敬畏上帝，也该敬畏金属。”\n　…………\n　奥雷里亚诺却用钱买来盐酸配制王水，还把钥匙镀了层金。不过他的古怪之处与阿尔卡蒂奥和阿玛兰妲相比又算不得什么，那两个孩子早就开始换牙，却依然整天跟在印第安女人后面，顽固地不肯说卡斯蒂利亚语而只说瓜希拉土语。“你有什么可抱怨的，”乌尔苏拉对丈夫说，“有发疯的父母就有发疯的儿女。”正当她哀叹自己命不好，认定儿女们的怪癖与猪尾巴同样可怕时，奥雷里亚诺眼神定定地望着她，令她感到一阵茫然。\n　“有人要来了。”他说。\n（没错，丽贝卡来了，这里接丽贝卡那里了）\n　…………\n　乌尔苏拉知道后，在药物治疗之外又加上了皮带抽打。永远无从确知，究竟是大黄或毒打，还是二者一起最终发挥了效用，总之几个星期后丽贝卡显出康复的迹象。她加入到阿尔卡蒂奥和阿玛兰妲的游戏中，他们把她当姐姐看待。她胃口颇佳，刀叉也用得不错。不久家人又发现她的卡斯蒂利亚语说得和印第安土语一样流利，手头活计也干得出色，还会哼唱音乐钟奏出的华尔兹舞曲，配上滑稽的自编歌词。大家很快就接纳她为家庭新成员。她和乌尔苏拉最亲，连乌尔苏拉的亲生儿女都比不上。她管阿玛兰妲和阿尔卡蒂奥叫小妹妹小弟弟，称奥雷里亚诺为叔叔，呼何塞·阿尔卡蒂奥·布恩迪亚为爷爷。于是，她和其他家人一样名正言顺地用上了丽贝卡·布恩迪亚的姓名，那也是她一生用过的唯一姓名，直到去世从未玷污。（这里第一人称是丽贝卡） 阿玛兰妲与皮埃特罗·克雷斯皮 　在这个古怪的家里，乌尔苏拉尽力保持正常，她扩大了糖果小动物生意，整夜不歇地开着烤炉，产出一篮篮面包以及品种丰富的布丁、蛋白酥和小饼干，几个小时内就在通往大泽区的小路上全部售出。明明已到可以安享生活的岁数，她反倒越来越活跃。她一直忙于自己兴隆的事业，一天下午，当印第安女人帮她往面团里加糖，她无意中向院子望去，竟看见两位陌生的美丽少女在暮色中绣花。那是丽贝卡和阿玛兰妲。她们为外祖母严格守孝三年，那时刚刚脱去孝服，鲜艳的衣裳仿佛使她们在世上获得了新的地位。谁也不曾想到，丽贝卡会是两人中更漂亮的那个。她面容白皙明净，眼睛大而沉静，一双有魔力的手仿佛在将无形的丝线绣成花样。年龄小些的阿玛兰妲虽然魅力稍逊，但遗传了过世外祖母自然的气质和内心的高傲。\n　…………\n　（人多了，修了新家）\n雪白如鸽子的新家落成时，举办了一场庆祝舞会。乌尔苏拉是在那天下午发现丽贝卡和阿玛兰妲已出落成婷婷少女的一刻萌生这个想法的，甚至可以说，扩建计划的主要目的正是为了让姑娘们有一处体面的地方接待访客。为了完美无缺地实现这一愿望，她在扩建进程中像苦役犯一般劳作，在竣工前就已订购了昂贵的装饰品和生活用具，还添置了一样必将震惊全镇、引发年轻人欢呼的神奇发明——自动钢琴。钢琴分部件装箱运来，一同到货的还有维也纳的家具，波希米亚的玻璃器皿，西印度公司的餐具，荷兰的桌布，以及各式各样的灯具，烛台、花瓶、帷幔和壁毯。进口公司自费派来一名意大利技师皮埃特罗·克雷斯皮，负责安装和调试自动钢琴，指导顾客使用，并教授如何伴着印满六卷纸带①【注①自动钢琴上用于控制琴键的穿孔纸带。】的时兴乐曲跳舞。\n　皮埃特罗·克雷斯皮是个金发的年轻人，马孔多的居民还从未见过这样英俊又有教养的男子。他非常注重仪表，酷暑天气仍身着花缎紧身马甲和厚厚的深色呢料上装。他出于礼貌与主人保持适当距离，好几个星期关在客厅里汗流浃背地工作，心无旁骛的状态足可与金银器作坊里的奥雷里亚诺媲美。一天上午，他没有开门，也没有招呼任何人来见证奇迹，就在自动钢琴上装好第一卷纸带，于是烦人的捶打声和板条持续的轰鸣戛然而止，只有明净谐和的乐声开始荡漾。所有人都赶到了客厅。何塞·阿尔卡蒂奥·布恩迪亚大吃一惊，倒不是因为优美的旋律，而是因为自动钢琴琴键的自行弹奏。他立刻把梅尔基亚德斯的照相机架设在客厅里，期望能够拍到那看不见的演奏者。那天意大利人和他们共进午餐。这个天使般的男子未戴戒指的苍白手指使用起刀叉来如行云流水，令负责斟酒上菜的丽贝卡和阿玛兰妲惊诧不已，在客厅旁的起居室里，皮埃特罗·克雷斯皮教她们跳舞。他用节拍器打着拍子指导舞步，但不触及她们的身体。这一切都受到乌尔苏拉礼貌的监视，她在女儿们上课的过程中一刻不曾离开房间。皮埃特罗·克雷斯皮这些日子脚踏舞鞋，身穿富于弹性又极其贴身的舞蹈长裤。“你用不着这么担心，”何塞·阿尔卡蒂奥·布恩迪亚对妻子说，“这人是个娘娘腔。”但她不肯放松警惕，直到课程结束，意大利人离开马孔多才罢休。接着他们开始筹备舞会。乌尔苏拉开列出一张经过严格筛选的宾客名单，入选的都是村庄创建者的后代——除去庇拉尔·特尔内拉一家不算，那女人又生了两个父亲不明的孩子。实际上这是门第之选，只不过以友情作为选择标准。那些入选者早在背井离乡创建马孔多之前就是何塞·阿尔卡蒂奥·布恩迪亚家的常客，而且他们的儿孙也是跟奥雷里亚诺和阿尔卡蒂奥一起长大的伙伴，他们的女儿则是唯一可以来家里与丽贝卡和阿玛兰妲一同绣花的姐妹。\n　…………\n　皮埃特罗·克雷斯皮重新把自动钢琴组装起来。丽贝卡和阿玛兰妲帮他理顺琴弦，听到那颠倒的华尔兹乐曲时跟他一起连连大笑。见他那样可亲又可靠，乌尔苏拉便取消了监视。在他告别的前夜，家里用修复的自动钢琴临时举行了一场舞会，他和丽贝卡联袂表演了一场美妙的现代舞。阿尔卡蒂奥和阿玛兰妲的舞姿舞技也并不逊色。但表演被迫中断，挤在门口围观人群中的庇拉尔·特尔内拉和另外一个女人又撕又咬打了起来，只因后者胆敢妄言年轻的阿尔卡蒂奥长着女人的屁股。将近午夜时分，皮埃特罗·克雷斯皮满怀感情地发表了简短致辞，并许诺会很快回来。丽贝卡一直送他到门口，随即关闭家门，熄灭灯火，她回到自己房间里恸哭起来。那是一种难以安慰的哭泣，持续了好几天，连阿玛兰妲也不明白其中的缘由。她的守口如瓶并不奇怪。她虽然表面热情坦诚，实际秉性孤僻，从不敞开心扉。她已出落成一位亭亭玉立的少女，身材修长结实，但仍旧喜欢坐在那把和她一起到来的小木头摇椅上，那椅子加固过多次，扶手已经不见了。没人留意她到了这个年龄还是喜欢吸吮手指，她一有机会便把自己关在浴室里，并养成了面朝墙壁睡觉的习惯。雨天的下午，她和女友们待在秋海棠长廊里刺绣，每当看到潮湿的土层和蚯蚓在花园里堆起的小丘，她常常会从交谈中走神，怀念的泪水带着咸味涌上舌尖。她一开始哭泣，当年那些被橘汁和大黄压服的秘密嗜好顿时化为无法抑制的渴望爆发。她又开始吃土。第一次几乎是出于好奇，她确信那糟糕的味道将是摆脱诱惑的最佳药方。她果然无法忍受泥土在嘴里的感觉，但她没有放弃，而是受制于不断增强的渴望，渐渐恢复了旧日的胃口，恢复了对原生矿物的喜爱以及原始食物带来的满足。她将一把把泥土藏进口袋，一边传授女友们最繁难的针法，谈论其他不值得自己为之吃下石灰墙皮的男人，一边趁人不注意一点点吃掉，心中涌起既幸福又愤怒的迷乱感觉。这一把把泥土使那唯一值得她自卑自贱的男人不再遥远也更加真切，仿佛从他脚上精巧的漆皮靴在世界另一处所踏的土地传来矿物的味道，她从中品出了他鲜血的重量和温度，这感觉在她口中猛烈烧灼，在她心里留下安慰。一天下午，安帕萝·摩斯科特无缘无故请求参观新家。阿玛兰妲和丽贝卡对这突如其来的到访不明所以，礼貌而生硬地接待了她。她们向她展示扩建后的家宅，请她听自动钢琴的演奏，为她端上橘子水和小饼干。安帕萝给她们上了一课，诸如什么是端庄大方，什么是仪态可亲，什么是举止得体，给在场不过短短一会儿的乌尔苏拉留下了深刻印象。两小时后，谈话渐渐无味，安帕萝趁阿玛兰妲分神的瞬间将一封信塞给丽贝卡。她只来得及看见“可敬的丽贝卡·布恩迪亚小姐”字样，与自动钢琴说明书上的字体同样工整，以同样的绿色墨水写就，使用同样的绮丽措辞。她立刻用指尖将信折起藏进胸衣，望着安帕萝·摩斯科特的眼神中充满无尽感激，还有结下生死之盟的无声承诺。\n　…………\n　她做到了。只是时机不对，因为家里已经失去往日的平静。（她指庇拉尔，这里不重要，为了连贯加上）丽贝卡那般喊叫已经无法保守秘密，阿玛兰妲发现了她的痴恋后开始发烧。她也在为没有回应的爱情而饱受折磨。她把自己关在浴室里，写下一封封狂热的信，以摆脱没有希望的激情带来的折磨，然后把信深藏在衣箱内。乌尔苏拉同时照顾两个病人，几乎忙不过来。她费尽心机长时间询问，也没能问出阿玛兰妲委靡的缘由。最终，她又灵机一动，撬开衣箱，便发现了用玫瑰色丝带系好的信，信内塞满新鲜的百合花瓣，信上泪痕未干，封封都写给皮埃特罗·克雷斯皮，但从未寄出。乌尔苏拉眼含愤怒的泪水，诅咒自己动念购买自动钢琴的那个时刻，并取消了刺绣课程，下令进入没有死人的丧期，直到女儿们死心断念为止。何塞·阿尔卡蒂奥·布恩迪亚已经改变对皮埃特罗·克雷斯皮最初的看法，十分欣赏他对音乐器械的灵活掌握，于是试图干预，却无济于事。庇拉尔·特尔内拉告诉奥雷里亚诺，蕾梅黛丝已经作好结婚的准备，他意识到这个消息会给父母带来新的痛苦。但他还是选择面对现实。何塞·阿尔卡蒂奥·布恩迪亚和乌尔苏拉被郑重其事地请到客厅，漠然听着儿子的宣告。但听到那未婚妻的名字时，何塞·阿尔卡蒂奥·布恩迪亚气红了脸。“爱情是瘟疫！”他咆哮着，“有那么多漂亮又正派的女孩，你偏偏要娶敌人的女儿。”乌尔苏拉却赞成儿子的选择。她坦承自己对摩斯科特家七姐妹的好感，说她们漂亮、能干、端庄又有教养，称赞儿子有眼光。何塞·阿尔卡蒂奥·布恩迪亚面对妻子的热情让了步，但提出一个条件：作为交换，丽贝卡要嫁给皮埃特罗·克雷斯皮。乌尔苏拉等到能腾出时间时，会带阿玛兰妲去省城观光，让她多和外人接触以淡忘自己的失落。丽贝卡听到这个结果，立时恢复了健康，给未婚夫写了一封欢喜万分的信，经父母过目后亲自送到邮局投递。阿玛兰妲假意接受了这一决定，渐渐退了烧，但在心中暗暗发誓，丽贝卡想要结婚除非从她的尸体上跨过去。\n　…………\n　（梅尔基亚德斯死了）\n他们将他葬在为公墓预留的空地中央，筑起一座坟墓，墓碑上铭刻着他们对他的唯一所知：梅尔基亚德斯。他们为他守灵九个夜晚。大家聚在庭院里喝咖啡、讲笑话、玩纸牌，阿玛兰妲趁着这混乱找到一个机会向皮埃特罗·克雷斯皮表白自己的爱情，后者几个星期前刚与丽贝卡正式订下婚约，并且开办了一家乐器和发条玩具店，就在当年阿拉伯人常常流连并用廉价的小玩意儿交换金刚鹦鹉的地方，也就是人们口中的土耳其人大街。意大利人那一头闪亮的鬈发常引得女人们情不自禁地赞叹，他觉得阿玛兰妲不过是个任性的小姑娘，没有把她的话当真。\n　“我有个弟弟，”他对她说，“他很快会来店里给我帮忙。”\n　阿玛兰妲感到受了侮辱，带着刻骨的怨恨告诉皮埃特罗·克雷斯皮，她下定决心要阻止姐姐的婚礼，就算横尸门前也在所不惜。意大利人对如此骇人的威胁大感震惊，忍不住告诉了丽贝卡。于是，因乌尔苏拉的繁忙一再推迟的旅行，在不到一个星期内就安排妥当。\n　阿玛兰妲没有反对，但在与丽贝卡吻别的一刻，在她耳边轻轻说道：\n　“你别做梦了。就算把我赶到天边，我也能想办法让你结不成婚，哪怕要杀了你也不在乎。”\n　乌尔苏拉的离开，以及梅尔基亚德斯无形的存在——他继续悄无声息地在房间里游荡——使家里显得分外空旷。丽贝卡接管了日常家务，印第安女人负责照管面包房。每到傍晚，皮埃特罗·克雷斯皮就在一阵薰衣草的香风中到来，总带上一件玩具做礼物，他的未婚妻则在客厅里接待他，并敞开所有门窗以免引起风言风语。这种谨慎不免显得多余，因为意大利人已充分表明他的正派可靠，他甚至连姑娘的手都没有碰过，尽管她年内就将成为他的妻子。这样的来访很快使家里摆满了神奇的玩具。上了弦就能翩翩起舞的跳舞女郎，八音盒，奔跑的马儿，耍杂技的猴子，敲鼓的小丑，各种令人惊异的机械动物，皮埃特罗·克雷斯皮带来的这些玩具驱散了何塞·阿尔卡蒂奥·布恩迪亚心头悼念梅尔基亚德斯去世的悲痛，他又回到了过去那个钻研炼金术的时期。他生活在满是开膛破肚的动物、大卸八块的机件的天堂里，试图利用钟摆原理设计一套永动系统，使这些玩具趋于完善。\n　…………\n　只有丽贝卡受了阿玛兰妲的威胁一直闷闷不乐。她了解妹妹的性格，了解她的高傲，因她刻毒的怨恨而担惊受怕。她连续几个小时躲在浴室里吸吮手指，竭尽全力抗拒吃土的诱惑。为了摆脱心头的忧虑，她请庇拉尔·特尔内拉为自己推算未来。说了些模棱两可的套话之后，庇拉尔·特尔内拉给出了预言：\n　“只有等你父母入士为安，你才会幸福。”\n　丽贝卡一阵颤抖。她记起好像在梦里，看见还是小女孩的自己走进家门，带着衣箱、小木头摇椅和一个口袋，而她一直不知道口袋里面装的什么。她记起一位秃顶的先生，他身着亚麻衣裳，领口别着一粒金扣，但与金杯国王①【66页①“金杯”(copa)与后文中的“金元”(oro)、“宝剑”(espada)都是西班牙纸牌中的花色，“国王”、“骑士”、“仆侍”分别为每种花色中的第十二、第十一、第十张牌。】毫无相似之处。她记起一位非常年轻美貌的女士，双手温和芬芳，与金元仆侍那双似乎患了风湿病的手相去甚远，那女士曾在她发间簪上鲜花，下午带她在一个绿色街巷的城镇中散步。\n　“我不明白。”她说。\n　庇拉尔·特尔内拉同样困惑。\n　“我也不明白，但牌上就是这么说的。”\n　丽贝卡被这解不开的谜团搅得忧心忡忡，便告诉了何塞·阿尔卡蒂奥·布恩迪亚。他责怪她竟然相信纸牌的预言，自己却在暗中翻遍衣柜和衣箱，挪开家具，掀起床板和地板，四处寻找那个骨殖袋。他想起自从房子扩建以后就再没见过，便偷偷找来那些泥瓦匠，其中一个承认，当时嫌那袋子碍事就把它砌在了夹壁里。他们耳朵贴在墙上四处侦听，听了好几天终于听到了低沉的咯啦咯啦声，于是凿开墙壁，发现骨殖仍完好无损地保存在袋中。当天他们便把骨殖安葬在一个没有墓碑的坟茔里，就在梅尔基亚德斯的坟墓旁。何塞·阿尔卡蒂奥·布恩迪亚回到家，心里卸下了如同对普鲁邓希奥·阿基拉尔的回忆一样的良心重负。经过厨房的时候，他吻了一下丽贝卡的额头。\n　“别胡思乱想了，”他说，“你会幸福的。”\n　…………\n　（奥雷里亚诺和蕾梅黛丝结婚了）\n喧闹的庆典一直持续到星期一早上，其间唯一不幸的人是丽贝卡·布恩迪亚。这本该也是她的喜事。乌尔苏拉已同意在同一天为她举行婚礼，不料皮埃特罗·克雷斯皮星期五接到的一封信带来了他母亲病危的消息。婚礼推迟了。度埃特罗·克雷斯皮接到信后一个小时即起程前往省城，在路上错过了与母亲的相遇，他母亲星期六晚上准时抵达马孔多，并在奥雷里亚诺的婚礼上献唱了本是为自己儿子婚礼准备的悲伤咏叹调。皮埃特罗·克雷斯皮为了及时赶回自己的婚礼，一路跑瘫了五匹马，但当他星期天午夜时分赶到的时候，能做的只剩下打扫喜事的残烛余烬。从未查出究竟是谁写了那封信。在乌尔苏拉的拷问下，阿玛兰妲气得哭了起来，对着木匠们尚未拆除的祭坛赌咒发誓以证明自己的无辜。\n　…………\n　从那以后，神甫担心自己的信念会动摇，就不再去探望他，全心投入教堂的建造以加快进程。（他指何塞阿尔卡迪奥布恩迪亚，不重要）丽贝卡重新燃起了希望。她的未来全系于教堂的竣工，因为有个星期天尼卡诺尔神甫来家里吃午饭时，全家人都在席间谈论教堂建成后举行的宗教仪式将是何等庄重堂皇。“最幸运的人是丽贝卡。”阿玛兰妲说。丽贝卡没有听懂她的意思，于是她带着天真的笑容解释：\n　“因为你的婚礼将是教堂落成后举行的第一个仪式。”\n　丽贝卡试图抢先作出评论。以现在的施工速度来看，教堂竣工起码要等十年。但尼卡诺尔神甫看法不同：鉴于信徒们捐赠日益慷慨，完全可以作出更乐观的估计。尽管丽贝卡暗暗生气，连饭都没有吃完，乌尔苏拉还是赞同阿玛兰妲的主意，并捐出一笔可观的款项以加速施工。尼卡诺尔神甫认为再有一笔相同数额的捐赠，教堂就能在三年内竣工。从此，丽贝卡不再和阿玛兰妲说话，确信她的用心并不像表面那样单纯无辜。“我已经手下留情了，”在当晚的激烈争吵中阿玛兰妲回答道，“这三年我都用不着杀你了。”丽贝卡接受了挑战。\n　皮埃特罗·克雷斯皮得知婚礼再次推迟，失望之极，但丽贝卡向他证明了自己的忠贞不渝。“等你准备好，咱们就私奔。”她对他说。然而皮埃特罗·克雷斯皮并不是敢于冒险的人，他不像未婚妻那样性情冲动，视对承诺的尊重为不容挥霍的资本。于是丽贝卡采取了更大胆的举措。一阵神秘的风吹灭了客厅里的灯，乌尔苏拉随即发现这对情侣在黑暗中接吻。皮埃特罗·克雷斯皮窘迫地向她解释说这要归咎于新式煤油灯的质量问题，甚至帮她在客厅里安上了更可靠的照明设施。但又一次不知是灯油出了问题还是灯芯被阻断，乌尔苏拉发现丽贝卡坐在未婚夫的腿上。她不再接受任何借口。她把面包房托付给印第安女人比西塔西翁打理，亲自坐到摇椅上监视情侣的相会，免得那些在自己的青春年代就已过时的花招得逞。“可怜的妈妈，”丽贝卡看着乌尔苏拉在一旁打着哈欠昏昏欲睡的样子，又好气又好笑，“到死也要在这把摇椅上受罪。”皮埃特罗·克雷斯皮天天去察看施工，在过了三个月受监视的爱情生活后终于厌烦了缓慢的工程进度，决定自己出钱给尼卡诺尔神甫补足完工所需的资金。阿玛兰妲并没有慌张。她每天和女友们在长廊里绣花或做编织活计，一边聊天一边酝酿新的计策。她自以为最有效的一招，即取走丽贝卡将嫁衣收入卧室衣柜之前就放好的樟脑丸，却因为估算失误落了空。她是在离教堂完工不到两个月时采取的行动，但随着婚期临近丽贝卡迫不及待地要试穿嫁衣，比阿玛兰妲预计的时间提前了许多。丽贝卡打开衣柜，依次取下包装纸和护衬布，发现从锦缎礼服、织绣纱巾直到橘花头冠都被蛾子蛀成了粉末。她确信当初在包装里放过两把樟脑丸，但这一悲剧似乎纯粹出于偶然，她不敢责怪到阿玛兰妲身上。离婚礼已不到一个月，安帕萝·摩斯科特竟慨然答允在一个星期内为她做出一身新嫁衣。那个阴雨绵绵的中午，当安帕萝抱着一堆泡沫般的织物走进家门让丽贝卡最后一次试衣时，阿玛兰妲几乎要昏厥过去。她瞬间失声，一道冷汗沿脊背下流。漫长的数月里，她一直在恐惧的战栗中等待这一刻的到来。她深信，如果最终找不到阻挠丽贝卡婚礼的办法，到了一切手段用尽的最后时刻，她不会缺乏下毒的胆量。那天下午，安帕萝以无穷无尽的耐心在丽贝卡周身上下别了千万枚别针，丽贝卡则裹在那甲胄般的缎料里热得透不过气来，与此同时，阿玛兰妲多次乱了针脚，扎了手指，但仍以可怕的冷静作出决定：日期定在婚礼前最后一个星期五，方式是在咖啡中加一剂鸦片酊。\n　不料一个更大的障碍突然出现，并且无法挽救，迫使婚礼再次无限期延迟。婚期前一个星期，小蕾梅黛丝半夜醒来，内脏打嗝般撕裂，火热的汁液爆涌浸透全身。三天后她被自己的血毒死，一对双胞胎也横死腹中。阿玛兰妲受到良心的谴责。她曾切切祈求上帝，希望发生某种可怕的事情免得自己向丽贝卡下毒，因此对蕾梅黛丝的死怀有负罪感。那并不是她日夜祈祷所期盼的障碍。蕾梅黛丝为这个家带来了欢快气息。她和丈夫在作坊旁收拾出一间小屋，用刚刚告别的童年时代的娃娃和玩具装饰一新。她欢快的活力溢出房间四壁，像生机盎然的和风吹过秋海棠长廊。她从清晨便开始唱歌。她是唯一敢在丽贝卡与阿玛兰妲争吵时从中斡旋的人。\n　…………\n　乌尔苏拉吩咐关闭门窗守丧，如非绝对必要不许任何人出入。她还要求一年之内不得高声说话，并将一张蕾梅黛丝的银版照片摆在停放遗体守灵的地方，照片上斜系着一根黑色饰带，前面点起一盏长明灯。此后子孙们一直保持灯火不熄，他们面对着照片上这个身着百褶裙、脚踏白色小靴子、头系蝉翼纱蝴蝶结的小女孩却不免困惑，难以将其与曾祖母的标准像联系起来。阿玛兰妲担负起照顾奥雷里亚诺·何塞的职责。她当作儿子抚养的这个孩子，将会分担她的孤独，缓解她的内疚——由于她向上帝疯狂祈求，鸦片酊误落在蕾梅黛丝的咖啡里。皮埃特罗·克雷斯皮戴着系了黑纱的帽子轻手轻脚走进家门，与一袭黑衣长袖及手、心中仿佛暗暗淌血的丽贝卡默默相会。此时此刻连重议婚期的念头也会被视为大不敬，恋人关系就此永远停滞不前，沦为无人再去理会的倦怠爱情，仿佛昔日为了亲吻而熄灭灯火的情侣已被抛弃，屈从于死神的淫威。方向迷失，希望破灭，丽贝卡又开始吃土。\n　居丧多日后十字绣活动已经恢复，一天下午两点，酷热的死寂中突然有人推开大门。房柱震颤不已，长廊里刺绣的阿玛兰妲及其女友，卧室里吸吮手指的丽贝卡，厨房里的乌尔苏拉，作坊里的奥雷里亚诺，甚至栗树下孤零零的何塞·阿尔卡蒂奥·布恩迪亚，都感到房子在大地的震动中摇摇欲坠。来人是一个身材过人的大汉。他粗壮的胸背几乎挤不进门。他野牛似的脖子上挂着救难圣母像，双臂和胸前覆满神秘的刺青，右手腕上紧紧缠着“十字架婴孩”①【注①“十字架婴孩”(ni?os-en-cruz)，带有浓厚巫术色彩的护身符，未必与圣婴(el Ni?o)有关，据说贴身携带并以自身鲜血饲喂后能令主人力大无穷，刀枪不入。】护符铜手链。他的身体经风吹日晒变成棕褐色，短发竖起好像骡子的鬃毛，下颌坚毅，眼神悲伤。他的腰带比马肚带宽两倍，靴子带护腿和马刺，靴跟钉了铁掌，走到哪里都给人以地震般的战栗感。他拎着几个破旧的褡裢穿过客厅和起居室，像一阵风暴般出现在秋海棠长廊，惊得阿玛兰妲和女友们一动不动，绣花针停在空中。“嗨。”他用疲倦的声音说道，随手将褡裢往缝纫桌上一丢，径直走向家中深处。“嗨。”他向丽贝卡打了个招呼，她看着他从自己卧室门前经过，吓得呆了。\n(后面的事都知道了……在丽贝卡里面)\n　…………\n　三天后，他们在五点钟的弥撒上结为夫妇（丽贝卡与“前面回来的人”）。何塞·阿尔卡蒂奥前一天去了皮埃特罗·克雷斯皮的商店，看见他正在给学生上古弦琴课，但并没有把他叫到一边回避学生。“我要和丽贝卡结婚了。”他说。皮埃特罗·克雷斯皮顿时脸色煞白，把琴交给学生，宣布课程结束。等到堆满乐器和上弦玩具的厅里只剩下他们两人，皮埃特罗·克雷斯皮说：\n　“她是您的妹妹。”\n　“我无所谓。”何塞·阿尔卡蒂奥回答。\n　皮埃特罗·克雷斯皮用散发出薰衣草气味的手帕擦了擦额头。\n　“这违背天理，”他解释道，“另外，法律也不允许。”\n　何塞·阿尔卡蒂奥失去了耐性，倒不是皮埃特罗·克雷斯皮所讲的道理，而是他那副苍白的脸色更让人恼火。\n　“去他的天理，”他说，“我来是为了告诉你，不要再费心去问丽贝卡什么。”\n　但当看到皮埃特罗·克雷斯皮眼眶湿润，他粗暴的态度软了下来。\n　“好吧，”他换了一副腔调，“如果您真喜欢我们家，那还有阿玛兰妲呢。”\n　尼卡诺尔神甫在星期天的讲道中申明何塞·阿尔卡蒂奥和丽贝卡不是兄妹。乌尔苏拉视此事为不可想象的失礼，永远不肯原谅。当他们从教堂回来的时候，她禁止这对新人再迈进家门。对她来说，他们就等于死了一样。因此他们到公墓对面租了一间小屋，屋里唯一的家具是何塞·阿尔卡蒂奥的吊床。新婚之夜一只蝎子钻进拖鞋蜇了丽贝卡的脚，她的舌头为此都麻痹了，但这并不妨碍他们度过一个惊世骇俗的蜜月。邻居们因惊醒整个街区的叫声而恐慌——每夜八次，连午睡时段也有三次——祈祷那种肆无忌惮的激情不要侵扰死人的安眠。\n　奥雷里亚诺是唯一关心他们的人。他给他们买了一些家具，并送钱过去，直到何塞·阿尔卡蒂奥恢复常态，开始耕种与家中院子相邻的无主土地。阿玛兰妲却永远无法摆脱对丽贝卡的怨恨，尽管生活为她带来了超出梦想的满足：乌尔苏拉不知如何洗刷耻辱，她主动提出让皮埃特罗·克雷斯皮每个星期二仍来家中共进午餐，后者平和而不失尊严地战胜了挫折。出于对这一家人的尊敬，他在帽子上仍然系着黑纱，并很乐意亲近乌尔苏拉，为她带来异国礼物：葡萄牙沙丁鱼，土耳其玫瑰果酱，还有一次是一条精美的马尼拉大披巾。阿玛兰妲总是亲切殷勤地款待他。她揣测他的喜好，为他扯掉衬衫袖口的脱线，在他过生日时送上一打绣着他姓名缩写的手帕。每个星期二吃过午饭，她在长廊里绣花，他陪伴一旁，其乐融融。对皮埃特罗·克雷斯皮而言，这个他一向当小女孩对待的姑娘不啻全新的发现。她虽然外表缺乏魅力，却拥有罕见的感受力，能体会世间万物的美好，还蕴含一种不为人知的柔情。一个星期二，发生了众人意料中早晚会发生的事：皮埃特罗·克雷斯皮向她求婚。她没有停下手里的活计，等耳边火热的红潮退去才开口，镇静的声音显出老成持重。\n　“当然可以，克雷斯皮，”她回答，“但要等了解更深的时候。太着急总是不好。”\n　…………\n　阿玛兰妲和皮埃特罗·克雷斯皮得到了乌尔苏拉的信任，友情日深，这一回她认为没有必要再监视他们的见面。这是一段暮色恋情。意大利人每天傍晚登门，扣眼里别着一枝栀子花，把彼特拉克的十四行诗译给阿玛兰妲听。他们待在弥漫着牛至和玫瑰香气的长廊里，他朗读，而她编织袖口花边，对战争中的种种动乱和噩耗都毫不关心，直到不堪蚊子的烦扰才躲进客厅。阿玛兰妲的善解人意，以及不失分寸又包容一切的温柔，织起一幅无形的网罗把男友围在其中，他不得不用自己未戴戒指的苍白手指生生拨开，才能在八点时告辞离去。他们用皮埃特罗·克雷斯皮收到的意大利明信片做成一本精美的图册，里面的图画都是幽静园林中的恋人，配以中箭的红心和鸽子衔起的金色缎带。“我知道佛罗伦萨的这个公园，”皮埃特罗·克雷斯皮边浏览明信片边说，“你一伸手，鸽子就落下来吃食。”有时看着一幅威尼斯的水彩画，思乡之情使运河中污泥和腐败水产的气味升华成了花朵的幽香。阿玛兰妲一时叹息，一时欢笑，幻想着第二故乡，在那里容貌俊美的男男女女说着孩童的语言，古老的城市昔日荣光不再，只剩下出没于瓦砾间的猫儿。皮埃特罗·克雷斯皮曾经穿过大洋上下寻索，曾经在丽贝卡冲动的纠缠中错生激情，最终找到了真爱。爱情的幸福带来了生意的兴隆。他的商店那时几乎占据了整个街区，堪称幻想的温床，里面有能以钟琴报时的佛罗伦萨钟楼仿制品，有索伦托的八音盒，有一开盖便奏起五音曲的中国香粉盒，以及一切所能想象的乐器和一切所能构想的上弦装置。他的弟弟布鲁诺·克雷斯皮负责商店的业务，因为他自己单单照管音乐学校就忙不过来。多亏了他那五光十色的玩物博览，土耳其人大街变成了一方和谐的绿洲，令人淡忘了阿尔卡蒂奥的种种专横和遥远的战争梦魇。乌尔苏拉恢复星期天弥撒的时候，皮埃特罗·克雷斯皮捐赠给教堂一架德国簧风琴，组织了一个儿童唱诗班，教他们唱格列高利圣诗，为尼卡诺尔神甫沉郁的仪式平添了几许亮丽色彩。没有人怀疑阿玛兰妲会是一位幸福的妻子。他们不刻意推进恋情，任凭心中的感情自然发展，最后只差定下婚期。他们没遇到什么阻碍。乌尔苏拉为当初反复推迟丽贝卡的婚期这一失误暗中自责不已，不愿重蹈覆辙增添懊悔。战争的戕害，奥雷里亚诺的远走，阿尔卡蒂奥的暴行，以及何塞·阿尔卡蒂奥和丽贝卡的被逐，都令为蕾梅黛丝的服丧退居其次，不再那么严格。婚期在望，皮埃特罗·克雷斯皮暗示将收养奥雷里亚诺·何塞为长子，他一直待他以父亲般的亲切。一切都预示着阿玛兰妲将一帆风顺地走向幸福。然而与丽贝卡相反，她丝毫不显急切。一如染桌布、织绦带、绣孔雀那样，她耐心等待着皮埃特罗·克雷斯皮向内心的煎熬屈服。她盼望的时刻与十月不祥的阴雨一同到来。皮埃特罗·克雷斯皮拿过她膝上的绣筐，双手紧握她的手。“我不能再等了，”他对她说，“我们下个月就结婚。”阿玛兰妲触碰到他冰冷的双手时没有颤抖。她像只抓不住的小动物似的缩回手去，继续自己的活计。\n　“别天真了，克雷斯皮，”她微笑着，“我死也不会和你结婚的。”\n　皮埃特罗·克雷斯皮瞬时崩溃，他不顾羞耻地哭泣，绝望得几乎扭断手指，但无法令她改变主意。“别浪费时间了，”这便是阿玛兰妲的全部回应，“如果你真那么爱我，就请不要再进这个家。”乌尔苏拉觉得自己羞愧得要发疯。皮埃特罗·克雷斯皮百般哀求，卑躬屈膝到了令人难以置信的程度。他在乌尔苏拉的怀里哭了一个下午，而她恨不得出卖自己的灵魂换取对他的安慰。雨夜里常可见到他的身影，擎着一把绸伞在屋子附近游荡，期望看到阿玛兰妲卧室里的一点儿灯光。他的衣着打扮从未像那段时间那样考究。他那受难君王一般的庄严头颅，显出一种奇异的伟大风姿。他去哀求阿玛兰妲的女友，就是那些和她一同在长廊里刺绣的女郎，请她们从中说项。他抛下生意，整日待在店后写下狂热的短笺，连同花朵薄瓣与蝴蝶标本寄给阿玛兰妲，又都被她原封不动地退了回来。他关在屋里无休无止地弹古弦琴。一天晚上，他唱了起来。马孔多在睡梦中惊醒，心神俱醉，那琴声不似这个世界所有，那饱含爱意的歌声也不会再现人间。一时间皮埃特罗·克雷斯皮看见镇上所有的灯火都亮了，唯独阿玛兰妲的窗前依旧黑暗。十一月二日，亡灵节，他弟弟打开店门，发现所有的灯都亮着，所有的八音盒都在奏乐，所有的钟表都停在一个永恒的时刻。在这纷乱的合奏中，皮埃特罗·克雷斯皮伏在店后的写字台上，双腕用剃刀割破，双手浸没在一盆安息香水里。\n　乌尔苏拉决定在家中为他守灵。尼卡诺尔神甫反对举行宗教仪式，也不同意将他葬在公墓里。乌尔苏拉顶撞了他。“尽管您和我都理解不了，但这个男人是一位圣徒，”她说，“所以我要违背您的意思，把他安葬，就葬在梅尔基亚德斯的墓旁边。”她得到了整个镇子的支持，葬礼极其隆重。阿玛兰妲没有离开卧室，她在床上听见乌尔苏拉的哭声，涌进家中的人群的脚步声和低语声，然后是一片深沉的寂静，带有被践踏花朵的气味。很长一段时间，每到傍晚她依然会闻到皮埃特罗·克雷斯皮身上的薰衣草余香，但她还能克制住不至于陷入谵妄。乌尔苏拉抛弃了她。那天下午当阿玛兰妲走进厨房，把手伸到炉子的炭火中，她甚至没有抬头表示同情。阿玛兰妲在剧痛中失去了痛感，只闻到自己皮肉烧灼的焦味。这是治疗悔恨的一剂猛药。很多天来，她在家里的时候都把手浸在一个盛着蛋清的碗里。当烧伤痊愈时，那些蛋清似乎也使她心中的创伤愈合。这场悲剧为她留下的唯一外在痕迹便是裹在伤手上的黑纱，她到死也没摘下。\n阿玛兰妲与赫里内勒多·马尔克斯 　（补充：赫里内勒多·马尔克斯是跟随家族第二代奥雷里亚诺·布恩迪亚一起打仗的朋友） 赫里内勒多·马尔克斯上校不仅是奥雷里亚诺·布恩迪亚上校最信任的人，还被乌尔苏拉当作家中的一员。他体质虚弱，性格腼腆，生来文质彬彬，却更适合打仗，不适合从政，他的政治顾问们毫不费力就将他绕进了理论迷宫。不过他还是在马孔多实现了奥雷里亚诺上校梦寐以求的乡土平安，后者希望可以在此安心打造小金鱼以终老。他住在父母家里，但每星期总有两三次到乌尔苏拉这里吃午饭。他开始教奥雷里亚诺·何塞使用火器，对他提前进行军事训练，还在征得乌尔苏拉的同意后带他去军营生活了几个月，使他成长为男子汉。多年以前，赫里内勒多·马尔克斯几乎还是个孩子，就表白过对阿玛兰妲的爱意。她那时正沉浸在对皮埃特罗·克雷斯皮的单相思中，因而还嘲笑过他。赫里内勒多·马尔克斯在等待。有一回他从狱中给阿玛兰妲捎来一张小纸条，请她在一打细棉布手帕上绣上自己父亲的名字缩写，还捎去了工钱。一个星期后，阿玛兰妲去监狱给他送那一打绣好的手帕，钱也还了他，两人谈了几个小时的往事。“等我出去就和你结婚。”赫里内勒多·马尔克斯在告别时说道。阿玛兰妲笑了，但教孩子们读写的时候仍然想着他，希望为他寻回年轻时对皮埃特罗·克雷斯皮燃起的激情。每个星期六是探监的日子，她都去赫里内勒多·马尔克斯父母家，陪他们一同去监狱。其中一个星期六，乌尔苏拉看见她在厨房里等蛋糕出炉，要挑出最好的裹在专为此绣出的餐巾里。\n　“嫁给他吧，”乌尔苏拉对她说，“你很难再找到像他这样的男人。”\n　阿玛兰妲装出生气的样子。\n　“我不需要追着男人嫁，”她回答，“我给赫里内勒多带蛋糕，是觉得他可怜，迟早会被枪毙。’ 她本是随口一说，却赶上政府公开威胁，如果叛军不交出里奥阿查就要枪毙赫里内勒多·马尔克斯上校。探监被取消。阿玛兰妲关起门来痛哭，与当初蕾梅黛丝死时相仿的罪疚感折磨着她，仿佛是她出于无心的话语又一次引来死亡。母亲安慰她，让她相信奥雷里亚诺·布恩迪亚上校一定会有所举动制止枪决，并许诺一等战争结束就亲自把赫里内勒多·马尔克斯给她带来。结果她提前兑现了承诺。当赫里内勒多·马尔克斯以军政首领的显赫身份再次登门时，她像对待儿子一般接待他，百般恭维以取悦他，全心祈求以唤起他迎娶阿玛兰妲的初衷。她的祈求看来灵验了。每次吃过午饭，赫里内勒多·马尔克斯上校都会留下，在秋海棠长廊里和阿玛兰妲下跳棋。乌尔苏拉给他们送上牛奶咖啡和蛋糕，并照顾好孩子，免得他们被打扰。阿玛兰妲在奋力重燃心中已被遗忘的青春激情的余烬。她无法忍受心头的焦虑，期盼着共进午餐的日子，期盼着下跳棋的午后。有这位勇士的陪伴时间流逝得飞快，他的名字带有怀旧色彩，他的手指移动棋子时的轻微颤抖不易觉察。但那天赫里内勒多·马尔克斯上校再次提出结婚的请求时，她拒绝了。\n　“我谁也不嫁，”她告诉他，“尤其不嫁给你。你太爱奥雷里亚诺才想跟我结婚，因为你没法跟他结婚。”\n　赫里内勒多·马尔克斯上校是个有耐性的人。“我会再提出来，”他说，“我迟早要说服你。”他继续登门造访。阿玛兰妲关在卧室里强忍悲声，捂住耳朵，免得听见那位追求者向乌尔苏拉谈论最新战况的声音。尽管心里无比渴望，她仍能克制着不出去见面。\n　…………\n阿玛兰妲与奥雷里亚诺·何塞 　（奥雷里亚诺·何塞是家族第二代奥雷里亚诺和庇拉尔的儿子） 阿玛兰妲坐在藤摇椅上，将手中活计搁在膝头，看着奥雷里亚诺·何塞往下巴上涂满泡沫，在皮条上刮着剃刀，准备平生第一次刮胡子。他试着把上唇棕黄的茸毛理成髭须时不慎割破皮肤，粉刺流出血来，而到最后他也没理成个样子，但这番艰苦的努力却让阿玛兰妲觉得自己从这时起便开始老了。\n　“你和你这个年龄时的奥雷里亚诺一模一样，”她说，“你已经是大人了。”\n　其实他早就是了，这可以追溯到已然遥远的一天，阿玛兰妲仍把他当作孩子，在浴室里当着他的面脱下衣服。自从庇拉尔·特尔内拉把孩子托付给她抚养，她一向这样做，已经习惯了。他第一次看到的时候，唯一注意到的是乳房间的深沟。他天真地问这是怎么了，阿玛兰妲装作用指尖在胸前掏挖的样子回答：“挖呀挖呀挖呀就成这样了。”后来，当她从皮埃特罗·克雷斯皮的自杀事件中恢复，又和奥雷里亚诺·何塞一起洗澡，他已经不再注意那深沟，而注目于那紫色乳头和丰硕双峰，感到一阵奇怪的战栗。他继续观察，一点一点发现她隐秘处的神奇，窥看时感到皮肤上汗毛倒竖，就像她的皮肤碰到水时一样。很小的时候他就习惯天亮前离开自己的吊床睡到阿玛兰妲的床上，觉得和她在一起就不会惧怕黑暗。然而从意识到她的裸体那天起，驱使他钻进她蚊帐的不再是对黑暗的恐惧，而是对天明时感受她温暖呼吸的渴望。一天凌晨，就在阿玛兰妲拒绝赫里内勒多·马尔克斯上校的那段日子，奥雷里亚诺·何塞在几近窒息中惊醒，感觉她的手指像滚烫的虫子在焦灼地向他的腹部蠕动。他装作熟睡未醒，调整姿势为她除去一切障碍，随即感到那只未缠黑纱的手宛如失明的软体动物在他饥渴的水藻间潜游。两人都装作不知道双方心知肚明的事实，都装作不知道对方已知情，自那天晚上起被一种不容侵犯的默契紧紧联结在一处。奥雷里亚诺·何塞不听到客厅里时钟午夜报时的华尔兹就无法安眠，而那位容颜开始枯萎的盛年处女没等到梦游人钻进蚊帐也一刻不得安宁。她亲手将他抚养大，未曾想到他有朝一日会成为宽慰自己孤独的良药。他们不仅赤身露体睡在一起，彼此爱抚到精疲力竭，还在家中各个角落互相追逐，随时随刻关在卧室里，沉浸于持久的兴奋中。他们差点儿被乌尔苏拉发现，那天下午她走进谷仓，正撞见他们准备接吻。“你很爱你姑妈？”她毫不知情地问奥雷里亚诺·何塞。他回答说是。“你做得对。”乌尔苏拉评判道，称好做面包的面粉就回了厨房。这一幕让阿玛兰妲从狂热中惊醒。她意识到自己已经走得太远，不是在和孩子玩亲嘴游戏，而是在挑动人过中年危险无望的情火，便决然断绝了关系。奥雷里亚诺·何塞那时快要完成军训，最终接受了现实，搬到军营去睡。每个星期六他都和士兵们去卡塔利诺的店里。他突如其来的孤独，早熟的青春，都在散发着残花味道的女人们身上得到了慰藉。他在黑暗中展开幻想，竭力将她们想象成阿玛兰妲。\n　…………\n　奥雷里亚诺·何塞从尼加拉瓜联邦派军队里开了小差，跑到一艘德国船上当水手，最后出现在家中的厨房里。他壮实如马，肤色黝黑，头发浓密，像个印第安人。他怀着秘密的目的回来，一心要和阿玛兰妲结婚。\n　阿玛兰妲见他进来，没等他开口，便明白了他回来的原因。在饭桌上，他们不敢对视。但两个星期后，他当着乌尔苏拉的面盯着她的双眼说：“我一直在想你。”阿玛兰妲躲着他，竭力避免碰面的机会，尽量不与美人儿蕾梅黛丝分开。那天当侄子问她手上的黑纱要戴到什么时候，她脸红了，并因自己脸红而气恼，因为她觉得那问题在影射她的童贞。自从他回来后，她就闩上了卧室的门，但许多个夜晚过去，听着隔壁房间他那平稳的鼾声，她放松了警惕。在他归来两个月后的一天凌晨，她察觉到他进了卧室。那一刻，她并没有像预想的那样逃走或叫喊，心头反而涌上一阵如释重负的轻松。她感觉到他钻进蚊帐，就像他孩提时代常做的那样，就像他一直以来所做的那样。她意识到他寸丝不挂，不禁冷汗直流，牙齿咯咯打战。“你走，”她低声道，惊得喘不过气来，“不走我就喊了。”但奥雷里亚诺·何塞知道此刻该做些什么，他已经不再是怕黑的孩子，而是出自军营的猛兽。自那天晚上起，没有结果的无声战斗又开始了，每每持续到黎明。“我是你姑妈，”精疲力竭的阿玛兰妲低声道，“差不多就等于你母亲，这不光因为年纪，我还把你养大，就差没给你喂过奶。”奥雷里亚诺·何塞黎明时离开，第二天凌晨又回来，每次发现房门并未闩上就愈加兴奋。他没有一刻不想她。在那些被攻陷村镇的阴暗卧室里，特别是在那些最下贱的地方，找到她的影子；在伤员绷带上干涸血迹的味道中，觅见她的身形；在致命危险所激发的恐惧中，随时随地与她相遇。他曾经从她身边逃开，试图在记忆中将她抹去，为此不仅远走他方，还表现出被战友们归为莽撞的凶悍冒进。他越是在战争的粪坑里摔打她的形象，战争本身就越像阿玛兰妲。他就这样在流亡中忍受煎熬，寻求以自己的死亡来消灭她，直到听见有人讲起那个古老的故事。故事主人公和既是自己姑妈又是自己表姐的女人结婚，结果生出的儿子成了自己的祖父。\n　“一个人能娶自己的姑妈吗？”他惊异地问。\n　“不光可以娶姑妈，”一个士兵回答，“我们现在跟教士打这场仗，就是为了让人连亲娘都能娶。” 十五天后他开了小差。他发现阿玛兰妲比记忆中更憔悴，也更忧伤、更端庄；她岁月的航船正在绕过盛年的最后一个岬角，但在卧室的幽暗中她却显出从未有过的狂热，激烈的反抗也从未显得这样富于挑战。“你是头野兽。”受他追逼的阿玛兰妲说，“不能对一个可怜的姑妈干这种事，除非有教皇的特许。”奥雷里亚诺·何塞答应去罗马，答应膝行整个欧洲去亲吻教皇的鞋子，只要她肯放下悬着的吊桥。\n　“不光是这个，”阿玛兰妲反驳道，“会生出猪尾巴孩子的。”\n　奥雷里亚诺·何塞对一切道理都充耳不闻。\n　“就算生出犰狳也不要紧。”他恳求道。\n　一天凌晨，他再也无法压抑欲望和忍受痛苦，便去了卡塔利诺的店里。他找到一个乳房干瘪、亲切又廉价的女人，暂时平息了欲火。他试图对阿玛兰妲采取蔑视的态度，见到她在长廊里做缝纫活计，已经能将手摇式缝纫机应用自如时，一句话都不对她说。阿玛兰妲感觉卸去了重担，却不明白自己为什么又想起了赫里内勒多·马尔克斯上校，为什么怀念下跳棋的午后，甚至渴望他成为卧室中的情人。奥雷里亚诺·何塞还不知道自己已丧失多少领地，一天晚上他无法再忍受伪装的漠然，又回到阿玛兰妲的房间。她以无可动摇的决心拒绝了他，从此永远闩上了卧室的房门。\n　…………\n　“要出大事，”乌尔苏拉对奥雷里亚诺·何塞说，“下午六点以后不要上街。”这些劝告都归于徒然。奥雷里亚诺·何塞和当年的阿尔卡蒂奥一样，已经脱离她的怀抱。他回到家里，仿佛就可以不再为日常需要操心，这在他身上唤醒了伯父何塞·阿尔卡蒂奥那种放浪懒散的习性。他对阿玛兰妲的激情消逝得无影无踪。他四处游荡，打打台球，拈花惹草排解孤独，翻出各个角落里乌尔苏拉藏起又忘记的钱财。到后来他只为换衣服回家。“都一个样。”乌尔苏拉哀叹道，“一开始好好的，又听话又体面连只苍蝇都舍不得打，结果刚长出胡子就都变坏了。”\n阿玛兰妲与赫里内勒多·马尔克斯② 　赫里内勒多·马尔克斯上校第一个感觉到战争的虚无。身为马孔多的军政首领，他每星期两次与奥雷里亚诺·布恩迪亚上校互通电报。起初，这种通话决定着一场血肉战争的进程，那清晰的局势让他们任何时刻都能确认所处位置并预见未来走向。奥雷里亚诺·布恩迪亚上校虽然从未与人推心置腹，即使对最亲近的朋友也不例外，但那时尚保持着亲切的口吻，能让线路另一端的人辨认出来。很多次他都延长谈话超出预计，扯开话题拉起家常来。然而随着战事吃紧战火绵延，他的形象渐渐黯淡，消逝在一个虚幻的世界。代表他声音的点横越来越遥远模糊，汇聚组合而成的词语逐渐失去意义。赫里内勒多·马尔克斯上校只是倾听，心中却感惶惑，觉得仿佛在和另一个世界的陌生人通电。\n　“明白，奥雷里亚诺，”他总是按下发报键这样作结，“自由党万岁！”\n　他最终失去了与战争的一切关联。曾几何时一段真实的经历，一股青春年代不可抗拒的激情，如今对他而言已成为遥远的注脚：虚无而己。他在阿玛兰妲的缝纫间里找到了唯一的慰藉。他每天下午都去看她。他喜欢看着她的双手为细麻布上褶，美人儿蕾梅黛丝则在一旁摇着缝纫机的摇柄。他们就这样静静地度过几个小时，享受彼此的陪伴。但当阿玛兰妲因他衷情不改而暗自欣喜的时候，他却猜不透她那无法捉摸的秘密思绪。刚听到他归来的消息，阿玛兰妲心中就无比焦灼。但当看见他混在奥雷里亚诺·布恩迪亚上校的卫队中进门，看见他被严酷的流亡生活折磨得脱了形，因岁月流逝和遭人遗忘而愈显衰老，因汗水和尘土而污秽不堪，左臂悬着绷带模样丑陋，甚至还闻到他散发出牲畜的气味，她险些因幻灭而晕倒。“上帝啊，”她想，“这可不是我盼的那个人。”但第二天他再次登门时，已经剃须沐浴，髭髯散发出薰衣草的香气，臂上染血的绷带也不见了。他给她带来一本散发着珍珠光泽的精装祈祷书。\n　“男人真是奇怪，”她这样说，因为想不出别的话来，“反对教士打了一辈子仗，到头来还送人祈祷书。”\n　从那以后，即使是战事最激烈的时日，他仍然每天下午来看她。有很多次美人儿蕾梅黛丝不在，他就负责转动缝纫机的摇柄。阿玛兰妲面对这个男人表现出的恒心、忠诚和温顺不知所措——他虽然大权在握，但总是将所有武器留在客厅，寸铁不带地走进缝纫间。四年间他多次求爱，她总能找到办法拒绝却不伤害他，因为她虽然不再爱他，却也离不开他。美人儿蕾梅黛丝似乎对一切都无动于衷，且被认为智力发育迟缓，却为这痴情感动，自愿帮赫里内勒多·马尔克斯上校说项。阿玛兰妲突然间发现，自己一手抚养成人的小女孩刚刚步入花季，就已出落成马孔多有史以来最美丽的女子。她感到当年对丽贝卡的那种仇怨在心中苏醒，于是祈求上帝不要让自己走上极端盼望她死去，同时将她赶出了缝纫间。就在这个时期，赫里内勒多·马尔克斯上校开始厌倦战争。他对阿玛兰妲百般劝说，表露出深沉蕴藉的无限柔情，甚至不惜为她牺牲自己用锦绣年华换来的荣光，但却没能说服她。八月的一个下午，阿玛兰妲在彻底拒绝了这位坚毅的追求者后，再也无法忍受执拗性情的重压，锁在房间里为自己孤独到死的命运痛哭起来。\n　“你我都忘掉对方吧，”她对他说，“我们已经老得不适合谈这种事了。”\n　那天下午赫里内勒多·马尔克斯上校收到了奥雷里亚诺·布恩迪亚上校的电报。那是一次例行公事的谈话，没有为胶着的战局带来任何突破。谈话即将结束时，赫里内勒多·马尔克斯上校望着荒凉的街道、巴旦杏树上凝结的水珠，感觉自己在孤独中迷失了。\n　“奥雷里亚诺，”他悲伤地敲下发报键，“马孔多在下雨。”\n　线路上一阵长久的沉默。忽然，机器上跳出奥雷里亚诺·布恩迪亚上校冷漠的电码。\n　“别犯傻了，赫里内勒多，”电码如是说道，“八月下雨很正常。”\n　…………\n　开始的时候，赫里内勒多·马尔克斯上校每到傍晚都来拜访，两人坐在大门口追忆过往。但阿玛兰妲无法忍受这个疲累的男人勾起自己的回忆，他的秃顶正将他引向未老先衰的深渊。于是她无理地令他处处难堪，终于他只在特殊情况下才登门，最后因瘫痪而彻底消失。\n　…………\n　赫里内勒多·马尔克斯上校尽管瘫痪在摇椅上，但在一段时期内的确是唯一能够联络到起义军旧部的人物。自从尼兰迪亚停战协定签订以来，奥雷里亚诺·布恩迪亚上校寄身于打造小金鱼的作坊，他却与直到战败仍忠心耿耿的部下保持着联系。他和他们一起打着一场屈辱的日常战争，其中充满恳求与申请：“请您明天再来”，“就快了”，“我们正在认真研究您的问题”；打着一场彻底失败的战争，败给了那些“您忠实恭顺的仆人”，他们应该签发但从未签发养老抚恤金。另一场血腥的战争延续了二十年，却不曾像这场无限拖延、日日消磨的战争带给他们如此多伤害。赫里内勒多·马尔克斯上校曾躲过三次暗杀。五次受伤大难不死，身经百战安然无恙，却败给了无尽的等待，屈服于凄凉的晚景，在一间借来的光线昏暗的屋子里想着阿玛兰妲。最后一批他知晓下落的老兵出现在报纸上的照片里，卑顺地仰着面孔，身旁站着不知名的共和国总统。他赏赐他们铸有自己头像的金扣子别在衣领上，又归还给他们一面染着鲜血和硝烟污痕的战旗，以备日后覆在棺材上。另一些人更有骨气，在社会救济的荫庇下仍苦苦等待回音，他们或因饥饿而死，或怀着一腔怒火苟活，或在精致的荣誉粪堆中衰老腐烂。因此，当奥雷里亚诺·布恩迪亚上校邀请他发动一场殊死决战，彻底铲除外国入侵者扶植的腐败可耻的政府，赫里内勒多·马尔克斯上校不禁因同情而颤抖起来。\n　“噢，奥雷里亚诺，”他叹气道，“我知道你老了，可现在才明白你比看起来的样子还要老得多。”\n阿玛兰妲与丽贝卡 　数月过去，奥雷里亚诺·特里斯特已为人们所熟识和喜爱，开始四处寻找房屋准备把自己的母亲和妹妹——不是上校的女儿——接来。他看上了广场一角那座似已废弃的破败宅子，便打听主人是谁。有人告诉他那房子没有主人，过去曾经住过一位以泥土和墙皮为食的孤单寡妇，她晚年时别人在街上只见过她两次。她头戴缀有细小假花的女帽，脚穿古银色的鞋子，穿过广场到邮局寄信给主教。他们说陪伴她的只有一个残忍的女仆，那女人杀死猫狗及其他一切闯入家中的动物，并把尸体抛到街上，让市镇上的人都闻得到腐烂的恶臭味。自从最后一只动物的尸体在阳光下晒干后，又过了很久，所有人都确信那女主人和她的女仆早在战争结束前就已去世，房子迄今未倒不过是因为近年来没赶上严酷的冬季，也没遇上能使房倒屋塌的暴风。铰链因锈蚀而断裂，门板靠成团的蛛网勉强支撑，窗框受潮卡死，地面长满杂草野花，其间裂缝成为蜥蜴和各种爬虫的巢穴，一切似乎都证明这里至少有半个世纪没人居住过。对冲动的奥雷里亚诺·特里斯特而言，并不需要见到这些迹象才会采取行动。他用肩膀撞了下大门，蛀蚀的木板便寂然倒塌，灰尘四溢，白蚁巢碎屑飞扬。奥雷里亚诺·特里斯特伫立在门口不动，等到尘雾落定，立时看见了客厅中央那位瘦骨嶙峋的女人。她穿着上个世纪的衣服，光秃的头顶上稀疏几根黄发，一双大眼睛仍残存着昔日的美丽，只是最后的希望之光已在其间熄灭，脸上的皮肤因孤寂而干裂。奥雷里亚诺·特里斯特被眼前非人间所有的景象震慑，险些没有察觉到那女人正用一把老旧的军用手枪指着他。\n　“抱歉。”他含糊地低声道。\n　她在堆满破烂的客厅中央一动不动，一点点仔细打量这肩宽背厚、额头有灰烬刺青的大汉。她透过尘雾看到他站在往昔的薄雾中，背上斜挎着双铳猎枪，手里拎着一串兔子。\n　“慈悲的上帝啊，”她低声惊叹道，“这不公平，现在又让我想起这些！”\n　“我想租房。”奥雷里亚诺·特里斯特说。\n　那女人举起手枪，稳稳瞄准他额间的灰烬十字，毅然决然地扣紧扳机。\n　“请出去。”她下令道。\n　当天晚上吃饭时，奥雷里亚诺·特里斯特向家人讲起自己的遭遇，乌尔苏拉难过地哭了起来。“神圣的上帝啊，”她双手抱头喊道，“她还活着！”时光流逝，战事频仍，加上平日里无数的不幸，她都把丽贝卡给忘了。自始至终清楚地知道她还活着并在蛆虫窝里腐烂的人，只有日渐衰老却毫不心软的阿玛兰妲。当天亮时心中的寒意将她从孤枕上唤醒，她会想起她；当她用肥皂擦洗自己凋零的乳房和枯萎的腹部，当她穿上老年人雪白的细棉布裙和胸衣，当她更换手上缠裹赎罪伤痕的黑纱，都会想起她。无论何时，或睡或醒，从最庄重到最卑下的时刻，她都会想起丽贝卡，因为孤独已经为她筛选记忆，将生活在她心中累积的无数垃圾尽行焚毁，并净化、升华了其他记忆，即那些最苦涩的记忆，使其永远存留。从她那里美人儿蕾梅黛丝知道了丽贝卡的存在。每当她们路过那幢破败的房子，她都会讲起丽贝卡一桩负心的事件，一个出丑的故事，想借此让侄女分享自己日渐衰竭的怨尤，并使积怨在她死后延续。但她没能成功，因为蕾梅黛丝对一切激烈的情感都具有免疫力，遑论他人恩怨。乌尔苏拉经历了与阿玛兰妲截然相反的过程，她记忆中的丽贝卡已经被净化，那个和父母的骨殖袋一起被送来的小女孩令人怜惜的形象已经掩盖了大逆不道脱离家庭的那段过往。奥雷里亚诺第二决定接她回家好生照料，但他的好意遭到丽贝卡的断然拒绝。她辛苦多年忍受折磨好不容易赢得的孤独特权，绝不肯用来换取一个被虚假迷人的怜悯打扰的晚年。\n阿玛兰妲准备死亡 　阿玛兰妲在织她的寿衣。费尔南达不理解她为什么不时给梅梅写信，还寄去礼物，但对何塞·阿尔卡蒂奥却提都不愿提起。“你们到死也不会明白。”当她通过乌尔苏拉询问原因时，阿玛兰妲这样回答，而这一回答在她心中种下的疑问，永远也没有得到解答。身材高挑瘦削，神情高傲，总穿着宽松的泡泡纱裙，顽强地抗拒岁月流逝以及苦痛记忆的侵蚀，阿玛兰妲仿佛在前额上刻着代表贞洁的灰烬十字。其实真正的记号在她手上，在她睡觉时也不摘下并且总是亲手清洗熨平的黑纱上。时间在她织绣寿衣的指缝间流逝。在人们的印象中，她似乎白天织晚上拆，却不是为了借此击败孤独，恰恰相反，为的是持守孤独。\n　…………\n　如果不是阿玛兰妲不合时宜的死亡引发新的动荡，布恩迪亚家衰颓宅院中安静恬和的日子或许能持续很久。这一事件出乎所有人的意料。她虽然衰老又孤僻离群，但看起来依然结实挺拔，一如往常健康得好像磐石。自从那个下午她彻底拒绝赫里内勒多·马尔克斯上校并关在房中痛哭，再没有人能窥见她的内心。她在走出房门的那一刻，已经耗尽所有的眼泪。从此再没见她哭过，不管是在美人儿蕾梅黛丝升天的时候、奥雷里亚诺们遇害的时候，还是在奥雷里亚诺·布恩迪亚上校去世的时候。上校是她在这世上最爱的人，尽管直到他的尸体在栗树下被发现时她才表现出这一点。她去帮忙抬运尸体。她为他穿上军装，刮胡子，梳头发，给髭须上蜡，比他自己在光荣岁月中做得还好。没有人觉察到其中的爱意，因为他们都已见惯阿玛兰妲熟练地处理丧葬事宜。费尔南达惊诧于她对天主教与生活的关系一无所知，只懂得天主教与死亡的关联，仿佛那不是一种宗教，而只是一套丧葬习俗的手册。阿玛兰妲太过沉浸于自己的回忆，无法理解那些精微的教理。她人老了，心中的往事却依然鲜活。她听到皮埃特罗·克雷斯皮的华尔兹舞曲时，想哭的欲望一如年轻时涌上心来，仿佛流逝的时间和往日的教训都没留下痕迹。那些她借口受潮发霉而亲手扔进垃圾桶的乐谱纸带，依然在记忆中转动【第14章2420页】令琴槌敲击不停。她曾经试图在与侄子奥雷里亚诺·何塞窘迫的激情中将记忆淹没，试图在赫里内勒多·马尔克斯上校稳重阳刚的庇护下藏身，但都是枉然，连她老年时最绝望的举措也归于徒劳。还在小何塞·阿尔卡蒂奥被送去神学院之前三年，她为他洗澡时用的爱抚方式就不像是老祖母对待孙儿，更像是女人对待男人，如同传言中法国女郎们所做的那样，也如同十二岁和十四岁的她看见皮埃特罗·克雷斯皮穿着紧身舞蹈长裤随着节拍器的拍子舞动魔杖时想要对他做的那样。她有时为自己没能阻止这一悲惨的暗流而痛苦，有时愤怒得甚至用针扎手指，然而最令她痛苦最令她愤怒最令她心酸的却是爱情这棵芳香四溢却暗遭虫蛀的番石榴树正渐渐走向死亡。就像奥雷里亚诺·布恩迪亚上校总想起战争一样，她不可避免地想起丽贝卡。她兄长可以看淡记忆，她却只能让它越发灼烫。多年间她对上帝的唯一祈求，就是不要让自己遭受惩罚死在丽贝卡之前。每次路过丽贝卡的家，看着房子日渐破败，她便心满意足地以为上帝垂听了她的祈求。一天下午，她在长廊里缝纫，突然冒出一个念头，确信自己会坐在这里，以同样的姿势并在同一束阳光下听见丽贝卡的死讯传来。她坐下等待，仿佛在等一封信。一段时间里，她拆下扣子又缝上，让等待变得不那么漫长难耐。家里没人注意到阿玛兰妲在为丽贝卡缝制一件精美的寿衣。后来，当奥雷里亚诺·特里斯特说看见丽贝卡形如鬼魂，皮肤遍布裂纹，头顶黄发稀疏，阿玛兰妲丝毫不觉惊奇，因为他描述的鬼魂和她很久以来想象的一模一样。她已作好决定要为丽贝卡的尸身装殓整容，用石蜡掩盖脸上的裂纹，再用圣徒像的头发为她做一顶假发。她将装扮出一具美丽的尸体，让它身着亚麻寿衣，并为棺材套上带紫色花边的丝绒衬面，还要举行最体面的仪式下葬到蛆虫的所在。她满怀怨恨地制定了计划，但心中一个念头令她战惊：纵然出于爱意，她也无法做得比这更好。但她没受困惑搅扰，继续完善各种细节，最后超越了丧葬专家的水准，不啻精通死亡仪轨的大师。在这可怖的计划中唯一没有考虑到的就是，她尽管曾向上帝祈求，仍有可能死在丽贝卡之前。事实上，事情就这样发生了。然而在最后的时刻，阿玛兰妲毫无受挫感，相反感到摆脱一切苦痛获得了自由，因为死神格外开恩，提前几年预先给出了通知。那是在梅梅上学后不久，一个炎热的中午，她正在长廊里缝纫时看见了死神。她当下认了出来，没有丝毫恐惧，因为她面前是一位穿蓝衫的长发女人，外表有些老气，与昔日帮忙下厨的庇拉尔·特尔内拉有几分相似。费尔南达很多次也在场，却没有看见她，尽管她是那样真实，那样有血有肉，好几回还请阿玛兰妲帮忙穿针。死神并未说到她何时会死，也没告知她是否会死在丽贝卡之前，只是让她从四月六日起开始为自己缝制寿衣。死神应许她尽可以做得精美复杂，但要像为丽贝卡缝制时一样认真，还说她会死在完工的当天傍晚，死时没有痛苦、没有恐惧也没有烦恼。为了尽可能拖延时间，阿玛兰妲订购了优等麻纱，亲手织布。她织得极其仔细，光做这项活计就耗费了四年时间。然后她开始绣花。随着完工日期不可避免地临近，她意识到除非发生奇迹，才能将活计拖到丽贝卡死后，但干活时的专注令她得以保持必要的镇静来接受失败。也就在那时，她理解了奥雷里亚诺·布恩迪亚上校制成小金鱼随即又销毁的举动。世界不过是身外之物，她的内心不再为任何苦痛而波动。她深深遗憾没能在多年前获得这样的领悟，那时还来得及净化记忆，在崭新的光芒下重建世界，平静地唤回傍晚时皮埃特罗·克雷斯皮身上的薰衣草味道，并且将丽贝卡救出悲惨的境地，而这不是出于爱也不是出于恨，而是出于对孤独的深切理解。那天晚上梅梅言语中的怨恨令她惊讶，并非因为她在情感上受到触动，而是因为她感觉到自己的经历在另一个少女身上重演，她表面看来纯洁无瑕，实际上却已遭到怨恨的玷污。但那时她已完全接受命运，明知纠正的一切可能都不复存在，也并不觉得失落。做完寿衣成了她的唯一目标。她非但没像当初那样借助不必要的精工细作来拖延时间，反而加快了进度。一个星期前，她估计将在二月四日晚间缝上最后一针，便向梅梅提议将预定在次日举行的古钢琴音乐会提前。她没有说明原因，结果建议没被采纳。于是，阿玛兰妲开始设法拖延四十八个小时，后来她甚至觉得死神也在助她一臂之力，因为二月四日晚上风雨大作破坏了发电厂。但到第二天早上八点，她还是在任何女人都不曾完成过的精美作品上添上了最后一针，并以最平常的口气宣告自己将死于当晚。她不仅告诉了家人，还通知了整个市镇，因为她相信可以通过最后一次造福世人的举动来补救自己卑微的一生，而在她看来没有什么事比给逝者带信更好。\n　正午之前，阿玛兰妲·布恩迪亚将在傍晚起程捎带冥信的消息就在马孔多传开，到下午三点客厅里已经放了整整一箱信件。不愿写信的人托阿玛兰妲带个口信，她就在小本子上一一记下收信人的姓名和去世日期。“放心，”她安慰委托人，“我一到那边就去打听他的下落，把口信带给他。”一切仿佛一场闹剧。阿玛兰妲没显出丝毫慌乱，也没露出任何痛苦的迹象，甚至因为履行了义务而显得更加年轻。她身形挺拔修长一如平常。如果不是颧骨凸出和牙齿略有缺残，她看上去会比实际年龄年轻得多。她亲自吩咐将信件放进涂了柏油的箱子，并指定安放在坟墓中的位置，以尽量做到防潮。上午她请来一位木匠，站在客厅里让他量尺寸做棺材，就像是要做一件礼服。她在最后几小时迸发出无穷活力，费尔南达认为她是在拿所有人寻开心。乌尔苏拉知道布恩迪亚家的人都是无疾而终，并不怀疑阿玛兰妲的死亡预感，但仍害怕昏了头的寄信人希望信件早些送达而将她活着下葬。于是她拼命在家中清场，喊叫着与侵入者争吵，到下午四点时终于达到目的。这时，阿玛兰妲刚刚将自己的物品分发给穷人，只留下死后要穿的一套换洗内衣和一双普通的灯芯绒便鞋放在简陋的粗木棺材板上。她没有忽略这个细节，因为她还记得奥雷里亚诺·布恩迪亚上校死的时候只剩下在作坊里穿的拖鞋，自己不得不给他买一双新鞋。快五点的时候，奥雷里亚诺第二来接梅梅去参加音乐会，惊讶地发现家里正在筹备丧事。那时看上去生机勃勃的活人就只有阿玛兰妲，她甚至还好整以暇地修了鸡眼。奥雷里亚诺第二和梅梅开玩笑似的与她告别，还约好下个星期六举办复活宴席。听说阿玛兰妲·布恩迪亚将给死人带信，安东尼奥·伊莎贝尔神甫在五点钟赶来准备施行临终仪式，但等了一刻多钟才看到濒死的女士从浴室出来。一见她穿着马达普兰白细布睡衣、披散着头发出现，老迈的神甫便认定这是一个玩笑，随即遣走了祭童。但他认为可以利用这个机会，让阿玛兰妲作出一次延宕了二十年的忏悔。阿玛兰妲直截了当地回答说，她不需要任何宗教仪式的帮助，因为她的良心是清白的。费尔南达大惊失色，她不顾别人会听见，高声自问阿玛兰妲究竟犯下了怎样可怕的罪行，以至于宁可亵渎神明而死也不愿丢脸地忏悔。于是阿玛兰妲躺下，逼迫乌尔苏拉当众检查自己的贞洁。\n　“谁也不用乱猜，”她喊道，好让费尔南达听见，“阿玛兰妲·布恩迪亚怎样来到这世上就怎样离开。”\n　她没再站起来。她靠在厚垫子上仿佛真的病了，编起长辫子在耳边盘好，根据死神的教导她应该这样躺进棺材。然后，她向乌尔苏拉要来一面镜子，四十多年来第一次看见自己饱经岁月摧残与苦痛煎熬的面容，惊讶于所见竟然与想象中的形象分毫不差。乌尔苏拉从房间里的寂静知道天色已暗了下来。\n　“跟费尔南达告别吧，”她恳求道，“一分钟的和好抵得过一辈子的友谊。”\n　“已经没这个必要了。”阿玛兰妲回答。\n　当临时搭起的舞台上灯光亮起，演出的第二部分开始时，梅梅不禁想到了她。曲子弹奏到一半时，有人到她耳边告知了消息，演出当即中止。奥雷里亚诺第二赶到家中的时候，不得不推开人群挤进去，看到了那位老处女的尸体。她面容丑陋惨淡，手缠黑纱，身穿精美的寿衣。棺材安置在客厅里，旁边是一箱信件。\n　　","date":"2021-09-04","permalink":"/posts/literature/amaranta/","series":[],"tags":[""],"title":"阿玛兰妲——以前的孤独"},{"categories":["文字类"],"content":"百年孤独中关于梅尔基亚德斯（Melquíades）和科学相关的一部分片段。\nPerface 目前我最喜欢的片段~ 特别喜欢那种探索求知的感觉，希望我以后也能抱着这种态度求知学习。\n由于在书中，家族第一代何塞·阿尔卡蒂奥·布恩迪亚，和科学相关很大，所以他们的部分片段也被放到了这里；而且在书中，知识和孤独也有很大联系。\n后：做了一个晚上发现科学和知识与家族的大部分成员关系很大，如果把他们拿出来放到一起还不如完整地看完书呢……于是乎只做了一点点，但是也有快2万字了。所以如果对后续感兴趣的话，可以下载电子版或者买实体书去看。\n梅尔基亚德斯部落发现马孔多 | 家族第一代 （梅尔基亚德斯是在书本一开始就出场了的）\n多年以后，面对行刑队，奥雷里亚诺·布恩迪亚上校将会回想起父亲带他去见识冰块的那个遥远的下午。那时的马孔多是一个二十户人家的村落，泥巴和芦苇盖成的屋子沿河岸排开，湍急的河水清澈见底，河床里卵石洁白光滑宛如史前巨蛋。世界新生伊始，许多事物还没有名字，提到的时候尚需用手指指点点。每年三月前后，一家衣衫褴褛的吉卜赛人都会来到村边扎下帐篷，击鼓鸣笛，在喧闹欢腾中介绍新近的发明。最初他们带来了磁石。一个身形肥大的吉卜赛人，胡须蓬乱，手如雀爪，自称梅尔基亚德斯，当众进行了一场可惊可怖的展示，号称是出自马其顿诸位炼金大师之手的第八大奇迹。他拖着两块金属锭走家串户，引发的景象使所有人目瞪口呆：铁锅、铁盆、铁钳、小铁炉纷纷跌落，木板因钉子绝望挣扎、螺丝奋力挣脱而吱嘎作响，甚至连那些丢失多日的物件也在久寻不见的地方出现，一窝蜂似的追随在梅尔基亚德斯的魔铁后面。“万物皆有灵，”吉卜赛人用嘶哑的嗓音宣告，“只需唤起它们的灵性。”何塞·阿尔卡蒂奥·布恩迪亚天马行空的想象一向超出大自然的创造，甚至超越了奇迹和魔法，他想到可以利用这个无用的发明来挖掘地下黄金。梅尔基亚德斯是个诚实的人，当时就提醒他：“干不了这个。”然而那时的何塞·阿尔卡蒂奥·布恩迪亚对吉卜赛人的诚实尚缺乏信任，仍然拿一头骡子和一对山羊换了那两块磁铁。他的妻子乌尔苏拉·伊瓜兰本指望着靠这些牲口扩展微薄的家业，却没能拦住他。“很快我们的金子就会多到能铺地了。”她丈夫回答。此后的几个月他费尽心力想要证实自己的猜想。他拖着两块铁锭，口中念着梅尔基亚德斯的咒语，勘测那片地区的每一寸土地，连河床底也不曾放过。唯一的挖掘成果是一副十五世纪锈迹斑斑的盔甲，敲击之下发出空洞的回声，好像塞满石块的大葫芦。何塞·阿尔卡蒂奥·布恩迪亚和一起探险的四个男人将盔甲成功拆卸之后，发现里面有一具已经钙化的骷髅，骷髅的颈子上挂着铜质的圣物盒，盒里有一缕女人的头发。\n　三月里，吉卜赛人又来了。这次带来一架望远镜和一台足有鼓面大小的放大镜，展出时声称是阿姆斯特丹犹太人的最新发明。他们让一个吉卜赛女人坐在村子一头，将望远镜安在帐篷入口。花上五个里亚尔，人们就可以凑到望远镜后，看到那个吉卜赛女人在眼前出现，仿佛触手可及。“科学消除了距离，”梅尔基亚德斯说，“用不了多久，人们不出家门就能看到世界上任何地方发生的事情。”一个烈日炎炎的中午，他们用那台巨型放大镜作了一次惊人的演示：把一堆干草铺在街道中央，然后通过聚焦阳光点燃起来。尚未从磁铁实验的失利中平复的何塞·阿尔卡蒂奥·布恩迪亚，又萌生了将这一发明应用于战争的想法。梅尔基亚德斯再次试图让他打消念头，但最后还是接受了两块磁铁加三枚殖民地金币，将放大镜换给了他。乌尔苏拉难过地哭了。那些钱是从她父亲一辈子省吃俭用攒下的一匣金币中拿出来的，她本来一直埋在床下，想等待合适的机会做本钱。何塞·阿尔卡蒂奥·布恩迪亚无暇安慰她，以科学家的忘我精神全心投入战术实验，甚至不惜以身犯险。为了验证放大镜对敌军产生的效果，他亲自待到阳光的焦点下，结果身体被灼伤后溃烂，挨了很长时间才痊愈。妻子对如此危险的发明心生恐惧而提出抗议，但他全然不顾，险些把家里的房子点燃。他久久待在房间里，计算新武器的战略威力，写出了一本解说无比清晰、说服力无可抗拒的手册。他把该手册连同多种实验记录和多幅示意图一起寄给当局，承担这一使命的信使翻越山脉，迷路于无边的沼泽，蹚过湍急的河水，遭猛兽的袭击、绝望情绪和瘟疫的打击险些丧命，最后终于找到了邮政骡队途经的驿道。虽然当时远赴首都不太可能，何塞·阿尔卡蒂奥·布恩迪亚仍然表示，只要政府一声令下他立刻出发，为军方实地演示他的发明，并亲自传授阳光战的精密战术。他等待回复多年，最终厌倦了等待，到梅尔基亚德斯面前哀叹自己的挫折。于是那个吉卜赛人做出了足以显明其诚实的举动：收回放大镜，把那三枚多卜隆①【注①多卜隆( dob1ón)，西班牙古金币名。】还给他，还留下一些葡萄牙人的地图和多种航海仪器。梅尔基亚德斯亲笔写了一份赫尔曼修士②【注②赫尔曼修士(monje Hermann，1013 - 1054)，即Hermann von Reichenau，德国本笃会修士，著有多种星相学著作。】的研究成果提要给他，教他如何使用星盘、罗盘和六分仪。为了确保不受打扰地进行实验，何塞·阿尔卡蒂奥·布恩迪亚在宅院深处盖了一间小屋，整个漫长的雨季都把自己关在屋中。他把家庭职责完全抛在脑后，整夜待在院子里观测星体的运行，为了寻找精确测定正午的方法险些患上日晒病。掌握了那些仪器的用法并操作自如之后，他对空间的认知使他无须离开小屋就能遨游未知的海洋，寻访荒凉的地域，并与神奇的生灵交流。正是在那个时期他养成了自言自语的习惯，旁若无人地在家中踱步，与此同时乌尔苏拉和孩子们却在菜园里累得直不起腰来，照料香蕉、海芋、木薯、山药、南瓜和茄子。然而，没有任何征兆，他疯狂的活动猝然中断，整个人陷入一种心醉神迷的状态。他连续好几天像是着了魔，喃喃自语，说出一连串自己都无法相信的惊人设想。最终，在十二月一个星期二的午饭时分，他从所有的折磨中一下解脱了。孩子们终其一生都将记得父亲如何在桌首庄严入座，被长期熬夜和苦思冥想折磨得形销骨立，因激动而颤抖着，向他们透露自己的发现：\n　“地球是圆的，就像个橙子。”\n　乌尔苏拉再也无法忍耐。“如果你非发疯不可，就一个人疯好了，”她喊道，“别想用你那套吉卜赛人的胡话教坏孩子！”何塞·阿尔卡蒂奥·布恩迪亚无动于衷，妻子在狂怒之下把星盘扔到地上摔得粉碎，他也没有被吓着。他又造了一台，还召集村里的男人到自己的小屋，用无人能懂的理论向他们证明，一直向东航行就有可能回到出发点。全村人都确信何塞·阿尔卡蒂奥·布恩迪亚已经失去理智，这时梅尔基亚德斯来到澄清了真相。他当众赞许这个男人的聪明才智，说他仅凭天文观测就建立起的理论尽管在马孔多尚不为人所知，但已经被实践所证明。为了表示敬佩，他特别馈赠了一样将对村子的未来产生深远影响的礼物：一间炼金实验室。\n　那一时期，梅尔基亚德斯在以惊人的速度衰老。他头几回来访时看上去和何塞·阿尔卡蒂奥·布恩迪亚岁数相仿，但当后者仍然力气过人，揪住马耳朵就能将马掀翻的时候，吉卜赛人却好像已被某种顽疾击垮。实际上，那是他无数次周游世界时染上多种罕见疾病的结果。他在帮助何塞·阿尔卡蒂奥·布恩迪亚搭建实验室时亲口说过，死神一直追随他的脚步，嗅闻他的行踪，但尚未下定决心给他最后一击。他经历了危害人类的各种疾病和灾难幸存下来。他在波斯得过蜀黍红斑病，在马来群岛患上坏血病，在亚历山大生过麻风病，在日本染上脚气病，在马达加斯加患过腺鼠疫，在西西里碰上地震，在麦哲伦海峡遭遇重大海难，却都大难不死。这个天赋异禀，自称掌握了诺查丹玛斯①【注①诺查丹玛斯(Nostradamus，1503 - 1566)，法国预言家，所著《诸世纪》中载预言诗千首，据说在后世多有应验。】之钥的人是个阴沉的男子，裹在一团愁云惨雾里，目光斜曳像是能够看透一切。他总戴着一顶黑色大礼帽，活像乌鸦展开的翅膀，身穿一件天鹅绒坎肩，染着沧桑岁月的苔印。他智慧无边又神秘莫测，但还是有着凡人的一面，未能摆脱日常生活中琐碎问题的烦扰。他抱怨着衰老和病痛，为经济上微不足道的困窘而难过：他很久以前就不再展露笑容，因为坏血病夺去了他所有的牙齿。在一个闷热的正午，他吐露了心声，何塞·阿尔卡蒂奥·布恩迪亚确信那是一段伟大友情的开始。孩子们听着他的神奇故事，目瞪口呆。奥雷里亚诺那时只有五岁，他一生都将记得，那个下午吉卜赛人如何坐在窗前金属的反光中，用管风琴般深沉的声音揭示最幽暗的想象地域，热得从太阳穴流下油腻的汗水。他的哥哥何塞·阿尔卡蒂奥，将会把这奇妙的形象作为记忆遗产，传给所有后世子孙。乌尔苏拉却对这次来访印象恶劣，因为她走进房间的时候，正赶上梅尔基亚德斯一分神，打破了一个装有二氯化汞的小瓶。\n　“这是魔鬼的气味。”她说。\n　“绝不是。”梅尔基亚德斯纠正道，“魔鬼已被证明具有硫化物的属性，而这不过是一点儿氯化汞。”\n　一向诲人不倦的梅尔基亚德斯详细讲解了朱砂与魔鬼相关的效用，但乌尔苏拉却未加理睬，径自带孩子们出去祈祷。那种刺鼻的味道将与对梅尔基亚德斯的记忆一起，永远铭刻在她心里。\n　那间简陋的实验室，除了大量的小锅、漏斗、蒸馏瓶、滤器和滤网，还备有一座简陋的炼金炉，一个仿照“哲学之卵”制成的长颈烧瓶，以及一套由吉卜赛人按照犹太人玛利亚对三臂蒸馏器的现代描述制作的蒸馏过滤设备。梅尔基亚德斯还留下了对应七大行星的七种金属的若干样品，摩西和索希莫①【注①索希莫(Zósimo)，公元3世纪的希腊炼金术士。】的倍金配方，以及“超绝之精”②【注②“超绝之精”(Gran Magisterio)，炼制点金石的程序指南，象征着灵魂臻于至善的进程。】系列笔记和草图，如果参悟成功就能炼出点金石。何塞·阿尔卡蒂奥·布恩迪亚见倍金配方很简单便着了迷，接连几个星期都央求乌尔苏拉挖出她的殖民地金币，说水银能分割多少次，金子就能翻上多少倍。乌尔苏拉像往常一样，在丈夫无可动摇的决心前让了步。于是，何塞·阿尔卡蒂奥·布恩迪亚将三十枚多卜隆金币投入一口坩埚，与铜屑、雌黄、硫黄和铅一起熔化，然后倒入盛满蓖麻油的锅里用旺火煮沸，直到熬出一摊发出恶臭的浓浆，看起来更像是劣质的糖浆而非美妙的黄金。在令人忐忑和绝望的蒸馏过程中，经过与七种行星金属冶合，再放入玄妙的水银和塞浦路斯的硫酸盐中炮制，又用猪油替代萝卜油回锅熬炼，乌尔苏拉宝贵的遗产最后变成一坨碳化的油渣，死死粘在锅底。\n　当吉卜赛人再来的时候，乌尔苏拉已经发动全村的人加以抵制。但好奇心胜过了恐惧，因为这一次吉卜赛人走遍全村，利用各式乐器制造出震耳欲聋的响声，叫卖人还声称将要展出纳西安索人最神奇的发明。因此全村人都去了帐篷，付上一个生太伏就看到了青春焕发的梅尔基亚德斯：身体痊愈，皱纹平复，全新的牙齿闪闪发亮。凡是还记得他的牙龈如何毁于坏血病、脸颊如何松弛、嘴唇如何干瘪的人，面对这一无可置疑的明证，都不禁为吉卜赛人的魔力而惊栗。梅尔基亚德斯将镶在牙床上的牙齿完好无损地摘下并向观众展示——那一瞬间他变回了往昔的老朽模样——随后又戴上牙齿展露出重获青春的微笑，这时惊慌变成了恐惧。即便是何塞·阿尔卡蒂奥·布恩迪亚都觉得梅尔基亚德斯的知识已经达到令人无法容忍的程度，不过当后者私下里给他讲解了假牙的原理后，他随即感到一阵畅然。他觉得这一切如此简单而神奇，一夜之间又对炼金研究完全失去了兴趣，陷入新的情绪危机，无心饮食，整天在家中踱步。“世上正发生着不可思议的事情，”他对乌尔荪拉说，“就在那边，在河的另一边，各种魔法机器应有尽有，而我们却还像驴子一样生活。”从马孔多创建之初就认识他的人，都惊讶于他在梅尔基亚德斯影响下发生的变化。\n　当初何塞·阿尔卡蒂奥·布恩迪亚是那种年轻的族长式人物，他指导人们怎样播种，建议怎样教育孩子、饲养牲畜，为村社的繁荣与所有人通力合作，在体力劳动上也不例外。从一开始他家的房子就是村里最好的，成为他人仿效的对象。他家有一间敞亮的小厅，一间鲜花盛开、颜色喜人的露台餐厅，两间卧室，一座栽着一棵大栗树的庭院，一片精心打理的菜园，还有一个畜栏，山羊、母鸡和猪在其间和谐相处。在家里乃至整个村子，斗鸡是唯一禁养的动物。\n　………………\n　何塞·阿尔卡蒂奥·布恩迪亚当初建功立业的雄心，迅速在磁铁迷狂、天文演算、炼金幻梦以及见识世上奇观的热望中消磨殆尽，曾经勇于开拓、仪表整洁的他，变成一个外表懒散、不修边幅的男人。他那野蛮人一样的胡须，乌尔苏拉费尽力气才能勉强用菜刀收拾干净。甚至有人将他视为某种诡异巫术的牺牲品。然而当他将开荒的工具扛上肩头，倡议全体村民共同开辟一条将马孔多与新兴发明相连的捷径时，即使是那些深信他已发疯的人也丢下活计与家人而去跟随他。\n　………………\n　“见鬼！”他喊了起来，“马孔多周围全是水！”\n　很长时间内，马孔多处在一个半岛上成为根深蒂固的观念，这源于何塞·阿尔卡蒂奥·布恩迪亚远征归来后武断绘出的地图。他绘图时满怀怒气，故意夸大交通的艰难，以此来惩罚自己竟如此荒唐地选择了这样一个地方。“我们一辈子哪儿也去不了，”他向乌尔苏拉抱怨道，“我们注定要在这里活活烂掉，享受不到科学的好处。”他在实验室小屋里思来想去，脑海中全是这个念头，几个月后终于酝酿出一个方案，要将马孔多迁移到更合宜的地点。但这一次，乌尔苏拉抢在了他那狂热计划的前头。凭借一番百折不挠的努力，她暗中与村里所有女人联合起来，反对男人们的突发奇想——他们已经在准备搬家了。何塞·阿尔卡蒂奥·布恩迪亚不知道从何时起，又是怎样的力量从中作梗，他的计划陷入由种种借口、托辞和阻力形成的罗网，最终彻底沦为幻想。这天早上他在庭院尽头的小屋里一边念叨着搬家梦想，一边把实验器具装回原来的箱子，乌尔苏拉带着无辜的神情关注着这一切，甚至对他感到些许怜悯。她任凭他装完，任凭他钉好箱笼、用刷子漆上自己名字的缩写，没有责怪他一句，心里却知道他已经明白——因为听见他这么低声自言自语——村里的人不会随他上路。只是当他开始拆卸小屋的房门时，乌尔苏拉才鼓起勇气询问为什么要这样做，他不无苦涩地回答：“既然没人肯走，那我们自己走。”乌尔苏拉没有动摇。\n　“我们不走，”她说，“就留在这儿，因为我们已经在这儿生了一个孩子。”\n　“我们还没有死人，”他说，“只要没有死人埋在地下，你就不属于这个地方。”\n　乌尔苏拉反驳了他，温和而坚定：\n　“如果非要我死了才能留下，那我就去死。”\n　何塞·阿尔卡蒂奥·布恩迪亚无法相信妻子竟会如此意志坚决。\n　他试图用自己的幻梦诱惑她，许诺带她去一个神奇的世界，在那里只需往地里洒一点儿魔水就能让作物按照自己的愿望结实，在那里花一点点钱就能买到各式各样的止痛器械。但乌尔苏拉对他预言的景象毫不动心。\n　“忘了你那些疯狂的新鲜玩意儿，还是管管你的孩子吧。”她回答，“瞧瞧他们，自生自灭没人管，和驴子一样。”\n　何塞·阿尔卡蒂奥·布恩迪亚照妻子的话做了。他往窗外望去，只见两个孩子赤脚待在阳光暴晒的菜园里，他感觉从那一刻起他们才开始存在，从乌尔苏拉的咒语中诞生出来。随即他内心发生了某种变化，某种神秘而明晰的力量将他从当下拉扯出来，带往记忆中从未涉足的所在。乌尔苏拉继续打扫，此刻她已经确信有生之年再也不会离开这个家园，而他一直凝视着孩子们，直到双眼湿润。他用手背擦干眼睛，深深地叹息一声，接受了现实。\n　“好吧，”他说，“让他们帮我把东西从箱子里拿出来。\n　…………\n　然而自从那个下午叫孩子们帮忙取出实验器具，他便将自己最宝贵的时间留给了他们。在僻静的小屋里，墙壁上渐渐挂满荒唐的地图和奇异的图画。他教他们读写和算术，向他们讲起世界上的诸多奇迹，不光涉及自己已知的事物，还充分发挥想象力达到令人难以置信的极致。就这样，孩子们得知在非洲的最南端有平和而智慧的人民，他们唯一的消遣是坐下来沉思；得知爱琴海可以徒步穿越，只需从一个岛屿跳上另一个直到萨洛尼卡港。那些光怪陆离的课程深深铭刻在孩子们的记忆中，以至于多年以后，在政府军军官向行刑队下令开枪的前一刻，奥雷里亚诺·布恩迪亚上校又回想起三月里那个温暖的下午：父亲在物理课上倏然顿住，一脸着迷的神情，手停在半空中，眼神凝固，倾听着远远传来的高音笛，串铃和鼓的声音。吉卜赛人又来到了村里，推销孟菲斯城的智者们最新最惊人的发明。\n　那是一批新的吉卜赛人，男男女女都很年轻，只会说他们自己的语言，个个容貌俊美，皮肤油亮，双手灵巧。他们在街上载歌载舞引来喧声笑语，激起惊诧不断：染成各种颜色的鹦鹉吟唱着意大利浪漫曲，母鸡伴着手鼓的节奏下出一百个金蛋，训练有素的猴子能猜出人的所思所想，多功能机器既能缝扣子又能退烧，还有用来忘却不快回忆的仪器、用来浪费时间的药膏以及其他上千种异想天开、闻所未闻的发明，何塞·阿尔卡蒂奥·布恩迪亚都恨不得发明一台记忆机器来记录下这一切。村子瞬间变了样。马孔多的居民在自己村子的街道间迷失了方向，置身于喧嚷的集市中不知所措。\n　何塞·阿尔卡蒂奥·布恩迪亚一手拉住一个孩子，免得他们在混乱中走失。他从镀金牙的卖药人和六条胳膊的杂耍艺人身旁跌跌撞撞地走过，在人群散发出的粪便和檀香气味中艰难地呼吸，发疯似的四处寻找梅尔基亚德斯，想请他解开这场神奇梦魇中的无尽奥秘。\n　他问了好几个吉卜赛人，但他们都听不懂他的语言。最后他来到梅尔基亚德斯惯常扎帐篷的地方，遇见一个神情郁郁的亚美尼亚人在用卡斯蒂利亚语①【注①卡斯蒂利亚语( castellano)，即西班牙语，今日的西班牙语起源于卡斯蒂利亚地区。】介绍一种用来隐形的糖浆。那人喝下一整杯琥珀色的液体，正好此时何塞·阿尔卡蒂奥·布恩迪亚挤进入神观看的人群向他询问。吉卜赛人惊讶地回望了他一眼，随即变成一摊热气腾腾散发恶臭的柏油，而他的回答犹自在空中回荡：“梅尔基亚德斯死了。”听到这个消息，何塞·阿尔卡蒂奥·布恩迪亚惊呆了，他竭力抑制悲恸，而人群渐渐被别处的机巧吸引过去，那一摊亚美尼亚人的遗存物也彻底消失。后来，别的吉卜赛人向他证实梅尔基亚德斯的确在新加坡的沙洲上死于热病，被丢到了爪哇海的最深处。孩子们对这个消息不感兴趣，坚持要父亲带他们去见识孟菲斯智者们创造的最新奇观，据帐篷入口处招揽生意的吉卜赛人说，那曾经是所罗门王的宝藏。孩子们非去不可，何塞·阿尔卡蒂奥·布恩迪亚只好付了三十里亚尔，领他们走到帐篷中央，那里有一个遍体生毛的光头巨人，鼻上穿着铜环，脚踝间绕着沉重的铁链，正看守着一个海盗藏宝箱。巨人刚打开箱子，立刻冒出一股寒气。箱中只有一块巨大的透明物体，里面含有无数针芒，薄暮的光线在其间破碎，化作彩色的星辰。何塞·阿尔卡蒂奥·布恩迪亚茫然无措，但他知道孩子们在期待他马上给出解释，只好鼓起勇气咕哝了一句：\n　“这是世上最大的钻石。”\n　“不是。”吉卜赛人纠正道，“是冰块。”\n　何塞·阿尔卡蒂奥·布恩迪亚没能领会，伸出手去触摸，却被巨人拦在一旁。“再付五个里亚尔才能摸。”巨人说。何塞·阿尔卡蒂奥·布恩迪亚付了钱，把手放在冰块上，就这样停了好几分钟，心中充满了体验神秘的恐惧和喜悦。他无法用语言表达，又另付了十个里亚尔，让儿子们也体验一下这神奇的感觉。小何塞·阿尔卡蒂奥不肯摸，奥雷里亚诺却上前一步，把手放上去又立刻缩了回来。“它在烧。”他吓得叫了起来。但何塞·阿尔卡蒂奥·布恩迪亚没有理睬，他正为这无可置疑的奇迹而迷醉，那一刻忘却了自己荒唐事业的挫败，忘却了梅尔基亚德斯的尸体已成为乌贼的美餐。他又付了五个里亚尔，把手放在冰块上，仿佛凭圣书作证般庄严宣告：\n　“这是我们这个时代最伟大的发明。” 梅尔基亚德斯死去之后 | 家族第二代 　何塞·阿尔卡蒂奥·布恩迪亚没能解开镜屋之梦，直到见识冰块的那一刻。于是他相信自己理解了梦境的深意。他想到在不久的将来可以利用水这种寻常材料大规模生产冰块，并用它们建造村庄的新居。马孔多将不再是一个连合页和插销都因高温而变形的酷热之地，而会变成一个寒冬之城。他没有坚持建立制冰厂的尝试，只因那时他正热衷教育儿子们，特别是奥雷里亚诺，这孩子起初就显露出炼金方面的罕见天赋。实验室已经收拾干净。他们重新查阅梅尔基亚德斯的笔记，如今已心情平静，不再有因新奇而生的兴奋。他们长时间耐心实验，试图将乌尔苏拉的金子从粘在锅底的废料中分离出来。年轻的何塞·阿尔卡蒂奥几乎从不参与。当他父亲全身心摆弄炼金炉的时候，这位冲动任性、发育一向超出实际年龄的长子，已经长成一个体格魁伟的小伙子。他变了声，上唇布满初生的茸毛。\n　…………\n　（下面的他是家族第二代何塞·阿尔卡蒂奥）\n他完全沉浸在自己的世界里，以至于当他父亲和弟弟的好消息使全家沸腾时，他还不知道是他们终于熔开了那个金属块，分离出了乌尔苏拉的金子。\n　经过多日繁难而艰巨的工作，他们的确做到了。乌尔苏拉欣喜万分，甚至为炼金术的发明赞美上帝。实验室里挤满了村民，主人端出番石榴甜点加小饼干款待他们，来庆祝这一奇迹。与此同时，何塞·阿尔卡蒂奥·布恩迪亚隆重展示了坩埚中失而复得的黄金，仿佛那是他刚刚创造出来的。他让所有人一一看过，最后来到近来极少在实验室露面的长子跟前。他把发黄的干硬块摆到儿子眼前，问道：“你觉得怎么样？”何塞·阿尔卡蒂奥直率地回答：\n　“像狗屎。”\n　父亲反手给了他一巴掌，打得他直流出血和泪来。那天晚上庇拉尔·特尔内拉在黑暗中摸索着找到药瓶和棉布，用山金车酊给他敷肿，还让他尽情享受而不用费神，爱怜他而不弄疼他。他们如此心心相印，片刻之后不知不觉开始窃窃私语。\n　“我想和你单独在一起。”他说，“总有一天我要把这一切告诉所有人，用不着再躲躲藏藏。”\n　她不想扫他的兴。\n　“那太好了。”她说，“要是单独在一起，我们就可以点亮灯，互相能看见，而且我想怎么叫就怎么叫，不用管别人，你在我耳边想说什么就说什么。”\n　这一场谈话，伴以对父亲的切齿怨恨，对纵情相爱的迫切憧憬，在他身上激发出一种沉着的勇气。他事先未作任何铺垫，直接把一切都告诉了弟弟。\n　一开始小奥雷里亚诺只意识到风险，觉得哥哥的冒险极有可能引来祸端，却没能理解其中的魅力所在。后来哥哥的渴望渐渐感染了他。他听他讲述种种波折的细节，分享他的痛苦和喜悦，与他一起担惊受怕，一起体验幸福。他整夜不睡，一个人躺在床上好像睡在炭火席上，直等到天亮哥哥回来，然后两人毫无睡意地交谈到起床的时候。很快两人都变得委靡不振，都对父亲的炼金术和智慧失去了敬意，都躲藏到孤独之中。“这两个孩子呆呆的，”乌尔苏拉说，“一定是肚子里有虫子。”她用土荆芥研末熬制了一剂难喝的汤药，不料两人都以意想不到的坚忍喝了下去，并且一天之内同时坐到便盆上达十一次之多，排出了几条粉红色的寄生虫。他们兴高采烈地向所有人展示，为的是避免乌尔苏拉追究他们神不守舍和倦怠消沉的真实原因。那时奥雷里亚诺不仅能理解，还能对哥哥的经历感同身受，因为有一次当哥哥详尽无遗地向他描述情爱的奥妙，他插话问道：“那是什么感觉？”何塞·阿尔卡蒂奥当即回答：\n　“好像地震。”\n（奥雷里亚诺也失去了对炼金的兴趣，因为“庇拉尔“）\n　…………\n　乌尔苏拉安稳休息了四十天不到，吉卜赛人又来了，是带来过冰块的同一拨江湖艺人和杂耍演员。与梅尔基亚德斯的部落不同，他们在很短的时间内就证明了自己并非传播进步的使者，而是贩卖娱乐的商人。包括他们带来的冰块，也不是为了推广应用到生活中，而是纯粹当作马戏团的奇物。这次的奇巧物件中有一块飞毯，他们同样没有将其视为交通发展上的重大贡献，而仅仅当作用于消遣的玩物来介绍。毫不奇怪，人们挖出了自家埋藏的最后几枚金币，想换取一次从村里房顶飞过的短暂经历。借着纷乱人潮的掩护，何塞·阿尔卡蒂奥和庇拉尔享受了一段惬意的独处时光。他们成为人群中一对幸福的情侣，甚至开始怀疑，爱情或许可以是一种比夜晚幽会中疯狂而短暂的快乐更平和深沉的感觉。然而，庇拉尔打破了美梦。她受身边何塞·阿尔卡蒂奥的激情感染，选择了错误的方式和时机，一句话就使他的世界地覆天翻。“现在你是真正的男人了。”见他没听懂自己的意思，她又明明白白地解释了一遍：\n　“你就要有儿子了。”\n　连续几天何塞·阿尔卡蒂奥都不敢走出家门一步。一听到厨房里传来庇拉尔声震屋瓦的笑声，他就立刻逃到实验室。那里的炼金器械在乌尔苏拉的祝福下都已重获新生，何塞·阿尔卡蒂奥·布恩迪亚兴高采烈地接纳了迷途知返的儿子，并且带他入门，参与自己终于启动的点金石探寻工作。一天下午，飞毯载着吉卜赛驭手和几个村里的孩子从实验室窗前迅捷掠过，他们在飞毯上兴奋地挥手致意，两个儿子都被吸引过去，而何塞·阿尔卡蒂奥·布恩迪亚看都不看一眼。“让他们做梦去吧，”他说，“将来我们要用更科学的方式比他们靠一条可怜的床罩飞得更高。”尽管装出感兴趣的样子，何塞·阿尔卡蒂奥其实从未理解“哲学之卵”的魔力，在他看来那不过是一个做坏了的瓶子。他无法抛开自己的心事。他吃不下睡不着，脾气变坏，就像父亲工作受挫时一个样。何塞·阿尔卡蒂奥·布恩迪亚见他举止失常，以为他对炼金术太过投入，便免去他在实验室的工作。奥雷里亚诺当然知道哥哥所受的折磨与寻找点金石毫无关系，但也无法令他吐露真情。往日的推心置腹已经一去不返，同谋和交流变成敌意与缄默。他渴望孤独，对整个世界的怨恨咬噬着他的心。一天晚上他像往常一样下了床，不过不是去庇拉尔·特尔内拉家，而是混迹于集市的喧嚷人潮中。他走过各样花巧的玩意儿，没有一样能引起他的兴趣。最后他的注意力落在一样非展品上：一个非常年轻的吉卜赛女郎，几乎还是个孩子，被身上的玻璃珠链压弯了腰。这是何塞·阿尔卡蒂奥一生见过的最美的女人。她正在人群中观看一个人因为忤逆父母而变成蟒蛇的惨剧。\n（之后何塞·阿尔卡蒂奥跟着吉普赛人走了，他失踪了，母亲乌尔苏拉也去找他了）\n　…………\n　时间使一切恢复了原样。何塞·阿尔卡蒂奥·布恩迪亚和儿子不知从何时起又回到了实验室，他们抖落尘埃，点起炉灶，拾起已经在粪床上沉睡了数月的材料，又一次耐心地操作起来。连躺在柳条小筐里的阿玛兰妲，也好奇地观看父兄在水银蒸气弥漫的小屋里入神地工作。架子上被遗忘多日的一个空瓶忽然重得挪不动。工作台上的一锅水未经加热便沸腾了半个小时，直到完全蒸发。何塞·阿尔卡蒂奥·布恩迪亚和儿子看着这一切又恐惧又欢喜，他们无法解释，只是将其视作新材料要诞生的预兆。一天阿玛兰妲的小筐自行移动起来，在房间里兜了个圈。奥雷里亚诺大吃一惊，连忙去拦下它。做父亲的却没有惊慌，他把小筐放回去，固定在桌腿上，坚信期待已久的事情即将发生。就在那时，奥雷里亚诺听见他说：\n　“就算你不敬畏上帝，也该敬畏金属。”\n梅尔基亚德斯复活 |家族第二代 　（乌尔苏拉回来了，同时发现了和外界联系的道路，很多人来到了马孔多）\n马孔多变了样。跟着乌尔苏拉一起来的人四处宣扬它土地肥美、位置又比大泽区优越，于是昔日僻静的小村落很快变成繁华的城镇，有了手工作坊和店铺，还开通了一条永久商道。第一批穿尖头靴戴耳环的阿拉伯人就沿商道而来，用玻璃珠链交换金刚鹦鹉。何塞·阿尔卡蒂奥·布恩迪亚一刻也不能平静。他着迷于眼前的现实，认为这比自己广袤的幻想世界更为神奇，因而对炼金实验完全丧失了兴趣。他将漫长时日中饱受锤炼的材料搁置一旁，又变回了创业之初那个富于进取心的男子，那时他忙于设计街道规划新居，以保证人人享有平等权益。他在新落户的居民中赢得极大尊重，任何人铺设地基或修造围栏都要先咨询他的意见，大家还一致决定由他掌管土地的分配。走江湖的吉卜赛人又来了，这次把流动游艺会变成了大型赌场。人们兴高采烈地表示欢迎，相信何塞·阿尔卡蒂奥会一道归来。但他并没有出现，吉卜赛人也没有带蛇人来，在乌尔苏拉看来有关儿子的唯一线索也没了着落。镇上因此拒绝吉卜赛人扎营，并将他们视为贪欲与堕落的传播者，不许他们以后再踏上这片土地。但何塞·阿尔卡蒂奥·布恩迪亚也明确表示，梅尔基亚德斯以他悠远的智慧和神奇的发明对村子的发展壮大作出过不可磨灭的贡献，马孔多的大门将永远对他古老的部落敞开。然而据那些周游各地的旅人说，梅尔基亚德斯的部落由于逾越了人类知识的界限，已从大地上被抹去。\n　何塞·阿尔卡蒂奥·布恩迪亚至少暂时从幻想的种种煎熬中解脱出来，很快便营造出一种井然有序的实干氛围，其中只批准一项自由：释放从建村伊始就以歌声欢快报时的群鸟，代之以家家户户各备一台音乐钟。这些雕刻精美的木钟是用金刚鹦鹉从阿拉伯人那里换来的，由何塞·阿尔卡蒂奥·布恩迪亚统一校准。每隔半小时镇上便响起同一乐曲的欢快和弦，一到正午更是蔚为壮观，所有时钟分秒不差地同时奏响整曲华尔兹。那些年间，也是何塞·阿尔卡蒂奥·布恩迪亚决定在街上种植巴旦杏代替金合欢，并且发现了能使树木经久不衰的方法，但一直秘不示人。多年以后，马孔多已经遍布锌顶木屋，那些最古老的街道上却依然可见巴旦杏树蒙尘的断枝残干，然而已无人知晓出自谁人手植。当父亲忙于整治市镇，母亲一心扩展家业，每天两次用树枝穿着糖制的小鸡小鱼出门销售，奥雷里亚诺则从早到晚待在被遗弃的实验室里，完全凭自己的探索掌握了金银器工艺。他身量大长，哥哥留下的衣服很快都不合身了，便开始穿父亲的衣服，只是得让比西塔西翁收紧衬衣修剪裤子，因为奥雷里亚诺没有他们那样魁伟的身材。青春期的他失去了甜美的童音，变得沉默寡言孤独入骨，但却恢复了呱呱坠地时流露出的执著眼神。他全神贯注于金银艺实验，甚至到了废寝忘食的地步。何塞·阿尔卡蒂奥·布恩迪亚担心他过于专注，认为他或许需要一个女人，便给了他家里的钥匙和一些零钱 。奥雷里亚诺却用钱买来盐酸配制王水，还把钥匙镀了层金。不过他的古怪之处与阿尔卡蒂奥和阿玛兰妲相比又算不得什么，那两个孩子早就开始换牙，却依然整天跟在印第安女人后面，顽固地不肯说卡斯蒂利亚语而只说瓜希拉土语。“你有什么可抱怨的，”乌尔苏拉对丈夫说，“有发疯的父母就有发疯的儿女。”正当她哀叹自己命不好，认定儿女们的怪癖与猪尾巴同样可怕时，奥雷里亚诺眼神定定地望着她，令她感到一阵茫然。\n　“有人要来了。”他说。\n（来的人是丽贝卡，之前做过）\n　…………\n　（关于失眠症这一段我觉得非常有趣，所以我一定要把这一段弄下来，故事接丽贝卡改掉吃土习惯）\n丽贝卡改掉食土的恶习后，被安排到其他孩子的房间睡觉。一天夜里，和他们睡在一起的印第安女人突然醒来，听见一种奇怪的响声在角落里时断时续。她以为有动物溜进房间，警觉起来，却发现丽贝卡坐在摇椅上吮着手指，双眼像猫眼一般在黑暗中放光。比西塔西翁心中充满恐惧和难逃宿命的凄苦，她在那双眼睛里认出了威胁他们的疫病，正是这种疫病逼得她和兄弟背井离乡，永远抛下了他们古老的王国，抛下了公主与王子的尊贵身份。这就是失眠症。\n　天亮的时候，印第安人卡塔乌雷失去了踪影。他姐姐比西塔西翁留了下来，认定了自己的宿命：就算逃到天边，这致命的疫病也会穷追不舍尾随而至。没有人理会她的惊恐。“要是不用睡觉，那再好不过。”何塞·阿尔卡蒂奥·布恩迪亚说，“那样我们就有更多的时间可用。”但印第安女人向他们解释，失眠症最可怕之处不在于让人毫无倦意不能入睡，而是会不可逆转地恶化到更严重的境地：遗忘。也就是说，患者慢慢习惯了无眠的状态，就开始淡忘童年的记忆，继之以事物的名称和概念，最后是各人的身份，以至失去自我，沦为没有过往的白痴。何塞·阿尔卡蒂奥·布恩迪亚笑得喘不过气来，认为这不过是又一种印第安人杜撰的疾病。乌尔苏拉为防万一，还是将丽贝卡和其他孩子隔离开来。\n　几个星期后，比西塔西翁的恐惧似乎平息了下去。有天晚上何塞·阿尔卡蒂奥·布恩迪亚在床上辗转反侧，难以入睡。乌尔苏拉也醒着，问他怎么了，他回答：“我又想起了普鲁邓希奥·阿基拉尔。”他们一刻也没睡着，但到了第二天感觉疲劳尽去，便把不眠之夜抛在了脑后。午饭时候，奥雷里亚诺惊异地讲起他如何一整夜都在实验室忙着给一枚别针镀金，准备在乌尔苏拉的生日送给她，但此刻却仍然感觉良好。到了第三天，大家在该入睡的时刻还是毫无睡意，这才意识到已连续五十多个小时没有合眼，终于警觉起来。\n　“孩子们也都醒着。”印第安女人的话里带着宿命意味，“这病一旦进了家门，谁也逃不了。”\n　他们果然染上了失眠症。乌尔苏拉从母亲那里学过各种草药的效用，熬制了乌头汤让所有人服下去，可他们仍然睡不着，整天醒着做梦，在这种清醒的梦幻中，他们不仅能看到自己梦中的形象，还能看到别人梦见的景象，一时间家里仿佛满是访客。丽贝卡坐在厨房角落里的摇椅上。梦见一个和自己相貌极其相似的男人，他身着白色亚麻衣裳，衬衫领口别着一粒金扣，给她带来一束玫瑰。陪伴他的还有一位女士，用纤细的手指拣出一枝玫瑰簪在她发间。乌尔苏拉知道那男人和女人是丽贝卡的父母，但一番努力辨认之后，还是确信从未与他们谋面。与此同时，由于何塞·阿尔卡蒂奥·布恩迪亚一个永远无法原谅自己的疏忽，家中出品的糖果小动物仍源源不断地在镇上出售。大人小孩都津津有味地吮咂着可口的绿色失眠小公鸡、美味的粉红失眠小鱼和柔软的黄色失眠小马，于是到了星期一凌晨整个镇子都醒着。一开始没人在意。恰恰相反，人们都因不用睡觉而兴高采烈，因为那时候马孔多有太多的事情要做，时间总不够用。他们夜以继日地工作，很快就把活儿都干完了，凌晨三点便无所事事，听着音乐钟数华尔兹的音符。那些想睡觉的人，不是因为疲倦而是出于对睡眠的怀念，试遍了各种消磨精力的方法。他们聚在一起不停地聊天，一连几个小时重复同样的笑话，甚至把阉鸡的故事演化到令人无法容忍的地步。那是一个讲不完的故事，讲故事的人问大家要不要听阉鸡的故事，如果大家说“要”，他就说没让大家说“要”，而是问大家要不要听阉鸡的故事；如果大家说“不要”，他就说没让大家说“不要”，而是问大家要不要听阉鸡的故事，如果大家都不说话，他就说没让大家不说话，而是问大家要不要听阉鸡的故事；而且谁也不许走，因为他没让人走，而是问大家要不要听阉鸡的故事。就这样继续下去，整夜整夜重复这一恶性循环。\n　何塞·阿尔卡蒂奥·布恩迪亚意识到失眠症已经侵入镇子，便召集起各家家长，把自己所知的失眠症情形讲给他们听。众人决定采取措施防止灾难扩展到大泽区的其他村镇。他们把用金刚鹦鹉跟阿拉伯人换来的小铃铛从山羊脖子上摘下，放在镇子入口，供那些不顾岗哨的劝告和恳求坚持进镇的来客使用。那时节走在马孔多街道上的所有外乡人都要摇动小铃铛，好让病人知道自己是健康人。他们在镇上逗留期间禁止一切饮食，因为疫病无疑只经入口之物传播，而所有食品饮料都已沾染失眠症。这项举措成功地将疫病控制在村镇之内。隔离卓有成效，后来人们就将紧急情况视为常态。生活恢复秩序，工作照常进行，没人再为睡眠这一无用的习惯担忧。\n　还是奥雷里亚诺想出了办法，在接下来的几个月中帮助人们抵御失忆。这发现本出于偶然。他属于第一批病人，已是老练的失眠者，并借此掌握了高超的金银器工艺。一天他在寻找用来捶打金属箔片的小铁砧时，却想不起它的名称。父亲告诉他：“砧子。”奥雷里亚诺把名称写在纸上，用树胶贴在小铁砧底部：砧子。这样，他相信今后就不会再忘记。当时他还没想到这便是失忆开始的症状，因为那东西的名称本不好记。没过几天，他发现自己对实验室里几乎所有器物都叫不出名来。于是他依次注明，这样只需看一下标签就可以辨认。当父亲不安地告诉他自己童年最深刻的记忆都已消失时，奥雷里亚诺向他传授了这一方法。何塞·阿尔卡蒂奥·布恩迪亚先在家中实行，而后推广到全镇。他用小刷子蘸上墨水给每样东西注明名称：桌子，椅子，钟，门，墙，床，平锅。他又到畜栏为动物和植物标上名称：奶牛，山羊，猪，母鸡，木薯，海芋，香蕉。随着对失忆各种可能症状的研究不断深入，他意识到终会有那么一天，人们即使能通过标签认出每样事物，仍会记不起它的功用。于是他又逐一详加解释。奶牛颈后所挂的名牌便是一个极好的例子，体现出马孔多居民与失忆作斗争的决心：这是奶牛，每天早晨都应挤奶，可得牛奶。牛奶应煮沸后和咖啡混合，可得牛奶咖啡。就这样，人们继续在捉摸不定的现实中生活，只是一旦标签文字的意义也被遗忘，这般靠词语暂时维系的现实终将一去不返。\n　通往大泽区的路口立起一块牌子，上写马孔多，中心大道立有一块更大的牌子，上书上帝存在。各家各户都已写好用来记住物品和情感的简要说明。这套做法需要高度的警醒和坚强的毅力，因而很多人选择了向虚拟现实的魅力屈服，寄情于自我幻想，这纵然不切实际却更能与人安慰。庇拉尔·特尔内拉在这场造梦运动中出力最多，她成功地将纸牌算命从推演未来应用到追溯过往。借助这一方法，失眠者开始生活在由纸牌萌生的模棱两可的世界中。在模糊的追忆中，父亲是四月初到来的肤色黝黑的男人，母亲是左手戴金戒指肌肤呈麦色的女人，出生日期则简化为最近一个有云雀在月桂树上啼叫的星期二。何塞·阿尔卡蒂奥·布恩迪亚对这些寻求慰藉的方式深感无奈，决定制造当初曾想用来记录吉卜赛人神奇发明的记忆机器。该装置的设计基于以下原理：每天清晨将一生获得的知识从头至尾复习一遍。他把它想象为一种旋转辞典，人坐在中轴位置用摇把操纵，在几小时内令生活中最必要的知识都从眼前经过。当他做好大约一万四千张卡片的时候，通往大泽区的路上出现了一位衣衫不整的老人，他用小铃铛摇出悲凉的声响以表示未染上失眠症，拖着一件绳索紧系的鼓囊囊的行李，拉着一辆黑布蒙住的小车。他径直来到何塞·阿尔卡蒂奥·布恩迪亚家门前。\n　比西塔西翁开了门，但并不认识他，以为他想要兜售什么，还不知道在这个已经深陷失忆泥沼的村镇任何物品都没有市场。这是一位风烛残年的老人，尽管声音也因犹疑时断时续，双手颤抖仿佛质疑着事物的真实存在，但仍可以明显看出，他来自另一个世界，来自人们可以安睡并拥有记忆的世界。何塞·阿尔卡蒂奥·布恩迪亚看见他坐在客厅里，一边用几经补缀的黑色礼帽扇风，一边带着同情的神色认真阅读贴在墙上的一个个标签。何塞·阿尔卡蒂奥·布恩迪亚分外殷勤地向他打了个招呼，担心他是曾经相识而现在已不记得的故人。但来访者看出了他的做作，感觉到自己已被遗忘，那并不是心中暂时的尚可补救的遗忘，而是另一种更残酷且不可逆转的遗忘，他对此绝不陌生，因为那正是死亡的遗忘。于是他都明白了。他打开塞满稀奇物件的行李，掏出一个小手提包，里面满是瓶瓶罐罐。他给何塞·阿尔卡蒂奥·布恩迪亚喝下一种淡色液体，重新燃起了他的记忆之光。泪水濡湿了他的双眼，随后他才意识到自己置身于一间各种物品都贴着标签的荒唐屋子里，为墙上煞有介事的蠢话而惭愧。他随即又认出了来人，脸上顿时焕发出欢喜的光彩。那人是梅尔基亚德斯。\n　马孔多欢庆重获记忆的同时，何塞·阿尔卡蒂奥·布恩迪亚和梅尔基亚德斯正在重温往昔的友情。老吉卜赛人准备就此留在镇上。他的确一度死去，但难以忍受孤独又重返人世。他因执著于生命受到惩罚，被剥夺了一切超自然能力，又被逐出了部落，便决定到这个死神尚未光顾的偏远角落栖身，专心创立一家银版照相术工作室。何塞·阿尔卡蒂奥·布恩迪亚还从未听说过这一发明，他看到自己和全家人的形象在一块闪光的金属版上凝固成永恒，顿时惊诧得说不出话来。在当时拍下的一张老照片上，何塞·阿尔卡蒂奥·布恩迪亚灰色的头发乱蓬蓬，硬挺的衬衫领子用一粒铜扣扣上。神情庄严中藏着惊诧，乌尔苏拉乐不可支地说他像“一位受惊的将军”。何塞·阿尔卡蒂奥·布恩迪亚在那个晴朗的十二月上午的确受惊不小，他以为人的形象一旦被摄到金属版上，生命就会随之日渐销蚀。有趣的是，乌尔苏拉一反常态，消除了丈夫的疑虑，并且抛下往日的怨气，决定让梅尔基亚德斯留下一起生活，只是她一直拒绝拍照，因为——按她自己的原话——不愿意将来让儿孙笑话。那天上午她给孩子们穿上最好的衣裳，在他们脸上都搽了粉，还让每人喝下一勺骨髓糖浆，好让他们面对梅尔基亚德斯壮观的机器保持近两分钟的安分。在这张唯一的全家福照片上，奥雷里亚诺身穿黑色天鹅绒正装，夹在阿玛兰妲和丽贝卡中间，那倦怠的模样和深邃的眼神与多年以后面对行刑队时一般无二。但那时他尚未感觉到命运的预示。他已是熟练的金银匠，凭着精湛的手艺在整个大泽区享有盛名。他的作坊与梅尔基亚德斯杂乱的实验室合在一起，屋里几乎听不到他的呼吸声。他父亲和老吉卜赛人为诺查丹玛斯的预言大声争论，瓶子和托盘撞击作响，酸液不时在磕磕碰碰中打翻，溴化银到处流淌，而他仿佛置身于另一个时空。他全神投入工作，加上经营有道，不久赚取的收入就超过了乌尔苏拉的美味糖果小动物生意。但所有人都觉得奇怪，他明明已是个十足的男子汉，竟然还没有结识女人。事实上他的确没有。\n　数月后，好汉弗朗西斯科回来了，他是个将近两百岁的江湖艺人，常来马孔多吟唱自编的歌谣。他通过这些歌谣不厌其详地讲述旅行途中的各地见闻，从马孔多直讲到大泽区的边界。如果有人要捎带口信或发布消息，就付两个生太伏请他加到曲目中。乌尔苏拉便是这样偶然得知母亲过世的消息，那天晚上她听着歌谣，本来还期望听到儿子何塞·阿尔卡蒂奥的下落。人们称他为好汉弗朗西斯科，是因为他曾在一次即兴赛歌会上击败魔鬼，至于其真名实姓则无人知晓。他在失眠症肆虐期间一度从马孔多消失，一天晚上又突然出现在卡塔利诺的店里。全镇人都去听他唱歌，想知道世界上发生了什么。这次和他同来的有个肥胖无比的女人，需要四个印第安人用摇椅抬着；还有一个黑白混血姑娘，一副孤单无助的神情，打着伞遮挡阳光。这天晚上奥雷里亚诺去了卡塔利诺的店里。他看见好汉弗朗西斯科像一条巨石雕成的变色龙端坐在好奇的听众中间。他用苍老走调的声音唱出世事变迁，以当年罗利爵士①【注①罗利爵士(Sir Walter Raleigh，1552 - 1618)，英国探险家，英女王伊丽莎白一世的宠臣。】在圭亚那相赠的那架古老手风琴伴奏，那双四方走遍、踩踏硝石而皴裂的大脚还打着拍子。院子深处的一扇门内不时有男人进出，门前鸨母坐在摇椅上静静地扇着扇子。卡塔利诺耳上别了一朵毡绒玫瑰，向听众兜售碗盛的甘蔗酒，并不失时机地靠近那些男人，将手放到不该放的地方。将近夜半时分，酷热难当，奥雷里亚诺已从头听到尾，没有听出什么与自家有关的消息。他正准备起身回家，鸨母挥手跟他打了个招呼。\n　“你也进去吧，”她说，“只要二十生太伏。”\n　奥雷里亚诺向鸨母腿上的钱罐里投了一枚硬币，走进房间却不知道要做什么。混血姑娘露着母狗那样的乳头，赤着身子躺在床上。在奥雷里亚诺之前，这天晚上已有六十三个男人光顾过这里。经过这么多人进进出出，房间里的空气中混合了汗水和喘息的气味，变得污浊不堪。姑娘掀起湿透的床单，请奥雷里亚诺抓着另一侧。床单沉得像粗麻布一样。他们俩抓住两头拧水，直到恢复正常重量。他们又翻过席子，汗水从另一面往下淌。奥雷里亚诺盼着这活儿永不停息。他在理论上了解情爱是怎么回事，但还是双膝发软站立不稳，皮肤滚烫毛发悚然，仍忍不住要立刻排出腹中的重负。那姑娘收拾好床铺，要他脱掉衣服时，他慌忙解释：“是他们让我进来的。要我往钱罐里投二十生太伏，还得动作快点儿。”姑娘明白了他的困惑。“如果你出去的时候再放二十生太伏，就可以多待一会儿。”她温柔地说。奥雷里亚诺脱了衣服，羞惭至极，总想着自己的裸体没法和哥哥相比。不管那姑娘怎样努力，他都愈加没有反应，愈觉孤独异常。“我会再放二十生太伏。”他绝望地说。姑娘默默地向他谢过。她的背上都已磨破。她瘦得皮包骨，呼吸间流露出无尽的疲惫。两年前，在离这里很远的地方，她睡前没有熄灭蜡烛，醒来已经身处火海。她和抚养她长大的祖母一起居住的房子化作灰烬。从此，祖母带着她走遍各个村镇，让她以二十生太伏的价钱卖身，以挣回烧毁的房屋。根据姑娘自己估算，按每夜接待七十个男人计还需要干十几年，因为她还需另付二人的旅费、饮食费以及抬摇椅的印第安人的工钱。鸨母第二次敲房门的时候，奥雷里亚诺离开了房间，什么也没做，惶惶然只想哭泣。当天夜里他想着那姑娘无法入睡，有欲望也有怜悯。他感到无可抑制的冲动，要去爱她和保护她。到天亮的时候，他已被失眠和狂热折磨得疲惫不堪，终于作出庄严的决定，要与她成婚并把她从所欠祖母的债务中解救出来，夜夜享受她给予七十个男人的满足。但上午十点他赶到卡塔利诺店里的时候，姑娘已经离开镇子。\n　时间平复了他一时的冲动，却加深了挫败感。他一心在工作中逃避。他决定认命，终生远离女人来遮掩自己无能带来的差耻。与此同时，梅尔基亚德斯已经把马孔多所有可照的都照在金属版上，然后把银版照相术工作室让给了臆想联翩的何塞·阿尔卡蒂奥·布恩迪亚，后者要用它来获取上帝存在的科学依据。他运用一套复杂的程序在家中各处采集影像叠加曝光，确信只要上帝存在，迟早会被他拍下银版照片，不然就可以一举推翻其存在的假设。梅尔基亚德斯在破解诺查丹玛斯预言方面取得了深入进展。他每每研究到深夜，缩在退色的天鹅绒坎肩里艰难喘息，用雀爪般的小手在纸上胡乱涂写，手上的戒指都已失去曾经的光彩。一天夜里，他相信已破译出一则有关马孔多未来的预言。它会变成一座光明的城市，矗立着玻璃建造的高楼大厦，却再没有布恩迪亚家的丝毫血脉存留。“一定弄错了，”何塞·阿尔卡蒂奥·布恩迪亚大发雷霆，“不是玻璃房子，是冰房子，像我梦见的那样。而且不管到什么时候，总会有布恩迪亚家的人，直到永永远远。\n　…………\n　蕾梅黛丝走近问了几个关于小金鱼的问题，奥雷里亚诺无法回答，因为他猝然间喘不过气来。他想永远这样待下去，守着她百合般的肌肤，伴着她翡翠色的眼睛，听她以对待父亲的尊敬，每问一个问题都叫一声“先生”。梅尔基亚德斯坐在角落里的书桌前，画着难以索解的符号。奥雷里亚诺恨他。他做不了别的，只能对蕾梅黛丝说要把小金鱼送给她，结果吓得她飞快地逃出了作坊。那天下午奥雷里亚诺失去了隐藏于心底的耐性，此前他正是靠这种耐性等待见面的机会。他无心干活。他竭力集中精神无数次呼唤，但蕾梅黛丝没有回应。他到她姐姐们的缝纫店寻找她，在她家窗前寻找她，去她父亲的办公室寻找她，但她的身影只出现在他心中，填满了他可怕的孤独。他和丽贝卡在客厅里一坐就是几个小吋，听着自动钢琴弹奏华尔兹。丽贝卡这样做是因为皮埃特罗·克雷斯皮曾教她如何伴着那音乐跳舞，奥雷里亚诺这样做则是因为一切，包括音乐在内，都能让他想起蕾梅黛丝。（lolicon奥雷里亚诺，当然这只是玩笑，这本书的爱情没有什么世俗制约）\n　…………\n　恢复不久的平静又被打破，这一次是梅尔基亚德斯的死。尽管这结果已在意料之中，但他死亡的情形却是人们事先所想象不到的。他归来后没几个月，便经历了一个急剧衰老的过程，很快就被归为那类无用的老翁，他们像幽灵般在卧室间步履蹒跚地游荡，高声追怀美好岁月却无人理睬，直到某天清晨死在床上才被人想起。起初，何塞·阿尔卡蒂奥·布恩迪亚出于对新奇的银版照相术和诺查丹玛斯预言的热情，还常常帮他的忙。但随着时间流逝，两人之间的交流日益困难，他最终被丢下孤独一人。他的视力和听力都在衰退，似乎把对话者混同于他在人类历史早期所结识的人物，回答他人问题时混乱使用多种语言。一天他忘了戴上夜里放在床边水杯里的假牙，从此索性不戴。乌尔苏拉着手扩建家宅的时候，特意为他盖了一个房间，紧挨着奥雷里亚诺的作坊，远离家中的忙乱喧闹，有一扇阳光充沛的窗子和一个书架。她亲自把尘侵蛾蛀几近损毁的书籍、写满难解符号的脆薄纸张和装假牙的杯子一一摆上书架，那杯子里已经长出水生植物，开着纤小的黄花。梅尔基亚德斯似乎很喜欢这个新居，因为从此再没见他出屋，甚至在饭厅也不见他的踪影。他只去奥雷里亚诺的作坊，一待就是几个小时，在随身携带的羊皮纸上涂写谜一般的文字，那纸好像由某种干燥的材料所制，像千层饼似的裂开。他就在那里吃下比西塔西翁每天两次送去的食物，但最后那段日子他没了胃口，只吃蔬菜过活。很快他就显出素食者特有的孤清模样。他的皮肤上覆着一层柔软的苔藓，与那件不分季节永不离身的坎肩上滋生的相仿，他的呼吸间散发出熟睡动物的臭气。奥雷里亚诺最终忘了他的存在，沉浸在自己的诗行里，但有一次感觉听懂了他低沉独白中的只言片语，便留了心。实际上，他滔滔不绝说出的艰深话语中唯一能够辨别出来的，只是像锤击般不断重复的一个词“二分点二分点二分点”①，【注①二分点(equinoccio)，昼夜平分点，黄道与天赤道的交点。】还有一个名字“亚历山大·冯·洪堡” ②。【注②亚历山大·冯·洪堡( Alexander Von Humboldt，1769 - 1859)，德国地理学家和博物学家。】阿尔卡蒂奥开始帮奥雷里亚诺做金银器活计的时候，曾尝试稍稍接近他。梅尔基亚德斯回应了这一沟通努力，不时吐出几个和现实毫不相干的卡斯蒂利亚语句子。然而一天下午，他好像突然间激情骤至，神采焕发。多年以后，面对行刑队，阿尔卡蒂奥将回想起梅尔基亚德斯为他朗读那一页页不可理解的文字时的颤抖，他自然是听不懂，但那铿锵的音调听起来仿佛教皇通谕的吟唱。随后，他很久以来第一次露出笑容，用西班牙语说道：“等我死的时候，请在我房间里烧上三天水银。”阿尔卡蒂奥告诉了何塞·阿尔卡蒂奥·布恩迪亚，后者试图获取更具体的信息，却只得到一句回答：“我已经达到永生。”每当梅尔基亚德斯的呼气发臭，阿尔卡蒂奧便在星期四的上午带他去河里洗澡。他看来好了些。他脱下衣服，和年轻人一起没到水里，凭着神秘的方向感绕过深凹和危险地带。“我们是水做的。”他有一次这么说道。就这样过了很长时间，没人在家里见过他，除了那天晚上他令人感动地努力修理自动钢琴，以及他腋下夹着用毛巾包好的加拉巴木果壳瓢和油椰肥皂跟阿尔卡蒂奥去河里洗澡的时候。一个星期四，在叫他去河边之前，奥雷里亚诺听见他说：“我已经发热病死在新加坡的沙洲上。”那天他下水时弄错了路线，直到第二天早上才在下游几公里的地方被找到，尸身搁浅在一处明晃晃的河湾里，一只孤零零的秃鹫落在他肚子上。乌尔苏拉哭得比自己父亲去世时还伤心。何塞·阿尔卡蒂奥·布恩迪亚不顾她的惊诧和反对，拒绝为他下葬。“他永生不死，”他说，“他自己给出了复活的配方。”他重新燃起遗忘多时的炼金炉，放上一锅水银煮沸，一旁的尸体渐渐充满蓝色的泡沫。堂阿波利纳尔·摩斯科特鼓起勇气提醒他，溺死者不安葬的话会危害公共卫生。“哪儿的话，他根本没死。”何塞·阿尔卡蒂奥·布恩迪亚如此回答。熏香一般的水银烧煮已经持续七十二小时，尸体上开始进裂出青紫色的花朵，伴随着轻微的爆响，家里充满恶臭。到了这个时候，他才同意下葬。但拒绝草率行事，而要用隆重的礼仪对待这位马孔多最大的恩人。这是镇上第一次也是参与人数最多的葬礼，一个世纪后格兰德大妈的葬礼或可与之媲美。他们将他葬在为公墓预留的空地中央，筑起一座坟墓，墓碑上铭刻着他们对他的唯一所知：梅尔基亚德斯。他们为他守灵九个夜晚。\n　　","date":"2021-08-21","permalink":"/posts/literature/melquiades/","series":[],"tags":[""],"title":"梅尔基亚德斯、炼金室及羊皮卷——我对知识的原始印象（完成度15%）"},{"categories":["文字类"],"content":"收集丽贝卡在百年孤独出现的所有片段。\nPreface 今天是端午节，非常无聊，自己又太困了，不想学习，于是想写点什么。写什么好呢？图灵？三体？星星？都不想写，又突然想到丽贝卡这位人物，于是就决定把丽贝卡在小说中所有的片段全部给复制在这篇文章上面。\n我已经将百年孤独的文档上传到了蓝奏云网盘，如果有兴趣的话，可以去这里 下载(密码:1111)。另外还可以下载一个Typora，然后将文件后缀改为.md，可以更好地阅读。\n更新日志 2021-06-13 创建。\n2021-07-11 删除一些自己的废话，简洁一下。\n2021-08-24 暑假时又看了一遍，应该没有遗漏的片段。\n丽贝卡的片段 丽贝卡的到来 多年以后，马孔多已经遍布锌顶木屋，那些最古老的街道上却依然可见巴旦杏树蒙尘的断枝残干，然而已无人知晓出自谁人手植。当父亲忙于整治市镇，母亲一心扩展家业，每天两次用树枝穿着糖制的小鸡小鱼出门销售，奥雷里亚诺则从早到晚待在被遗弃的实验室里，完全凭自己的探索掌握了金银器工艺。他身量大长，哥哥留下的衣服很快都不合身了，便开始穿父亲的衣服，只是得让比西塔西翁收紧衬衣修剪裤子，因为奥雷里亚诺没有他们那样魁伟的身材。青春期的他失去了甜美的童音，变得沉默寡言孤独入骨，但却恢复了呱呱坠地时流露出的执著眼神。他全神贯注于金银艺实验，甚至到了废寝忘食的地步。何塞·阿尔卡蒂奥·布恩迪亚担心他过于专注，认为他或许需要一个女人，便给了他家里的钥匙和一些零钱 。奥雷里亚诺却用钱买来盐酸配制王水，还把钥匙镀了层金。不过他的古怪之处与阿尔卡蒂奥和阿玛兰妲相比又算不得什么，那两个孩子早就开始换牙，却依然整天跟在印第安女人后面，顽固地不肯说卡斯蒂利亚语而只说瓜希拉土语。“你有什么可抱怨的，”乌尔苏拉对丈夫说，“有发疯的父母就有发疯的儿女。”正当她哀叹自己命不好，认定儿女们的怪癖与猪尾巴同样可怕时，奥雷里亚诺眼神定定地望着她，令她感到一阵茫然。\n　“有人要来了。”他说。\n　和往常一样，乌尔苏拉听到他发表预言又试图用家庭主妇的常识来解释。有人来再正常不过。每天都有数十个外乡人经过马孔多，从未引发混乱，更无须事先神秘预告。然而，奥雷里亚诺对一切逻辑解说浑不在意，对自己的预感确信不疑。\n　“我不知道是谁，”他坚持道，“但不管是谁，人已经在路上了。”\n　果然，到了星期天，丽贝卡来了。此时她只有十一岁。几位皮革商人带着她从马纳乌雷辛苦跋涉而来，受人之托将她连同一封信送到何塞·阿尔卡蒂奥·布恩迪亚家，却又说不清楚托付他们的人究竟是谁。她的所有行李包括一个小衣箱、一把绘有彩色小花的小摇椅和一个帆布口袋，袋里装着她父母的骨殖，一刻不停地发出咯啦咯啦的响声。那封带给何塞·阿尔卡蒂奥·布恩迪亚的信中充满温情的话语，可见纵然岁月蹉跎天各一方，写信人依然对他深情不改，并且出于基本的人道精神将这个无依无靠的孤儿送来这里。孩子算乌尔苏拉的远房表妹，因而也是何塞·阿尔卡蒂奥·布恩迪亚的亲人，尽管关系上要更远些。她是难忘的挚友尼卡诺尔·乌略亚和他可敬的妻子丽贝卡·蒙铁尔的女儿，愿他们在天国安息，一并送来他们的骨殖，盼以基督徒的礼仪安葬云云。信中提到的名字和末尾的签名都清晰可辨，然而何塞·阿尔卡蒂奥·布恩迪亚和乌尔苏拉都不记得有这些亲戚，也从不认识叫这个名字的写信人，更不用提还是在遥远的马纳乌雷。从女孩那里也无法获得更多信息。从来到的那一刻起，她就一直坐在摇椅上吮手指，一双受惊的大眼睛打量着所有人，不曾流露出能听懂别人提问的迹象。她穿着已显破旧的黑色斜纹布衣裳，脚上是漆皮脱落的短靴。头发拢到耳后，用黑带子束住两个发髻。披肩上的图案沁染汗渍已无法辨认，一颗食肉动物的犬牙配上铜托系在右手腕上当作抵抗“邪眼”的护身符。青绿色的皮肤，圆滚紧绷如一面鼓的肚子，都显示出她体弱多病、忍饥挨饿的历史甚至要比自身的年龄更久远，然而食物端上来的时候，她却任凭盘子搁在腿上尝也不尝。大家几乎要相信她是个聋哑儿，直到印第安人用他们的语言问她要不要喝点儿水的时候，她才眼神一动仿佛认出了他们，点了点头。\n　家人没有办法，只得把她收留下来。奥雷里亚诺耐心地在她面前从头到尾念了一遍圣徒节期表，但她对所有名字都没有反应，家人只好根据信中她母亲的名字叫她丽贝卡。那时马孔多还没死过人，自然没有墓地，他们只得暂时将骨殖袋收藏起来，等将来有合宜的地方再下葬。很长一段时间这些遗骨在家中到处碍事，总在意想不到的地方出现，像母鸡抱窝似的咯咯作响。丽贝卡过了很久才融入家庭生活。她总是缩到家中最偏僻的角落，坐在摇椅上吮吸手指。什么都无法引起她的注意，除了那些钟表奏出的音乐，她每过半小时就会瞪着受惊的眼睛四下寻找，仿佛想在空中某个位置找到那乐声。数天过去，她什么也不肯吃。谁都无法理解她居然没有饿死，后来印第安人——他们一刻不停、悄无声息地在家里走来走去，一切都逃不过他们的眼睛——发现她只喜欢吃院子里的湿土和用指甲刮下的石灰墙皮。显然她父母或是其他抚养人曾斥责过这一恶习，因为她总是心有愧疚暗中行事，藏起口粮来等没人时再享用。从那以后，家里开始对她严加监视。他们在院子里洒牛胆汁，往墙壁上涂辣椒油，相信用这些方法可以遏制她的恶习。然而她找寻泥土时显得异常狡黠机智，乌尔苏拉不得不采取更严厉的手段。乌尔苏拉在小锅里放入橘汁，兑上大黄晾了一整夜，次日让她空腹喝下。没人说过这就是治疗食土怪癖的特效药，但乌尔苏拉却相信任何苦味的食物进入空腹都会令肝脏产生反应。丽贝卡拼命反抗，力气之大与瘦小身量根本不符，他们不得不像扳倒一头小牛犊似的逼她服药，却难以制止她的乱踢乱踹，无法忍受她在撕咬和吐口水之余古怪难解的呼号。印第安人听得目瞪口呆，说那是他们语言中最污秽的辱骂。乌尔苏拉知道后，在药物治疗之外又加上了皮带抽打。永远无从确知，究竟是大黄或毒打，还是二者一起最终发挥了效用，总之几个星期后丽贝卡显出康复的迹象。她加入到阿尔卡蒂奥和阿玛兰妲的游戏中，他们把她当姐姐看待。她胃口颇佳，刀叉也用得不错。不久家人又发现她的卡斯蒂利亚语说得和印第安土语一样流利，手头活计也干得出色，还会哼唱音乐钟奏出的华尔兹舞曲，配上滑稽的自编歌词。大家很快就接纳她为家庭新成员。她和乌尔苏拉最亲，连乌尔苏拉的亲生儿女都比不上。她管阿玛兰妲和阿尔卡蒂奥叫小妹妹小弟弟，称奥雷里亚诺为叔叔，呼何塞·阿尔卡蒂奥·布恩迪亚为爷爷。于是，她和其他家人一样名正言顺地用上了丽贝卡·布恩迪亚的姓名，那也是她一生用过的唯一姓名，直到去世从未玷污。\n　丽贝卡改掉食土的恶习后，被安排到其他孩子的房间睡觉。一天夜里，和他们睡在一起的印第安女人突然醒来，听见一种奇怪的响声在角落里时断时续。她以为有动物溜进房间，警觉起来，却发现丽贝卡坐在摇椅上吮着手指，双眼像猫眼一般在黑暗中放光。比西塔西翁心中充满恐惧和难逃宿命的凄苦，她在那双眼睛里认出了威胁他们的疫病，正是这种疫病逼得她和兄弟背井离乡，永远抛下了他们古老的王国，抛下了公主与王子的尊贵身份。这就是失眠症。\n豆蔻年华的丽贝卡 在这个古怪的家里，乌尔苏拉尽力保持正常，她扩大了糖果小动物生意，整夜不歇地开着烤炉，产出一篮篮面包以及品种丰富的布丁、蛋白酥和小饼干，几个小时内就在通往大泽区的小路上全部售出。明明已到可以安享生活的岁数，她反倒越来越活跃。她一直忙于自己兴隆的事业，一天下午，当印第安女人帮她往面团里加糖，她无意中向院子望去，竟看见两位陌生的美丽少女在暮色中绣花。那是丽贝卡和阿玛兰妲。她们为外祖母严格守孝三年，那时刚刚脱去孝服，鲜艳的衣裳仿佛使她们在世上获得了新的地位。谁也不曾想到，丽贝卡会是两人中更漂亮的那个。她面容白皙明净，眼睛大而沉静，一双有魔力的手仿佛在将无形的丝线绣成花样。年龄小些的阿玛兰妲虽然魅力稍逊，但遗传了过世外祖母自然的气质和内心的高傲。\n丽贝卡与皮埃特罗·克雷斯皮 （为了理解下面的部分，说明一下皮埃特罗·克雷斯皮是一名意大利技师，他来帮助家里安装调试自动钢琴。阿玛兰妲简单来讲和丽贝卡是同龄人，她是家里面亲生的女儿）\n皮埃特罗·克雷斯皮重新把自动钢琴组装起来。丽贝卡和阿玛兰妲帮他理顺琴弦，听到那颠倒的华尔兹乐曲时跟他一起连连大笑。见他那样可亲又可靠，乌尔苏拉便取消了监视。在他告别的前夜，家里用修复的自动钢琴临时举行了一场舞会，他和丽贝卡联袂表演了一场美妙的现代舞。………………将近午夜时分，皮埃特罗·克雷斯皮满怀感情地发表了简短致辞，并许诺会很快回来。丽贝卡一直送他到门口，随即关闭家门，熄灭灯火，她回到自己房间里恸哭起来。那是一种难以安慰的哭泣，持续了好几天，连阿玛兰妲也不明白其中的缘由。她的守口如瓶并不奇怪。她虽然表面热情坦诚，实际秉性孤僻，从不敞开心扉。她已出落成一位亭亭玉立的少女，身材修长结实，但仍旧喜欢坐在那把和她一起到来的小木头摇椅上，那椅子加固过多次，扶手已经不见了。没人留意她到了这个年龄还是喜欢吸吮手指，她一有机会便把自己关在浴室里，并养成了面朝墙壁睡觉的习惯。雨天的下午，她和女友们待在秋海棠长廊里刺绣，每当看到潮湿的土层和蚯蚓在花园里堆起的小丘，她常常会从交谈中走神，怀念的泪水带着咸味涌上舌尖。她一开始哭泣，当年那些被橘汁和大黄压服的秘密嗜好顿时化为无法抑制的渴望爆发。她又开始吃土。第一次几乎是出于好奇，她确信那糟糕的味道将是摆脱诱惑的最佳药方。她果然无法忍受泥土在嘴里的感觉，但她没有放弃，而是受制于不断增强的渴望，渐渐恢复了旧日的胃口，恢复了对原生矿物的喜爱以及原始食物带来的满足。她将一把把泥土藏进口袋，一边传授女友们最繁难的针法，谈论其他不值得自己为之吃下石灰墙皮的男人，一边趁人不注意一点点吃掉，心中涌起既幸福又愤怒的迷乱感觉。这一把把泥土使那唯一值得她自卑自贱的男人不再遥远也更加真切，仿佛从他脚上精巧的漆皮靴在世界另一处所踏的土地传来矿物的味道，她从中品出了他鲜血的重量和温度，这感觉在她口中猛烈烧灼，在她心里留下安慰。一天下午，安帕萝·摩斯科特无缘无故请求参观新家。阿玛兰妲和丽贝卡对这突如其来的到访不明所以，礼貌而生硬地接待了她。她们向她展示扩建后的家宅，请她听自动钢琴的演奏，为她端上橘子水和小饼干。安帕萝给她们上了一课，诸如什么是端庄大方，什么是仪态可亲，什么是举止得体，给在场不过短短一会儿的乌尔苏拉留下了深刻印象。两小时后，谈话渐渐无味，安帕萝趁阿玛兰妲分神的瞬间将一封信塞给丽贝卡。她只来得及看见“可敬的丽贝卡·布恩迪亚小姐”字样，与自动钢琴说明书上的字体同样工整，以同样的绿色墨水写就，使用同样的绮丽措辞。她立刻用指尖将信折起藏进胸衣，望着安帕萝·摩斯科特的眼神中充满无尽感激，还有结下生死之盟的无声承诺。\n………………\n丽贝卡每天下午四点待在窗边绣花，等待情书的到来。明明知道运送邮件的骡子每十五天才来一次，她依然天天等候，相信他们会算错时间，任何一天都有可能到来。然而事与愿违，有一次到了预定的日期，骡子却没有出现。丽贝卡绝望得发疯，半夜爬起来，自戕般饥渴地吞下一把把花园里的泥土。她又痛苦又愤怒地哭泣，咀嚼着柔软的蚯蚓，咬碎蜗牛的硬壳崩裂牙齿，又呕吐直到天亮。她陷入一种迷狂的衰弱状态，失去意识，在毫不知耻的呓语中吐露心声。乌尔苏拉惊诧之下撬开她的衣箱，在箱底发现了用玫瑰色丝带系好的十六封香气四溢的信件，夹在旧书里的枯叶和花瓣，以及一碰就化为粉末的蝴蝶标本。\n………………\n（何塞·阿尔卡蒂奥·布恩迪亚是建村元老，不用关注）\n丽贝卡那般喊叫已经无法保守秘密，阿玛兰妲发现了她的痴恋后开始发烧。她也在为没有回应的爱情而饱受折磨。她把自己关在浴室里，写下一封封狂热的信，以摆脱没有希望的激情带来的折磨，然后把信深藏在衣箱内。乌尔苏拉同时照顾两个病人，几乎忙不过来。她费尽心机长时间询问，也没能问出阿玛兰妲委靡的缘由。最终，她又灵机一动，撬开衣箱，便发现了用玫瑰色丝带系好的信，信内塞满新鲜的百合花瓣，信上泪痕未干，封封都写给皮埃特罗·克雷斯皮，但从未寄出。乌尔苏拉眼含愤怒的泪水，诅咒自己动念购买自动钢琴的那个时刻，并取消了刺绣课程，下令进入没有死人的丧期，直到女儿们死心断念为止。………………何塞·阿尔卡蒂奥·布恩迪亚面对妻子的热情让了步，但提出一个条件：作为交换，丽贝卡要嫁给皮埃特罗·克雷斯皮。乌尔苏拉等到能腾出时间时，会带阿玛兰妲去省城观光，让她多和外人接触以淡忘自己的失落。丽贝卡听到这个结果，立时恢复了健康，给未婚夫写了一封欢喜万分的信，经父母过目后亲自送到邮局投递。阿玛兰妲假意接受了这一决定，渐渐退了烧，但在心中暗暗发誓，丽贝卡想要结婚除非从她的尸体上跨过去。\n………………\n（一个重要的人物“死”了——梅尔基亚德斯，也不用关注）\n这是镇上第一次也是参与人数最多的葬礼，一个世纪后格兰德大妈的葬礼或可与之媲美。他们将他葬在为公墓预留的空地中央，筑起一座坟墓，墓碑上铭刻着他们对他的唯一所知：梅尔基亚德斯。他们为他守灵九个夜晚。大家聚在庭院里喝咖啡、讲笑话、玩纸牌，阿玛兰妲趁着这混乱找到一个机会向皮埃特罗·克雷斯皮表白自己的爱情，后者几个星期前刚与丽贝卡正式订下婚约，并且开办了一家乐器和发条玩具店，就在当年阿拉伯人常常流连并用廉价的小玩意儿交换金刚鹦鹉的地方，也就是人们口中的土耳其人大街。意大利人那一头闪亮的鬈发常引得女人们情不自禁地赞叹，他觉得阿玛兰妲不过是个任性的小姑娘，没有把她的话当真。\n　“我有个弟弟，”他对她说，“他很快会来店里给我帮忙。”\n　阿玛兰妲感到受了侮辱，带着刻骨的怨恨告诉皮埃特罗·克雷斯皮，她下定决心要阻止姐姐的婚礼，就算横尸门前也在所不惜。意大利人对如此骇人的威胁大感震惊，忍不住告诉了丽贝卡。于是，因乌尔苏拉的繁忙一再推迟的旅行，在不到一个星期内就安排妥当。\n　阿玛兰妲没有反对，但在与丽贝卡吻别的一刻，在她耳边轻轻说道：\n　“你别做梦了。就算把我赶到天边，我也能想办法让你结不成婚，哪怕要杀了你也不在乎。”\n乌尔苏拉的离开，以及梅尔基亚德斯无形的存在——他继续悄无声息地在房间里游荡——使家里显得分外空旷。丽贝卡接管了日常家务，印第安女人负责照管面包房。每到傍晚，皮埃特罗·克雷斯皮就在一阵薰衣草的香风中到来，总带上一件玩具做礼物，他的未婚妻则在客厅里接待他，并敞开所有门窗以免引起风言风语。这种谨慎不免显得多余，因为意大利人已充分表明他的正派可靠，他甚至连姑娘的手都没有碰过，尽管她年内就将成为他的妻子。这样的来访很快使家里摆满了神奇的玩具。上了弦就能翩翩起舞的跳舞女郎，八音盒，奔跑的马儿，耍杂技的猴子，敲鼓的小丑，各种令人惊异的机械动物，皮埃特罗·克雷斯皮带来的这些玩具驱散了何塞·阿尔卡蒂奥·布恩迪亚心头悼念梅尔基亚德斯去世的悲痛，他又回到了过去那个钻研炼金术的时期。………………\n只有丽贝卡受了阿玛兰妲的威胁一直闷闷不乐。她了解妹妹的性格，了解她的高傲，因她刻毒的怨恨而担惊受怕。她连续几个小时躲在浴室里吸吮手指，竭尽全力抗拒吃土的诱惑。为了摆脱心头的忧虑，她请庇拉尔·特尔内拉为自己推算未来。说了些模棱两可的套话之后，庇拉尔·特尔内拉给出了预言：\n　“只有等你父母入士为安，你才会幸福。”\n　丽贝卡一阵颤抖。她记起好像在梦里，看见还是小女孩的自己走进家门，带着衣箱、小木头摇椅和一个口袋，而她一直不知道口袋里面装的什么。她记起一位秃顶的先生，他身着亚麻衣裳，领口别着一粒金扣，但与金杯国王毫无相似之处。她记起一位非常年轻美貌的女士，双手温和芬芳，与金元仆侍那双似乎患了风湿病的手相去甚远，那女士曾在她发间簪上鲜花，下午带她在一个绿色街巷的城镇中散步。\n　“我不明白。”她说。\n　庇拉尔·特尔内拉同样困惑。\n　“我也不明白，但牌上就是这么说的。”\n　丽贝卡被这解不开的谜团搅得忧心忡忡，便告诉了何塞·阿尔卡蒂奥·布恩迪亚。他责怪她竟然相信纸牌的预言，自己却在暗中翻遍衣柜和衣箱，挪开家具，掀起床板和地板，四处寻找那个骨殖袋。他想起自从房子扩建以后就再没见过，便偷偷找来那些泥瓦匠，其中一个承认，当时嫌那袋子碍事就把它砌在了夹壁里。他们耳朵贴在墙上四处侦听，听了好几天终于听到了低沉的咯啦咯啦声，于是凿开墙壁，发现骨殖仍完好无损地保存在袋中。当天他们便把骨殖安葬在一个没有墓碑的坟茔里，就在梅尔基亚德斯的坟墓旁。何塞·阿尔卡蒂奥·布恩迪亚回到家，心里卸下了如同对普鲁邓希奥·阿基拉尔的回忆一样的良心重负。经过厨房的时候，他吻了一下丽贝卡的额头。\n　“别胡思乱想了，”他说，“你会幸福的。”\n………………\n（蕾梅黛丝结婚了，我也会收集她的片段）\n喧闹的庆典一直持续到星期一早上，其间唯一不幸的人是丽贝卡·布恩迪亚。这本该也是她的喜事。乌尔苏拉已同意在同一天为她举行婚礼，不料皮埃特罗·克雷斯皮星期五接到的一封信带来了他母亲病危的消息。婚礼推迟了。度埃特罗·克雷斯皮接到信后一个小时即起程前往省城，在路上错过了与母亲的相遇，他母亲星期六晚上准时抵达马孔多，并在奥雷里亚诺的婚礼上献唱了本是为自己儿子婚礼准备的悲伤咏叹调。皮埃特罗·克雷斯皮为了及时赶回自己的婚礼，一路跑瘫了五匹马，但当他星期天午夜时分赶到的时候，能做的只剩下打扫喜事的残烛余烬。从未查出究竟是谁写了那封信。在乌尔苏拉的拷问下，阿玛兰妲气得哭了起来，对着木匠们尚未拆除的祭坛赌咒发誓以证明自己的无辜。\n（来主持结婚的神浦决定在这地方修一座教堂）\n从那以后，神甫担心自己的信念会动摇，就不再去探望他，全心投入教堂的建造以加快进程。丽贝卡重新燃起了希望。她的未来全系于教堂的竣工，因为有个星期天尼卡诺尔神甫来家里吃午饭时，全家人都在席间谈论教堂建成后举行的宗教仪式将是何等庄重堂皇。“最幸运的人是丽贝卡。”阿玛兰妲说。丽贝卡没有听懂她的意思，于是她带着天真的笑容解释：\n　“因为你的婚礼将是教堂落成后举行的第一个仪式。”\n　丽贝卡试图抢先作出评论。以现在的施工速度来看，教堂竣工起码要等十年。但尼卡诺尔神甫看法不同：鉴于信徒们捐赠日益慷慨，完全可以作出更乐观的估计。尽管丽贝卡暗暗生气，连饭都没有吃完，乌尔苏拉还是赞同阿玛兰妲的主意，并捐出一笔可观的款项以加速施工。尼卡诺尔神甫认为再有一笔相同数额的捐赠，教堂就能在三年内竣工。从此，丽贝卡不再和阿玛兰妲说话，确信她的用心并不像表面那样单纯无辜。“我已经手下留情了，”在当晚的激烈争吵中阿玛兰妲回答道，“这三年我都用不着杀你了。”丽贝卡接受了挑战。\n　皮埃特罗·克雷斯皮得知婚礼再次推迟，失望之极，但丽贝卡向他证明了自己的忠贞不渝。“等你准备好，咱们就私奔。”她对他说。然而皮埃特罗·克雷斯皮并不是敢于冒险的人，他不像未婚妻那样性情冲动，视对承诺的尊重为不容挥霍的资本。于是丽贝卡采取了更大胆的举措。一阵神秘的风吹灭了客厅里的灯，乌尔苏拉随即发现这对情侣在黑暗中接吻。皮埃特罗·克雷斯皮窘迫地向她解释说这要归咎于新式煤油灯的质量问题，甚至帮她在客厅里安上了更可靠的照明设施。但又一次不知是灯油出了问题还是灯芯被阻断，乌尔苏拉发现丽贝卡坐在未婚夫的腿上。她不再接受任何借口。她把面包房托付给印第安女人比西塔西翁打理，亲自坐到摇椅上监视情侣的相会，免得那些在自己的青春年代就已过时的花招得逞。“可怜的妈妈，”丽贝卡看着乌尔苏拉在一旁打着哈欠昏昏欲睡的样子，又好气又好笑，“到死也要在这把摇椅上受罪。”皮埃特罗·克雷斯皮天天去察看施工，在过了三个月受监视的爱情生活后终于厌烦了缓慢的工程进度，决定自己出钱给尼卡诺尔神甫补足完工所需的资金。阿玛兰妲并没有慌张。她每天和女友们在长廊里绣花或做编织活计，一边聊天一边酝酿新的计策。她自以为最有效的一招，即取走丽贝卡将嫁衣收入卧室衣柜之前就放好的樟脑丸，却因为估算失误落了空。她是在离教堂完工不到两个月时采取的行动，但随着婚期临近丽贝卡迫不及待地要试穿嫁衣，比阿玛兰妲预计的时间提前了许多。丽贝卡打开衣柜，依次取下包装纸和护衬布，发现从锦缎礼服、织绣纱巾直到橘花头冠都被蛾子蛀成了粉末。她确信当初在包装里放过两把樟脑丸，但这一悲剧似乎纯粹出于偶然，她不敢责怪到阿玛兰妲身上。离婚礼已不到一个月，安帕萝·摩斯科特竟慨然答允在一个星期内为她做出一身新嫁衣。那个阴雨绵绵的中午，当安帕萝抱着一堆泡沫般的织物走进家门让丽贝卡最后一次试衣时，阿玛兰妲几乎要昏厥过去。她瞬间失声，一道冷汗沿脊背下流。漫长的数月里，她一直在恐惧的战栗中等待这一刻的到来。她深信，如果最终找不到阻挠丽贝卡婚礼的办法，到了一切手段用尽的最后时刻，她不会缺乏下毒的胆量。那天下午，安帕萝以无穷无尽的耐心在丽贝卡周身上下别了千万枚别针，丽贝卡则裹在那甲胄般的缎料里热得透不过气来，与此同时，阿玛兰妲多次乱了针脚，扎了手指，但仍以可怕的冷静作出决定：日期定在婚礼前最后一个星期五，方式是在咖啡中加一剂鸦片酊。\n　不料一个更大的障碍突然出现，并且无法挽救，迫使婚礼再次无限期延迟。婚期前一个星期，小蕾梅黛丝半夜醒来，内脏打嗝般撕裂，火热的汁液爆涌浸透全身。三天后她被自己的血毒死，一对双胞胎也横死腹中。阿玛兰妲受到良心的谴责。她曾切切祈求上帝，希望发生某种可怕的事情免得自己向丽贝卡下毒，因此对蕾梅黛丝的死怀有负罪感。那并不是她日夜祈祷所期盼的障碍。\n……………………\n乌尔苏拉吩咐关闭门窗守丧，如非绝对必要不许任何人出入。她还要求一年之内不得高声说话，并将一张蕾梅黛丝的银版照片摆在停放遗体守灵的地方，照片上斜系着一根黑色饰带，前面点起一盏长明灯。此后子孙们一直保持灯火不熄，他们面对着照片上这个身着百褶裙、脚踏白色小靴子、头系蝉翼纱蝴蝶结的小女孩却不免困惑，难以将其与曾祖母的标准像联系起来。阿玛兰妲担负起照顾奥雷里亚诺·何塞的职责。她当作儿子抚养的这个孩子，将会分担她的孤独，缓解她的内疚——由于她向上帝疯狂祈求，鸦片酊误落在蕾梅黛丝的咖啡里。皮埃特罗·克雷斯皮戴着系了黑纱的帽子轻手轻脚走进家门，与一袭黑衣长袖及手、心中仿佛暗暗淌血的丽贝卡默默相会。此时此刻连重议婚期的念头也会被视为大不敬，恋人关系就此永远停滞不前，沦为无人再去理会的倦怠爱情，仿佛昔日为了亲吻而熄灭灯火的情侣已被抛弃，屈从于死神的淫威。方向迷失，希望破灭，丽贝卡又开始吃土。\n丽贝卡与何塞·阿尔卡蒂奥 （又一位与丽贝卡的重要人物出现——何塞·阿尔卡蒂奥。他在小时候跟着来卖东西的外地人走了，现在终于回来了，从以下描写中可见这人“身体很壮”，他应该是家族的第二代，第一代就是何塞元老咯）\n居丧多日后十字绣活动已经恢复，一天下午两点，酷热的死寂中突然有人推开大门。房柱震颤不已，长廊里刺绣的阿玛兰妲及其女友，卧室里吸吮手指的丽贝卡，厨房里的乌尔苏拉，作坊里的奥雷里亚诺，甚至栗树下孤零零的何塞·阿尔卡蒂奥·布恩迪亚，都感到房子在大地的震动中摇摇欲坠。来人是一个身材过人的大汉。他粗壮的胸背几乎挤不进门。他野牛似的脖子上挂着救难圣母像，双臂和胸前覆满神秘的刺青，右手腕上紧紧缠着“十字架婴孩”护符铜手链。他的身体经风吹日晒变成棕褐色，短发竖起好像骡子的鬃毛，下颌坚毅，眼神悲伤。他的腰带比马肚带宽两倍，靴子带护腿和马刺，靴跟钉了铁掌，走到哪里都给人以地震般的战栗感。他拎着几个破旧的褡裢穿过客厅和起居室，像一阵风暴般出现在秋海棠长廊，惊得阿玛兰妲和女友们一动不动，绣花针停在空中。“嗨。”他用疲倦的声音说道，随手将褡裢往缝纫桌上一丢，径直走向家中深处。“嗨。”他向丽贝卡打了个招呼，她看着他从自己卧室门前经过，吓得呆了。“嗨。”他对奥雷里亚诺说道，后者正在作坊工作台前全神贯注地干活。他没在任何人身边停留，直接走向厨房，在那里才第一次停住脚步，结束了从世界另一端起程的旅行。“嗨。”他说。乌尔苏拉瞬间愣住，看着他的眼睛，随即发出一声惊呼，扑过去搂住他的脖子，高兴得又哭又叫。他是何塞·阿尔卡蒂奥。他像离开时一样赤贫，乌尔苏拉还得给他两个比索付雇马的钱。他说的西班牙语掺杂着水手的黑话。家人问他都去了哪里，他回答：“那边。”他把吊床支在为他安排的房间里，睡了三天三夜。醒来后吃了十六个生鸡蛋，便直接去了卡塔利诺的店里，他那超常的身材在女人当中引发了好奇和恐慌。他要求奏乐并请所有人喝甘蔗酒。他打赌说能同时和五个男人掰腕子。“这不可能。”那些人确信无法撼动他的手臂后，不禁发出感慨，“他有‘十字架婴孩’。”卡塔利诺不相信这类角力花样，押上十二比索赌他挪不动柜台。何塞·阿尔卡蒂奥将柜台从原地搬起，举过头顶，又放到大街上。结果出动了十一个男人才把它搬回去。在节庆般的狂热气氛中，他在柜台上展示了自己那令人难以置信的阳物，上面红蓝两色纵横交错，覆满多种语言的刺青。那些女人饥渴地围在他身边，他问谁肯出最高价。最有钱的一个愿出二十比索。他又提议所有女人一起抽签，十比索一个签号。这是个夸张的价格，最红的姑娘一夜也不过挣八比索，然而所有女人都表示同意。她们把自己的名字写在十四张纸条上，放在一顶帽子里，然后每人抽出一张。最后抽到只剩两张了，中奖者将在其中产生。\n　“每人再出五比索，”何塞·阿尔卡蒂奥建议，“我就让你们两个分享。”\n　他以此为生。他曾与一群无国籍的水手一起周游世界六十五次。当晚与他在卡塔利诺店里同床的女人将他赤身裸体带到舞厅，让大家观赏他从前额到后背、从脖颈到脚趾，通身上下没有一丝一毫皮肤没文刺青。他没能融入家庭。他白天睡觉，晚上就去烟花巷赌赛力气。难得几次乌尔苏拉把他拉到餐桌前，他表现得迷人又可亲，特别是当他讲述异国冒险的时候。他曾经遭遇海难，在日本海漂流了两个星期，以死于日晒病的同伴尸体为食，那一次次用海水腌制，又经阳光烤熟的肉质有种甜美的味道。在孟加拉湾一个阳光灿烂的正午，他们的船杀死了一条海龙，他们还在龙腹中发现了一名十字军战士的头盔、搭扣和武器。他在加勒比海见过维克多·休斯的海盗幽灵船，船帆被死亡的阴风扯得七零八落，桅杆被海蠊蛀蚀，它再也找不到瓜德罗普岛的方向。乌尔苏拉坐在桌边哭个不停，仿佛在阅读一封封从未抵达的家书，阅读何塞·阿尔卡蒂奥讲述的英雄业绩和不幸际遇。“家里有这么多房间，我的儿子啊，”她抽泣道，“有那么多吃的都喂了猪！”但在内心深处，她无法把那个被吉卜赛人带走的男孩和这个吃午饭能吃掉半扇乳猪、放屁能令花儿枯萎的巨汉联系起来。其他家人的感觉也是如此。阿玛兰妲听到他在席间如野兽般打嗝，无法掩饰自己的厌恶。阿尔卡蒂奥从未得悉自己的身世秘密，对他刻意博取好感的问长问短，几乎不加理睬。奥雷里亚诺试图重温两人共宿一室的旧日时光，重拾少年时代的默契，但何塞·阿尔卡蒂奥都已忘却，因为海上生涯里有太多事情塞满了记忆。只有丽贝卡一见面就被他征服。那天下午看见他从自己卧室门前经过，她就觉得比起这个呼气好像火山爆发、全家都为之震颤的阳刚化身，皮埃特罗·克雷斯皮不过是个好赶时髦的文弱小子。她寻找一切借口接近他。有一次，何塞·阿尔卡蒂奥肆无忌惮地上下打量着她，对她说：“你很有女人味，小妹妹。”丽贝卡失去了自制力，又开始以往日的狂热吃泥土和墙皮，饥渴地吸吮手指，拇指上甚至都结出了茧子。她呕出混杂有死水蛭的绿色液体。她夜夜不眠，烧热得颤抖，在谵妄中挣扎，直等到凌晨时分整栋房子因何塞·阿尔卡蒂奥的归来而震颤。一天下午全家人都在午睡，她再也无法忍受，去了他的房间。她发现他穿着短裤，醒着躺在用缆绳绑在柱子上的吊床里。她盯着那花饰繁复的巨大身躯大感震惊，不禁想要退回去。“对不起，”她辩解道，“我不知道您在这儿。”她压低了声音，以免惊醒旁人。“到这儿来。”他说。丽贝卡照做了。她站在吊床前，流出冷汗，感到五脏六腑都纠结在一起，而阿尔卡蒂奥用指肚抚摸她的脚踝，然后是小腿肚，然后是大腿，嘴里喃喃地说：“小妹妹，啊，小妹妹。”一股强似龙卷风却又惊人精准的力量将她拦腰举起，三两下扯去内衣，像撕裂一只小鸟一般，她得努力支撑着才不至于死在当场。她感谢上帝让自己拥有生命，随即失去神志，沉浸在由无法承受的痛苦生出的不可思议的快感中，扑腾挣扎于吊床这热气腾腾的泥沼间，喷出的血液被泥沼像吸墨纸一般吸收了。\n　三天后，他们在五点钟的弥撒上结为夫妇。何塞·阿尔卡蒂奥前一天去了皮埃特罗·克雷斯皮的商店，看见他正在给学生上古弦琴课，但并没有把他叫到一边回避学生。“我要和丽贝卡结婚了。”他说。皮埃特罗·克雷斯皮顿时脸色煞白，把琴交给学生，宣布课程结束。等到堆满乐器和上弦玩具的厅里只剩下他们两人，皮埃特罗·克雷斯皮说：\n　“她是您的妹妹。”\n　“我无所谓。”何塞·阿尔卡蒂奥回答。\n　皮埃特罗·克雷斯皮用散发出薰衣草气味的手帕擦了擦额头。\n　“这违背天理，”他解释道，“另外，法律也不允许。”\n　何塞·阿尔卡蒂奥失去了耐性，倒不是皮埃特罗·克雷斯皮所讲的道理，而是他那副苍白的脸色更让人恼火。\n　“去他的天理，”他说，“我来是为了告诉你，不要再费心去问丽贝卡什么。”\n　但当看到皮埃特罗·克雷斯皮眼眶湿润，他粗暴的态度软了下来。\n　“好吧，”他换了一副腔调，“如果您真喜欢我们家，那还有阿玛兰妲呢。”\n　尼卡诺尔神甫在星期天的讲道中申明何塞·阿尔卡蒂奥和丽贝卡不是兄妹。乌尔苏拉视此事为不可想象的失礼，永远不肯原谅。当他们从教堂回来的时候，她禁止这对新人再迈进家门。对她来说，他们就等于死了一样。因此他们到公墓对面租了一间小屋，屋里唯一的家具是何塞·阿尔卡蒂奥的吊床。新婚之夜一只蝎子钻进拖鞋蜇了丽贝卡的脚，她的舌头为此都麻痹了，但这并不妨碍他们度过一个惊世骇俗的蜜月。邻居们因惊醒整个街区的叫声而恐慌——每夜八次，连午睡时段也有三次——祈祷那种肆无忌惮的激情不要侵扰死人的安眠。\n　奥雷里亚诺是唯一关心他们的人。他给他们买了一些家具，并送钱过去，直到何塞·阿尔卡蒂奥恢复常态，开始耕种与家中院子相邻的无主土地。阿玛兰妲却永远无法摆脱对丽贝卡的怨恨，尽管生活为她带来了超出梦想的满足：乌尔苏拉不知如何洗刷耻辱，她主动提出让皮埃特罗·克雷斯皮每个星期二仍来家中共进午餐，后者平和而不失尊严地战胜了挫折。出于对这一家人的尊敬，他在帽子上仍然系着黑纱，并很乐意亲近乌尔苏拉，为她带来异国礼物：葡萄牙沙丁鱼，土耳其玫瑰果酱，还有一次是一条精美的马尼拉大披巾。\n……………………\n（经历了一些时间）\n亲戚中只有何塞·阿尔卡蒂奥和丽贝卡知情，那时候他们与阿尔卡蒂奥的亲密关系与其说是出于亲情，倒不如说是源于同谋间的戚戚。何塞·阿尔卡蒂奥已然低头负起婚姻的重轭。丽贝卡凭着不屈的性格、贪婪的情欲和执著的野心，吸纳了丈夫超常的精力，使他从一个游手好闲、寻花问柳的男人变成一头干活的巨大牲口。他们的家清洁整齐。每天清晨丽贝卡都打开门窗，墓地的风从窗子进自院门出，裹挟着尸骨析出的硝石，在家中的墙壁和家具上都覆了一层泛白的粉末。想吃泥土的饥渴，父母骨殖的咯啦咯啦响声，皮埃特罗·克雷斯皮的优柔寡断激起的厌烦心绪，这些都被抛在了记忆的角落。她不受战乱的影响，从早到晚都在窗边刺绣，等到陶瓷的锅碗瓢盆开始在碗橱里颤抖就起身热饭。过了很久才会出现那几只邋遢的猎犬，然后是脚踏带马刺的高筒靴，肩挎双铳猎枪的巨人，他有时会带回一头鹿，更多的时候是一串兔子或野鸭。\n……………………\n丽贝卡回到孤独 （革命早就开始了，所以才上校逃走）\n　并非所有的消息都是好的，奥雷里亚诺·布恩迪亚上校逃走一年后，何塞·阿尔卡蒂奥和丽贝卡搬进了阿尔卡蒂奥建起的房子。没人知道他阻止行刑的事。新家坐落在广场最好的一角，掩映在一棵巴旦杏树的浓荫里，树上足有三个知更鸟的鸟巢。一扇大门迎送访客，四扇明窗承接阳光，他们就在这房子里安下热情好客的新家。丽贝卡旧日的女伴，包括摩斯科特家四个尚未出嫁的女儿，重新聚在一起刺绣，就像数年前在秋海棠长廊里一样。何塞·阿尔卡蒂奥继续享受掠夺来的土地收益，他的所有权已得到保守党政府的承认。每天下午都可以看见他骑马归来，扛着双铳猎枪，带着猎狗，一串兔子挂在马鞍上。九月的一天下午，眼看暴风雨迫近，他比平时提前回了家。他到饭厅和丽贝卡打过招呼，把狗拴在院中，又将兔子挂在厨房准备晚些时候腌起来，随后去卧室换衣服。丽贝卡事后声称丈夫进卧室时自己正在浴室，丝毫没有察觉。这一说法难以令人信服，但又没有更可信的其他说法，另外谁也想不出丽贝卡会有什么动机谋杀令她幸福的男人。这也许是马孔多唯一从未解开的谜团。何塞·阿尔卡蒂奥刚关上卧室的门，一声枪响震彻全屋。一道血线从门下涌出，穿过客厅，流到街上，沿着起伏不平的便道径直向前，经台阶下行，爬上路栏，绕过土耳其人大街，右拐又左拐，九十度转向直奔布恩迪亚家，从紧闭的大门下面潜入，紧贴墙边穿过客厅以免弄脏地毯，经过另一个房间，划出一道大弧线绕开餐桌，沿秋海棠长廊继续前行，无声无息地从正给奥雷里亚诺·何塞上算术课的阿玛兰妲的椅子下经过而没被察觉，钻进谷仓，最后出现在厨房，乌尔苏拉在那里正准备打上三十六个鸡蛋做面包。\n　“圣母在上！”乌尔苏拉喊了起来。\n　她沿着血流溯源而上，穿过谷仓，经过秋海棠长廊——奥雷里亚诺·何塞正在那里念诵三加三等于六、六加三等于九——又穿过饭厅和一个个房间，径直走到街上，先右拐再左拐到了土耳其人大街，忘了自己还穿着烤面包的围裙和家居拖鞋，来到广场，走进一户从未登过门的人家，推开卧室的门，险些被火药燃烧的气味呛死，发现何塞·阿尔卡蒂奥仰面躺在地上，身下压着刚脱下来的靴子，这就看到了血流的源头，而血已不再从他右耳流出。没发现他身上有任何伤口，也没找到凶器何在。另外也无法除去尸体上呛人的火药味。最初用丝瓜瓤蘸肥皂洗过三遍，然后先用盐和醋、后用草木灰和柠檬汁擦拭，最后浸到一桶碱水里泡了六个小时。经过反复揉搓擦洗，他身上的刺青花纹开始退色。他们不得已想出一个极端的方案，加入辣椒、莳萝和月桂叶用小火煮上一整天，但尸体已经开始腐烂，不得不即刻下葬。他们用一口长两米三、宽一米一，内部以铁板与钢栓加固的特制棺材将他装起来秘密下葬，但仍然在一路经过的街道上留下了气味。尼卡诺尔神甫的肝部肿胀紧绷如鼓，他只能在床上为死者祈福。此后数月，虽然为坟墓砌起层层护板，在其间撒上压实的灰土、锯末和生石灰，墓园依然飘荡着火药味，直到多年以后香蕉公司的工程师在墓上添了一层水泥，那气味才消失。从尸体被抬出的那一刻起，丽贝卡就紧闭家门，过上了活死人的生活。她将自己包覆在高傲的厚壳里，尘世间的一切诱惑都无法将其打破。她出过一次家门，那时她已进入晚年，脚下一双古银色鞋子，头上一顶缀有小花的女帽。那时正值传言中“流浪的犹太人”经过村庄带来酷暑，飞鸟都热得撞破纱窗死在卧室里。最后一次有人看到她的时候，她一枪命中，当场击毙一个企图撬门入室的小偷。除了阿尔赫尼妲，她的女仆和心腹，再也没人与她有过联系。人们一度听说她给被她视作表兄的主教写过信，但从未听说她收到过回音。她已被镇上的人遗忘。\n（丽贝卡开始封闭，另外火药味的描述很有趣）\n…………\n（上校打回来了）\n最后出于礼貌，他搁下手头的事务，抽出一个小时去见丽贝卡通知他的决定。\n　在屋内的阴影中，那位曾经见证他被压抑的爱情，并以自己的执拗救过他性命的孤零孀妇已变成往昔的幽灵。她遍体着黑直到指节，心如死灰，对战事几乎一无所知。奥雷里亚诺·布恩迪亚上校感觉她骨头的磷光从皮肤透出，感觉她在重重鬼火间行走，而凝滞的空气中还能隐隐闻到火药的味道。他开始劝说她节哀除丧，改善屋内通风，不要再为何塞·阿尔卡蒂奥的死迁怒整个世间。然而丽贝卡已经看破一切浮华。她曾经在泥土的味道中，在皮埃特罗·克雷斯皮芬芳的书信里，在丈夫如狂风暴雨的床榻上徒劳地寻寻觅觅，最终却在这个家中找到了安宁。在这里，记忆因思绪无情的力量化为实体，如同活人一般在幽闭的房间里游荡。她躺在藤摇椅里，望着奥雷里亚诺·布恩迪亚上校，仿佛他才是一个往昔的幽灵。甚至听到何塞·阿尔卡蒂奥强夺的土地都将归还原主，她也不显丝毫激动。\n　“你想怎样就怎样吧，奥雷里亚诺。”她叹息道，“我一直认为，你是个无情的人，现在更确定了。”\n……………………\n（这里的上校已经是绕了一大圈又回来的时候了）\n数月过去，奥雷里亚诺·特里斯特已为人们所熟识和喜爱，开始四处寻找房屋准备把自己的母亲和妹妹——不是上校的女儿——接来。他看上了广场一角那座似已废弃的破败宅子，便打听主人是谁。有人告诉他那房子没有主人，过去曾经住过一位以泥土和墙皮为食的孤单寡妇，她晚年时别人在街上只见过她两次。她头戴缀有细小假花的女帽，脚穿古银色的鞋子，穿过广场到邮局寄信给主教。他们说陪伴她的只有一个残忍的女仆，那女人杀死猫狗及其他一切闯入家中的动物，并把尸体抛到街上，让市镇上的人都闻得到腐烂的恶臭味。自从最后一只动物的尸体在阳光下晒干后，又过了很久，所有人都确信那女主人和她的女仆早在战争结束前就已去世，房子迄今未倒不过是因为近年来没赶上严酷的冬季，也没遇上能使房倒屋塌的暴风。铰链因锈蚀而断裂，门板靠成团的蛛网勉强支撑，窗框受潮卡死，地面长满杂草野花，其间裂缝成为蜥蜴和各种爬虫的巢穴，一切似乎都证明这里至少有半个世纪没人居住过。对冲动的奥雷里亚诺·特里斯特而言，并不需要见到这些迹象才会采取行动。他用肩膀撞了下大门，蛀蚀的木板便寂然倒塌，灰尘四溢，白蚁巢碎屑飞扬。奥雷里亚诺·特里斯特伫立在门口不动，等到尘雾落定，立时看见了客厅中央那位瘦骨嶙峋的女人。她穿着上个世纪的衣服，光秃的头顶上稀疏几根黄发，一双大眼睛仍残存着昔日的美丽，只是最后的希望之光已在其间熄灭，脸上的皮肤因孤寂而干裂。奥雷里亚诺·特里斯特被眼前非人间所有的景象震慑，险些没有察觉到那女人正用一把老旧的军用手枪指着他。\n　“抱歉。”他含糊地低声道。\n　她在堆满破烂的客厅中央一动不动，一点点仔细打量这肩宽背厚、额头有灰烬刺青的大汉。她透过尘雾看到他站在往昔的薄雾中，背上斜挎着双铳猎枪，手里拎着一串兔子。\n　“慈悲的上帝啊，”她低声惊叹道，“这不公平，现在又让我想起这些！”\n　“我想租房。”奥雷里亚诺·特里斯特说。\n　那女人举起手枪，稳稳瞄准他额间的灰烬十字，毅然决然地扣紧扳机。\n　“请出去。”她下令道。\n　当天晚上吃饭时，奥雷里亚诺·特里斯特向家人讲起自己的遭遇，乌尔苏拉难过地哭了起来。“神圣的上帝啊，”她双手抱头喊道，“她还活着！”时光流逝，战事频仍，加上平日里无数的不幸，她都把丽贝卡给忘了。自始至终清楚地知道她还活着并在蛆虫窝里腐烂的人，只有日渐衰老却毫不心软的阿玛兰妲。当天亮时心中的寒意将她从孤枕上唤醒，她会想起她；当她用肥皂擦洗自己凋零的乳房和枯萎的腹部，当她穿上老年人雪白的细棉布裙和胸衣，当她更换手上缠裹赎罪伤痕的黑纱，都会想起她。无论何时，或睡或醒，从最庄重到最卑下的时刻，她都会想起丽贝卡，因为孤独已经为她筛选记忆，将生活在她心中累积的无数垃圾尽行焚毁，并净化、升华了其他记忆，即那些最苦涩的记忆，使其永远存留。从她那里美人儿蕾梅黛丝知道了丽贝卡的存在。每当她们路过那幢破败的房子，她都会讲起丽贝卡一桩负心的事件，一个出丑的故事，想借此让侄女分享自己日渐衰竭的怨尤，并使积怨在她死后延续。但她没能成功，因为蕾梅黛丝对一切激烈的情感都具有免疫力，遑论他人恩怨。乌尔苏拉经历了与阿玛兰妲截然相反的过程，她记忆中的丽贝卡已经被净化，那个和父母的骨殖袋一起被送来的小女孩令人怜惜的形象已经掩盖了大逆不道脱离家庭的那段过往。奥雷里亚诺第二决定接她回家好生照料，但他的好意遭到丽贝卡的断然拒绝。她辛苦多年忍受折磨好不容易赢得的孤独特权，绝不肯用来换取一个被虚假迷人的怜悯打扰的晚年。\n　二月里，奥雷里亚诺·布恩迪亚上校的十六个儿子归来时额上仍带着灰烬十字的印记。奥雷里亚诺·特里斯特在欢闹中提起丽贝卡，于是他们在半天内就修复了房子外观：更换门窗，给立面漆上欢快的颜色，加固墙壁，重铺水泥地面。但他们没能得到许可进行室内装修。丽贝卡甚至没在门口露面。她任凭他们七手八脚完成了工程，随后估算了花销，让一直陪伴自己的老女仆阿尔赫尼妲送去一把在最后一场战事结束后就不再流通，而她以为还通用的硬币。这时人们才明白她与世隔绝到了何种程度，也知道只要她一息尚存，便不可能将她从顽固的自闭中解救出来。\n丽贝卡的结局 （死于乌乌尔苏拉死的那年底）\n丽贝卡死于那年年底。毕生服侍她的女仆阿尔赫尼妲请求当局强行打开卧室的房门，她的主人已经在里面关了三天。人们看到她躺在孤寂的床榻上，像虾米般缩成一团，头发因生癣而落尽，大拇指含在嘴里。奥雷里亚诺第二负责料理了丧事，并打算把房子修葺好卖掉。然而那房子已破败得无可挽救，墙皮刚抹好即纷纷脱落，刷上再厚的灰浆也无济于事，只能眼看着杂草穿透地面、蔓藤侵蚀椽柱。\n我的感觉 自己对丽贝卡印象深刻的很大一部分原因是丽贝卡吃土吧。通过吃土来逃避内心的情感，想想就感觉很刺激人，吃土的味道…………ennnnn。另外还有就是最后她回到一人的生活也挺让我印象深刻，前半生激情了那么久，依靠吃土回避感情，最终却通过这样的方式找到了内心的平静，谁杀死了何塞？原因只可能是自己自杀或者被丽贝卡杀了，我认为应该是丽贝卡杀的，和阿玛兰旭一样相似的人啊~注孤独~然后何塞死后强烈的火药是不是代表丽贝卡的什么东西呢？理解不了。\n","date":"2021-06-13","permalink":"/posts/literature/rebeca/","series":[],"tags":[""],"title":"丽贝卡的一生"},{"categories":["数学类"],"content":"阅读本篇对考试没有什么帮助，感兴趣就随便看看，看之后反而可能会学不懂概率，因为用的符号有些不一样~\nPreface 这学期排课有概率论与数理统计，其实每次学这些课程的时候都会想一些乱七八糟的东西，而且基本上和正常考试内容不沾边，属于浪费时间游玩的部分。\n注意，如果数学公式没有渲染出来需要刷新一下。推荐使用大屏幕观看，左边有目录。另外有的公式太长了，手机也放不下。补：刚刚我换了$\\KaTeX$渲染，这下应该没问题了，网站加载速度也应该变快了。编辑公式时出了一些问题，千万不能用换行符！\n更新日志  2021-05-18 01:30:20创建，2021-05-25 15:37:44发布，不想写了，以后有时间再写。兴趣文如果当成了作业性质就变化了不是吗，所以还是有兴趣时再写吧。 2021-06-05 22:27:38:要期末了，更没时间了！而且写这个根本复习不了概率！懒癌发作死ね！要不要烂尾了呢？ 2021-06-10 17:41:16：还是不写了，因为我懒了，还有就是第一章+一点点第二章字数都已经超过6000字了，写下去会没完没了，还有个重要原因是写这个根本对复习没有什么帮助！  一、概率结构 概率映射是这样的映射：\n$$ A\\ \\overset{P}{\\rightarrow} P(A) $$\n$A$为任意事件，$P(A)$为事件$A$的概率。其中集合A在概率论中又分为单个随机试验形成的样本空间与多个随机试验形成的样本空间，这和之后的独立性相关。我们在讨论独立性之前假设$S$为单个随机试验形成的样本空间。\n于是，要讨论一般的概率结构，就需要讨论集合运算$A$，概率运算$P(A)$，概率映射$P$。\n1.一点代数风味的集合运算 I 统一符号 教材中的出现的集合运算有$\\bigcup$，$ \\bigcap$，$—$，$\\overline{A}$ ，$AB$。为了统一和更有代数的感觉，本篇统一将 ”$\\bigcup$“ 写作 ”$+$“ ，将”$ \\bigcap$“写作”$\\ \\cdot\\ $ “，并且通过这两个基本运算规定其他运算。\n先来看看“$+$”运算：\n$$ \\begin{aligned} \u0026amp;A+B = B+A \\\\ \u0026amp;A+(B+C) = (A+B)+C \\\\ \u0026amp;A+B=A+C \\rightarrow B\\cdot\\overline{A} = C\\cdot \\overline{A} \\\\ \\\\ \u0026amp;for\\ any\\ A\\subset S,A+\\varnothing = A \\\\ \u0026amp;if\\ A+B = \\varnothing \\ ,\\ then\\ A = B=\\varnothing \\\\ \\\\ \u0026amp;A+\\overline{A} = S \\\\ \u0026amp;if\\ A+B =S\\ ,\\ then\\subset B\\subset S \\\\ \\end{aligned} $$\n我们可以看出，$+$运算具有交换律，结合律，有类似消去律的性质，以$\\varnothing$作为单位元，且没有逆元，如果以$S$作为单位元，没有唯一的逆元，但有个比较特殊的逆元。\n再来看看”$\\ \\cdot\\ $“运算：\n$$ \\begin{aligned} \u0026amp;A \\cdot B = B \\cdot A\\\\ \u0026amp;A \\cdot (B \\cdot C) = (A \\cdot B) \\cdot C\\\\ \u0026amp;A \\cdot B = A \\cdot C \\rightarrow A \\cdot \\overline{B} = A \\cdot \\overline{C}\\\\ \\\\ \u0026amp;for\\ any\\ A\\subset S\\ ,\\ A \\cdot S = A\\\\ \u0026amp;if\\ A\\cdot B = S\\ ,\\ A=B=S\\\\ \\\\ \u0026amp;A\\cdot\\overline{A} =\\varnothing \\\\ \u0026amp;if\\ A\\cdot B =\\varnothing\\ ,\\ then\\varnothing\\subset B\\subset \\overline{A}\\\\ \\end{aligned} $$\n可以看出，”$\\ \\cdot\\ $“运算具有交换律，结合律，类似的类似的消去律，以$S$作为单位元，没有逆元。如果以$\\varnothing$作为单位元，没有唯一逆元，但有个比较特殊的逆元。\n在集合中大小的关系就是子集的关系。对于任意两个集合，他们之间不一定是子集关系。\n II 定义逆事件，转化差事件 从上面可以看出这两种集合运算都满足一些性质，但又不完全满足我们熟悉的代数特征，并且他们两者互相有交叉。接下来我们先把$-$与$\\overline{A}$表达为这两种基本运算的形式，并看看这两种基本运算之间的反应。\n首先，对于逆事件$\\overline{A}$，我们有定义：对一给定$A$，总存在$B$，有$A+B=S$，且$A\\cdot B=\\varnothing$，我们将这个$B$记作$\\overline{A}$，称为$A$的逆事件。对于一个事件的逆事件，是通过这两种基本运算定义的，想要证明一个事件是逆事件，只需要按照上述定义证明即可。\n其次，对于减法\u0026quot;$-$\u0026ldquo;运算，我们将其表示为基础运算的形式：$A-B=A\\cdot \\overline{B}=A \\cdot \\overline{AB} = A- AB$。证明留到后面介绍了基本定理之后。其实将减法转化为交运算在做题中并不常用，更多是利用公式转化为无关联的并运算。\n III 基础定律和一些证明 下面是两个基础集合运算以及由此定义的补集他们之间的运算关系，在集合化简中起着非常基础的作用。特别说明，我这里取的$+$与$\\cdot$具有误导性，实际上这两种运算他们之间是平等的，没有优先级的高低，所以要注意括号。\n$$ \\begin{aligned} \u0026amp;A+(B\\cdot C) = (A+B)\\cdot (A+C) \\\\ \u0026amp;A\\cdot (B + C) = (A\\cdot B) + (A\\cdot C) \\\\ \u0026amp;\\overline{A+B} = \\overline{A}\\cdot \\overline{B} \\\\ \u0026amp;\\overline{A\\cdot B} = \\overline{A} + \\overline{B} \\\\ \\end{aligned} $$\n这些运算定律都可以拓展到$N$元情况，他们的形式不变。前两个的证明利用$A\\subset B$，$B\\subset A$，$A=B$即可。后面两个不常见的，我利用逆事件的定义证明一下第3条，第4同理。\n证明第3条：由\n$$ \\begin{aligned} (A+B)\\cdot (\\overline{A}\\cdot \\overline{B})\u0026amp;=(A\\cdot\\overline{A}\\cdot\\overline{B}) + (B\\cdot \\overline{A}\\cdot\\overline{B}) \\\\ \u0026amp;= \\varnothing + \\varnothing = \\varnothing \\\\ (A+B)+(\\overline{A}\\cdot\\overline{B}) \u0026amp;= (A+B+\\overline{A})\\cdot(A+B+\\overline{B}) \\\\ \u0026amp;= S \\cdot S=S\\\\ \\end{aligned} $$\n可知，$\\overline{A}\\cdot \\overline{B}$满足$A+B$逆的定义，得证。\n由于概率的计算核心是围绕概率定义中的可列可加性，需要将复杂的事件分开为互异的事件，也就是$A\\cdot B=\\varnothing$，所以我们也补上两个很重要的相关式子： $$ \\begin{aligned} \u0026amp;if\\ X\\cdot Y=\\varnothing\\ ,\\ XBCD \\cdot YEFG = \\varnothing \\\\ \u0026amp;A = A\\cdot S = A\\cdot (B+\\overline{B}) = (A\\cdot B) + (A\\cdot \\overline{B}) \\\\ \\end{aligned} $$\n第一个式子表明，两个事件中只要包含了一对互斥事件（一般情况为两事件为对立事件），这两个事件一定互斥。第二个式子用于将一个事件拆分了两个互斥事件。\n现在我们利用上面的基本定律证明一些特别的式子。\n①$A-B=A\\cdot \\overline{B}=A \\cdot \\overline{AB} = A- AB$\n证明：\n$$ \\begin{aligned} A-B\u0026amp;=A\\cdot \\overline{B}\\\\ \u0026amp;= (A\\cdot \\overline{B})+ \\varnothing\\\\ \u0026amp;=(A\\cdot \\overline{B})+ (A\\cdot\\overline{A})\\\\ \u0026amp;=A\\cdot (\\overline{A}+\\overline{B})\\\\ \u0026amp;=A\\cdot \\overline{AB} = A -AB \\\\ \\end{aligned} $$\n②$A+B = A+\\overline{A}B = B + \\overline{B}A = \\overline{A}B + AB + A\\overline{B}$\n证明：\n$$ \\begin{aligned} A + B \u0026amp;=(A+B)\\cdot S\\\\ \u0026amp;= (A + B) \\cdot (A+\\overline{A}) \\\\ \u0026amp;= A+ (\\overline{A}\\cdot B)\\\\ \u0026amp;=A +\\overline{A}B\\ (=A+(B-A)) \\\\ \\\\ A+B \u0026amp;=(A+B)\\cdot S\\\\ \u0026amp;=(A+B)\\cdot (B+\\overline{B})\\\\ \u0026amp;=B+(A\\cdot \\overline{B})\\\\ \u0026amp;=B+A\\overline{B}\\ (=B+(A-B)) \\\\ \\end{aligned} $$ 对于第三个，只需要前两个中任意一个后面补充$\\cdot (A+\\overline{A})$或者$\\cdot (B+\\overline{B})$即可证明。\n2.概率运算 概率$P(A)$实际上是一个范围为$\\left [0,1 \\right ]$的实数（也许更大？超出我的知识范围外了），所以概率的代数性质一部分继承与实数域性质但又有很大的不同，这里只写一部分比较特殊的：\n$$ \\begin{aligned} \u0026amp;for\\ any\\ P(A)\\ ,\\ P(A)+0 = P(A) \\\\ \u0026amp;if\\ P(A) + P(B) = 0\\ ,\\ P(A)=P(B)=0\\\\ \\\\ \u0026amp;for\\ any\\ P(A)\\ ,\\ P(A)\\cdot 1 = P(A) \\\\ \u0026amp;if\\ P(A)\\cdot P(B)=1\\ ,\\ P(A)=P(B)=1 \\\\ \\end{aligned} $$\n虽然概率的加运算与乘运算都没有逆元，但是概率中却有减法与除法。同时，概率的加法与乘法在很多情况下是没有意义的，当两个事件互异时，加法表示两个事件和的概率，不互异时则没有意义；乘法则要求更多，普通情况没有任何意义，只是两个实数相乘，当两个事件独立时，概率相乘表示两事件同时发生的概率。同样的对于减法与除法。\n所以，由于概率定义的限制，我们经常用各种无意义的或是大于1的，或是负数的量对概率化简，转化求解有意义的概率量。为什么会这样呢？关键是条件概率。虽然条件概率的定义中出现了普通概率，条件概率$P(\\cdot\\ |A)$和普通概率$P(\\cdot \\ )$的地位是同等的。我们需要将条件概率的$\\frac{P(AB)}{P(A)}$看作是一个整体，它和普通概率互不干涉，条件概率中事件$A$是固定的，所以它和普通概率都满足概率的定义。所以在普通概率中，是没有乘法和除法的，凡是出现了乘法除法，一定和条件概率相关，那么事件本身的范围就不局限于单个随机试验了（除了特殊情况如$\\varnothing$,$S$），比如相互独立。\n所以现在我们来看看条件概率$P(\\cdot\\ |A)$，没什么好写，都一样，因为都满足的是概率的定义，所以推导出来的都一样。\n那么乘法呢？不是将条件概率看作整体吗？如何得来？其实同样的问题减法也是如此。这个问题我想和外面平常生活中可以用减法一样，生活中大部分时间负数是无意义的，但是同样可以使用减法，是因为整个系统建立在整数域的基础上，只是有范围限制。\n3.概率映射 概率映射$P$是概率中的关键，在教材中，通过概率的定义可列可加性，化简出互异的事件来将概率化简，这里我们将采用教材中对概率的定义化简，后面一节将尝试通过重定义概率，使得化简过程不一样点。\n首先先写一下比较特殊的映射： $$ \\begin{aligned} \u0026amp;P(A+B)=P(A)+P(B) 当A,B互异 \\\\ \u0026amp;P(AB) =P(A)P(B) 当A,B独立\\\\ \\end{aligned} $$ 这两个映射遵从了这样的原则：$\\varphi (ab) = \\varphi (a)\\varphi (b)$。\n上面这两个式子在概率化简中占核心地位，我们化简其实就是围绕这两个公式，将事件转化为互异事件，当然独立事件只有题目声明或可以判断才能肯定（互异不一定独立，独立一定互异）。\n教材中通过概率的可列可加性推导出了全部概率公式。这里我们推导一些公式，并且观察观察。\n①$P(A-B)=P(A)-P(AB)=P(A-AB)$\n$$ \\begin{aligned} P(A)\u0026amp;=P(A\\cdot S)\\\\ \u0026amp;=P(A\\cdot(B+\\overline{B}))\\\\ \u0026amp;=P((A\\cdot B)+(A\\cdot\\overline{B}))\\\\ \u0026amp;=P(AB)+P(A-B)\\\\ \\end{aligned} $$ 所有的减法都不能直接推导，只能转化为加推导，负概率是没有意义的。那为什么还有负概率呢？你开心就好。这里减法也是很神奇，也许我们可以建立一支减法军团？后面试试\n②$P(A+B)=P(A)+P(B)-P(AB)$\n$$ \\begin{aligned} P(A+B) \u0026amp;=P(A+\\overline{A}B) = P(A)+P(\\overline{A}B)\\\\ \u0026amp;=P(A)+P(A-B)\\\\ \u0026amp;=P(A)+P(B)-P(AB)\\\\ \\end{aligned} $$\n同样的有减法，通过之前的式子替换。\n③$P(\\overline{A})=1-P(A)$\n这条就不证明了\n上面这三个式子是关于普通概率的式子了，下面我们开始证明条件概率的式子。条件概率中的定义式，乘法定理，全概率公式，贝叶斯公式这里不再重复写出了，我们主要看看“独立性”关系。独立性正如之前所说的，两个事件前提就是不能扯上关系，也就是不能同在一个样本空间上，我们来证明一下：\n①如果两不为空的事件$A$，$B$在一个样本空间上，他们一定不独立\n证明：如果$A$和$B$在一个样本空间上，他们一定有下列关系之一： $$ \\begin{aligned} \u0026amp;A\\cdot B = \\varnothing \\\\ \u0026amp;A\\cdot B \\neq \\varnothing\\\\ \\end{aligned} $$ 对于第一种情况，有$P(AB)=0\\neq P(A)P(B)$。对于第二种情况，有$P(AB)=P(A)+P(B)-P(A+B)=$（发现在某种特殊情况下成立）\n条件概率还有其他性质：\n②$P(B|A)+P(\\overline{B}|A) = 1$\n③如果$A$,$B$相互独立，那么$\\overline{A}$与$B$，$A$与$\\overline{B}$，$\\overline{A}$与$\\overline{B}$相互独立\n④对一组相互独立的事件作运算，所得的新事件仍然独立。\n⑤当$A$,$B$独立时，有$P(B|\\overline{A})=P(B|A)$\n我们可以由这条推出当$A,B$独立时，$P(B|A)+P(\\overline{B}|\\overline{A})=1$\n其实②③⑤都可以通过条件概率定义推出，我比较感兴趣③，下面我来证明一下③：\n证明：首先需要清楚条件，对于$A_i,i=1,2,\\dots$，有$P(\\sum_m^n A_k) = \\sum_{m}^{n}P(A_k)$，$m\u0026lt;n,m,n\\in Z^+$（这里渲染有问题，目前没有解决），所以我们只需要将基础运算组合独立证明然后再说明他们组合后即可完成证明\n4.自己重新定义概率 教材中概率的定义是这样的，只需要满足这三条即可称为概率：\n $1^{o}$非负性：对于每一事件$A$，有$P(A) \u0026gt; 0$.\n$2^{o}$规范性：对于必然事件$S$，有$P(S)=1$.\n$3^{o}$可列可加性：设$A_1$,$A_2$,$A_3$,$\\dots$是两两不相容的事件，即对于$A_{i}A_{j}=\\varnothing$,$i\\neq j$,$i$,$j=1,2,\\dots,$有$P(A_1+A_2+\\dots)=P(A_1)+P(A_2)+\\dots$\n 最重要的是第三条，教材和做题中核心思想就是将事件分解为不相容的事件，之后通过这一公式化简概率。这个条件看起来非常合理，也很容易理解，可以说是一个人们默认的东西，但是之前我们列过，集合有两种基本运算，交和并，这里只用了交定义概率，并作控制，这是不是对并有点太不公平了呢？明明我们两地位相同不是吗？气抖冷！！！（只是玩笑）下面我就来尝试利用并来定义概率，主要还是受到了普通概率公式①的启发，当然只是重新定义第三条，前两条在概率中都是根基性的，怎么改？改不了。\n I 重新定义 首先对集合减法说明一下，之前减法是二元的：$A-B=A\\cdot \\overline{B}$。现在我们需要把减法扩充到$N$元。公式： $$ \\begin{aligned} A-B_1-B_2-\\dots = A\\cdot\\overline{B_1}\\cdot\\overline{B_2}\\cdot\\dots \\end{aligned} $$\n减法很符合我们的预期，就和加法一样，其实教材中的可列可加性就是将互不相关的“块”加起来，通过Venn图想象就知道了，所以我的思路即是做减法，将互不相关的块减去即可，这个过程其实就是举一反一罢了。\n概率条件$3^{o}$：$P(A-B_1-B_2-\\dots) = P(A)-P(AB_1)-P(AB_2)-\\dots$，对于$i$,$j=1,2,\\dots$有$B_{i}B_{j}=\\varnothing$\n这个式子很符合常识，和可列可加性一样的符合常识。我们可以利用普通概率公式①将减法同交运算联系起来，下面我们证明我们定义的第三条概率和可列可加性是一回事：\n证明：可列可加性是“可列可减性”的充分必要条件\n充分性：假设可列可加性成立，利用普通概率公式①，将$B$替换为两两互斥的$B_1+B_2+\\dots$，有： $$ \\begin{aligned} P(A-(B_1+B_2+\\dots))\u0026amp;=P(A)-P(A(B_1+B_2+\\dots))\\\\ \u0026amp;=P(A)-P(AB_1)-P(AB_2)-\\dots\\\\ \\end{aligned} $$\n必要性：假设可列可减性成立，将减法项移项得： $$ \\begin{aligned} P(A-B_1-B_2-\\dots)+P(AB_1)+P(AB_2)+\\dots = P(A) \\end{aligned} $$ 我们知道$B_i$之间是互斥的，而由于$A-B_1-B_2-\\dots$中对任意$B_i$交运算的$B_i$，由之前集合运算的知识，我们知道左边事件两两互斥，现在令$A-B_1-B_2-\\dots=C$，即得： $$ \\begin{aligned} P(C+B_1+B_2+\\dots)=P(C)+P(B_1)+P(B_2)+\\dots，事件两两互斥 \\end{aligned} $$\n这样我们完成了，他们两是一个东西。而普通概率和条件概率都满足这个条件。\n那么接下来模仿教材通过“可列可减性”推导概率映射的基本性质。\n II 推导性质 ①$P(\\varnothing)=0$ 证明：令$A,B_1,B_2,\\dots-\\varnothing$，有$P(\\varnothing)=P(\\varnothing)-P(\\varnothing)-\\dots $，化简即得$P(\\varnothing)=0$\n②有限可减性\n③设$A,B$是两个事件，若$A\\subset B$，则有$P(B-A)=P(B)-P(A),P(B)\\geqslant P(A)$\n④对于任一事件$A$，$P(A)\\leqslant 1$\n⑤对于任一事件$A$，有$P(\\overline{A})=1-P(A)$\n证明：令$A=S$，$B_1=A$，$B_i=\\varnothing, i\\neq 1$，则有：$P(S-A)=P(\\overline{A})=P(S)-P(SA)=1-P(A)$\n⑥对于任一两事件$A,B$，有$P(A+B)=P(A)+P(B)-P(AB)$\n证明：令$A=A+B$,$B_1=B$,$B_i=\\varnothing$,$i\\neq 1$，得到： $$ \\begin{aligned} P((A+B)-B)=P(A+B)-P(B) \\end{aligned} $$ 由$(A+B)-B=(A+B)\\overline{B}=A\\overline{B}=A-B$，得： $$ \\begin{aligned} P(A-B)=P(A)-P(AB)=P(A+B)-P(B) \\end{aligned} $$ 移项，证毕。\n III 尝试做题 我们利用减法的思想能不能像加法一样做题呢？这里我拿了一题作尝试，是可行的。其实为了用减法，只需要将所有的并运算通过这个式子转化为减法即可：$P(A-B)+P(B)=P(A+B)$。具体我不想写了……写这个东西消耗的时间比我想象中的要长，我还是想快点结束。\n二、随机变量和分布函数 1.随机变量 为了明确一下随机变量的定义，首先我将教材中的几个定义拿出来：\n 随机试验：满足①相同条件可以重复进行②事先明确试验的所有可能结果③试验前不能确定哪一个结果出现。\n样本空间：随记实验$E$的所有可能结果组成的集合成为E的样本空间，记为$S$。\n样本点：样本空间的元素，即E的每个结果，称为样本点。\n$e$代表样本空间的元素，而将样本空间记成$\\left \\{ e \\right \\}$\n随机变量：设随机试验的样本空间为$S=\\left \\{e\\right \\}$，$X=X(e)$是定义在样本空间S上的实值单值函数，称$X=X(e)$为随机变量\n二维随机变量：设$E$是一个随机试验，它的样本空间是$S=\\left \\{e\\right \\}$，设$X=X(e)$和$Y=Y(e)$是定义在$S$上的随机变量，由它们构成的一个向量$\\left (X,Y \\right )$，叫做二维随机变量。\n 看起来蛮融洽的，但是有一个地方让我很困惑。首先，随机试验一定有结果，有动作，但是解读方式可以不同。所以，$S$中的所有元素都是有的结果，而不能是一个对象，比如$S$中的元素不能是3枚硬币，不能是一群人这种对象，而应该更具体些。所以我觉得教材关于二维随机变量的叙述有点问题，教材中在二维随机变量中举了一例（p61）：\n 样本空间：$S=\\left \\{e \\right \\} = \\left \\{ 某地区的全部学龄前儿童\\right \\}$\n 是有问题的。\n并且明确一下，普通的事件，就是对单一试验样本空间的单一解读，这个解读呢可以有一定关系，比如几次硬币朝正，也可以没有现实意义上的关系，我就想把这几个东西拉到一起形成一个事件，命名为我的事件也没问题，随机变量就是对样本空间元素的单一解读的数据抽象，数据到底取什么值，一些时候和现实意义有关，如朝正的次数1次2次，一些时候也无关，比如我随便取个数行吗？我觉得也行，没违反定义就行。而多元随机变量，有可能是单一试验样本空间的多种解读，也有可能根本就不是从一个随机试验出来的（当然这和教材的定义有驳，但确实是可以这么研究的）\n2.分布函数 I 分布函数的性质 当我们将事件转化为数字后，就可以用分析来研究概率了。而分布函数就是研究概率最重要的一个东西了。随机变量分为离散和连续还有别的，分为单元和多元，这在分布函数中都有体现，比如不连续的分布函数肯定不是连续型随机变量，有可能是离散或者混合的；分布函数的自变量和研究的随机变量的数目是对应的，有几个随机变量，就最多有几个自变量。现在我们来看看分布函数的基本性质：\n $F(x)$是$x$的单调不减 $F(x)$右连续 $F(-\\infty )=0$,$F(+\\infty )=1$  只需要满足以上3条，这个函数就是一个随机变量的分布函数！这表示我们可以随便构造满足条件的函数，然后来猜猜他对应什么随机变量。\n概率分布（分布律）和概率密度需要满足的条件：\n $\\{p_i\\}$是概率分布 $\\Leftrightarrow $ $p_i \\geq 0$，且$\\sum_{i}p_i = 1$ $f(x)$是概率密度 $\\Leftrightarrow$ $f(x) \\geq 0$，且$\\int_{-\\infty }^{+\\infty }f(x)dx = 1$   II 一些教材中的特殊分布函数 为了能更好地大展身手，我们先来看看教材中的分布函数，只是简单的列出来，当然离散的：\n①$X\\sim U(a,b)$： $$ F(x)=\\left\\{ \\begin{aligned} \u0026amp;0 \\ \\ , \u0026amp; \u0026amp; {x\u0026lt; a}\\\\ \u0026amp;\\frac{b-a}{x-a} \\ \\ , \u0026amp; \u0026amp; {a\\leq x \u0026lt; b}\\\\ \u0026amp; 1\\ \\ , \u0026amp; \u0026amp; {x \\geq b}\\\\ \\end{aligned} \\right. $$ ②$X$服从参数为$\\theta $的指数分布 $$ F(x)=\\left\\{ \\begin{aligned} \u0026amp;1-e^{-x/\\theta} \\ \\ , \u0026amp; \u0026amp; {x\u0026lt; a}\\\\ \u0026amp;0 \\ \\ , \u0026amp; \u0026amp; {其他}\\\\ \\end{aligned} \\right. $$ ③$X\\sim N(\\mu,\\sigma^2)$ $$ F(x)=\\frac{1}{\\sqrt{2\\pi }\\sigma}\\int_{-\\infty }^{x}e^{-\\frac{(t-\\mu)^2}{2\\sigma^2}}dt $$ ④$(X,Y)\\sim N(\\mu_1,\\mu_2,\\sigma_1^2,\\sigma_2^2,\\rho )$\n公式太长不写了\n离散型的概率公式也写出来，虽然不是分布函数，但是对我们构造函数也有帮助：\n⑤$X\\sim b(n,\\rho)$ $$ P\\{X=k\\} = \\binom{n}{k}p^k q^{n-k} $$ ⑥泊松分布 $$ P\\{X=k\\}=\\frac{\\lambda^k e^{-k}}{k!} $$\n可以看到连续型本质上都是初等函数，而离散型是混有阶乘的初等函数\n III现在来构造吧 利用分布律，概率密度，分布函数需要满足的条件构造一些函数。这里主要是给一点思路，有兴趣的话可以继续研究，我想快点结束文章了。。。花的时间有点久，或许以后没事干了可以把响应函数的性质给补充一下，现在大致就是概览吧。\n①多项式$f(x)=a_n x^n + a_{n-1}x^{n-1}+\\dots + a_1 x^1 + a_0$\n对于离散型，假设随机变量范围是$X=12,\\dots,N$，当多项式最高次幂为0时，随机变量每一项的概率都为常数$\\frac{1}{N}$；当多项式最高次幂为1时，随机变量每一项概率成线性变化，对于固定的$N$，系数需满足$a_1\\frac{N(N+1)}{2}+a_0 N = 1$；其他的就不写了，反正是根据函数变化。\n对于连续型，假设随机变量范围是$[a,b]$，当多项式最高次幂为0时，就是均匀分布；当多项式最高次幂为1时\u0026hellip;\n②其他有理函数\n③自然指数\n④自然对数\n⑤三角函数\n3.无记忆性 4.函数分布？ Reference [1] 盛骤,谢式千,潘承毅. 2019. 概率论与数理统计. 高等教育出版社.\n[2] 张宇. 2021. 张宇概率论与数理统计9讲. 北京理工大学出版社有限责任公司.\n​\n","date":"2021-05-25","permalink":"/posts/math/probability-theory/","series":[""],"tags":[""],"title":"学习概率论的一些随意思考"},{"categories":[],"content":"随记合集\n2022-01-22 15:36 刚睡醒就看互联网是对自己的一大不尊重。现在互联网流行因为一点小事就可以疯狂骂起来，越是看多了互联网的骂战，越是觉得非常地空洞，不知道他们为了什么了争吵。不过我已经发现了一篇净土，希望我以后远离污秽。\n2022-01-19 00:55 很久没有看过这么精彩的动漫了……魔法少女小圆是神！！！\n接下来我会写几篇关于小圆的文章的……魔法少女小圆是神！！！ 魔法少女小圆是神！！！\n2022-01-12 22:21 终于考完了。我这学期过得还是太浪了，比我之前的学期都浪。不过我想并没有违背我的愿望，我做得没有太大问题，只是可能有点不完美。另外关于Java课程和大作业，我是觉得越来越没有意思了，学校的课程，中国的课程，好像从来都不是以培养学生的技能或者锻炼他们为主要目的，而是取得虚假的high score罢了。我认真做的网站项目我很喜欢的东西并没有取得别人的认同。算了，我之后也会按照自己的思路想法行事。我以后希望能去德国学数学。\n2022-01-07 00:04 已经考完两科了，明天上午将要进行数据挖掘的考试，而我只是随便看了看。虽然我早就决定将数据挖掘放入补考行列，但是目前心情还是有些不爽……大概是因为这是我第一次正式补考将考试拖到下学期吧。没办法，我在学期最后犯了一个错误：企图用10天时间将几乎未学的7门科目复习到及格水准。也不是不行，但是这样做会很损害身体，而我现在已经不想这么做了，意味はない。不就是那个毕业证吗，是吧，没必要那么复杂。\n关于病情方面，我终于认识到这是完全是我的世界了，一切都是幻想都是假象。没错，我自己居然不知不觉地踏入了神经病的行列，而且还以为事情是真实正常的。非常魔幻有趣的经历。\n现在我仍然痛苦。希望我以后用我自己的双眼去发现事实，真实，本物。\n2021-12-01 23:21 仿佛所有东西都在努力告诉我一个 我即将领悟的东西。另外，我准备开始重新写日记了，以前初三时写了半年多。\n最近我也在建Minecraft服务器，用的Spigot，但是建了很多次访问不到，也不知道是那出问题了，我想只有先建正版的服务器了，用spigot主要是担心有些同学没买正版一起玩不了。\n2021-11-05 13:47 我之前低估了我病的程度，还需要更多时间。我现在很多认知都是错误的，这非常痛苦。但是我觉得最长也只需要一年多吧。还是继续加油吧，继续脱敏，坚持训练，好好生活，好好休息，好好工作。\n2021-09-29 21:34 距离开学已经一个月了，我还是正在稳步地恢复中，我觉得最多今年底应该可以好吧。但是也不确定哈哈。\n明天过后就放假了，希望我能实现自己的愿望，活得更加自由快乐一点。祝国庆快乐。\n2021-09-18 16:57 中秋快乐呀~ 我正在稳步恢复，但是这么多年的条件反射很难一下子消除，但是是肯定可以的，只是还多需要一点时间~ 祝看到这条message的人不管什么时间都中秋快乐，虽然并不是在中秋节。\n2021-09-10 10:19 现在的世界处于叠加态，叠加于之前错误的世界和现在我相信的世界，我相信只要我信念足够，我会很快出来的~\n2021-09-04 12:56 我慢慢出来啦！~おめでとう！！另外，猜疑链真有意思，我会拿时间来写一篇这个东西，我发现世界上几乎所有的人都受这个影响，只是影响程度参差不一。\n2021-08-24 20:33 暑假即将结束，努力抓住夏日的尾巴。这个暑假过得有好有坏，打分7分/10分吧。\n2021-07-14 11:17 1️⃣ 鸽子成长史.png。趁着自己还有兴致的时候抓紧时间完成吧。其实网络社交空间我已经写了1000字了，但发现还是太难写了，所以还需要更多的时间，于是暂鸽了。\n2️⃣ 那是那个音乐框框在手机端显示不是很好看，，得想办法改改。\n3️⃣ 另外还想说一件事，我的博客是以学习，生活为止，但是他们之间的比例很不协调，原因是我不想写总结知识点的文章，那样子太没意思了，如果要写学习相关的文章，我只会写关于教程，探索的文章，就和概率论那样，自己探索。\n马上快要选课了，溜。😊\n2021-07-10 21:53 考完试了，标志着暑假来到了，这个暑假我已经定了计划了，种类还算丰富，希望自己能过一个比之前都要好的暑假~ 具体计划就不写啦，祝看到这段话的人暑假快乐~ 追寻自己的兴趣感觉也快要接触到真实的答案了。\n2021-06-24 17:45 今日无事。刚刚过去的6月23号是太阳直射北回归线的日子，我想为什么那一天不是平均下来最热的呢？查了查百度，哦，还有很多因素，不能够单纯一元论。离谱的是百度回答还整个了病情分析在前面。\n2021-05-28 18:23 想写关于星星与诸葛亮的收集整理文，先放在这了，什么时候有空什么时候写，毕竟概率论还有一大半没有写完。向着无用的星星出发！\n最近系统换了bitstream vera sans mono字体（我也不知道是什么意思），英文是挺好看，就是中文真让人头扁。\n老习惯，放一首歌，其实网易好像直接可以生成外链播放器，但我试了几次不行。\n 好了弄好了。enjoy！这首歌不是那么大众。\n2021-05-16 19:55 写东西好麻烦，不想写了。。我估计以后写的东西大部分应该都是随便一写。我准备先写写关于我对概率论的一些思考的东西，正好复习复习。至于之前说的那两个不相干的东西，估计需要更久了😂。​\n就这样，最近一直想玩一些新的gal可惜没什么时间，之前看到了知乎有一位gal爱好者，现在是字节的实习生，看到他写的考据文章很是羡慕憧憬。我希望我也能有一个爱好，目前正在慢慢寻找中。\n最后放一首最近听的歌：\n 2021-05-08 16:06 首先送上一首歌：\n 做了小站之后发现有好多想写的东西，现在准备写“网络社交空间”与“对川农电梯的观察分析”这两篇，但目测需要至少3周的感觉（最近有点忙，但还是会写完的），想看的朋友敬请期待😋\n2021-05-04 12:51 1️⃣ 最近遇见了南登かなる（なんとかなる），一个800粉丝的V，很是喜欢，已经作为头像了（\n2️⃣ 最近乘着假期完了魔女的夜宴（サノバウィッチ）xi ttu。很喜欢里面的戸隠\n3️⃣ 顺带一提，这个hugo theme的作者是大连东软信息学院的大四学生，很厉害。\n4️⃣ 之后可能会上线评论功能，现在暂时想慢慢来，博客的需求差不多就好，毕竟我不想学网页相关的知识太多\n","date":"2021-05-04","permalink":"/tweet/essay/","series":[],"tags":[],"title":"随记合集2021.5-2022.1"},{"categories":["普通类"],"content":"广告位~广告位~\n广告位，此站点流量为一位数，所以肯定不会吃亏的！\n联系我哦\n其实是因为无聊而发表的。\n","date":"2021-05-02","permalink":"/posts/other/ads/","series":[],"tags":[],"title":"广告位招租/Advertising space for rent"},{"categories":[],"content":" 人生是什么？人生就是《百年孤独》，但我拒绝没有情感的欲望。\n事情分为获得金钱和需要金钱保障的事。\n明晰规律，辨证运用。\n人生的一部分是艺术的体验与创造。\n 本站主要是关于【我】做的事，学的东西，一些兴趣爱好，还有一些想法记录。\n想联系我请通过邮箱，我的邮箱：bnaod1@qq.com ， z475856982@gmail.com\n——Update at 2024.11\n站点进化史  2021-05-01 五一假期时，注册域名+hugo+cloudflare建本静态网站，使用的是dream主题 2021-07-28 暑假时更换主题，主要还是想突出阅读感。 2023-02 添加了valine无后端评论。 2024-11 为了提升网站访问速度, 削弱CDN源的不稳定性移除部分js cdn, 同时站内提供对应js. ","date":"2021-05-01","permalink":"/about/","series":[],"tags":[],"title":"关于"},{"categories":["普通类"],"content":"First post\n2021-05-01 今天是有史以来第一次弄博客，5月1号从早上弄到晚上。\n今天的经过：博客怎么弄？ \u0026gt; 看看sharzy大佬的博客吧 \u0026gt; 意外发现了cloudflare \u0026gt; 翻阅友情link发现了hugo \u0026gt; 开始整 \u0026gt; 阿里云 \u0026gt; git，ssh，rsa \u0026gt; 想把丛雨的背景加上去，但是色彩太高了 \u0026gt; 算了，大概就这样吧，之后再改。\n非常非常想让丛雨来作背景，于是之后需要将作者头像这块处理一下。之后一旦处理完毕，基本上长期不会进行改动了，还是需要多学硬知识。\n丛雨(´ω｀)！\n2021-05-02 1.调整   将背景替换为丛雨修复剑时的场景，采用画布模糊。\n  在作者栏加了一个浅色边框，更容易分辨文字了。\n  将背景进行压缩，由原来的5.58Mb变为404Kb，访问更快了。\n  数学公式，代码渲染。\n  将其他图片压缩，加入更多的defaultpicture。\n  2.没有实现的地方  category目录，link。并且暂时不打算去做  3.打算  博客只是$hugo$搭建的，很快速，我对HTML与CSS的知识也局限于单单学过一遍但没有实践的程度，所以准备页面布局暂时就这样，不会进行改动了，可能偶尔会改变一下背景。想起之前浏览过的博客有一个添加背景API功能，每次重新访问页面背景会刷新，考虑之后做一个这样的丛雨API。 之后想了解一下$cloudflare$的托管功能，不想用gitpage了。 博客本身目前打算更新的内容有：学习总结，复习，传送记录门和其他随想。学习总结的频率目测应该是4-6周，考试复习会总结知识点。 向大佬学习！推荐大佬Sharzy\u0026rsquo;s Homepage | Sharzy 。据我所知，他应该是大三大四清华大学计算机学生一枚，今年3月份参加了托福考试，平时读了很多书，数学，计算机和音乐鉴赏水平很高。昨天到今天做博客的经历真实地感受到自己的水平多么不足，一定要好好学习。  4.功能测试 之前一直没有正式在$Markdown$上认真写过东西，所以这里先测试一下需要的功能，正确写漂亮点~\nI 数学公式 $\\LaTeX$行内公式：$\\left [ G : ker \\varphi \\right ] = \\left |im \\varphi \\right |$\n 行间公式:  $$ \\left |G \\right | = \\left |ker \\varphi \\right | \\cdot \\left |im \\varphi \\right | $$\nII 图片插入 这里放没有扭曲之前的背景，可爱的丛雨。当然图片还是压缩一下。\nIII 代码 JavaScript。\n1function test() { 2 console.log(\u0026#34;Hello world!\u0026#34;); 3} 5.尾巴 暂时就这样了。\n2021-05-03 1.调整  处理好了hugo构建背景的问题。之前一直需要手动修改，每次查看都报错，经过了类似代码审计的过程，以为是多大的麻烦，结果发现是因为hugo构建public后，background的imgurl是类似这样的\u0026quot;/img\u0026quot;，如果在本地打开的话，因为是file协议浏览器会去找如\u0026quot;C:/img\u0026quot;，而网站发布了就不会存在这样的问题。这种经验问题之后应该不会再犯了= =. 加入了更多的文章cover，加入了一些可爱的图片。 category和tag目录页已经处理好了。目前准备是category放“大类”，如生活类，数学类，计算机类；tag放小类，如proxy，JavaScript，网络。 各种图片近一步压缩，以提升访问速度。 cloudflare已经弄好了。 时间调整，post图片固定。（我真是个Σ(☉▽☉\u0026quot;，改了好久没想到在config里面） 个人描述页面终于弄好了😎 文章加入了description，不再显示全文了⭐  2.之后  可能会加入评论功能，实现方法好像有很多，之后再弄了。 魔改theme！？😇  3.尾巴 这里就是结尾了。写这篇记录的时候51假期过去了55.667%（从5月1日00:00算起到5月6日00:00)。\n本来是三篇，减少位置缩减为一篇~\n","date":"2021-05-01","permalink":"/posts/other/first-post/","series":[],"tags":[],"title":"第一次弄博客"}]