<!doctype html>
<html lang="zh-cn">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>协程 - 理想奈的博客</title><link rel="apple-touch-icon" href="/images/favicons/apple-touch-icon.png" sizes="180x180">
<link rel="icon" href="/images/favicons/favicon-32x32.png" sizes="32x32" type="image/png">
<link rel="icon" href="/images/favicons/favicon-16x16.png" sizes="16x16" type="image/png">
<link rel="manifest" href="/images/favicons/manifest.json">
<link rel="icon" href="/images/favicons/favicon.ico">
<meta name="keywords" content="" />
<meta name="description" content="" /><meta itemprop="name" content="协程">
<meta itemprop="description" content=""><meta itemprop="datePublished" content="2024-11-27T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2024-11-27T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="4387">
<meta itemprop="keywords" content=",,," /><meta property="og:title" content="协程" />
<meta property="og:description" content="" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/tech/media-coroutine-begin/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-11-27T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2024-11-27T00:00:00&#43;00:00" /><meta property="og:site_name" content="理想奈的博客" />


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="协程"/>
<meta name="twitter:description" content=""/>
<meta data-name="palette" content="blue"><link rel=stylesheet href="/css/bundle.min.d63d5781d5b3b2441c3e0c8ba081eb171c0ae292f799670fe6d38f68e3a2816d.css" integrity="sha256-1j1XgdWzskQcPgyLoIHrFxwK4pL3mWcP5tOPaOOigW0=" crossorigin="anonymous"><script src="/js/bundle.min.1c471eeba442e80350b91324d765b69b27af83f0de35d552aa2a410bac6ee793.js" integrity="sha256-HEce66RC6ANQuRMk12W2myevg/DeNdVSqipBC6xu55M=" crossorigin="anonymous"></script>
<script type="text/javascript">
	document.addEventListener("DOMContentLoaded", function() {
  renderMathInElement(document.body, {
    delimiters: [
      {left: "$$", right: "$$", display: true},
      {left: "$", right: "$", display: false}
    ],
    macros: {
      "\\ge": "\\geqslant",
      "\\le": "\\leqslant",
      "\\geq": "\\geqslant",
      "\\leq": "\\leqslant"
	}
  });
}); 
</script>
<meta property="og:type" content="index"/>
<meta property="og:title" content="Unzybaryl`s Sekai" />
<meta property="og:image" content="https://eustia.me/images/profile1.jpg" />
<meta property="og:url" content="https://eustia.me/" />





<script type="text/javascript" src="/js/Valine.min.js"></script>
<script type="text/javascript" src="/js/cave-draw.min.js"></script>
<link rel="stylesheet" type="text/css" href="/js/katex.min.css">
<script type="text/javascript" src="/js/katex.min.js"></script>
<script type="text/javascript" src="/js/auto-render.min.js"></script>
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="stylesheet" type="text/css" href="/js/font.css">

</head><body><header><nav class="navbar navbar-expand-xl fixed-top">
  <div class="container">
    <a class="navbar-brand" href="/">
      
      
      さぁ、君、取りたまえ
      
    </a>
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav me-1 mb-2 mb-lg-0"><form class="search-bar d-flex ms-1" action="/search">
  <div class="input-group input-group-sm">
    <button class="btn btn-search disabled position-absolute left-0" type="submit"><i class="fas fa-fw fa-search"></i></button>
    <input class="form-control rounded-pill" id="searchQuery" name="q" type="search" aria-label="Search">
  </div>
</form></ul><ul class="navbar-nav me-1 mb-2 mb-lg-0 me-1 ms-auto"><li class="nav-item">
          <a class="nav-link" href="/archives">
            <i class="fas fa-fw fa-file-archive"></i>归档
          </a>
        </li><li class="nav-item">
          <a class="nav-link" href="/about/">
            <i class="fas fa-fw fa-info-circle"></i>关于
          </a>
        </li><li class="nav-item">
          <a class="nav-link" href="/bin/">
            <i class="fas fa-fw fa-bookmark"></i>废案
          </a>
        </li><li class="nav-item">
  <a class="nav-link" data-bs-toggle="offcanvas" href="#offcanvasSettings" role="button"
    aria-controls="offcanvasSettings">
    <i class="fas fa-fw fa-sliders-h"></i> 设置
  </a>
</li>

<div class="offcanvas offcanvas-end surface h-100" tabindex="-1" id="offcanvasSettings"
  aria-labelledby="offcanvasSettingsLabel">
  <div class="offcanvas-header">
    <h5 class="offcanvas-title" w id="offcanvasSettingsLabel"><i class="fas fa-fw fa-sliders-h"></i> 设置</h5>
    <a role="button" data-bs-dismiss="offcanvas" aria-label="Close">
      <span class="fas fa-2x fa-fw fa-times"></span>
    </a>
  </div>
  <div class="offcanvas-body"><section class="setting">
  <form class="row">
    <div class="col-auto">
      <label><i class="fas fa-fw fa-adjust"></i> 模式</label>
    </div>
    <div class="col-auto ms-auto">
      <div class="form-check form-switch">
        <input class="form-check-input" type="checkbox" id="modeSwitcher">
      </div>
    </div>
  </form>
</section>
<section class="setting">
  <form class="font-size-switcher-form row">
    <div class="col-auto">
      <label for="fontSize" class="form-label"><i class="fas fa-fw fa-font"></i> 字体大小</label>
    </div>
    <div class="col-auto ms-auto">
      <input type="range" class="form-range" min="-2" max="2" id="fontSize">
    </div>
  </form>
</section>

</div>
</div></ul>
    </div>
  </div>
</nav>
</header>
<main role="main" class="container">
      <div class="row content">
<div class="col-lg-8">
  <div class="container"><nav class="row" aria-label="breadcrumb">
  <ol class="breadcrumb surface"><li class="breadcrumb-item"><a href="/">主页</a></li><li class="breadcrumb-item"><a href="/posts/">文章</a></li><li class="breadcrumb-item"><a href="/posts/tech/">Tech</a></li><li class="breadcrumb-item active">协程</li></ol>
</nav><article class="post row surface"><div class="post-panel-wrapper">
  <div class="post-panel d-flex flex-column">
    <a id="sidebarToggler" class="action d-none d-lg-block" role="button">
  <i class="fas fa-fw fa-expand-alt fa-rotate-45"></i>
</a>
  
    

    
    <a class="action" data-bs-container="body" data-bs-toggle="popover" data-bs-html="true" data-bs-placement="bottom"
  data-bs-trigger="focus" tabindex="0"
  data-bs-content="&lt;a target=&#34;_blank&#34; rel=&#34;license&#34; href=&#34;https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh&#34;&gt;CC BY-NC-ND 4.0 &lt;i class=&#34;fab fa-fw fa-creative-commons&#34;&gt;&lt;/i&gt;&lt;i class=&#34;fab fa-fw fa-creative-commons-by&#34;&gt;&lt;/i&gt;&lt;i class=&#34;fab fa-fw fa-creative-commons-nc&#34;&gt;&lt;/i&gt;&lt;i class=&#34;fab fa-fw fa-creative-commons-nd&#34;&gt;&lt;/i&gt;&lt;/a&gt;
">
  <i class="fas fa-fw fa-copyright"></i>
</a>
    <a id="btnTOC" class="fas fa-fw fa-list-alt" data-bs-toggle="offcanvas" href="#offcanvasTOC" aria-controls="offcanvasTOC" role="button">
</a>
  </div>
</div>
<h1 class="post-title my-3">协程
</h1><div class="post-meta mb-3">
  <span class="post-date me-2">
    <i class="fas fa-fw fa-calendar-alt"></i>2024-11-27
  </span>
  <span class="post-reading-time me-2">
    <i class="fas fa-fw fa-coffee"></i>9 分钟阅读
  </span>
<a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" class="post-taxonomy">#计算机</a><a href="/series/%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91/" class="post-taxonomy">#媒体开发</a></div>



                
                <div class="addthis_inline_share_toolbox"></div>
            <div class="offcanvas offcanvas-end surface" tabindex="-1" id="offcanvasTOC" aria-labelledby="offcanvasTOCLabel">
  <div class="offcanvas-header">
    <h5 class="offcanvas-title" id="offcanvasTOCLabel">目录</h5>
    <a role="button" data-bs-dismiss="offcanvas" aria-label="Close">
      <span class="fas fa-2x fa-fw fa-times"></span>
    </a>
  </div>
  <div class="offcanvas-body">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#概念">概念</a>
      <ul>
        <li><a href="#与进程线程的区别">与进程，线程的区别</a></li>
        <li><a href="#产生原因">产生原因</a></li>
        <li><a href="#优缺点">优缺点</a></li>
        <li><a href="#协程库">协程库</a></li>
      </ul>
    </li>
    <li><a href="#ucontext库">ucontext库</a>
      <ul>
        <li><a href="#概念-1">概念</a></li>
        <li><a href="#核心函数">核心函数</a></li>
        <li><a href="#ucontext_t-结构体">ucontext_t 结构体</a></li>
        <li><a href="#代码示例">代码示例：</a></li>
        <li><a href="#伪代码框架解析">伪代码框架解析</a></li>
      </ul>
    </li>
    <li><a href="#hook实践">hook实践</a>
      <ul>
        <li><a href="#基本概念">基本概念</a></li>
        <li><a href="#代码实践">代码实践</a></li>
        <li><a href="#完整代码">完整代码</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div><div class="post-content mb-3" ><p><a href="https://blog.csdn.net/weixin_43925427/article/details/140907523">https://blog.csdn.net/weixin_43925427/article/details/140907523</a></p>
<p><a href="https://blog.csdn.net/qq_62821433/article/details/139480927">https://blog.csdn.net/qq_62821433/article/details/139480927</a></p>
<h2 id="概念">概念</h2>
<p>协程（Coroutines） 是一种程序组件，允许不同的执行线程或路径在单个进程中共享同一个执行环境。与线程相比，协程是轻量级的，因为它们共享相同的进程空间并具有较小的上下文切换开销。主要特点包括：</p>
<ul>
<li>非阻塞执行：协程可以在等待 I/O 操作或其他长时间执行的任务时让出 CPU，允许其他协程运行。</li>
<li>协作式多任务处理：协程的切换是显式的，由程序员或协程库控制，不是由操作系统的调度器控制。</li>
<li>高效的并发：协程可以在单个线程中实现高效的并发执行，适用于处理大量并发连接和请求。</li>
</ul>
<p>在网络应用中，协程可用于优化 I/O 操作，尤其是在高并发环境下。使用协程可以避免为每个客户端连接创建一个线程的高成本，从而减少资源消耗和提高性能。</p>
<h3 id="与进程线程的区别">与进程，线程的区别</h3>
<ul>
<li>
<p>进程</p>
<blockquote>
<p>1.程序的一次执行过程；</p>
<p>2.系统资源分配的单位，具有独立的虚拟内存，PCB控制块，代码，数据，堆栈，文件资源等；</p>
<p>3.进程上下文切换开销大（主要问题）</p>
</blockquote>
</li>
<li>
<p>线程</p>
<blockquote>
<p>1.系统调度的单位；</p>
<p>2.共享进程的资源空间；具有自己的栈，寄存器</p>
<p>3.并发性好，同一进程内的线程切换不会导致进程的上下文切换，所以线程切换开销小；</p>
<p>4.共享进程资源，多线程会发生冲突，需要进行同步。</p>
</blockquote>
</li>
<li>
<p>协程</p>
<blockquote>
<p>1.可以理解为线程中的线程；</p>
<p>2.具有自己的上下文；</p>
<p>3.协程切换不会引起线程的上下文（更轻量）</p>
<p>4.一个线程同一时刻只有一个协程执行；</p>
<p>5.协程执行任意时刻都可以退出，下次可以继续执行（与函数的区别，函数一条路走到黑）</p>
<p>6.高并发场景下性能很好，并且不需要同步</p>
</blockquote>
</li>
</ul>
<h3 id="产生原因">产生原因</h3>
<p>协程效率高并不是根本原因。</p>
<p>在高并发场景下，两个原因：</p>
<p>1.用同步代码逻辑简单，并发性差强人意</p>
<p>同步阻塞：阻塞等待业务处理，期间不能做其他事情</p>
<p>同步非阻塞：不断轮询，忙等待占用cpu，</p>
<p>2.用异步，并发性好，代码逻辑又很复杂</p>
<p>基于以上就产生了协程，协程可以做到用同步的代码逻辑达到异步的效果</p>
<h3 id="优缺点">优缺点</h3>
<p>优点：</p>
<p>1.用同步的思想编写出异步的效果，</p>
<p>2.并发性好，性能高</p>
<p>缺点：</p>
<p>单线程中同时只能执行一个协程，无法利用多核功能，还是得结合多线程</p>
<h3 id="协程库">协程库</h3>
<ul>
<li>Boost.Coroutine2：这是Boost库中的⼀个模块，提供了⼀组灵活的协程实现，包括对称协程和⾮对称协程。它提供了⼀些强⼤的特性，如⽀持多个栈和⾃定义栈⼤⼩。</li>
<li>libco：腾讯微信团队开源的⼀个C/C++协程库，据说微信后台⼤量在使⽤这个库，通过⼏个简单的接⼝就能实现协程的创建/调度，同时基于epoll/kqueue实现了⼀个事件反应堆，再加上sys_call（系统调⽤）hook技术，以此给开发者提供同步/异步的开发⽅法</li>
<li>libgo ：是⼀个使⽤ C++ 编写的协作式调度的stackful有栈协程库, 同时也是⼀个强⼤的并⾏编程库。⽀持linux平台，MacOS和windows平台，在c++11以上的环境中都能⽤。</li>
</ul>
<h2 id="ucontext库">ucontext库</h2>
<h3 id="概念-1">概念</h3>
<p>在 C 语言中，ucontext 库提供了一套功能丰富的 API，用于管理程序的执行上下文。这些功能主要用于实现用户空间的轻量级线程（协程），允许程序在多个执行流之间进行显式的上下文切换。</p>
<ul>
<li>上下文（Context）：表示程序在某一时间点的运行状态，包括程序计数器、寄存器集合和堆栈等。</li>
<li>协程（Coroutine）：是一种比线程更轻量的执行单元，它允许进行非抢占式的任务切换，即在用户空间进行切换而无需内核介入。</li>
</ul>
<h3 id="核心函数">核心函数</h3>
<ol>
<li>
<h5 id="getcontextucontext_t-ucp"><strong><code>getcontext(ucontext_t \*ucp)</code></strong>:</h5>
<p>获取当前执行流的上下文，并保存在 <code>ucp</code> 指向的 <code>ucontext_t</code> 结构体中。（初始化）</p>
</li>
<li>
<h5 id="setcontextconst-ucontext_t-ucp"><strong><code>setcontext(const ucontext_t \*ucp)</code></strong>:</h5>
<p>切换到 <code>ucp</code> 指定的上下文执行。调用此函数后，程序的控制流会转移到新的上下文继续执行，当前函数不会返回。</p>
</li>
<li>
<h5 id="makecontextucontext_t-ucp-void-func-int-argc-"><strong><code>makecontext(ucontext_t \*ucp, void (\*func)(), int argc, ...)</code></strong>:</h5>
<p>修改 <code>ucp</code> 指定的上下文，设置它的执行函数和函数参数。<code>func</code> 应是一个不返回值的函数，因为从该函数返回将导致程序终止。（第一次swap到ctx时，就开始执行func；后面swap回来时，继续执行func）</p>
</li>
<li>
<h5 id="swapcontextucontext_t-oucp-const-ucontext_t-ucp"><strong><code>swapcontext(ucontext_t \*oucp, const ucontext_t \*ucp)</code></strong>:</h5>
<p>保存当前上下文到 <code>oucp</code> 并切换到 <code>ucp</code> 指向的上下文。通常用于实现协程之间的切换。</p>
</li>
</ol>
<h3 id="ucontext_t-结构体">ucontext_t 结构体</h3>
<p><code>ucontext_t</code> 结构体是管理上下文的核心，它包括以下几个部分：</p>
<ul>
<li>
<p><strong><code>uc_link</code></strong>:</p>
<p>当前上下文结束后，程序执行将继续的上下文的指针。</p>
</li>
<li>
<h5 id="uc_stack"><strong><code>uc_stack</code></strong>:</h5>
<p>描述当前上下文使用的堆栈的信息，包括堆栈的位置、大小和标志。</p>
</li>
<li>
<h5 id="uc_mcontext"><strong><code>uc_mcontext</code></strong>:</h5>
<p>保存特定于机器的执行上下文信息（如寄存器），这部分是系统特定的。</p>
</li>
<li>
<h5 id="uc_sigmask"><strong><code>uc_sigmask</code></strong>:</h5>
<p>上下文执行时的信号屏蔽集，用于控制哪些信号在此上下文中被阻塞。</p>
</li>
</ul>
<h3 id="代码示例">代码示例：</h3>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="ln"> 2</span><span class="cp">#include</span> <span class="cpf">&lt;ucontext.h&gt;</span><span class="cp">
</span><span class="ln"> 3</span><span class="cp"></span> 
<span class="ln"> 4</span><span class="n">ucontext_t</span> <span class="n">ctx</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span> <span class="c1">// 创建三个上下文对象，对应三个协程
</span><span class="ln"> 5</span><span class="c1"></span><span class="n">ucontext_t</span> <span class="n">main_ctx</span><span class="p">;</span> <span class="c1">// 主上下文，用于协程之间的调度
</span><span class="ln"> 6</span><span class="c1"></span> 
<span class="ln"> 7</span><span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 全局变量，用于控制打印次数和协程切换
</span><span class="ln"> 8</span><span class="c1"></span> 
<span class="ln"> 9</span><span class="c1">// coroutine1
</span><span class="ln">10</span><span class="c1"></span><span class="kt">void</span> <span class="nf">func1</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">11</span>    <span class="c1">// 当 count 小于 30 时持续执行
</span><span class="ln">12</span><span class="c1"></span>	<span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">++</span> <span class="o">&lt;</span> <span class="mi">30</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">13</span>		<span class="n">printf</span><span class="p">(</span><span class="s">&#34;1</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span> <span class="c1">// 打印标识符1
</span><span class="ln">14</span><span class="c1"></span>		<span class="n">swapcontext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">main_ctx</span><span class="p">);</span> <span class="c1">// 从协程1切换到主上下文
</span><span class="ln">15</span><span class="c1"></span>		<span class="n">printf</span><span class="p">(</span><span class="s">&#34;4</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span> <span class="c1">// 当协程1再次获得控制时，打印标识符4
</span><span class="ln">16</span><span class="c1"></span>	<span class="p">}</span>
<span class="ln">17</span><span class="p">}</span>
<span class="ln">18</span> 
<span class="ln">19</span><span class="c1">// coroutine2
</span><span class="ln">20</span><span class="c1"></span><span class="kt">void</span> <span class="nf">func2</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">21</span>    <span class="c1">// 当 count 小于 30 时持续执行
</span><span class="ln">22</span><span class="c1"></span>	<span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">++</span> <span class="o">&lt;</span> <span class="mi">30</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">23</span>		<span class="n">printf</span><span class="p">(</span><span class="s">&#34;2</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span> <span class="c1">// 打印标识符2
</span><span class="ln">24</span><span class="c1"></span>		<span class="n">swapcontext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">main_ctx</span><span class="p">);</span> <span class="c1">// 从协程2切换到主上下文
</span><span class="ln">25</span><span class="c1"></span>		<span class="n">printf</span><span class="p">(</span><span class="s">&#34;5</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span> <span class="c1">// 当协程2再次获得控制时，打印标识符5
</span><span class="ln">26</span><span class="c1"></span>	<span class="p">}</span>
<span class="ln">27</span><span class="p">}</span>
<span class="ln">28</span> 
<span class="ln">29</span><span class="c1">// coroutine3
</span><span class="ln">30</span><span class="c1"></span><span class="kt">void</span> <span class="nf">func3</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">31</span>    <span class="c1">// 当 count 小于 30 时持续执行
</span><span class="ln">32</span><span class="c1"></span>	<span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">++</span> <span class="o">&lt;</span> <span class="mi">30</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">33</span>		<span class="n">printf</span><span class="p">(</span><span class="s">&#34;3</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span> <span class="c1">// 打印标识符3
</span><span class="ln">34</span><span class="c1"></span>		<span class="n">swapcontext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">main_ctx</span><span class="p">);</span> <span class="c1">// 从协程3切换到主上下文
</span><span class="ln">35</span><span class="c1"></span>		<span class="n">printf</span><span class="p">(</span><span class="s">&#34;6</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span> <span class="c1">// 当协程3再次获得控制时，打印标识符6
</span><span class="ln">36</span><span class="c1"></span>	<span class="p">}</span>
<span class="ln">37</span><span class="p">}</span>
<span class="ln">38</span> 
<span class="ln">39</span><span class="c1">// schedule
</span><span class="ln">40</span><span class="c1"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
<span class="ln">41</span>    <span class="c1">// 分配堆栈空间
</span><span class="ln">42</span><span class="c1"></span>	<span class="kt">char</span> <span class="n">stack1</span><span class="p">[</span><span class="mi">2048</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="ln">43</span>	<span class="kt">char</span> <span class="n">stack2</span><span class="p">[</span><span class="mi">2048</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="ln">44</span>	<span class="kt">char</span> <span class="n">stack3</span><span class="p">[</span><span class="mi">2048</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="ln">45</span> 
<span class="ln">46</span>    <span class="c1">// 初始化协程1的上下文，并设置堆栈和链接
</span><span class="ln">47</span><span class="c1"></span>	<span class="n">getcontext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="ln">48</span>	<span class="n">ctx</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">uc_stack</span><span class="p">.</span><span class="n">ss_sp</span> <span class="o">=</span> <span class="n">stack1</span><span class="p">;</span>
<span class="ln">49</span>	<span class="n">ctx</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">uc_stack</span><span class="p">.</span><span class="n">ss_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">stack1</span><span class="p">);</span>
<span class="ln">50</span>	<span class="n">ctx</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">uc_link</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">main_ctx</span><span class="p">;</span>
<span class="ln">51</span>	<span class="n">makecontext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">func1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln">52</span> 
<span class="ln">53</span>    <span class="c1">// 初始化协程2的上下文，并设置堆栈和链接
</span><span class="ln">54</span><span class="c1"></span>	<span class="n">getcontext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="ln">55</span>	<span class="n">ctx</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">uc_stack</span><span class="p">.</span><span class="n">ss_sp</span> <span class="o">=</span> <span class="n">stack2</span><span class="p">;</span>
<span class="ln">56</span>	<span class="n">ctx</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">uc_stack</span><span class="p">.</span><span class="n">ss_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">stack2</span><span class="p">);</span>
<span class="ln">57</span>	<span class="n">ctx</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">uc_link</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">main_ctx</span><span class="p">;</span>
<span class="ln">58</span>	<span class="n">makecontext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">func2</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln">59</span> 
<span class="ln">60</span>    <span class="c1">// 初始化协程3的上下文，并设置堆栈和链接
</span><span class="ln">61</span><span class="c1"></span>	<span class="n">getcontext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
<span class="ln">62</span>	<span class="n">ctx</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">uc_stack</span><span class="p">.</span><span class="n">ss_sp</span> <span class="o">=</span> <span class="n">stack3</span><span class="p">;</span>
<span class="ln">63</span>	<span class="n">ctx</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">uc_stack</span><span class="p">.</span><span class="n">ss_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">stack3</span><span class="p">);</span>
<span class="ln">64</span>	<span class="n">ctx</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">uc_link</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">main_ctx</span><span class="p">;</span>
<span class="ln">65</span>	<span class="n">makecontext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">func3</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln">66</span> 
<span class="ln">67</span>    <span class="c1">// 开始从主上下文切换到协程
</span><span class="ln">68</span><span class="c1"></span>	<span class="n">printf</span><span class="p">(</span><span class="s">&#34;swapcontext</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
<span class="ln">69</span>	<span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;=</span> <span class="mi">30</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 调度器，循环切换到各个协程
</span><span class="ln">70</span><span class="c1"></span>		<span class="n">swapcontext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">main_ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="p">[</span><span class="n">count</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]);</span> <span class="c1">// 循环切换到三个协程
</span><span class="ln">71</span><span class="c1"></span>	<span class="p">}</span>
<span class="ln">72</span> 
<span class="ln">73</span>	<span class="n">printf</span><span class="p">(</span><span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
<span class="ln">74</span><span class="p">}</span>
</code></pre></div><p>关键点：</p>
<ol>
<li><strong>初始化上下文</strong>：为每个协程分配堆栈并设置其执行的函数。</li>
<li><strong>协程调度</strong>：主函数中的 <code>while</code> 循环实现简单的轮转调度（Round-Robin），根据 <code>count</code> 的值循环切换到三个协程的上下文。</li>
<li><strong><code>swapcontext()</code></strong>：保存当前上下文并激活新的上下文。在每个协程中，它将控制权交回给主上下文，而主上下文则根据调度逻辑选择下一个要运行的协程。</li>
</ol>
<p>运行结果：</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback"><span class="ln"> 1</span>1
<span class="ln"> 2</span>2
<span class="ln"> 3</span>3
<span class="ln"> 4</span>4
<span class="ln"> 5</span>1
<span class="ln"> 6</span>5
<span class="ln"> 7</span>2
<span class="ln"> 8</span>6
<span class="ln"> 9</span>3
<span class="ln">10</span>4
<span class="ln">11</span>1
<span class="ln">12</span>5
<span class="ln">13</span>2
<span class="ln">14</span>6
<span class="ln">15</span>3
<span class="ln">16</span>4
<span class="ln">17</span>1
<span class="ln">18</span>5
<span class="ln">19</span>2
<span class="ln">20</span>6
<span class="ln">21</span>3
<span class="ln">22</span>4
<span class="ln">23</span>1
<span class="ln">24</span>5
<span class="ln">25</span>2
<span class="ln">26</span>6
<span class="ln">27</span>3
<span class="ln">28</span>4
<span class="ln">29</span>1
<span class="ln">30</span>5
<span class="ln">31</span>2
<span class="ln">32</span>6
<span class="ln">33</span>3
<span class="ln">34</span>4
<span class="ln">35</span>1
<span class="ln">36</span>5
<span class="ln">37</span>2
<span class="ln">38</span>6
<span class="ln">39</span>3
<span class="ln">40</span>4
<span class="ln">41</span>1
<span class="ln">42</span>5
<span class="ln">43</span>2
<span class="ln">44</span>6
<span class="ln">45</span>3
<span class="ln">46</span>4
<span class="ln">47</span>1
<span class="ln">48</span>5
<span class="ln">49</span>2
<span class="ln">50</span>6
<span class="ln">51</span>3
<span class="ln">52</span>4
<span class="ln">53</span>1
<span class="ln">54</span>5
<span class="ln">55</span>2
<span class="ln">56</span>6
<span class="ln">57</span>3
<span class="ln">58</span>4
</code></pre></div><h3 id="伪代码框架解析">伪代码框架解析</h3>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln">1</span><span class="k">struct</span> <span class="n">coroutine</span><span class="p">{</span>
<span class="ln">2</span>    <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>                 <span class="c1">// 文件描述符，用于网络 I/O
</span><span class="ln">3</span><span class="c1"></span>    <span class="n">ucontext_t</span> <span class="n">ctx</span><span class="p">;</span>        <span class="c1">// 上下文信息，用于协程切换
</span><span class="ln">4</span><span class="c1"></span>    <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">;</span>             <span class="c1">// 函数参数
</span><span class="ln">5</span><span class="c1"></span>    <span class="n">queue_node</span><span class="p">(</span><span class="n">coroutine</span><span class="p">,</span> <span class="p">)</span> <span class="n">ready_queue</span><span class="p">;</span>  <span class="c1">// 准备就绪的协程队列
</span><span class="ln">6</span><span class="c1"></span>    <span class="n">rbtree_node</span><span class="p">(</span><span class="n">coroutine</span><span class="p">,</span> <span class="p">)</span> <span class="n">wait_rb</span><span class="p">;</span>     <span class="c1">// 等待中的协程红黑树
</span><span class="ln">7</span><span class="c1"></span>    <span class="n">rbtree_node</span><span class="p">(</span><span class="n">coroutine</span><span class="p">,</span> <span class="p">)</span> <span class="n">sleep_rb</span><span class="p">;</span>    <span class="c1">// 睡眠中的协程红黑树
</span><span class="ln">8</span><span class="c1"></span><span class="p">};</span>
</code></pre></div><p>这里，每个协程包括一个文件描述符、上下文信息、函数参数以及三种状态的管理节点：就绪、等待和睡眠。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln">1</span><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
<span class="ln">2</span><span class="p">}</span>
<span class="ln">3</span><span class="k">typedef</span> <span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">coroutine_entry</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span>
<span class="ln">4</span><span class="kt">int</span> <span class="n">create_coroutine</span><span class="p">(</span><span class="n">co_id</span><span class="p">,</span> <span class="n">coroutine_entry</span> <span class="n">entry</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">){</span>
<span class="ln">5</span>    <span class="k">struct</span> <span class="n">coroutine</span> <span class="o">*</span><span class="n">co</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">coroutine</span><span class="p">));</span>
<span class="ln">6</span>    <span class="n">co</span><span class="o">-&gt;</span><span class="n">ss_sp</span> <span class="o">=</span> 
<span class="ln">7</span>    <span class="n">makecontext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">co</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln">8</span><span class="p">}</span>
</code></pre></div><p>在这段代码中，<code>create_coroutine</code> 函数用于初始化一个协程。它分配内存，设置栈空间，并使用 <code>makecontext</code> 准备上下文切换。<code>func</code> 是协程将要执行的函数。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln">1</span><span class="c1">// 调度器
</span><span class="ln">2</span><span class="c1"></span><span class="k">struct</span> <span class="n">scheduler</span><span class="p">{</span>
<span class="ln">3</span>    <span class="kt">int</span> <span class="n">epfd</span><span class="p">;</span>                          <span class="c1">// epoll 文件描述符
</span><span class="ln">4</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">events</span><span class="p">[];</span>       <span class="c1">// 事件数组
</span><span class="ln">5</span><span class="c1"></span> 
<span class="ln">6</span>    <span class="n">queue_node</span><span class="p">(</span><span class="n">coroutine</span><span class="p">,</span> <span class="p">)</span> <span class="n">ready_head</span><span class="p">;</span>  <span class="c1">// 就绪队列头
</span><span class="ln">7</span><span class="c1"></span>    <span class="n">rbtree_root</span><span class="p">(</span><span class="n">coroutine</span><span class="p">,</span> <span class="p">)</span> <span class="n">wait</span><span class="p">;</span>        <span class="c1">// 等待红黑树
</span><span class="ln">8</span><span class="c1"></span>    <span class="n">rbtree_root</span><span class="p">(</span><span class="n">coroutine</span><span class="p">,</span> <span class="p">)</span> <span class="n">sleep</span><span class="p">;</span>       <span class="c1">// 睡眠红黑树
</span><span class="ln">9</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>调度器负责管理所有协程的生命周期和状态转换。它使用 <code>epoll</code> 监听事件，根据 I/O 事件调度协程。就绪、等待和睡眠队列/树用于管理不同状态的协程。</p>
<p>通过使用协程，你可以高效地管理数以万计的并发连接，每个连接使用非常少的内存，同时避免多线程编程中常见的同步和竞争状态问题。</p>
<h2 id="hook实践">hook实践</h2>
<h3 id="基本概念">基本概念</h3>
<p>Hook 是一种编程技术，用于拦截和修改函数或方法的调用。通过 hook，程序员可以在函数调用前后插入自定义逻辑，从而改变程序的行为。Hook 常用于以下几个场景：</p>
<ul>
<li>调试：插入调试代码来监控函数调用及其参数和返回值。</li>
<li>监控：监控系统或应用程序的行为，例如记录日志。</li>
<li>扩展功能：在不修改原始代码的情况下添加新的功能。</li>
<li>安全性：拦截和修改系统调用以增强安全性。</li>
</ul>
<p>Hook 的实现方式有多种，常见的包括：</p>
<ul>
<li>动态链接库插桩：使用动态链接库 (DLL) 的加载机制来替换或扩展现有函数。</li>
<li>代码注入：将自定义代码注入到目标进程中。</li>
<li>函数指针替换：修改函数指针，使其指向自定义的函数。</li>
<li>虚函数表 (VTable) 替换：在 C++ 中，通过替换对象的虚函数表条目来实现 hook。</li>
</ul>
<h3 id="代码实践">代码实践</h3>
<p>定义函数指针类型和变量</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln">1</span><span class="k">typedef</span> <span class="nf">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">read_t</span><span class="p">)(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">count</span><span class="p">);</span>
<span class="ln">2</span><span class="n">read_t</span> <span class="n">read_f</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="ln">3</span> 
<span class="ln">4</span><span class="k">typedef</span> <span class="nf">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">write_t</span><span class="p">)(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">count</span><span class="p">);</span>
<span class="ln">5</span><span class="n">write_t</span> <span class="n">write_f</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</code></pre></div><p>定义了两个函数指针类型 read_t 和 write_t，并声明了两个全局变量 read_f 和 write_f。这些变量将用于保存原始的 read 和 write 函数地址。
Hook 函数实现</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="n">ssize_t</span> <span class="nf">read</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">count</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 2</span>    <span class="k">struct</span> <span class="n">pollfd</span> <span class="n">fds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="ln"> 3</span> 
<span class="ln"> 4</span>    <span class="n">fds</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">fd</span> <span class="o">=</span> <span class="n">fd</span><span class="p">;</span>
<span class="ln"> 5</span>    <span class="n">fds</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">events</span> <span class="o">=</span> <span class="n">POLLIN</span><span class="p">;</span>
<span class="ln"> 6</span> 
<span class="ln"> 7</span>    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">poll</span><span class="p">(</span><span class="n">fds</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln"> 8</span>    <span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 9</span>        <span class="n">getcontext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">main_ctx</span><span class="p">);</span>
<span class="ln">10</span>        <span class="n">swapcontext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">main_ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">read_ctx</span><span class="p">);</span> <span class="c1">// fd --&gt; ctx
</span><span class="ln">11</span><span class="c1"></span>    <span class="p">}</span>
<span class="ln">12</span> 
<span class="ln">13</span>    <span class="n">ssize_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">read_f</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
<span class="ln">14</span>    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;read: %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">);</span>
<span class="ln">15</span>    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="ln">16</span><span class="p">}</span>
</code></pre></div><p>这是自定义的 read 函数，它会拦截所有对 read 函数的调用，并在调用原始 read 函数之前执行一些逻辑。</p>
<ul>
<li>poll 调用：使用 poll 检查文件描述符 fd 是否有数据可读。</li>
<li>上下文切换：如果没有数据可读，保存当前上下文并切换到 read_ctx。</li>
<li>调用原始 read：调用保存的原始 read 函数 read_f。</li>
<li>打印读取的数据：将读取的数据打印出来。</li>
</ul>
<p>另一个 Hook 函数</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln">1</span><span class="n">ssize_t</span> <span class="nf">write</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">count</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">2</span>    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;write: %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">);</span>
<span class="ln">3</span>    <span class="k">return</span> <span class="n">write_f</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
<span class="ln">4</span><span class="p">}</span>
</code></pre></div><p>自定义的 write 函数会拦截所有对 write 函数的调用，打印写入的数据，并调用原始 write 函数。
初始化 Hook</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln">1</span><span class="kt">void</span> <span class="nf">init_hook</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">2</span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">read_f</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">3</span>        <span class="n">read_f</span> <span class="o">=</span> <span class="n">dlsym</span><span class="p">(</span><span class="n">RTLD_NEXT</span><span class="p">,</span> <span class="s">&#34;read&#34;</span><span class="p">);</span>
<span class="ln">4</span>    <span class="p">}</span>
<span class="ln">5</span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">write_f</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">6</span>        <span class="n">write_f</span> <span class="o">=</span> <span class="n">dlsym</span><span class="p">(</span><span class="n">RTLD_NEXT</span><span class="p">,</span> <span class="s">&#34;write&#34;</span><span class="p">);</span>
<span class="ln">7</span>    <span class="p">}</span>
<span class="ln">8</span><span class="p">}</span>
</code></pre></div><p>init_hook 函数用于初始化 read_f 和 write_f，它们分别指向原始的 read 和 write 函数。dlsym 函数从共享库中查找符号的地址，这里查找的是 read 和 write 函数。
主函数</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
<span class="ln"> 2</span>    <span class="n">init_hook</span><span class="p">();</span>
<span class="ln"> 3</span> 
<span class="ln"> 4</span>    <span class="c1">// 初始化 read_ctx 上下文
</span><span class="ln"> 5</span><span class="c1"></span>    <span class="n">getcontext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">read_ctx</span><span class="p">);</span>
<span class="ln"> 6</span>    <span class="n">read_ctx</span><span class="p">.</span><span class="n">uc_link</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">main_ctx</span><span class="p">;</span>
<span class="ln"> 7</span>    <span class="n">read_ctx</span><span class="p">.</span><span class="n">uc_stack</span><span class="p">.</span><span class="n">ss_sp</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">SIGSTKSZ</span><span class="p">);</span>
<span class="ln"> 8</span>    <span class="n">read_ctx</span><span class="p">.</span><span class="n">uc_stack</span><span class="p">.</span><span class="n">ss_size</span> <span class="o">=</span> <span class="n">SIGSTKSZ</span><span class="p">;</span>
<span class="ln"> 9</span>    <span class="n">makecontext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">read_ctx</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">void</span><span class="p">))</span><span class="n">read</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln">10</span> 
<span class="ln">11</span>    <span class="kt">int</span> <span class="n">sockfd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln">12</span> 
<span class="ln">13</span>    <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">serveraddr</span><span class="p">;</span>
<span class="ln">14</span>    <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serveraddr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_in</span><span class="p">));</span>
<span class="ln">15</span> 
<span class="ln">16</span>    <span class="n">serveraddr</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
<span class="ln">17</span>    <span class="n">serveraddr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">INADDR_ANY</span><span class="p">);</span>
<span class="ln">18</span>    <span class="n">serveraddr</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="mi">2048</span><span class="p">);</span>
<span class="ln">19</span> 
<span class="ln">20</span>    <span class="k">if</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">==</span> <span class="n">bind</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">serveraddr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span><span class="p">)))</span> <span class="p">{</span>
<span class="ln">21</span>        <span class="n">perror</span><span class="p">(</span><span class="s">&#34;bind&#34;</span><span class="p">);</span>
<span class="ln">22</span>        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="ln">23</span>    <span class="p">}</span>
<span class="ln">24</span> 
<span class="ln">25</span>    <span class="n">listen</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
<span class="ln">26</span> 
<span class="ln">27</span>    <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">clientaddr</span><span class="p">;</span>
<span class="ln">28</span>    <span class="n">socklen_t</span> <span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">clientaddr</span><span class="p">);</span>
<span class="ln">29</span>    <span class="kt">int</span> <span class="n">clientfd</span> <span class="o">=</span> <span class="n">accept</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">clientaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>
<span class="ln">30</span>    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;accept</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
<span class="ln">31</span> 
<span class="ln">32</span>    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">33</span>        <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">128</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="ln">34</span>        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">clientfd</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="mi">128</span><span class="p">);</span>
<span class="ln">35</span>        <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">36</span>            <span class="k">break</span><span class="p">;</span>
<span class="ln">37</span>        <span class="p">}</span>
<span class="ln">38</span>        <span class="n">write</span><span class="p">(</span><span class="n">clientfd</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
<span class="ln">39</span>        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;sockfd: %d, clientfd: %d, count: %d, buffer: %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">sockfd</span><span class="p">,</span> <span class="n">clientfd</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
<span class="ln">40</span>    <span class="p">}</span>
<span class="ln">41</span> 
<span class="ln">42</span>    <span class="n">free</span><span class="p">(</span><span class="n">read_ctx</span><span class="p">.</span><span class="n">uc_stack</span><span class="p">.</span><span class="n">ss_sp</span><span class="p">);</span>
<span class="ln">43</span> 
<span class="ln">44</span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">45</span><span class="p">}</span>
</code></pre></div><p>在主函数中，首先调用 init_hook 初始化 read_f 和 write_f。然后初始化 read_ctx 上下文，并使用 makecontext 函数设置上下文的执行函数为 read。</p>
<p>接下来，创建一个套接字，并绑定到本地地址，开始监听连接。接受一个客户端连接后，进入循环，读取客户端发送的数据，并将数据回写给客户端。</p>
<p>通过这种方式，read 和 write 的行为被拦截，并增加了自定义逻辑。</p>
<h3 id="完整代码">完整代码</h3>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln">  1</span> 
<span class="ln">  2</span> 
<span class="ln">  3</span><span class="cp">#define _GNU_SOURCE
</span><span class="ln">  4</span><span class="cp"></span> 
<span class="ln">  5</span><span class="cp">#include</span> <span class="cpf">&lt;dlfcn.h&gt;</span><span class="cp">
</span><span class="ln">  6</span><span class="cp"></span> 
<span class="ln">  7</span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="ln">  8</span><span class="cp">#include</span> <span class="cpf">&lt;ucontext.h&gt;</span><span class="cp">
</span><span class="ln">  9</span><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span><span class="ln"> 10</span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="ln"> 11</span><span class="cp">#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="cp">
</span><span class="ln"> 12</span><span class="cp"></span> 
<span class="ln"> 13</span><span class="cp">#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
</span><span class="ln"> 14</span><span class="cp">#include</span> <span class="cpf">&lt;errno.h&gt;</span><span class="cp">
</span><span class="ln"> 15</span><span class="cp">#include</span> <span class="cpf">&lt;netinet/in.h&gt;</span><span class="cp">
</span><span class="ln"> 16</span><span class="cp"></span> 
<span class="ln"> 17</span><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span><span class="ln"> 18</span><span class="cp">#include</span> <span class="cpf">&lt;sys/poll.h&gt;</span><span class="cp">
</span><span class="ln"> 19</span><span class="cp">#include</span> <span class="cpf">&lt;sys/epoll.h&gt;</span><span class="cp">
</span><span class="ln"> 20</span><span class="cp"></span> 
<span class="ln"> 21</span><span class="cp">#if 1
</span><span class="ln"> 22</span><span class="cp"></span><span class="c1">// hook
</span><span class="ln"> 23</span><span class="c1"></span><span class="k">typedef</span> <span class="nf">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">read_t</span><span class="p">)(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">count</span><span class="p">);</span>
<span class="ln"> 24</span><span class="n">read_t</span> <span class="n">read_f</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="ln"> 25</span> 
<span class="ln"> 26</span><span class="k">typedef</span> <span class="nf">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">write_t</span><span class="p">)(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">count</span><span class="p">);</span>
<span class="ln"> 27</span><span class="n">write_t</span> <span class="n">write_f</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="ln"> 28</span> 
<span class="ln"> 29</span><span class="n">ssize_t</span> <span class="nf">read</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="ln"> 30</span><span class="p">{</span>
<span class="ln"> 31</span> 
<span class="ln"> 32</span>	<span class="k">struct</span> <span class="n">pollfd</span> <span class="n">fds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="ln"> 33</span> 
<span class="ln"> 34</span>	<span class="n">fds</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">fd</span> <span class="o">=</span> <span class="n">fd</span><span class="p">;</span>
<span class="ln"> 35</span>	<span class="n">fds</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">events</span> <span class="o">=</span> <span class="n">POLLIN</span><span class="p">;</span>
<span class="ln"> 36</span> 
<span class="ln"> 37</span>	<span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">poll</span><span class="p">(</span><span class="n">fds</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln"> 38</span>	<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
<span class="ln"> 39</span>	<span class="p">{</span> <span class="c1">//
</span><span class="ln"> 40</span><span class="c1"></span> 
<span class="ln"> 41</span>		<span class="c1">// fd --&gt; epoll_ctl();
</span><span class="ln"> 42</span><span class="c1"></span> 
<span class="ln"> 43</span>		<span class="n">swapcontext</span><span class="p">();</span> <span class="c1">// fd --&gt; ctx
</span><span class="ln"> 44</span><span class="c1"></span>	<span class="p">}</span>
<span class="ln"> 45</span>	<span class="c1">// io
</span><span class="ln"> 46</span><span class="c1"></span> 
<span class="ln"> 47</span>	<span class="n">ssize_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">read_f</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
<span class="ln"> 48</span>	<span class="n">printf</span><span class="p">(</span><span class="s">&#34;read: %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">);</span>
<span class="ln"> 49</span>	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="ln"> 50</span><span class="p">}</span>
<span class="ln"> 51</span> 
<span class="ln"> 52</span><span class="n">ssize_t</span> <span class="nf">write</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="ln"> 53</span><span class="p">{</span>
<span class="ln"> 54</span> 
<span class="ln"> 55</span>	<span class="n">printf</span><span class="p">(</span><span class="s">&#34;write: %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">);</span>
<span class="ln"> 56</span> 
<span class="ln"> 57</span>	<span class="k">return</span> <span class="n">write_f</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
<span class="ln"> 58</span><span class="p">}</span>
<span class="ln"> 59</span> 
<span class="ln"> 60</span><span class="kt">void</span> <span class="nf">init_hook</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="ln"> 61</span><span class="p">{</span>
<span class="ln"> 62</span> 
<span class="ln"> 63</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">read_f</span><span class="p">)</span>
<span class="ln"> 64</span>	<span class="p">{</span>
<span class="ln"> 65</span>		<span class="n">read_f</span> <span class="o">=</span> <span class="n">dlsym</span><span class="p">(</span><span class="n">RTLD_NEXT</span><span class="p">,</span> <span class="s">&#34;read&#34;</span><span class="p">);</span>
<span class="ln"> 66</span>	<span class="p">}</span>
<span class="ln"> 67</span> 
<span class="ln"> 68</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">write_f</span><span class="p">)</span>
<span class="ln"> 69</span>	<span class="p">{</span>
<span class="ln"> 70</span>		<span class="n">write_f</span> <span class="o">=</span> <span class="n">dlsym</span><span class="p">(</span><span class="n">RTLD_NEXT</span><span class="p">,</span> <span class="s">&#34;write&#34;</span><span class="p">);</span>
<span class="ln"> 71</span>	<span class="p">}</span>
<span class="ln"> 72</span><span class="p">}</span>
<span class="ln"> 73</span> 
<span class="ln"> 74</span><span class="cp">#endif
</span><span class="ln"> 75</span><span class="cp"></span> 
<span class="ln"> 76</span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="ln"> 77</span><span class="p">{</span>
<span class="ln"> 78</span> 
<span class="ln"> 79</span>	<span class="n">init_hook</span><span class="p">();</span>
<span class="ln"> 80</span> 
<span class="ln"> 81</span>	<span class="kt">int</span> <span class="n">sockfd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln"> 82</span> 
<span class="ln"> 83</span>	<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">serveraddr</span><span class="p">;</span>
<span class="ln"> 84</span>	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serveraddr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_in</span><span class="p">));</span>
<span class="ln"> 85</span> 
<span class="ln"> 86</span>	<span class="n">serveraddr</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
<span class="ln"> 87</span>	<span class="n">serveraddr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">INADDR_ANY</span><span class="p">);</span>
<span class="ln"> 88</span>	<span class="n">serveraddr</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="mi">2048</span><span class="p">);</span>
<span class="ln"> 89</span> 
<span class="ln"> 90</span>	<span class="k">if</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">==</span> <span class="n">bind</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">serveraddr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span><span class="p">)))</span>
<span class="ln"> 91</span>	<span class="p">{</span>
<span class="ln"> 92</span>		<span class="n">perror</span><span class="p">(</span><span class="s">&#34;bind&#34;</span><span class="p">);</span>
<span class="ln"> 93</span>		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="ln"> 94</span>	<span class="p">}</span>
<span class="ln"> 95</span> 
<span class="ln"> 96</span>	<span class="n">listen</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
<span class="ln"> 97</span> 
<span class="ln"> 98</span>	<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">clientaddr</span><span class="p">;</span>
<span class="ln"> 99</span>	<span class="n">socklen_t</span> <span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">clientaddr</span><span class="p">);</span>
<span class="ln">100</span>	<span class="kt">int</span> <span class="n">clientfd</span> <span class="o">=</span> <span class="n">accept</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">clientaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>
<span class="ln">101</span>	<span class="n">printf</span><span class="p">(</span><span class="s">&#34;accept</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
<span class="ln">102</span> 
<span class="ln">103</span>	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="ln">104</span>	<span class="p">{</span>
<span class="ln">105</span> 
<span class="ln">106</span>		<span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">128</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="ln">107</span>		<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">clientfd</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="mi">128</span><span class="p">);</span>
<span class="ln">108</span>		<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
<span class="ln">109</span>		<span class="p">{</span>
<span class="ln">110</span>			<span class="k">break</span><span class="p">;</span>
<span class="ln">111</span>		<span class="p">}</span>
<span class="ln">112</span>		<span class="n">write</span><span class="p">(</span><span class="n">clientfd</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
<span class="ln">113</span>		<span class="n">printf</span><span class="p">(</span><span class="s">&#34;sockfd: %d, clientfd: %d, count: %d, buffer: %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">sockfd</span><span class="p">,</span> <span class="n">clientfd</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
<span class="ln">114</span>	<span class="p">}</span>
<span class="ln">115</span> 
<span class="ln">116</span>	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">117</span><span class="p">}</span>
</code></pre></div><p>通过 hook 技术，可以拦截系统函数的调用，并在调用之前或之后执行自定义逻辑。这在调试、监视和修改函数行为时非常有用。在代码中，hook 技术用于拦截 <code>read</code> 和 <code>write</code> 函数的调用，打印读取和写入的数据，并实现上下文切换的逻辑。</p></div><hr /><div class="post-navs d-flex mb-3 justify-content-between">
  <div class="post-nav w-50"><div class="prev-post btn btn-sm">
      <a href="/posts/tech/media-mermaid/">Mermaid
</a>
    </div></div>
  <div class="post-nav flex-row-reverse"><div class="next-post btn btn-sm">
      <a href="/posts/tech/media-rtp/">RTP：实时应用传输协议 （RFC3550）
</a>
    </div></div>
</div><section class="related-posts">
    <h3>相关文章</h3>
    <ul class="related-posts"><li><a href="/posts/tech/media-rtp/">RTP：实时应用传输协议 （RFC3550）
</a></li><li><a href="/posts/tech/media-lightrtp/">lightrtp学习
</a></li><li><a href="/posts/tech/media-mermaid/">Mermaid
</a></li><li><a href="/posts/tech/media-sdptoc/">SDP协议解析C结构体
</a></li><li><a href="/posts/tech/media-algorithm-c/">Leetcode C语言算法刷题
</a></li></ul>
  </section></article>




<div id="vcomments" class="post-comments surface row">
</div>
    <script>
        new Valine({
            el: '#vcomments',
            appId: '18xpdRPZMKmyTjmjtMIK8zyB-gzGzoHsz',
            appKey: 'haH3Ysz9ic7RFcoqbIvPDh8H',
            avatar:'retro',
            visitor:true,
            placeholder:'有什么想说的吗？'

        });

        var count = 0;
        var domTimer = setInterval(function () {
            if (++count > 50) clearInterval(domTimer);
            if (document.querySelector('#veditor')) {
                clearInterval(domTimer);
                var cdraw = new CaveDraw({
                    element: "#veditor",
                    readOnlyMode: false, 
                    afterUpdateEditor: ()=>{ 
                        document.querySelector('#veditor').focus();
                        document.querySelector('#veditor').blur();
                    },
                    controls: ['brush', 'eraser', 'bucket', 'clear', 'undo', 'redo', 'save']
                });
            }
        }, 200);
    </script></div>
</div><aside class="col-lg-4 sidebar d-flex">
  <div class="container"><section class="profile surface row">
  <div class="col-xl-6 d-flex align-items-center justify-content-center">
    <img class="profile-avatar img-fluid" src="/images/profile2.jpg" alt="理想奈" loading="lazy">
  </div>
  <div class="col-xl-6">
    <h5 class="profile-name my-2">理想奈</h5><div class="profile-bio mb-2">所感所喜所爱所恨所愿，即行之所往。</div>
    
  </div>
</section><section class="recent-posts row surface">
  <h4>最近文章</h4>
  <ul><li><a href="/posts/tech/media-rebar2/">rebar2学习
</a></li><li><a href="/posts/tech/media-erlang/">《Erlang程序设计》
</a></li><li><a href="/posts/other/2024/">2024年终总结和来年展望
</a></li><li><a href="/posts/math/estimate/">量化交易系统设想
</a></li><li><a href="/posts/math/beginner/">量化交易初学
</a></li><li><a href="/posts/tech/media-computer-systems/">《深入理解计算机系统》
</a></li><li><a href="/posts/other/physics-computer/">计算机和物理的一点感悟
</a></li><li><a href="/posts/tech/media-ffmpeg/">FFmpeg学习
</a></li><li><a href="/posts/tech/media-pcmu/">pcmu编码
</a></li><li><a href="/posts/tech/media-sox/">Sox基本使用
</a></li><li><a href="/posts/other/human-mind-weekness/">上头与下头与suicide
</a></li><li><a href="/posts/other/everyweek-english/">每周一篇经济学人
</a></li><li><a href="/posts/tech/media-automake/">automake使用
</a></li></ul>
</section><section class="taxonomy-categories row surface">
      <h4>
        <a href="/categories">分类</a>
      </h4>
      <div><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" class="post-taxonomy rounded btn btn-sm me-2 mb-2" title="计算机">
          计算机 <span class="badge rounded-pill">37</span>
        </a><a href="/categories/%E4%BA%8C%E6%AC%A1%E5%85%83/" class="post-taxonomy rounded btn btn-sm me-2 mb-2" title="二次元">
          二次元 <span class="badge rounded-pill">24</span>
        </a><a href="/categories/%E6%99%AE%E9%80%9A%E7%B1%BB/" class="post-taxonomy rounded btn btn-sm me-2 mb-2" title="普通类">
          普通类 <span class="badge rounded-pill">9</span>
        </a><a href="/categories/%E6%96%87%E5%AD%97%E7%B1%BB/" class="post-taxonomy rounded btn btn-sm me-2 mb-2" title="文字类">
          文字类 <span class="badge rounded-pill">6</span>
        </a><a href="/categories/%E6%95%B0%E5%AD%A6%E7%B1%BB/" class="post-taxonomy rounded btn btn-sm me-2 mb-2" title="数学类">
          数学类 <span class="badge rounded-pill">4</span>
        </a></div>
    </section><section class="taxonomy-series row surface">
      <h4>
        <a href="/series">专栏</a>
      </h4>
      <div><a href="/series/%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91/" class="post-taxonomy rounded btn btn-sm me-2 mb-2" title="媒体开发">
          媒体开发 <span class="badge rounded-pill">22</span>
        </a><a href="/series/%E5%8A%A8%E6%BC%AB%E6%AD%8C%E6%9B%B2/" class="post-taxonomy rounded btn btn-sm me-2 mb-2" title="动漫歌曲">
          动漫歌曲 <span class="badge rounded-pill">21</span>
        </a><a href="/series/galgame/" class="post-taxonomy rounded btn btn-sm me-2 mb-2" title="Galgame">
          Galgame <span class="badge rounded-pill">10</span>
        </a><a href="/series/java/" class="post-taxonomy rounded btn btn-sm me-2 mb-2" title="Java">
          Java <span class="badge rounded-pill">10</span>
        </a><a href="/series/%E9%87%8F%E5%8C%96%E4%BA%A4%E6%98%93/" class="post-taxonomy rounded btn btn-sm me-2 mb-2" title="量化交易">
          量化交易 <span class="badge rounded-pill">2</span>
        </a><a href="/series/%E9%9A%8F%E6%84%8F%E6%80%9D%E8%80%83/" class="post-taxonomy rounded btn btn-sm me-2 mb-2" title="随意思考">
          随意思考 <span class="badge rounded-pill">2</span>
        </a></div>
    </section></div>
</aside>
</div>
    </main><footer class="footer mt-auto py-3 text-center container"><nav class="social-links nav my-2 justify-content-center"></nav>
<div class="copyright mb-2">
  Copyright © 2021-2025 Unaybaryl. All Rights Reserved.
</div>
</footer>
<a id="btnScrollToTop" class="btn-scroll-to-top">
  <i class="fas fa-fw fa-chevron-circle-up fa-2x"></i>
</a>



              
            </body>
</html>
